#![allow(
    dead_code,
    mutable_transmutes,
    non_camel_case_types,
    non_snake_case,
    non_upper_case_globals,
    unused_assignments,
    unused_mut
)]
#![feature(c_variadic, core_intrinsics, extern_types, label_break_value)]
#![allow(dead_code)]

#[macro_use] extern crate libc;
#[macro_use] extern crate c2rust_bitfields;
extern crate core;

extern "C" {
    pub type pcre2_real_match_data_8;
    pub type _IO_wide_data;
    pub type _IO_codecvt;
    pub type _IO_marker;
    pub type sockaddr_x25;
    pub type sockaddr_ns;
    pub type sockaddr_iso;
    pub type sockaddr_ipx;
    pub type sockaddr_inarp;
    pub type sockaddr_eon;
    pub type sockaddr_dl;
    pub type sockaddr_ax25;
    pub type sockaddr_at;
    pub type pcre2_real_match_context_8;
    pub type pcre2_real_code_8;
    pub type pcre2_real_general_context_8;
    pub type pcre2_real_compile_context_8;
    pub type dirent;
    fn atoi(__nptr: *const libc::c_char) -> libc::c_int;
    fn strtol(_: *const libc::c_char, _: *mut *mut libc::c_char, _: libc::c_int) -> libc::c_long;
    fn strtoul(_: *const libc::c_char, _: *mut *mut libc::c_char, _: libc::c_int) -> libc::c_ulong;
    fn strtoll(
        _: *const libc::c_char,
        _: *mut *mut libc::c_char,
        _: libc::c_int,
    ) -> libc::c_longlong;
    fn select(
        __nfds: libc::c_int,
        __readfds: *mut fd_set,
        __writefds: *mut fd_set,
        __exceptfds: *mut fd_set,
        __timeout: *mut timeval,
    ) -> libc::c_int;
    fn memcpy(_: *mut libc::c_void, _: *const libc::c_void, _: libc::c_ulong) -> *mut libc::c_void;
    fn random() -> libc::c_long;
    fn malloc(_: libc::c_ulong) -> *mut libc::c_void;
    fn free(_: *mut libc::c_void);
    fn memset(_: *mut libc::c_void, _: libc::c_int, _: libc::c_ulong) -> *mut libc::c_void;
    fn srandom(__seed: libc::c_uint);
    fn rand() -> libc::c_int;
    fn srand(__seed: libc::c_uint);
    fn calloc(_: libc::c_ulong, _: libc::c_ulong) -> *mut libc::c_void;
    fn realloc(_: *mut libc::c_void, _: libc::c_ulong) -> *mut libc::c_void;
    fn abort() -> !;
    fn exit(_: libc::c_int) -> !;
    fn getenv(__name: *const libc::c_char) -> *mut libc::c_char;
    fn setenv(
        __name: *const libc::c_char,
        __value: *const libc::c_char,
        __replace: libc::c_int,
    ) -> libc::c_int;
    fn unsetenv(__name: *const libc::c_char) -> libc::c_int;
    fn mkostemp(__template: *mut libc::c_char, __flags: libc::c_int) -> libc::c_int;
    fn getloadavg(__loadavg: *mut libc::c_double, __nelem: libc::c_int) -> libc::c_int;
    fn memmove(_: *mut libc::c_void, _: *const libc::c_void, _: libc::c_ulong)
        -> *mut libc::c_void;
    fn memcmp(_: *const libc::c_void, _: *const libc::c_void, _: libc::c_ulong) -> libc::c_int;
    fn memchr(_: *const libc::c_void, _: libc::c_int, _: libc::c_ulong) -> *mut libc::c_void;
    fn strcmp(_: *const libc::c_char, _: *const libc::c_char) -> libc::c_int;
    fn strncmp(_: *const libc::c_char, _: *const libc::c_char, _: libc::c_ulong) -> libc::c_int;
    fn strdup(_: *const libc::c_char) -> *mut libc::c_char;
    fn strchr(_: *const libc::c_char, _: libc::c_int) -> *mut libc::c_char;
    fn strrchr(_: *const libc::c_char, _: libc::c_int) -> *mut libc::c_char;
    fn strcspn(_: *const libc::c_char, _: *const libc::c_char) -> libc::c_ulong;
    fn strstr(_: *const libc::c_char, _: *const libc::c_char) -> *mut libc::c_char;
    fn mempcpy(_: *mut libc::c_void, _: *const libc::c_void, _: libc::c_ulong)
        -> *mut libc::c_void;
    fn strlen(_: *const libc::c_char) -> libc::c_ulong;
    fn strerror_r(
        __errnum: libc::c_int,
        __buf: *mut libc::c_char,
        __buflen: size_t,
    ) -> *mut libc::c_char;
    fn strncasecmp(_: *const libc::c_char, _: *const libc::c_char, _: libc::c_ulong)
        -> libc::c_int;
    fn explicit_bzero(__s: *mut libc::c_void, __n: size_t);
    static mut stderr: *mut FILE;
    fn fflush(__stream: *mut FILE) -> libc::c_int;
    fn fprintf(_: *mut FILE, _: *const libc::c_char, _: ...) -> libc::c_int;
    fn clock_gettime(__clock_id: clockid_t, __tp: *mut timespec) -> libc::c_int;
    fn snprintf(
        _: *mut libc::c_char,
        _: libc::c_ulong,
        _: *const libc::c_char,
        _: ...
    ) -> libc::c_int;
    fn close(__fd: libc::c_int) -> libc::c_int;
    fn __errno_location() -> *mut libc::c_int;
    fn open(__file: *const libc::c_char, __oflag: libc::c_int, _: ...) -> libc::c_int;
    fn _exit(_: libc::c_int) -> !;
    fn perror(__s: *const libc::c_char);
    static mut environ: *mut *mut libc::c_char;
    fn execve(
        __path: *const libc::c_char,
        __argv: *const *mut libc::c_char,
        __envp: *const *mut libc::c_char,
    ) -> libc::c_int;
    fn signal(__sig: libc::c_int, __handler: __sighandler_t) -> __sighandler_t;
    fn fcntl(__fd: libc::c_int, __cmd: libc::c_int, _: ...) -> libc::c_int;
    fn dup2(__fd: libc::c_int, __fd2: libc::c_int) -> libc::c_int;
    fn fchdir(__fd: libc::c_int) -> libc::c_int;
    fn fork() -> __pid_t;
    fn pipe(__pipedes: *mut libc::c_int) -> libc::c_int;
    fn pipe2(__pipedes: *mut libc::c_int, __flags: libc::c_int) -> libc::c_int;
    fn write(__fd: libc::c_int, __buf: *const libc::c_void, __n: size_t) -> ssize_t;
    fn vsnprintf(
        _: *mut libc::c_char,
        _: libc::c_ulong,
        _: *const libc::c_char,
        _: ::core::ffi::VaList,
    ) -> libc::c_int;
    fn unlink(__name: *const libc::c_char) -> libc::c_int;
    fn prctl(__option: libc::c_int, _: ...) -> libc::c_int;
    fn pwrite(
        __fd: libc::c_int,
        __buf: *const libc::c_void,
        __nbytes: size_t,
        __offset: __off64_t,
    ) -> ssize_t;
    fn splice(
        __fdin: libc::c_int,
        __offin: *mut __off64_t,
        __fdout: libc::c_int,
        __offout: *mut __off64_t,
        __len: size_t,
        __flags: libc::c_uint,
    ) -> __ssize_t;
    fn read(__fd: libc::c_int, __buf: *mut libc::c_void, __nbytes: size_t) -> ssize_t;
    fn setrlimit(__resource: __rlimit_resource_t, __rlimits: *const rlimit) -> libc::c_int;
    fn getrlimit(__resource: __rlimit_resource_t, __rlimits: *mut rlimit) -> libc::c_int;
    fn fstat(__fd: libc::c_int, __buf: *mut stat) -> libc::c_int;
    fn pread(
        __fd: libc::c_int,
        __buf: *mut libc::c_void,
        __nbytes: size_t,
        __offset: __off64_t,
    ) -> ssize_t;
    fn sysconf(__name: libc::c_int) -> libc::c_long;
    fn timegm(__tp: *mut tm) -> time_t;
    fn getpwnam(__name: *const libc::c_char) -> *mut passwd;
    fn initgroups(__user: *const libc::c_char, __group: __gid_t) -> libc::c_int;
    fn setgroups(__n: size_t, __groups: *const __gid_t) -> libc::c_int;
    fn getgrnam(__name: *const libc::c_char) -> *mut group;
    fn tzset();
    fn getgrgid(__gid: __gid_t) -> *mut group;
    fn htons(__hostshort: uint16_t) -> uint16_t;
    fn socket(__domain: libc::c_int, __type: libc::c_int, __protocol: libc::c_int) -> libc::c_int;
    fn bind(__fd: libc::c_int, __addr: __CONST_SOCKADDR_ARG, __len: socklen_t) -> libc::c_int;
    fn getsockname(__fd: libc::c_int, __addr: __SOCKADDR_ARG, __len: *mut socklen_t)
        -> libc::c_int;
    fn connect(__fd: libc::c_int, __addr: __CONST_SOCKADDR_ARG, __len: socklen_t) -> libc::c_int;
    fn getpeername(__fd: libc::c_int, __addr: __SOCKADDR_ARG, __len: *mut socklen_t)
        -> libc::c_int;
    fn recv(
        __fd: libc::c_int,
        __buf: *mut libc::c_void,
        __n: size_t,
        __flags: libc::c_int,
    ) -> ssize_t;
    fn getsockopt(
        __fd: libc::c_int,
        __level: libc::c_int,
        __optname: libc::c_int,
        __optval: *mut libc::c_void,
        __optlen: *mut socklen_t,
    ) -> libc::c_int;
    fn setsockopt(
        __fd: libc::c_int,
        __level: libc::c_int,
        __optname: libc::c_int,
        __optval: *const libc::c_void,
        __optlen: socklen_t,
    ) -> libc::c_int;
    fn listen(__fd: libc::c_int, __n: libc::c_int) -> libc::c_int;
    fn accept(__fd: libc::c_int, __addr: __SOCKADDR_ARG, __addr_len: *mut socklen_t)
        -> libc::c_int;
    fn accept4(
        __fd: libc::c_int,
        __addr: __SOCKADDR_ARG,
        __addr_len: *mut socklen_t,
        __flags: libc::c_int,
    ) -> libc::c_int;
    fn shutdown(__fd: libc::c_int, __how: libc::c_int) -> libc::c_int;
    static in6addr_any: in6_addr;
    static in6addr_loopback: in6_addr;
    fn ntohs(__netshort: uint16_t) -> uint16_t;
    fn htonl(__hostlong: uint32_t) -> uint32_t;
    fn chmod(__file: *const libc::c_char, __mode: __mode_t) -> libc::c_int;
    fn getppid() -> __pid_t;
    fn getpid() -> __pid_t;
    fn puts(__s: *const libc::c_char) -> libc::c_int;
    fn fputs(__s: *const libc::c_char, __stream: *mut FILE) -> libc::c_int;
    fn gmtime_r(__timer: *const time_t, __tp: *mut tm) -> *mut tm;
    fn printf(_: *const libc::c_char, _: ...) -> libc::c_int;
    fn localtime_r(__timer: *const time_t, __tp: *mut tm) -> *mut tm;
    fn setlocale(__category: libc::c_int, __locale: *const libc::c_char) -> *mut libc::c_char;
    fn strftime(
        __s: *mut libc::c_char,
        __maxsize: size_t,
        __format: *const libc::c_char,
        __tp: *const tm,
    ) -> size_t;
    fn lstat(__file: *const libc::c_char, __buf: *mut stat) -> libc::c_int;
    fn time(__timer: *mut time_t) -> time_t;
    fn stat(__file: *const libc::c_char, __buf: *mut stat) -> libc::c_int;
    fn sigaction(
        __sig: libc::c_int,
        __act: *const sigaction,
        __oact: *mut sigaction,
    ) -> libc::c_int;
    fn sigemptyset(__set: *mut sigset_t) -> libc::c_int;
    fn raise(__sig: libc::c_int) -> libc::c_int;
    fn kill(__pid: __pid_t, __sig: libc::c_int) -> libc::c_int;
    fn ftruncate(__fd: libc::c_int, __length: __off64_t) -> libc::c_int;
    fn chroot(__path: *const libc::c_char) -> libc::c_int;
    fn getopt(
        ___argc: libc::c_int,
        ___argv: *const *mut libc::c_char,
        __shortopts: *const libc::c_char,
    ) -> libc::c_int;
    static mut optind: libc::c_int;
    static mut optarg: *mut libc::c_char;
    fn setgid(__gid: __gid_t) -> libc::c_int;
    fn setuid(__uid: __uid_t) -> libc::c_int;
    fn getegid() -> __gid_t;
    fn getgid() -> __gid_t;
    fn geteuid() -> __uid_t;
    fn getuid() -> __uid_t;
    fn setsid() -> __pid_t;
    fn execv(__path: *const libc::c_char, __argv: *const *mut libc::c_char) -> libc::c_int;
    fn alarm(__seconds: libc::c_uint) -> libc::c_uint;
    fn getentropy(__buffer: *mut libc::c_void, __length: size_t) -> libc::c_int;
    fn rename(__old: *const libc::c_char, __new: *const libc::c_char) -> libc::c_int;
    fn dlopen(__file: *const libc::c_char, __mode: libc::c_int) -> *mut libc::c_void;
    fn lseek(__fd: libc::c_int, __offset: __off64_t, __whence: libc::c_int) -> __off64_t;
    fn dlsym(__handle: *mut libc::c_void, __name: *const libc::c_char) -> *mut libc::c_void;
    fn dlerror() -> *mut libc::c_char;
    fn dlclose(__handle: *mut libc::c_void) -> libc::c_int;
    fn dup(__fd: libc::c_int) -> libc::c_int;
    fn getcwd(__buf: *mut libc::c_char, __size: size_t) -> *mut libc::c_char;
    fn chdir(__path: *const libc::c_char) -> libc::c_int;
    fn inet_pton(
        __af: libc::c_int,
        __cp: *const libc::c_char,
        __buf: *mut libc::c_void,
    ) -> libc::c_int;
    fn inet_ntop(
        __af: libc::c_int,
        __cp: *const libc::c_void,
        __buf: *mut libc::c_char,
        __len: socklen_t,
    ) -> *const libc::c_char;
    fn pcre2_code_free_8(_: *mut pcre2_code_8);
    fn pcre2_get_error_message_8(_: libc::c_int, _: *mut PCRE2_UCHAR8, _: size_t) -> libc::c_int;
    fn pcre2_pattern_info_8(
        _: *const pcre2_code_8,
        _: uint32_t,
        _: *mut libc::c_void,
    ) -> libc::c_int;
    fn pcre2_match_data_create_8(
        _: uint32_t,
        _: *mut pcre2_general_context_8,
    ) -> *mut pcre2_match_data_8;
    fn pcre2_jit_compile_8(_: *mut pcre2_code_8, _: uint32_t) -> libc::c_int;
    fn pcre2_compile_8(
        _: PCRE2_SPTR8,
        _: size_t,
        _: uint32_t,
        _: *mut libc::c_int,
        _: *mut size_t,
        _: *mut pcre2_compile_context_8,
    ) -> *mut pcre2_code_8;
    fn pcre2_match_8(
        _: *const pcre2_code_8,
        _: PCRE2_SPTR8,
        _: size_t,
        _: size_t,
        _: uint32_t,
        _: *mut pcre2_match_data_8,
        _: *mut pcre2_match_context_8,
    ) -> libc::c_int;
    fn pcre2_get_ovector_pointer_8(_: *mut pcre2_match_data_8) -> *mut size_t;
    fn pcre2_match_data_create_from_pattern_8(
        _: *const pcre2_code_8,
        _: *mut pcre2_general_context_8,
    ) -> *mut pcre2_match_data_8;
    fn pcre2_match_data_free_8(_: *mut pcre2_match_data_8);
    fn epoll_create1(__flags: libc::c_int) -> libc::c_int;
    fn epoll_wait(
        __epfd: libc::c_int,
        __events: *mut epoll_event,
        __maxevents: libc::c_int,
        __timeout: libc::c_int,
    ) -> libc::c_int;
    fn epoll_ctl(
        __epfd: libc::c_int,
        __op: libc::c_int,
        __fd: libc::c_int,
        __event: *mut epoll_event,
    ) -> libc::c_int;
    fn poll(__fds: *mut pollfd, __nfds: nfds_t, __timeout: libc::c_int) -> libc::c_int;
    fn writev(__fd: libc::c_int, __iovec: *const iovec, __count: libc::c_int) -> ssize_t;
    fn pwritev(
        __fd: libc::c_int,
        __iovec: *const iovec,
        __count: libc::c_int,
        __offset: __off64_t,
    ) -> ssize_t;
    fn sendfile(
        __out_fd: libc::c_int,
        __in_fd: libc::c_int,
        __offset: *mut __off64_t,
        __count: size_t,
    ) -> ssize_t;
    fn __ctype_b_loc() -> *mut *const libc::c_ushort;
    fn syslog(__pri: libc::c_int, __fmt: *const libc::c_char, _: ...);
    fn globfree(__pglob: *mut glob_t);
    fn glob(
        __pattern: *const libc::c_char,
        __flags: libc::c_int,
        __errfunc: Option<unsafe extern "C" fn(*const libc::c_char, libc::c_int) -> libc::c_int>,
        __pglob: *mut glob_t,
    ) -> libc::c_int;
    fn openlog(__ident: *const libc::c_char, __option: libc::c_int, __facility: libc::c_int);
    fn closelog();
    fn waitpid(__pid: __pid_t, __stat_loc: *mut libc::c_int, __options: libc::c_int) -> __pid_t;
    fn munmap(__addr: *mut libc::c_void, __len: size_t) -> libc::c_int;
    fn mmap(
        __addr: *mut libc::c_void,
        __len: size_t,
        __prot: libc::c_int,
        __flags: libc::c_int,
        __fd: libc::c_int,
        __offset: __off64_t,
    ) -> *mut libc::c_void;
    fn ioctl(__fd: libc::c_int, __request: libc::c_ulong, _: ...) -> libc::c_int;
    fn inotify_init1(__flags: libc::c_int) -> libc::c_int;
    fn inotify_rm_watch(__fd: libc::c_int, __wd: libc::c_int) -> libc::c_int;
    fn inotify_add_watch(
        __fd: libc::c_int,
        __name: *const libc::c_char,
        __mask: uint32_t,
    ) -> libc::c_int;
    fn getaddrinfo(
        __name: *const libc::c_char,
        __service: *const libc::c_char,
        __req: *const addrinfo,
        __pai: *mut *mut addrinfo,
    ) -> libc::c_int;
    fn freeaddrinfo(__ai: *mut addrinfo);
    fn gai_strerror(__ecode: libc::c_int) -> *const libc::c_char;
    fn getnameinfo(
        __sa: *const sockaddr,
        __salen: socklen_t,
        __host: *mut libc::c_char,
        __hostlen: socklen_t,
        __serv: *mut libc::c_char,
        __servlen: socklen_t,
        __flags: libc::c_int,
    ) -> libc::c_int;
}
pub type __builtin_va_list = [__va_list_tag; 1];
#[derive(Copy, Clone)]
#[repr(C)]
pub struct __va_list_tag {
    pub gp_offset: libc::c_uint,
    pub fp_offset: libc::c_uint,
    pub overflow_arg_area: *mut libc::c_void,
    pub reg_save_area: *mut libc::c_void,
}
pub type __int8_t = libc::c_schar;
pub type __uint8_t = libc::c_uchar;
pub type __int16_t = libc::c_short;
pub type __uint16_t = libc::c_ushort;
pub type __int32_t = libc::c_int;
pub type __uint32_t = libc::c_uint;
pub type __int64_t = libc::c_long;
pub type __uint64_t = libc::c_ulong;
pub type __intmax_t = libc::c_long;
pub type __uintmax_t = libc::c_ulong;
pub type __dev_t = libc::c_ulong;
pub type __uid_t = libc::c_uint;
pub type __gid_t = libc::c_uint;
pub type __ino_t = libc::c_ulong;
pub type __ino64_t = libc::c_ulong;
pub type __mode_t = libc::c_uint;
pub type __nlink_t = libc::c_ulong;
pub type __off_t = libc::c_long;
pub type __off64_t = libc::c_long;
pub type __pid_t = libc::c_int;
pub type __clock_t = libc::c_long;
pub type __rlim64_t = libc::c_ulong;
pub type __time_t = libc::c_long;
pub type __suseconds_t = libc::c_long;
pub type __clockid_t = libc::c_int;
pub type __blksize_t = libc::c_long;
pub type __blkcnt_t = libc::c_long;
pub type __ssize_t = libc::c_long;
pub type __syscall_slong_t = libc::c_long;
pub type __loff_t = __off64_t;
pub type __socklen_t = libc::c_uint;
pub type __sig_atomic_t = libc::c_int;
pub type loff_t = __loff_t;
pub type ino_t = __ino64_t;
pub type dev_t = __dev_t;
pub type gid_t = __gid_t;
pub type mode_t = __mode_t;
pub type uid_t = __uid_t;
pub type off_t = __off64_t;
pub type pid_t = __pid_t;
pub type ssize_t = __ssize_t;
pub type clockid_t = __clockid_t;
pub type time_t = __time_t;
pub type size_t = libc::c_ulong;
pub type int8_t = __int8_t;
pub type int16_t = __int16_t;
pub type int32_t = __int32_t;
pub type int64_t = __int64_t;
#[derive(Copy, Clone)]
#[repr(C)]
pub struct __sigset_t {
    pub __val: [libc::c_ulong; 16],
}
pub type sigset_t = __sigset_t;
#[derive(Copy, Clone)]
#[repr(C)]
pub struct timeval {
    pub tv_sec: __time_t,
    pub tv_usec: __suseconds_t,
}
#[derive(Copy, Clone)]
#[repr(C)]
pub struct timespec {
    pub tv_sec: __time_t,
    pub tv_nsec: __syscall_slong_t,
}
pub type __fd_mask = libc::c_long;
#[derive(Copy, Clone)]
#[repr(C)]
pub struct fd_set {
    pub fds_bits: [__fd_mask; 16],
}
pub type rsize_t = libc::c_ulong;
pub type uint8_t = __uint8_t;
pub type uint16_t = __uint16_t;
pub type uint32_t = __uint32_t;
pub type uint64_t = __uint64_t;
pub type int_fast32_t = libc::c_long;
pub type uint_fast32_t = libc::c_ulong;
pub type intptr_t = libc::c_long;
pub type uintptr_t = libc::c_ulong;
pub type intmax_t = __intmax_t;
pub type uintmax_t = __uintmax_t;
pub type unix_time64_t = time_t;
pub type unix_timespec64_t = timespec;
pub type XXH_errorcode = libc::c_uint;
pub const XXH_ERROR: XXH_errorcode = 1;
pub const XXH_OK: XXH_errorcode = 0;
pub type XXH32_hash_t = uint32_t;
pub type xxh_u32 = XXH32_hash_t;
pub type XXH_alignment = libc::c_uint;
pub const XXH_unaligned: XXH_alignment = 1;
pub const XXH_aligned: XXH_alignment = 0;
pub type xxh_u8 = uint8_t;
#[derive(Copy, Clone)]
#[repr(C)]
pub struct XXH32_state_s {
    pub total_len_32: XXH32_hash_t,
    pub large_len: XXH32_hash_t,
    pub v: [XXH32_hash_t; 4],
    pub mem32: [XXH32_hash_t; 4],
    pub memsize: XXH32_hash_t,
    pub reserved: XXH32_hash_t,
}
pub type XXH32_state_t = XXH32_state_s;
#[derive(Copy, Clone)]
#[repr(C)]
pub struct XXH32_canonical_t {
    pub digest: [libc::c_uchar; 4],
}
#[derive(Copy, Clone)]
#[repr(C)]
pub struct tm {
    pub tm_sec: libc::c_int,
    pub tm_min: libc::c_int,
    pub tm_hour: libc::c_int,
    pub tm_mday: libc::c_int,
    pub tm_mon: libc::c_int,
    pub tm_year: libc::c_int,
    pub tm_wday: libc::c_int,
    pub tm_yday: libc::c_int,
    pub tm_isdst: libc::c_int,
    pub tm_gmtoff: libc::c_long,
    pub tm_zone: *const libc::c_char,
}
pub type __sigval_t = sigval;
#[derive(Copy, Clone)]
#[repr(C)]
pub union sigval {
    pub sival_int: libc::c_int,
    pub sival_ptr: *mut libc::c_void,
}
#[derive(Copy, Clone)]
#[repr(C)]
pub struct server {
    pub plugin_slots: *mut libc::c_void,
    pub config_context: *mut array,
    pub config_captures: libc::c_int,
    pub ev: *mut fdevents,
    pub network_backend_write: Option<
        unsafe extern "C" fn(libc::c_int, *mut chunkqueue, off_t, *mut log_error_st) -> libc::c_int,
    >,
    pub request_env: Option<unsafe extern "C" fn(*mut request_st) -> handler_t>,
    pub tmp_buf: *mut buffer,
    pub con_opened: libc::c_int,
    pub con_read: libc::c_int,
    pub con_written: libc::c_int,
    pub con_closed: libc::c_int,
    pub max_fds: libc::c_int,
    pub max_fds_lowat: libc::c_int,
    pub max_fds_hiwat: libc::c_int,
    pub cur_fds: libc::c_int,
    pub sockets_disabled: libc::c_int,
    pub lim_conns: uint32_t,
    pub conns: *mut connection,
    pub conns_pool: *mut connection,
    pub errh: *mut log_error_st,
    pub loadts: unix_time64_t,
    pub loadavg: [libc::c_double; 3],
    pub srvconf: server_config,
    pub config_data_base: *mut libc::c_void,
    pub srv_sockets: server_socket_array,
    pub srv_sockets_inherited: server_socket_array,
    pub plugins: C2RustUnnamed,
    pub startup_ts: unix_time64_t,
    pub graceful_expire_ts: unix_time64_t,
    pub uid: uid_t,
    pub gid: gid_t,
    pub pid: pid_t,
    pub stdin_fd: libc::c_int,
    pub argv: *mut *mut libc::c_char,
    pub match_data: *mut libc::c_void,
}
#[derive(Copy, Clone)]
#[repr(C)]
pub struct C2RustUnnamed {
    pub ptr: *mut libc::c_void,
    pub used: uint32_t,
    pub size: uint32_t,
}
#[derive(Copy, Clone)]
#[repr(C)]
pub struct server_socket_array {
    pub ptr: *mut *mut server_socket,
    pub size: uint32_t,
    pub used: uint32_t,
}
#[derive(Copy, Clone)]
#[repr(C)]
pub struct server_socket {
    pub addr: sock_addr,
    pub fd: libc::c_int,
    pub is_ssl: uint8_t,
    pub srv_token_colon: uint8_t,
    pub sidx: libc::c_ushort,
    pub fdn: *mut fdnode,
    pub srv: *mut server,
    pub srv_token: *mut buffer,
}
#[derive(Copy, Clone)]
#[repr(C)]
pub struct buffer {
    pub ptr: *mut libc::c_char,
    pub used: uint32_t,
    pub size: uint32_t,
}
pub type fdnode = fdnode_st;
#[derive(Copy, Clone)]
#[repr(C)]
pub struct fdnode_st {
    pub handler: fdevent_handler,
    pub ctx: *mut libc::c_void,
    pub fd: libc::c_int,
    pub events: libc::c_int,
    pub fde_ndx: libc::c_int,
}
pub type fdevent_handler =
    Option<unsafe extern "C" fn(*mut libc::c_void, libc::c_int) -> handler_t>;
pub type handler_t = libc::c_uint;
pub const HANDLER_ERROR: handler_t = 4;
pub const HANDLER_WAIT_FOR_EVENT: handler_t = 3;
pub const HANDLER_COMEBACK: handler_t = 2;
pub const HANDLER_FINISHED: handler_t = 1;
pub const HANDLER_GO_ON: handler_t = 0;
#[derive(Copy, Clone)]
#[repr(C)]
pub union sock_addr {
    pub ipv6: sockaddr_in6,
    pub ipv4: sockaddr_in,
    pub un: sockaddr_un,
    pub plain: sockaddr,
}
#[derive(Copy, Clone)]
#[repr(C)]
pub struct sockaddr {
    pub sa_family: sa_family_t,
    pub sa_data: [libc::c_char; 14],
}
pub type sa_family_t = libc::c_ushort;
#[derive(Copy, Clone)]
#[repr(C)]
pub struct sockaddr_un {
    pub sun_family: sa_family_t,
    pub sun_path: [libc::c_char; 108],
}
#[derive(Copy, Clone)]
#[repr(C)]
pub struct sockaddr_in {
    pub sin_family: sa_family_t,
    pub sin_port: in_port_t,
    pub sin_addr: in_addr,
    pub sin_zero: [libc::c_uchar; 8],
}
#[derive(Copy, Clone)]
#[repr(C)]
pub struct in_addr {
    pub s_addr: in_addr_t,
}
pub type in_addr_t = uint32_t;
pub type in_port_t = uint16_t;
#[derive(Copy, Clone)]
#[repr(C)]
pub struct sockaddr_in6 {
    pub sin6_family: sa_family_t,
    pub sin6_port: in_port_t,
    pub sin6_flowinfo: uint32_t,
    pub sin6_addr: in6_addr,
    pub sin6_scope_id: uint32_t,
}
#[derive(Copy, Clone)]
#[repr(C)]
pub struct in6_addr {
    pub __in6_u: C2RustUnnamed_0,
}
#[derive(Copy, Clone)]
#[repr(C)]
pub union C2RustUnnamed_0 {
    pub __u6_addr8: [uint8_t; 16],
    pub __u6_addr16: [uint16_t; 8],
    pub __u6_addr32: [uint32_t; 4],
}
#[derive(Copy, Clone)]
#[repr(C)]
pub struct server_config {
    pub max_request_field_size: uint32_t,
    pub log_request_header_on_error: libc::c_uchar,
    pub http_header_strict: libc::c_uchar,
    pub http_host_strict: libc::c_uchar,
    pub http_host_normalize: libc::c_uchar,
    pub http_method_get_body: libc::c_uchar,
    pub high_precision_timestamps: libc::c_uchar,
    pub h2proto: libc::c_uchar,
    pub absolute_dir_redirect: libc::c_uchar,
    pub http_url_normalize: libc::c_ushort,
    pub max_worker: libc::c_ushort,
    pub max_fds: libc::c_ushort,
    pub max_conns: libc::c_ushort,
    pub port: libc::c_ushort,
    pub upload_temp_file_size: libc::c_uint,
    pub upload_tempdirs: *mut array,
    pub dont_daemonize: libc::c_uchar,
    pub preflight_check: libc::c_uchar,
    pub enable_cores: libc::c_uchar,
    pub compat_module_load: libc::c_uchar,
    pub config_deprecated: libc::c_uchar,
    pub config_unsupported: libc::c_uchar,
    pub systemd_socket_activation: libc::c_uchar,
    pub errorlog_use_syslog: libc::c_uchar,
    pub syslog_facility: *const buffer,
    pub bindhost: *const buffer,
    pub changeroot: *const buffer,
    pub username: *const buffer,
    pub groupname: *const buffer,
    pub network_backend: *const buffer,
    pub feature_flags: *const array,
    pub event_handler: *const libc::c_char,
    pub modules_dir: *const libc::c_char,
    pub pid_file: *mut buffer,
    pub modules: *mut array,
    pub config_touched: *mut array,
    pub empty_array: array,
}
#[derive(Copy, Clone)]
#[repr(C)]
pub struct array {
    pub data: *mut *mut data_unset,
    pub sorted: *mut *mut data_unset,
    pub used: uint32_t,
    pub size: uint32_t,
}
#[derive(Copy, Clone)]
#[repr(C)]
pub struct data_unset {
    pub key: buffer,
    pub fn_0: *const data_methods,
    pub type_0: data_type_t,
}
pub type data_type_t = libc::c_uint;
pub const TYPE_OTHER: data_type_t = 4;
pub const TYPE_CONFIG: data_type_t = 3;
pub const TYPE_INTEGER: data_type_t = 2;
pub const TYPE_ARRAY: data_type_t = 1;
pub const TYPE_STRING: data_type_t = 0;
#[derive(Copy, Clone)]
#[repr(C)]
pub struct data_methods {
    pub copy: Option<unsafe extern "C" fn(*const data_unset) -> *mut data_unset>,
    pub free: Option<unsafe extern "C" fn(*mut data_unset) -> ()>,
    pub insert_dup: Option<unsafe extern "C" fn(*mut data_unset, *mut data_unset) -> ()>,
}
pub type log_error_st = fdlog_st;
#[derive(Copy, Clone)]
#[repr(C)]
pub struct fdlog_st {
    pub mode: C2RustUnnamed_1,
    pub fd: libc::c_int,
    pub b: buffer,
    pub fn_0: *const libc::c_char,
}
pub type C2RustUnnamed_1 = libc::c_uint;
pub const FDLOG_PIPE: C2RustUnnamed_1 = 3;
pub const FDLOG_SYSLOG: C2RustUnnamed_1 = 2;
pub const FDLOG_FD: C2RustUnnamed_1 = 1;
pub const FDLOG_FILE: C2RustUnnamed_1 = 0;
#[derive(Copy, Clone)]
#[repr(C)]
pub struct connection {
    pub request: request_st,
    pub h2: *mut h2con,
    pub fd: libc::c_int,
    pub fdn: *mut fdnode,
    pub jqnext: *mut connection,
    pub is_readable: libc::c_schar,
    pub is_writable: libc::c_schar,
    pub is_ssl_sock: libc::c_char,
    pub traffic_limit_reached: libc::c_char,
    pub revents_err: uint16_t,
    pub proto_default_port: uint16_t,
    pub write_queue: *mut chunkqueue,
    pub read_queue: *mut chunkqueue,
    pub bytes_written: off_t,
    pub bytes_written_cur_second: off_t,
    pub bytes_read: off_t,
    pub network_write:
        Option<unsafe extern "C" fn(*mut connection, *mut chunkqueue, off_t) -> libc::c_int>,
    pub network_read:
        Option<unsafe extern "C" fn(*mut connection, *mut chunkqueue, off_t) -> libc::c_int>,
    pub reqbody_read: Option<unsafe extern "C" fn(*mut request_st) -> handler_t>,
    pub srv: *mut server,
    pub plugin_slots: *mut libc::c_void,
    pub plugin_ctx: *mut *mut libc::c_void,
    pub config_data_base: *mut libc::c_void,
    pub dst_addr: sock_addr,
    pub dst_addr_buf: buffer,
    pub srv_socket: *const server_socket,
    pub read_idle_ts: unix_time64_t,
    pub close_timeout_ts: unix_time64_t,
    pub write_request_ts: unix_time64_t,
    pub connection_start: unix_time64_t,
    pub request_count: uint32_t,
    pub keep_alive_idle: libc::c_int,
    pub next: *mut connection,
    pub prev: *mut connection,
}
#[derive(Copy, Clone)]
#[repr(C)]
pub struct request_st {
    pub state: request_state_t,
    pub http_status: libc::c_int,
    pub h2state: uint32_t,
    pub h2id: uint32_t,
    pub h2_rwin: int32_t,
    pub h2_swin: int32_t,
    pub http_method: http_method_t,
    pub http_version: http_version_t,
    pub handler_module: *const plugin,
    pub plugin_ctx: *mut *mut libc::c_void,
    pub con: *mut connection,
    pub conditional_is_valid: uint32_t,
    pub cond_cache: *mut cond_cache_t,
    pub cond_match: *mut *mut cond_match_t,
    pub cond_match_data: *mut cond_match_t,
    pub conf: request_config,
    pub rqst_header_len: uint32_t,
    pub rqst_htags: uint64_t,
    pub rqst_headers: array,
    pub uri: request_uri,
    pub physical: physical,
    pub env: array,
    pub reqbody_length: off_t,
    pub te_chunked: off_t,
    pub resp_body_scratchpad: off_t,
    pub http_host: *mut buffer,
    pub server_name: *const buffer,
    pub target: buffer,
    pub target_orig: buffer,
    pub pathinfo: buffer,
    pub server_name_buf: buffer,
    pub resp_header_len: uint32_t,
    pub resp_htags: uint64_t,
    pub resp_headers: array,
    pub resp_body_finished: libc::c_char,
    pub resp_body_started: libc::c_char,
    pub resp_send_chunked: libc::c_char,
    pub resp_decode_chunked: libc::c_char,
    pub resp_header_repeated: libc::c_char,
    pub loops_per_request: libc::c_char,
    pub keep_alive: int8_t,
    pub async_callback: libc::c_char,
    pub tmp_buf: *mut buffer,
    pub gw_dechunk: *mut response_dechunk,
    pub bytes_written_ckpt: off_t,
    pub bytes_read_ckpt: off_t,
    pub start_hp: unix_timespec64_t,
    pub error_handler_saved_status: libc::c_int,
    pub error_handler_saved_method: http_method_t,
    pub write_queue: chunkqueue,
    pub read_queue: chunkqueue,
    pub reqbody_queue: chunkqueue,
    pub tmp_sce: *mut stat_cache_entry,
    pub cond_captures: libc::c_int,
}
#[derive(Copy, Clone)]
#[repr(C)]
pub struct stat_cache_entry {
    pub name: buffer,
    pub stat_ts: unix_time64_t,
    pub fd: libc::c_int,
    pub refcnt: libc::c_int,
    pub fam_dir: *mut libc::c_void,
    pub etag: buffer,
    pub content_type: buffer,
    pub st: stat,
}
#[derive(Copy, Clone)]
#[repr(C)]
pub struct stat {
    pub st_dev: __dev_t,
    pub st_ino: __ino_t,
    pub st_nlink: __nlink_t,
    pub st_mode: __mode_t,
    pub st_uid: __uid_t,
    pub st_gid: __gid_t,
    pub __pad0: libc::c_int,
    pub st_rdev: __dev_t,
    pub st_size: __off_t,
    pub st_blksize: __blksize_t,
    pub st_blocks: __blkcnt_t,
    pub st_atim: timespec,
    pub st_mtim: timespec,
    pub st_ctim: timespec,
    pub __glibc_reserved: [__syscall_slong_t; 3],
}
#[derive(Copy, Clone)]
#[repr(C)]
pub struct chunkqueue {
    pub first: *mut chunk,
    pub last: *mut chunk,
    pub bytes_in: off_t,
    pub bytes_out: off_t,
    pub tempdirs: *const array,
    pub upload_temp_file_size: off_t,
    pub tempdir_idx: libc::c_uint,
}
#[derive(Copy, Clone)]
#[repr(C)]
pub struct chunk {
    pub next: *mut chunk,
    pub type_0: C2RustUnnamed_4,
    pub mem: *mut buffer,
    pub offset: off_t,
    pub file: C2RustUnnamed_2,
}
#[derive(Copy, Clone)]
#[repr(C)]
pub struct C2RustUnnamed_2 {
    pub length: off_t,
    pub fd: libc::c_int,
    pub is_temp: libc::c_int,
    pub mmap: C2RustUnnamed_3,
    pub ref_0: *mut libc::c_void,
    pub refchg: Option<unsafe extern "C" fn(*mut libc::c_void, libc::c_int) -> ()>,
}
#[derive(Copy, Clone)]
#[repr(C)]
pub struct C2RustUnnamed_3 {
    pub start: *mut libc::c_char,
    pub length: size_t,
    pub offset: off_t,
}
pub type C2RustUnnamed_4 = libc::c_uint;
pub const FILE_CHUNK: C2RustUnnamed_4 = 1;
pub const MEM_CHUNK: C2RustUnnamed_4 = 0;
pub type http_method_t = libc::c_int;
pub const HTTP_METHOD_VERSION_CONTROL: http_method_t = 37;
pub const HTTP_METHOD_UPDATEREDIRECTREF: http_method_t = 36;
pub const HTTP_METHOD_UPDATE: http_method_t = 35;
pub const HTTP_METHOD_UNLOCK: http_method_t = 34;
pub const HTTP_METHOD_UNLINK: http_method_t = 33;
pub const HTTP_METHOD_UNCHECKOUT: http_method_t = 32;
pub const HTTP_METHOD_UNBIND: http_method_t = 31;
pub const HTTP_METHOD_SEARCH: http_method_t = 30;
pub const HTTP_METHOD_REPORT: http_method_t = 29;
pub const HTTP_METHOD_REBIND: http_method_t = 28;
pub const HTTP_METHOD_PROPPATCH: http_method_t = 27;
pub const HTTP_METHOD_PROPFIND: http_method_t = 26;
pub const HTTP_METHOD_PATCH: http_method_t = 25;
pub const HTTP_METHOD_ORDERPATCH: http_method_t = 24;
pub const HTTP_METHOD_MOVE: http_method_t = 23;
pub const HTTP_METHOD_MKWORKSPACE: http_method_t = 22;
pub const HTTP_METHOD_MKREDIRECTREF: http_method_t = 21;
pub const HTTP_METHOD_MKCOL: http_method_t = 20;
pub const HTTP_METHOD_MKCALENDAR: http_method_t = 19;
pub const HTTP_METHOD_MKACTIVITY: http_method_t = 18;
pub const HTTP_METHOD_MERGE: http_method_t = 17;
pub const HTTP_METHOD_LOCK: http_method_t = 16;
pub const HTTP_METHOD_LINK: http_method_t = 15;
pub const HTTP_METHOD_LABEL: http_method_t = 14;
pub const HTTP_METHOD_COPY: http_method_t = 13;
pub const HTTP_METHOD_CHECKOUT: http_method_t = 12;
pub const HTTP_METHOD_CHECKIN: http_method_t = 11;
pub const HTTP_METHOD_BIND: http_method_t = 10;
pub const HTTP_METHOD_BASELINE_CONTROL: http_method_t = 9;
pub const HTTP_METHOD_ACL: http_method_t = 8;
pub const HTTP_METHOD_TRACE: http_method_t = 7;
pub const HTTP_METHOD_OPTIONS: http_method_t = 6;
pub const HTTP_METHOD_CONNECT: http_method_t = 5;
pub const HTTP_METHOD_DELETE: http_method_t = 4;
pub const HTTP_METHOD_PUT: http_method_t = 3;
pub const HTTP_METHOD_POST: http_method_t = 2;
pub const HTTP_METHOD_HEAD: http_method_t = 1;
pub const HTTP_METHOD_GET: http_method_t = 0;
pub const HTTP_METHOD_UNSET: http_method_t = -1;
pub const HTTP_METHOD_PRI: http_method_t = -2;
#[derive(Copy, Clone)]
#[repr(C)]
pub struct response_dechunk {
    pub gw_chunked: off_t,
    pub b: buffer,
    pub done: libc::c_int,
}
#[derive(Copy, Clone)]
#[repr(C)]
pub struct physical {
    pub path: buffer,
    pub basedir: buffer,
    pub doc_root: buffer,
    pub rel_path: buffer,
}
#[derive(Copy, Clone)]
#[repr(C)]
pub struct request_uri {
    pub scheme: buffer,
    pub authority: buffer,
    pub path: buffer,
    pub query: buffer,
}
#[derive(Copy, Clone)]
#[repr(C)]
pub struct request_config {
    pub http_parseopts: libc::c_uint,
    pub max_request_field_size: uint32_t,
    pub mimetypes: *const array,
    pub document_root: *const buffer,
    pub server_name: *const buffer,
    pub server_tag: *const buffer,
    pub errh: *mut fdlog_st,
    pub max_request_size: libc::c_uint,
    pub max_keep_alive_requests: libc::c_ushort,
    pub max_keep_alive_idle: libc::c_ushort,
    pub max_read_idle: libc::c_ushort,
    pub max_write_idle: libc::c_ushort,
    pub stream_request_body: libc::c_ushort,
    pub stream_response_body: libc::c_ushort,
    pub high_precision_timestamps: libc::c_uchar,
    pub allow_http11: libc::c_uchar,
    pub follow_symlink: libc::c_uchar,
    pub etag_flags: libc::c_uchar,
    pub force_lowercase_filenames: libc::c_uchar,
    pub use_xattr: libc::c_uchar,
    pub range_requests: libc::c_uchar,
    pub error_intercept: libc::c_uchar,
    pub h2proto: libc::c_uchar,
    pub log_file_not_found: libc::c_uchar,
    pub log_request_header: libc::c_uchar,
    pub log_request_handling: libc::c_uchar,
    pub log_response_header: libc::c_uchar,
    pub log_condition_handling: libc::c_uchar,
    pub log_timeouts: libc::c_uchar,
    pub log_state_handling: libc::c_uchar,
    pub log_request_header_on_error: libc::c_uchar,
    pub bytes_per_second: libc::c_uint,
    pub global_bytes_per_second: libc::c_uint,
    pub global_bytes_per_second_cnt_ptr: *mut off_t,
    pub error_handler: *const buffer,
    pub error_handler_404: *const buffer,
    pub errorfile_prefix: *const buffer,
    pub serrh: *mut fdlog_st,
}
#[derive(Copy, Clone)]
#[repr(C)]
pub struct cond_match_t {
    pub comp_value: *const buffer,
    pub match_data: *mut pcre2_real_match_data_8,
    pub captures: libc::c_int,
    pub matches: *mut libc::c_void,
}
#[derive(Copy, Clone)]
#[repr(C)]
pub struct cond_cache_t {
    pub result: int8_t,
    pub local_result: int8_t,
}
#[derive(Copy, Clone)]
#[repr(C)]
pub struct plugin {
    pub data: *mut libc::c_void,
    pub handle_uri_raw:
        Option<unsafe extern "C" fn(*mut request_st, *mut libc::c_void) -> handler_t>,
    pub handle_uri_clean:
        Option<unsafe extern "C" fn(*mut request_st, *mut libc::c_void) -> handler_t>,
    pub handle_docroot:
        Option<unsafe extern "C" fn(*mut request_st, *mut libc::c_void) -> handler_t>,
    pub handle_physical:
        Option<unsafe extern "C" fn(*mut request_st, *mut libc::c_void) -> handler_t>,
    pub handle_request_env:
        Option<unsafe extern "C" fn(*mut request_st, *mut libc::c_void) -> handler_t>,
    pub handle_request_done:
        Option<unsafe extern "C" fn(*mut request_st, *mut libc::c_void) -> handler_t>,
    pub handle_subrequest_start:
        Option<unsafe extern "C" fn(*mut request_st, *mut libc::c_void) -> handler_t>,
    pub handle_subrequest:
        Option<unsafe extern "C" fn(*mut request_st, *mut libc::c_void) -> handler_t>,
    pub handle_response_start:
        Option<unsafe extern "C" fn(*mut request_st, *mut libc::c_void) -> handler_t>,
    pub handle_request_reset:
        Option<unsafe extern "C" fn(*mut request_st, *mut libc::c_void) -> handler_t>,
    pub handle_connection_accept:
        Option<unsafe extern "C" fn(*mut connection, *mut libc::c_void) -> handler_t>,
    pub handle_connection_shut_wr:
        Option<unsafe extern "C" fn(*mut connection, *mut libc::c_void) -> handler_t>,
    pub handle_connection_close:
        Option<unsafe extern "C" fn(*mut connection, *mut libc::c_void) -> handler_t>,
    pub handle_trigger: Option<unsafe extern "C" fn(*mut server, *mut libc::c_void) -> handler_t>,
    pub handle_sighup: Option<unsafe extern "C" fn(*mut server, *mut libc::c_void) -> handler_t>,
    pub handle_waitpid: Option<
        unsafe extern "C" fn(*mut server, *mut libc::c_void, pid_t, libc::c_int) -> handler_t,
    >,
    pub init: Option<unsafe extern "C" fn() -> *mut libc::c_void>,
    pub priv_defaults: Option<unsafe extern "C" fn(*mut server, *mut libc::c_void) -> handler_t>,
    pub set_defaults: Option<unsafe extern "C" fn(*mut server, *mut libc::c_void) -> handler_t>,
    pub worker_init: Option<unsafe extern "C" fn(*mut server, *mut libc::c_void) -> handler_t>,
    pub cleanup: Option<unsafe extern "C" fn(*mut libc::c_void) -> ()>,
    pub name: *const libc::c_char,
    pub version: size_t,
    pub lib: *mut libc::c_void,
}
pub type http_version_t = libc::c_int;
pub const HTTP_VERSION_2: http_version_t = 2;
pub const HTTP_VERSION_1_1: http_version_t = 1;
pub const HTTP_VERSION_1_0: http_version_t = 0;
pub const HTTP_VERSION_UNSET: http_version_t = -1;
pub type request_state_t = libc::c_uint;
pub const CON_STATE_CLOSE: request_state_t = 10;
pub const CON_STATE_ERROR: request_state_t = 9;
pub const CON_STATE_RESPONSE_END: request_state_t = 8;
pub const CON_STATE_WRITE: request_state_t = 7;
pub const CON_STATE_RESPONSE_START: request_state_t = 6;
pub const CON_STATE_HANDLE_REQUEST: request_state_t = 5;
pub const CON_STATE_READ_POST: request_state_t = 4;
pub const CON_STATE_REQUEST_END: request_state_t = 3;
pub const CON_STATE_READ: request_state_t = 2;
pub const CON_STATE_REQUEST_START: request_state_t = 1;
pub const CON_STATE_CONNECT: request_state_t = 0;
#[derive(Copy, Clone)]
#[repr(C)]
pub struct h2con {
    pub r: [*mut request_st; 8],
    pub rused: uint32_t,
    pub h2_cid: uint32_t,
    pub h2_sid: uint32_t,
    pub sent_goaway: int32_t,
    pub sent_settings: unix_time64_t,
    pub s_header_table_size: uint32_t,
    pub s_enable_push: uint32_t,
    pub s_max_concurrent_streams: uint32_t,
    pub s_initial_window_size: int32_t,
    pub s_max_frame_size: uint32_t,
    pub s_max_header_list_size: uint32_t,
    pub decoder: lshpack_dec,
    pub encoder: lshpack_enc,
    pub half_closed_ts: unix_time64_t,
}
#[derive(Copy, Clone)]
#[repr(C)]
pub struct lshpack_enc {
    pub hpe_cur_capacity: libc::c_uint,
    pub hpe_max_capacity: libc::c_uint,
    pub hpe_next_id: libc::c_uint,
    pub hpe_nelem: libc::c_uint,
    pub hpe_nbits: libc::c_uint,
    pub hpe_all_entries: lshpack_enc_head,
    pub hpe_buckets: *mut lshpack_double_enc_head,
    pub hpe_hist_buf: *mut uint32_t,
    pub hpe_hist_size: libc::c_uint,
    pub hpe_hist_idx: libc::c_uint,
    pub hpe_hist_wrapped: libc::c_int,
    pub hpe_flags: C2RustUnnamed_5,
}
pub type C2RustUnnamed_5 = libc::c_uint;
pub const LSHPACK_ENC_USE_HIST: C2RustUnnamed_5 = 1;
#[derive(Copy, Clone)]
#[repr(C)]
pub struct lshpack_double_enc_head {
    pub by_name: lshpack_enc_head,
    pub by_nameval: lshpack_enc_head,
}
#[derive(Copy, Clone)]
#[repr(C)]
pub struct lshpack_enc_head {
    pub stqh_first: *mut lshpack_enc_table_entry,
    pub stqh_last: *mut *mut lshpack_enc_table_entry,
}
#[derive(Copy, Clone)]
#[repr(C)]
pub struct lshpack_enc_table_entry {
    pub ete_next_nameval: C2RustUnnamed_6,
    pub ete_next_name: C2RustUnnamed_6,
    pub ete_next_all: C2RustUnnamed_6,
    pub ete_id: libc::c_uint,
    pub ete_nameval_hash: libc::c_uint,
    pub ete_name_hash: libc::c_uint,
    pub ete_name_len: libc::c_uint,
    pub ete_val_len: libc::c_uint,
    pub ete_buf: [libc::c_char; 0],
}
#[derive(Copy, Clone)]
#[repr(C)]
pub struct C2RustUnnamed_6 {
    pub stqe_next: *mut lshpack_enc_table_entry,
}
#[derive(Copy, Clone)]
#[repr(C)]
pub struct lshpack_dec {
    pub hpd_dyn_table: lshpack_arr,
    pub hpd_max_capacity: libc::c_uint,
    pub hpd_cur_max_capacity: libc::c_uint,
    pub hpd_cur_capacity: libc::c_uint,
    pub hpd_state: libc::c_uint,
}
#[derive(Copy, Clone)]
#[repr(C)]
pub struct lshpack_arr {
    pub nalloc: libc::c_uint,
    pub nelem: libc::c_uint,
    pub off: libc::c_uint,
    pub els: *mut uintptr_t,
}
#[derive(Copy, Clone)]
#[repr(C)]
pub struct fdevents {
    pub fdarray: *mut *mut fdnode,
    pub pendclose: *mut fdnode,
    pub event_set:
        Option<unsafe extern "C" fn(*mut fdevents, *mut fdnode, libc::c_int) -> libc::c_int>,
    pub event_del: Option<unsafe extern "C" fn(*mut fdevents, *mut fdnode) -> libc::c_int>,
    pub poll: Option<unsafe extern "C" fn(*mut fdevents, libc::c_int) -> libc::c_int>,
    pub errh: *mut log_error_st,
    pub cur_fds: *mut libc::c_int,
    pub maxfds: uint32_t,
    pub epoll_fd: libc::c_int,
    pub epoll_events: *mut epoll_event,
    pub pollfds: *mut pollfd,
    pub size: uint32_t,
    pub used: uint32_t,
    pub unused: buffer_int,
    pub reset: Option<unsafe extern "C" fn(*mut fdevents) -> libc::c_int>,
    pub free: Option<unsafe extern "C" fn(*mut fdevents) -> ()>,
    pub event_handler: *const libc::c_char,
    pub type_0: fdevent_handler_t,
}
pub type fdevent_handler_t = libc::c_uint;
pub const FDEVENT_HANDLER_LIBEV: fdevent_handler_t = 7;
pub const FDEVENT_HANDLER_FREEBSD_KQUEUE: fdevent_handler_t = 6;
pub const FDEVENT_HANDLER_SOLARIS_PORT: fdevent_handler_t = 5;
pub const FDEVENT_HANDLER_SOLARIS_DEVPOLL: fdevent_handler_t = 4;
pub const FDEVENT_HANDLER_LINUX_SYSEPOLL: fdevent_handler_t = 3;
pub const FDEVENT_HANDLER_POLL: fdevent_handler_t = 2;
pub const FDEVENT_HANDLER_SELECT: fdevent_handler_t = 1;
pub const FDEVENT_HANDLER_UNSET: fdevent_handler_t = 0;
#[derive(Copy, Clone)]
#[repr(C)]
pub struct buffer_int {
    pub ptr: *mut libc::c_int,
    pub used: uint32_t,
    pub size: uint32_t,
}
#[derive(Copy, Clone)]
#[repr(C)]
pub struct pollfd {
    pub fd: libc::c_int,
    pub events: libc::c_short,
    pub revents: libc::c_short,
}
#[derive(Copy, Clone)]
#[repr(C, packed)]
pub struct epoll_event {
    pub events: uint32_t,
    pub data: epoll_data_t,
}
pub type epoll_data_t = epoll_data;
#[derive(Copy, Clone)]
#[repr(C)]
pub union epoll_data {
    pub ptr: *mut libc::c_void,
    pub fd: libc::c_int,
    pub u32_0: uint32_t,
    pub u64_0: uint64_t,
}
pub type FILE = _IO_FILE;
#[derive(Copy, Clone)]
#[repr(C)]
pub struct _IO_FILE {
    pub _flags: libc::c_int,
    pub _IO_read_ptr: *mut libc::c_char,
    pub _IO_read_end: *mut libc::c_char,
    pub _IO_read_base: *mut libc::c_char,
    pub _IO_write_base: *mut libc::c_char,
    pub _IO_write_ptr: *mut libc::c_char,
    pub _IO_write_end: *mut libc::c_char,
    pub _IO_buf_base: *mut libc::c_char,
    pub _IO_buf_end: *mut libc::c_char,
    pub _IO_save_base: *mut libc::c_char,
    pub _IO_backup_base: *mut libc::c_char,
    pub _IO_save_end: *mut libc::c_char,
    pub _markers: *mut _IO_marker,
    pub _chain: *mut _IO_FILE,
    pub _fileno: libc::c_int,
    pub _flags2: libc::c_int,
    pub _old_offset: __off_t,
    pub _cur_column: libc::c_ushort,
    pub _vtable_offset: libc::c_schar,
    pub _shortbuf: [libc::c_char; 1],
    pub _lock: *mut libc::c_void,
    pub _offset: __off64_t,
    pub _codecvt: *mut _IO_codecvt,
    pub _wide_data: *mut _IO_wide_data,
    pub _freeres_list: *mut _IO_FILE,
    pub _freeres_buf: *mut libc::c_void,
    pub __pad5: size_t,
    pub _mode: libc::c_int,
    pub _unused2: [libc::c_char; 20],
}
pub type _IO_lock_t = ();
#[derive(Copy, Clone)]
#[repr(C)]
pub struct const_iovec {
    pub iov_base: *const libc::c_void,
    pub iov_len: size_t,
}
pub type buffer_encoding_t = libc::c_uint;
pub const ENCODING_MINIMAL_XML: buffer_encoding_t = 3;
pub const ENCODING_HTML: buffer_encoding_t = 2;
pub const ENCODING_REL_URI_PART: buffer_encoding_t = 1;
pub const ENCODING_REL_URI: buffer_encoding_t = 0;
pub type errno_t = libc::c_int;
#[derive(Copy, Clone)]
#[repr(C)]
pub struct data_string {
    pub key: buffer,
    pub fn_0: *const data_methods,
    pub type_0: data_type_t,
    pub ext: libc::c_int,
    pub value: buffer,
}
#[derive(Copy, Clone)]
#[repr(C)]
pub struct data_array {
    pub key: buffer,
    pub fn_0: *const data_methods,
    pub type_0: data_type_t,
    pub value: array,
}
#[derive(Copy, Clone)]
#[repr(C)]
pub struct data_integer {
    pub key: buffer,
    pub fn_0: *const data_methods,
    pub type_0: data_type_t,
    pub value: libc::c_int,
}
pub type __sighandler_t = Option<unsafe extern "C" fn(libc::c_int) -> ()>;
#[derive(Copy, Clone)]
#[repr(C)]
pub struct fdlog_pipe {
    pub fdlog: *mut fdlog_st,
    pub pid: pid_t,
    pub fd: libc::c_int,
    pub start: unix_time64_t,
}
#[derive(Copy, Clone)]
#[repr(C)]
pub struct fdlog_pipes_t {
    pub ptr: *mut fdlog_pipe,
    pub used: uint32_t,
    pub size: uint32_t,
}
#[derive(Copy, Clone)]
#[repr(C)]
pub struct fdlog_files_t {
    pub ptr: *mut *mut fdlog_st,
    pub used: uint32_t,
    pub size: uint32_t,
}
pub type va_list = __builtin_va_list;
#[derive(Copy, Clone)]
#[repr(C)]
pub struct iovec {
    pub iov_base: *mut libc::c_void,
    pub iov_len: size_t,
}
pub const _SC_PAGESIZE: C2RustUnnamed_33 = 30;
#[derive(Copy, Clone)]
#[repr(C)]
pub struct keyvalue {
    pub key: libc::c_int,
    pub vlen: libc::c_uint,
    pub value: *const libc::c_char,
}
#[derive(Copy, Clone)]
#[repr(C)]
pub struct http_header_parse_ctx {
    pub k: *mut libc::c_char,
    pub v: *mut libc::c_char,
    pub klen: uint32_t,
    pub vlen: uint32_t,
    pub hlen: uint32_t,
    pub pseudo: uint8_t,
    pub scheme: uint8_t,
    pub trailers: uint8_t,
    pub id: int8_t,
    pub max_request_field_size: uint32_t,
    pub http_parseopts: libc::c_uint,
}
pub const HTTP_PARSEOPT_URL_NORMALIZE_CTRLS_REJECT: burl_opts_e = 64;
pub const HTTP_PARSEOPT_HEADER_STRICT: burl_opts_e = 1;
pub type http_header_e = libc::c_uint;
pub const HTTP_HEADER_X_XSS_PROTECTION: http_header_e = 58;
pub const HTTP_HEADER_X_FRAME_OPTIONS: http_header_e = 57;
pub const HTTP_HEADER_X_FORWARDED_PROTO: http_header_e = 56;
pub const HTTP_HEADER_X_FORWARDED_FOR: http_header_e = 55;
pub const HTTP_HEADER_X_CONTENT_TYPE_OPTIONS: http_header_e = 54;
pub const HTTP_HEADER_WWW_AUTHENTICATE: http_header_e = 53;
pub const HTTP_HEADER_VARY: http_header_e = 52;
pub const HTTP_HEADER_USER_AGENT: http_header_e = 51;
pub const HTTP_HEADER_UPGRADE_INSECURE_REQUESTS: http_header_e = 50;
pub const HTTP_HEADER_UPGRADE: http_header_e = 49;
pub const HTTP_HEADER_TRANSFER_ENCODING: http_header_e = 48;
pub const HTTP_HEADER_TE: http_header_e = 47;
pub const HTTP_HEADER_STRICT_TRANSPORT_SECURITY: http_header_e = 46;
pub const HTTP_HEADER_STATUS: http_header_e = 45;
pub const HTTP_HEADER_SET_COOKIE: http_header_e = 44;
pub const HTTP_HEADER_SERVER: http_header_e = 43;
pub const HTTP_HEADER_REFERRER_POLICY: http_header_e = 42;
pub const HTTP_HEADER_REFERER: http_header_e = 41;
pub const HTTP_HEADER_RANGE: http_header_e = 40;
pub const HTTP_HEADER_PRAGMA: http_header_e = 39;
pub const HTTP_HEADER_P3P: http_header_e = 38;
pub const HTTP_HEADER_ONION_LOCATION: http_header_e = 37;
pub const HTTP_HEADER_LOCATION: http_header_e = 36;
pub const HTTP_HEADER_LINK: http_header_e = 35;
pub const HTTP_HEADER_LAST_MODIFIED: http_header_e = 34;
pub const HTTP_HEADER_IF_UNMODIFIED_SINCE: http_header_e = 33;
pub const HTTP_HEADER_IF_RANGE: http_header_e = 32;
pub const HTTP_HEADER_IF_NONE_MATCH: http_header_e = 31;
pub const HTTP_HEADER_IF_MODIFIED_SINCE: http_header_e = 30;
pub const HTTP_HEADER_IF_MATCH: http_header_e = 29;
pub const HTTP_HEADER_HTTP2_SETTINGS: http_header_e = 28;
pub const HTTP_HEADER_HOST: http_header_e = 27;
pub const HTTP_HEADER_FORWARDED: http_header_e = 26;
pub const HTTP_HEADER_EXPIRES: http_header_e = 25;
pub const HTTP_HEADER_EXPECT_CT: http_header_e = 24;
pub const HTTP_HEADER_EXPECT: http_header_e = 23;
pub const HTTP_HEADER_ETAG: http_header_e = 22;
pub const HTTP_HEADER_DNT: http_header_e = 21;
pub const HTTP_HEADER_DATE: http_header_e = 20;
pub const HTTP_HEADER_COOKIE: http_header_e = 19;
pub const HTTP_HEADER_CONTENT_TYPE: http_header_e = 18;
pub const HTTP_HEADER_CONTENT_SECURITY_POLICY: http_header_e = 17;
pub const HTTP_HEADER_CONTENT_RANGE: http_header_e = 16;
pub const HTTP_HEADER_CONTENT_LOCATION: http_header_e = 15;
pub const HTTP_HEADER_CONTENT_LENGTH: http_header_e = 14;
pub const HTTP_HEADER_CONTENT_ENCODING: http_header_e = 13;
pub const HTTP_HEADER_CONNECTION: http_header_e = 12;
pub const HTTP_HEADER_CACHE_CONTROL: http_header_e = 11;
pub const HTTP_HEADER_AUTHORIZATION: http_header_e = 10;
pub const HTTP_HEADER_ALT_USED: http_header_e = 9;
pub const HTTP_HEADER_ALT_SVC: http_header_e = 8;
pub const HTTP_HEADER_ALLOW: http_header_e = 7;
pub const HTTP_HEADER_AGE: http_header_e = 6;
pub const HTTP_HEADER_ACCESS_CONTROL_ALLOW_ORIGIN: http_header_e = 5;
pub const HTTP_HEADER_ACCEPT_RANGES: http_header_e = 4;
pub const HTTP_HEADER_ACCEPT_LANGUAGE: http_header_e = 3;
pub const HTTP_HEADER_ACCEPT_ENCODING: http_header_e = 2;
pub const HTTP_HEADER_ACCEPT: http_header_e = 1;
pub const HTTP_HEADER_OTHER: http_header_e = 0;
#[derive(Copy, Clone)]
#[repr(C)]
pub struct keyvlenvalue {
    pub key: int16_t,
    pub vlen: uint16_t,
    pub value: [libc::c_char; 28],
}
pub const HTTP_HEADER_H2_UNKNOWN: http_header_h2_e = -1;
pub const HTTP_HEADER_H2_SCHEME_HTTPS: http_header_h2_e = -8;
pub const HTTP_HEADER_H2_SCHEME_HTTP: http_header_h2_e = -7;
pub const HTTP_HEADER_H2_PATH_INDEX_HTML: http_header_h2_e = -6;
pub const HTTP_HEADER_H2_PATH: http_header_h2_e = -5;
pub const HTTP_HEADER_H2_METHOD_POST: http_header_h2_e = -4;
pub const HTTP_HEADER_H2_METHOD_GET: http_header_h2_e = -3;
pub const HTTP_HEADER_H2_AUTHORITY: http_header_h2_e = -2;
pub const HTTP_PARSEOPT_METHOD_GET_BODY: burl_opts_e = 32768;
#[derive(Copy, Clone)]
#[repr(C)]
pub struct C2RustUnnamed_7 {
    pub s: [libc::c_char; 46],
    pub n: size_t,
}
pub type socklen_t = __socklen_t;
#[derive(Copy, Clone)]
#[repr(C)]
pub struct C2RustUnnamed_8 {
    pub s: [libc::c_char; 16],
    pub n: size_t,
}
pub const HTTP_PARSEOPT_HOST_NORMALIZE: burl_opts_e = 4;
pub const HTTP_PARSEOPT_HOST_STRICT: burl_opts_e = 2;
pub const HTTP_PARSEOPT_URL_NORMALIZE_QUERY_20_PLUS: burl_opts_e = 4096;
pub const HTTP_PARSEOPT_URL_NORMALIZE_PATH_DOTSEG_REJECT: burl_opts_e = 2048;
pub const HTTP_PARSEOPT_URL_NORMALIZE_PATH_DOTSEG_REMOVE: burl_opts_e = 1024;
pub const HTTP_PARSEOPT_URL_NORMALIZE_PATH_2F_DECODE: burl_opts_e = 256;
pub const HTTP_PARSEOPT_URL_NORMALIZE_PATH_2F_REJECT: burl_opts_e = 512;
pub const HTTP_PARSEOPT_URL_NORMALIZE_REQUIRED: burl_opts_e = 32;
pub const HTTP_PARSEOPT_URL_NORMALIZE: burl_opts_e = 8;
#[derive(Copy, Clone)]
#[repr(C)]
pub union proto_un {
    pub c: [libc::c_char; 8],
    pub u: uint64_t,
}
pub type __socket_type = libc::c_uint;
pub const SOCK_NONBLOCK: __socket_type = 2048;
pub const SOCK_CLOEXEC: __socket_type = 524288;
pub const SOCK_PACKET: __socket_type = 10;
pub const SOCK_DCCP: __socket_type = 6;
pub const SOCK_SEQPACKET: __socket_type = 5;
pub const SOCK_RDM: __socket_type = 4;
pub const SOCK_RAW: __socket_type = 3;
pub const SOCK_DGRAM: __socket_type = 2;
pub const SOCK_STREAM: __socket_type = 1;
pub type C2RustUnnamed_9 = libc::c_uint;
pub const MSG_CMSG_CLOEXEC: C2RustUnnamed_9 = 1073741824;
pub const MSG_FASTOPEN: C2RustUnnamed_9 = 536870912;
pub const MSG_ZEROCOPY: C2RustUnnamed_9 = 67108864;
pub const MSG_BATCH: C2RustUnnamed_9 = 262144;
pub const MSG_WAITFORONE: C2RustUnnamed_9 = 65536;
pub const MSG_MORE: C2RustUnnamed_9 = 32768;
pub const MSG_NOSIGNAL: C2RustUnnamed_9 = 16384;
pub const MSG_ERRQUEUE: C2RustUnnamed_9 = 8192;
pub const MSG_RST: C2RustUnnamed_9 = 4096;
pub const MSG_CONFIRM: C2RustUnnamed_9 = 2048;
pub const MSG_SYN: C2RustUnnamed_9 = 1024;
pub const MSG_FIN: C2RustUnnamed_9 = 512;
pub const MSG_WAITALL: C2RustUnnamed_9 = 256;
pub const MSG_EOR: C2RustUnnamed_9 = 128;
pub const MSG_DONTWAIT: C2RustUnnamed_9 = 64;
pub const MSG_TRUNC: C2RustUnnamed_9 = 32;
pub const MSG_PROXY: C2RustUnnamed_9 = 16;
pub const MSG_CTRUNC: C2RustUnnamed_9 = 8;
pub const MSG_TRYHARD: C2RustUnnamed_9 = 4;
pub const MSG_DONTROUTE: C2RustUnnamed_9 = 4;
pub const MSG_PEEK: C2RustUnnamed_9 = 2;
pub const MSG_OOB: C2RustUnnamed_9 = 1;
pub type C2RustUnnamed_10 = libc::c_uint;
pub const SHUT_RDWR: C2RustUnnamed_10 = 2;
pub const SHUT_WR: C2RustUnnamed_10 = 1;
pub const SHUT_RD: C2RustUnnamed_10 = 0;
#[derive(Copy, Clone)]
#[repr(C)]
pub union __SOCKADDR_ARG {
    pub __sockaddr__: *mut sockaddr,
    pub __sockaddr_at__: *mut sockaddr_at,
    pub __sockaddr_ax25__: *mut sockaddr_ax25,
    pub __sockaddr_dl__: *mut sockaddr_dl,
    pub __sockaddr_eon__: *mut sockaddr_eon,
    pub __sockaddr_in__: *mut sockaddr_in,
    pub __sockaddr_in6__: *mut sockaddr_in6,
    pub __sockaddr_inarp__: *mut sockaddr_inarp,
    pub __sockaddr_ipx__: *mut sockaddr_ipx,
    pub __sockaddr_iso__: *mut sockaddr_iso,
    pub __sockaddr_ns__: *mut sockaddr_ns,
    pub __sockaddr_un__: *mut sockaddr_un,
    pub __sockaddr_x25__: *mut sockaddr_x25,
}
#[derive(Copy, Clone)]
#[repr(C)]
pub union __CONST_SOCKADDR_ARG {
    pub __sockaddr__: *const sockaddr,
    pub __sockaddr_at__: *const sockaddr_at,
    pub __sockaddr_ax25__: *const sockaddr_ax25,
    pub __sockaddr_dl__: *const sockaddr_dl,
    pub __sockaddr_eon__: *const sockaddr_eon,
    pub __sockaddr_in__: *const sockaddr_in,
    pub __sockaddr_in6__: *const sockaddr_in6,
    pub __sockaddr_inarp__: *const sockaddr_inarp,
    pub __sockaddr_ipx__: *const sockaddr_ipx,
    pub __sockaddr_iso__: *const sockaddr_iso,
    pub __sockaddr_ns__: *const sockaddr_ns,
    pub __sockaddr_un__: *const sockaddr_un,
    pub __sockaddr_x25__: *const sockaddr_x25,
}
pub type C2RustUnnamed_11 = libc::c_uint;
pub const IPPROTO_MAX: C2RustUnnamed_11 = 263;
pub const IPPROTO_MPTCP: C2RustUnnamed_11 = 262;
pub const IPPROTO_RAW: C2RustUnnamed_11 = 255;
pub const IPPROTO_ETHERNET: C2RustUnnamed_11 = 143;
pub const IPPROTO_MPLS: C2RustUnnamed_11 = 137;
pub const IPPROTO_UDPLITE: C2RustUnnamed_11 = 136;
pub const IPPROTO_SCTP: C2RustUnnamed_11 = 132;
pub const IPPROTO_COMP: C2RustUnnamed_11 = 108;
pub const IPPROTO_PIM: C2RustUnnamed_11 = 103;
pub const IPPROTO_ENCAP: C2RustUnnamed_11 = 98;
pub const IPPROTO_BEETPH: C2RustUnnamed_11 = 94;
pub const IPPROTO_MTP: C2RustUnnamed_11 = 92;
pub const IPPROTO_AH: C2RustUnnamed_11 = 51;
pub const IPPROTO_ESP: C2RustUnnamed_11 = 50;
pub const IPPROTO_GRE: C2RustUnnamed_11 = 47;
pub const IPPROTO_RSVP: C2RustUnnamed_11 = 46;
pub const IPPROTO_IPV6: C2RustUnnamed_11 = 41;
pub const IPPROTO_DCCP: C2RustUnnamed_11 = 33;
pub const IPPROTO_TP: C2RustUnnamed_11 = 29;
pub const IPPROTO_IDP: C2RustUnnamed_11 = 22;
pub const IPPROTO_UDP: C2RustUnnamed_11 = 17;
pub const IPPROTO_PUP: C2RustUnnamed_11 = 12;
pub const IPPROTO_EGP: C2RustUnnamed_11 = 8;
pub const IPPROTO_TCP: C2RustUnnamed_11 = 6;
pub const IPPROTO_IPIP: C2RustUnnamed_11 = 4;
pub const IPPROTO_IGMP: C2RustUnnamed_11 = 2;
pub const IPPROTO_ICMP: C2RustUnnamed_11 = 1;
pub const IPPROTO_IP: C2RustUnnamed_11 = 0;
pub type C2RustUnnamed_12 = libc::c_uint;
pub const TCP_CLOSING: C2RustUnnamed_12 = 11;
pub const TCP_LISTEN: C2RustUnnamed_12 = 10;
pub const TCP_LAST_ACK: C2RustUnnamed_12 = 9;
pub const TCP_CLOSE_WAIT: C2RustUnnamed_12 = 8;
pub const TCP_CLOSE: C2RustUnnamed_12 = 7;
pub const TCP_TIME_WAIT: C2RustUnnamed_12 = 6;
pub const TCP_FIN_WAIT2: C2RustUnnamed_12 = 5;
pub const TCP_FIN_WAIT1: C2RustUnnamed_12 = 4;
pub const TCP_SYN_RECV: C2RustUnnamed_12 = 3;
pub const TCP_SYN_SENT: C2RustUnnamed_12 = 2;
pub const TCP_ESTABLISHED: C2RustUnnamed_12 = 1;
#[derive(Copy, Clone, BitfieldStruct)]
#[repr(C)]
pub struct tcp_info {
    pub tcpi_state: uint8_t,
    pub tcpi_ca_state: uint8_t,
    pub tcpi_retransmits: uint8_t,
    pub tcpi_probes: uint8_t,
    pub tcpi_backoff: uint8_t,
    pub tcpi_options: uint8_t,
    #[bitfield(name = "tcpi_snd_wscale", ty = "uint8_t", bits = "0..=3")]
    #[bitfield(name = "tcpi_rcv_wscale", ty = "uint8_t", bits = "4..=7")]
    pub tcpi_snd_wscale_tcpi_rcv_wscale: [u8; 1],
    #[bitfield(padding)]
    pub c2rust_padding: [u8; 1],
    pub tcpi_rto: uint32_t,
    pub tcpi_ato: uint32_t,
    pub tcpi_snd_mss: uint32_t,
    pub tcpi_rcv_mss: uint32_t,
    pub tcpi_unacked: uint32_t,
    pub tcpi_sacked: uint32_t,
    pub tcpi_lost: uint32_t,
    pub tcpi_retrans: uint32_t,
    pub tcpi_fackets: uint32_t,
    pub tcpi_last_data_sent: uint32_t,
    pub tcpi_last_ack_sent: uint32_t,
    pub tcpi_last_data_recv: uint32_t,
    pub tcpi_last_ack_recv: uint32_t,
    pub tcpi_pmtu: uint32_t,
    pub tcpi_rcv_ssthresh: uint32_t,
    pub tcpi_rtt: uint32_t,
    pub tcpi_rttvar: uint32_t,
    pub tcpi_snd_ssthresh: uint32_t,
    pub tcpi_snd_cwnd: uint32_t,
    pub tcpi_advmss: uint32_t,
    pub tcpi_reordering: uint32_t,
    pub tcpi_rcv_rtt: uint32_t,
    pub tcpi_rcv_space: uint32_t,
    pub tcpi_total_retrans: uint32_t,
}
#[derive(Copy, Clone)]
#[repr(C)]
pub struct addrinfo {
    pub ai_flags: libc::c_int,
    pub ai_family: libc::c_int,
    pub ai_socktype: libc::c_int,
    pub ai_protocol: libc::c_int,
    pub ai_addrlen: socklen_t,
    pub ai_addr: *mut sockaddr,
    pub ai_canonname: *mut libc::c_char,
    pub ai_next: *mut addrinfo,
}
pub type config_plugin_value_t = config_plugin_value;
#[derive(Copy, Clone)]
#[repr(C)]
pub struct config_plugin_value {
    pub k_id: libc::c_int,
    pub vtype: config_values_type_t,
    pub v: v_u,
}
#[derive(Copy, Clone)]
#[repr(C)]
pub union v_u {
    pub v: *mut libc::c_void,
    pub a: *const array,
    pub b: *const buffer,
    pub s: *const libc::c_char,
    pub u: libc::c_uint,
    pub shrt: libc::c_ushort,
    pub d: libc::c_double,
    pub o: off_t,
    pub u2: [uint32_t; 2],
}
pub type config_values_type_t = libc::c_uint;
pub const T_CONFIG_UNSUPPORTED: config_values_type_t = 12;
pub const T_CONFIG_DEPRECATED: config_values_type_t = 11;
pub const T_CONFIG_LOCAL: config_values_type_t = 10;
pub const T_CONFIG_ARRAY_VLIST: config_values_type_t = 9;
pub const T_CONFIG_ARRAY_KVSTRING: config_values_type_t = 8;
pub const T_CONFIG_ARRAY_KVARRAY: config_values_type_t = 7;
pub const T_CONFIG_ARRAY_KVANY: config_values_type_t = 6;
pub const T_CONFIG_ARRAY: config_values_type_t = 5;
pub const T_CONFIG_BOOL: config_values_type_t = 4;
pub const T_CONFIG_INT: config_values_type_t = 3;
pub const T_CONFIG_SHORT: config_values_type_t = 2;
pub const T_CONFIG_STRING: config_values_type_t = 1;
pub const T_CONFIG_UNSET: config_values_type_t = 0;
#[derive(Copy, Clone)]
#[repr(C)]
pub struct network_plugin_data {
    pub id: libc::c_int,
    pub nconfig: libc::c_int,
    pub cvlist: *mut config_plugin_value_t,
    pub self_0: *mut plugin,
    pub defaults: network_socket_config,
    pub conf: network_socket_config,
}
#[derive(Copy, Clone)]
#[repr(C)]
pub struct network_socket_config {
    pub listen_backlog: libc::c_int,
    pub ssl_enabled: libc::c_uchar,
    pub use_ipv6: libc::c_uchar,
    pub set_v6only: libc::c_uchar,
    pub defer_accept: libc::c_uchar,
    pub v4mapped: int8_t,
    pub socket_perms: *const buffer,
    pub bsd_accept_filter: *const buffer,
}
pub const CONFIG_COND_NE: config_cond_t = 3;
pub type config_cond_t = libc::c_uint;
pub const CONFIG_COND_ELSE: config_cond_t = 5;
pub const CONFIG_COND_NOMATCH: config_cond_t = 4;
pub const CONFIG_COND_MATCH: config_cond_t = 2;
pub const CONFIG_COND_EQ: config_cond_t = 1;
pub const CONFIG_COND_UNSET: config_cond_t = 0;
#[derive(Copy, Clone)]
#[repr(C)]
pub struct config_cond_info {
    pub comp: comp_key_t,
    pub cond: config_cond_t,
    pub string: *const buffer,
    pub comp_key: *const libc::c_char,
}
pub type comp_key_t = libc::c_uint;
pub const COMP_LAST_ELEMENT: comp_key_t = 13;
pub const COMP_HTTP_REQUEST_HEADER: comp_key_t = 12;
pub const COMP_HTTP_REQUEST_METHOD: comp_key_t = 11;
pub const COMP_HTTP_SCHEME: comp_key_t = 10;
pub const COMP_HTTP_QUERY_STRING: comp_key_t = 9;
pub const COMP_HTTP_REMOTE_IP: comp_key_t = 8;
pub const COMP_HTTP_COOKIE: comp_key_t = 7;
pub const COMP_HTTP_LANGUAGE: comp_key_t = 6;
pub const COMP_HTTP_USER_AGENT: comp_key_t = 5;
pub const COMP_HTTP_REFERER: comp_key_t = 4;
pub const COMP_HTTP_HOST: comp_key_t = 3;
pub const COMP_HTTP_URL: comp_key_t = 2;
pub const COMP_SERVER_SOCKET: comp_key_t = 1;
pub const COMP_UNSET: comp_key_t = 0;
#[derive(Copy, Clone)]
#[repr(C)]
pub struct data_config {
    pub key: buffer,
    pub fn_0: *const data_methods,
    pub type_0: data_type_t,
    pub context_ndx: libc::c_int,
    pub comp: comp_key_t,
    pub cond: config_cond_t,
    pub parent: *mut data_config,
    pub prev: *mut data_config,
    pub next: *mut data_config,
    pub string: buffer,
    pub code: *mut libc::c_void,
    pub match_data: *mut pcre2_real_match_data_8,
    pub capture_idx: libc::c_int,
    pub ext: libc::c_int,
    pub comp_tag: buffer,
    pub comp_key: *const libc::c_char,
    pub children: vector_config_weak,
    pub value: *mut array,
}
#[derive(Copy, Clone)]
#[repr(C)]
pub struct vector_config_weak {
    pub data: *mut *mut data_config,
    pub used: size_t,
    pub size: size_t,
}
#[derive(Copy, Clone)]
#[repr(C)]
pub struct C2RustUnnamed_13 {
    pub data: *const *const data_config,
    pub used: uint32_t,
}
#[derive(Copy, Clone)]
#[repr(C)]
pub struct config_plugin_keys_t {
    pub k: *const libc::c_char,
    pub klen: uint8_t,
    pub ktype: uint8_t,
    pub scope: uint8_t,
}
pub const T_CONFIG_SCOPE_UNSET: C2RustUnnamed_31 = 0;
pub const T_CONFIG_SCOPE_CONNECTION: C2RustUnnamed_31 = 2;
#[derive(Copy, Clone)]
#[repr(C)]
pub struct plugin_data_base {
    pub id: libc::c_int,
    pub nconfig: libc::c_int,
    pub cvlist: *mut config_plugin_value_t,
    pub self_0: *mut plugin,
}
pub const T_CONFIG_SCOPE_SERVER: C2RustUnnamed_31 = 1;
pub const NETWORK_BACKEND_WRITE: network_backend_t = 1;
pub const NETWORK_BACKEND_WRITEV: network_backend_t = 2;
pub const NETWORK_BACKEND_SENDFILE: network_backend_t = 3;
pub type network_backend_t = libc::c_uint;
pub const NETWORK_BACKEND_UNSET: network_backend_t = 0;
#[derive(Copy, Clone)]
#[repr(C)]
pub struct nb_map {
    pub nb: network_backend_t,
    pub name: *const libc::c_char,
}
pub const PLUGIN_FUNC_HANDLE_CONNECTION_CLOSE: C2RustUnnamed_54 = 10;
#[derive(Copy, Clone)]
#[repr(C)]
pub struct plugin_fn_data {
    pub fn_0: Option<unsafe extern "C" fn() -> handler_t>,
    pub data: *mut plugin_data_base,
}
pub const PLUGIN_FUNC_HANDLE_REQUEST_RESET: C2RustUnnamed_54 = 6;
pub const PLUGIN_FUNC_HANDLE_CONNECTION_ACCEPT: C2RustUnnamed_54 = 8;
#[derive(Copy, Clone)]
#[repr(C)]
pub struct C2RustUnnamed_14 {
    pub s: [libc::c_char; 47],
}
#[derive(Copy, Clone)]
#[repr(C)]
pub struct C2RustUnnamed_15 {
    pub ipv6: in6_addr,
}
#[derive(Copy, Clone)]
#[repr(C)]
pub struct C2RustUnnamed_16 {
    pub s: [libc::c_char; 17],
}
#[derive(Copy, Clone)]
#[repr(C)]
pub struct C2RustUnnamed_17 {
    pub ipv4: in_addr,
}
#[derive(Copy, Clone)]
#[repr(C)]
pub union C2RustUnnamed_18 {
    pub c: [uint8_t; 12],
    pub u: [uint32_t; 3],
}
pub const H2_FTYPE_HEADERS: C2RustUnnamed_25 = 1;
pub const H2_FTYPE_CONTINUATION: C2RustUnnamed_25 = 9;
pub const H2_FLAG_END_HEADERS: C2RustUnnamed_27 = 4;
pub type request_h2error_t = libc::c_uint;
pub const H2_E_HTTP_1_1_REQUIRED: request_h2error_t = 13;
pub const H2_E_INADEQUATE_SECURITY: request_h2error_t = 12;
pub const H2_E_ENHANCE_YOUR_CALM: request_h2error_t = 11;
pub const H2_E_CONNECT_ERROR: request_h2error_t = 10;
pub const H2_E_COMPRESSION_ERROR: request_h2error_t = 9;
pub const H2_E_CANCEL: request_h2error_t = 8;
pub const H2_E_REFUSED_STREAM: request_h2error_t = 7;
pub const H2_E_FRAME_SIZE_ERROR: request_h2error_t = 6;
pub const H2_E_STREAM_CLOSED: request_h2error_t = 5;
pub const H2_E_SETTINGS_TIMEOUT: request_h2error_t = 4;
pub const H2_E_FLOW_CONTROL_ERROR: request_h2error_t = 3;
pub const H2_E_INTERNAL_ERROR: request_h2error_t = 2;
pub const H2_E_PROTOCOL_ERROR: request_h2error_t = 1;
pub const H2_E_NO_ERROR: request_h2error_t = 0;
#[derive(Copy, Clone)]
#[repr(C)]
pub union C2RustUnnamed_19 {
    pub c: [uint8_t; 16],
    pub u: [uint32_t; 4],
}
pub const H2_FTYPE_RST_STREAM: C2RustUnnamed_25 = 3;
pub const H2_STATE_CLOSED: C2RustUnnamed_28 = 6;
pub const H2_STATE_HALF_CLOSED_REMOTE: C2RustUnnamed_28 = 5;
pub type lsxpack_header_t = lsxpack_header;
#[derive(Copy, Clone, BitfieldStruct)]
#[repr(C)]
pub struct lsxpack_header {
    pub buf: *mut libc::c_char,
    pub name_hash: uint32_t,
    pub nameval_hash: uint32_t,
    pub name_offset: lsxpack_strlen_t,
    pub name_len: lsxpack_strlen_t,
    pub val_offset: lsxpack_strlen_t,
    pub val_len: lsxpack_strlen_t,
    pub chain_next_idx: uint16_t,
    pub hpack_index: uint8_t,
    pub qpack_index: uint8_t,
    pub app_index: uint8_t,
    #[bitfield(name = "flags", ty = "lsxpack_flag", bits = "0..=7")]
    pub flags: [u8; 1],
    pub indexed_type: uint8_t,
    pub dec_overhead: uint8_t,
}
pub type lsxpack_flag = libc::c_uint;
pub const LSXPACK_NEVER_INDEX: lsxpack_flag = 64;
pub const LSXPACK_VAL_MATCHED: lsxpack_flag = 32;
pub const LSXPACK_NAMEVAL_HASH: lsxpack_flag = 16;
pub const LSXPACK_NAME_HASH: lsxpack_flag = 8;
pub const LSXPACK_APP_IDX: lsxpack_flag = 4;
pub const LSXPACK_QPACK_IDX: lsxpack_flag = 2;
pub const LSXPACK_HPACK_VAL_MATCHED: lsxpack_flag = 1;
pub type lsxpack_strlen_t = uint16_t;
pub const LSHPACK_HDR_UNKNOWN: lshpack_static_hdr_idx = 0;
#[derive(Copy, Clone)]
#[repr(C)]
pub struct C2RustUnnamed_20 {
    pub name_len: libc::c_uint,
    pub val_len: libc::c_uint,
    pub name: *const libc::c_char,
    pub val: *const libc::c_char,
}
#[derive(Copy, Clone)]
#[repr(C)]
pub struct encode_el {
    pub code: uint32_t,
    pub bits: libc::c_int,
}
pub const LSHPACK_HDR_ACCEPT_ENCODING: lshpack_static_hdr_idx = 16;
pub const PLUGIN_FUNC_HANDLE_CONNECTION_SHUT_WR: C2RustUnnamed_54 = 9;
pub const PLUGIN_FUNC_HANDLE_REQUEST_DONE: C2RustUnnamed_54 = 5;
#[derive(Copy, Clone)]
#[repr(C)]
pub struct dec_table_entry {
    pub dte_name_len: libc::c_uint,
    pub dte_val_len: libc::c_uint,
    pub dte_name_idx: uint8_t,
    pub dte_buf: [libc::c_char; 0],
}
#[derive(Copy, Clone)]
#[repr(C)]
pub union C2RustUnnamed_21 {
    pub c: [uint8_t; 20],
    pub u: [uint32_t; 5],
}
pub const H2_FTYPE_GOAWAY: C2RustUnnamed_25 = 7;
pub const H2_FLAG_END_STREAM: C2RustUnnamed_27 = 1;
pub const LSHPACK_HDR_SERVER: lshpack_static_hdr_idx = 54;
pub const LSHPACK_HDR_DATE: lshpack_static_hdr_idx = 33;
pub const LSHPACK_HDR_WWW_AUTHENTICATE: lshpack_static_hdr_idx = 61;
pub const LSHPACK_HDR_STRICT_TRANSPORT_SECURITY: lshpack_static_hdr_idx = 56;
pub const LSHPACK_HDR_REFERER: lshpack_static_hdr_idx = 51;
pub const LSHPACK_HDR_LINK: lshpack_static_hdr_idx = 45;
pub const LSHPACK_HDR_IF_UNMODIFIED_SINCE: lshpack_static_hdr_idx = 43;
pub const LSHPACK_HDR_IF_RANGE: lshpack_static_hdr_idx = 42;
pub const LSHPACK_HDR_IF_MATCH: lshpack_static_hdr_idx = 39;
pub const LSHPACK_HDR_EXPIRES: lshpack_static_hdr_idx = 36;
pub const LSHPACK_HDR_CONTENT_RANGE: lshpack_static_hdr_idx = 30;
pub const LSHPACK_HDR_ALLOW: lshpack_static_hdr_idx = 22;
pub const LSHPACK_HDR_AGE: lshpack_static_hdr_idx = 21;
pub const LSHPACK_HDR_ACCESS_CONTROL_ALLOW_ORIGIN: lshpack_static_hdr_idx = 20;
pub const LSHPACK_HDR_ACCEPT_RANGES: lshpack_static_hdr_idx = 18;
pub const LSHPACK_HDR_ACCEPT_LANGUAGE: lshpack_static_hdr_idx = 17;
pub const LSHPACK_HDR_ACCEPT: lshpack_static_hdr_idx = 19;
pub const LSHPACK_HDR_VARY: lshpack_static_hdr_idx = 59;
pub const LSHPACK_HDR_USER_AGENT: lshpack_static_hdr_idx = 58;
pub const LSHPACK_HDR_TRANSFER_ENCODING: lshpack_static_hdr_idx = 57;
pub const LSHPACK_HDR_SET_COOKIE: lshpack_static_hdr_idx = 55;
pub const LSHPACK_HDR_RANGE: lshpack_static_hdr_idx = 50;
pub const LSHPACK_HDR_LOCATION: lshpack_static_hdr_idx = 46;
pub const LSHPACK_HDR_LAST_MODIFIED: lshpack_static_hdr_idx = 44;
pub const LSHPACK_HDR_IF_NONE_MATCH: lshpack_static_hdr_idx = 41;
pub const LSHPACK_HDR_IF_MODIFIED_SINCE: lshpack_static_hdr_idx = 40;
pub const LSHPACK_HDR_HOST: lshpack_static_hdr_idx = 38;
pub const LSHPACK_HDR_EXPECT: lshpack_static_hdr_idx = 35;
pub const LSHPACK_HDR_ETAG: lshpack_static_hdr_idx = 34;
pub const LSHPACK_HDR_COOKIE: lshpack_static_hdr_idx = 32;
pub const LSHPACK_HDR_CONTENT_TYPE: lshpack_static_hdr_idx = 31;
pub const LSHPACK_HDR_CONTENT_LOCATION: lshpack_static_hdr_idx = 29;
pub const LSHPACK_HDR_CONTENT_LENGTH: lshpack_static_hdr_idx = 28;
pub const LSHPACK_HDR_CONTENT_ENCODING: lshpack_static_hdr_idx = 26;
pub const LSHPACK_HDR_CACHE_CONTROL: lshpack_static_hdr_idx = 24;
pub const LSHPACK_HDR_AUTHORIZATION: lshpack_static_hdr_idx = 23;
pub const LSHPACK_HDR_STATUS_500: lshpack_static_hdr_idx = 14;
pub const LSHPACK_HDR_STATUS_404: lshpack_static_hdr_idx = 13;
pub const LSHPACK_HDR_STATUS_400: lshpack_static_hdr_idx = 12;
pub const LSHPACK_HDR_STATUS_304: lshpack_static_hdr_idx = 11;
pub const LSHPACK_HDR_STATUS_206: lshpack_static_hdr_idx = 10;
pub const LSHPACK_HDR_STATUS_204: lshpack_static_hdr_idx = 9;
pub const LSHPACK_HDR_STATUS_200: lshpack_static_hdr_idx = 8;
#[derive(Copy, Clone)]
#[repr(C)]
pub struct fam_dir_entry {
    pub name: buffer,
    pub refcnt: libc::c_int,
    pub req: FAMRequest,
    pub stat_ts: unix_time64_t,
    pub st_dev: dev_t,
    pub st_ino: ino_t,
    pub fam_parent: *mut fam_dir_entry,
}
pub type FAMRequest = libc::c_int;
#[derive(Copy, Clone)]
#[repr(C)]
pub struct stat_cache_fam {
    pub dirs: *mut splay_tree,
    pub wds: *mut splay_tree,
    pub errh: *mut log_error_st,
    pub ev: *mut fdevents,
    pub fdn: *mut fdnode,
    pub fd: libc::c_int,
}
pub type splay_tree = tree_node;
#[derive(Copy, Clone)]
#[repr(C)]
pub struct tree_node {
    pub left: *mut tree_node,
    pub right: *mut tree_node,
    pub key: libc::c_int,
    pub data: *mut libc::c_void,
}
#[derive(Copy, Clone)]
#[repr(C)]
pub struct stat_cache {
    pub stat_cache_engine: libc::c_int,
    pub files: *mut splay_tree,
    pub scf: *mut stat_cache_fam,
}
pub const STAT_CACHE_ENGINE_NONE: C2RustUnnamed_52 = 1;
pub const STAT_CACHE_ENGINE_FAM: C2RustUnnamed_52 = 2;
pub const STAT_CACHE_ENGINE_SIMPLE: C2RustUnnamed_52 = 0;
pub const PLUGIN_FUNC_HANDLE_RESPONSE_START: C2RustUnnamed_54 = 4;
pub const PLUGIN_FUNC_HANDLE_SUBREQUEST_START: C2RustUnnamed_54 = 3;
pub const PLUGIN_FUNC_HANDLE_PHYSICAL: C2RustUnnamed_54 = 2;
pub const PLUGIN_FUNC_HANDLE_DOCROOT: C2RustUnnamed_54 = 1;
pub const PLUGIN_FUNC_HANDLE_URI_CLEAN: C2RustUnnamed_54 = 0;
#[derive(Copy, Clone)]
#[repr(C)]
pub struct config_data_base {
    pub id: libc::c_int,
    pub nconfig: libc::c_int,
    pub cvlist: *mut config_plugin_value_t,
    pub self_0: *mut plugin,
    pub defaults: request_config,
}
pub const ETAG_USE_SIZE: C2RustUnnamed_48 = 4;
pub const ETAG_USE_MTIME: C2RustUnnamed_48 = 2;
pub const ETAG_USE_INODE: C2RustUnnamed_48 = 1;
pub type cond_result_t = libc::c_uint;
pub const COND_RESULT_TRUE: cond_result_t = 3;
pub const COND_RESULT_FALSE: cond_result_t = 2;
pub const COND_RESULT_SKIP: cond_result_t = 1;
pub const COND_RESULT_UNSET: cond_result_t = 0;
pub type pcre2_match_context_8 = pcre2_real_match_context_8;
pub type pcre2_match_data_8 = pcre2_real_match_data_8;
pub type PCRE2_SPTR8 = *const PCRE2_UCHAR8;
pub type PCRE2_UCHAR8 = uint8_t;
pub type pcre2_code_8 = pcre2_real_code_8;
pub type pcre2_general_context_8 = pcre2_real_general_context_8;
#[derive(Copy, Clone)]
#[repr(C)]
pub struct const_char_buffer {
    pub ptr: *const libc::c_char,
    pub used: uint32_t,
    pub size: uint32_t,
}
#[derive(Copy, Clone)]
#[repr(C)]
pub union C2RustUnnamed_22 {
    pub c: [uint8_t; 12],
    pub u: [uint32_t; 3],
}
pub const H2_FTYPE_DATA: C2RustUnnamed_25 = 0;
#[derive(Copy, Clone)]
#[repr(C)]
pub union C2RustUnnamed_23 {
    pub c: [uint8_t; 12],
    pub u: [uint32_t; 3],
}
pub const H2_FTYPE_PUSH_PROMISE: C2RustUnnamed_25 = 5;
pub const H2_STATE_IDLE: C2RustUnnamed_28 = 0;
pub const H2_FLAG_ACK: C2RustUnnamed_27 = 1;
pub const H2_FTYPE_PING: C2RustUnnamed_25 = 6;
pub const H2_FTYPE_SETTINGS: C2RustUnnamed_25 = 4;
pub const H2_SETTINGS_MAX_HEADER_LIST_SIZE: C2RustUnnamed_26 = 6;
pub const H2_SETTINGS_MAX_FRAME_SIZE: C2RustUnnamed_26 = 5;
pub const H2_STATE_HALF_CLOSED_LOCAL: C2RustUnnamed_28 = 4;
pub const H2_SETTINGS_INITIAL_WINDOW_SIZE: C2RustUnnamed_26 = 4;
pub const H2_SETTINGS_MAX_CONCURRENT_STREAMS: C2RustUnnamed_26 = 3;
pub const H2_SETTINGS_ENABLE_PUSH: C2RustUnnamed_26 = 2;
pub const H2_SETTINGS_HEADER_TABLE_SIZE: C2RustUnnamed_26 = 1;
pub const H2_FTYPE_PRIORITY: C2RustUnnamed_25 = 2;
pub const H2_FTYPE_WINDOW_UPDATE: C2RustUnnamed_25 = 8;
pub const H2_FLAG_PADDED: C2RustUnnamed_27 = 8;
#[derive(Copy, Clone)]
#[repr(C)]
pub union C2RustUnnamed_24 {
    pub c: [uint8_t; 16],
    pub u: [uint32_t; 4],
}
pub const H2_STATE_OPEN: C2RustUnnamed_28 = 3;
pub const LSHPACK_ADD_INDEX: C2RustUnnamed_46 = 0;
#[derive(Copy, Clone)]
#[repr(C)]
pub struct decode_status {
    pub state: uint8_t,
    pub eos: uint8_t,
}
pub const HPACK_HUFFMAN_FLAG_ACCEPTED: C2RustUnnamed_45 = 1;
#[derive(Copy, Clone)]
#[repr(C)]
pub struct decode_el {
    pub state: uint8_t,
    pub flags: uint8_t,
    pub sym: uint8_t,
}
pub const HPACK_HUFFMAN_FLAG_SYM: C2RustUnnamed_45 = 2;
pub const HPACK_HUFFMAN_FLAG_FAIL: C2RustUnnamed_45 = 4;
pub const LSHPACK_VAL_INDEX: C2RustUnnamed_46 = 3;
pub const LSHPACK_NO_INDEX: C2RustUnnamed_46 = 1;
pub const LSHPACK_NEVER_INDEX: C2RustUnnamed_46 = 2;
pub const H2_FLAG_PRIORITY: C2RustUnnamed_27 = 32;
pub type base64_charset = libc::c_uint;
pub const BASE64_URL: base64_charset = 1;
pub const BASE64_STANDARD: base64_charset = 0;
pub type lshpack_static_hdr_idx = libc::c_uint;
pub const LSHPACK_HDR_TOBE_INDEXED: lshpack_static_hdr_idx = 255;
pub const LSHPACK_HDR_VIA: lshpack_static_hdr_idx = 60;
pub const LSHPACK_HDR_RETRY_AFTER: lshpack_static_hdr_idx = 53;
pub const LSHPACK_HDR_REFRESH: lshpack_static_hdr_idx = 52;
pub const LSHPACK_HDR_PROXY_AUTHORIZATION: lshpack_static_hdr_idx = 49;
pub const LSHPACK_HDR_PROXY_AUTHENTICATE: lshpack_static_hdr_idx = 48;
pub const LSHPACK_HDR_MAX_FORWARDS: lshpack_static_hdr_idx = 47;
pub const LSHPACK_HDR_FROM: lshpack_static_hdr_idx = 37;
pub const LSHPACK_HDR_CONTENT_LANGUAGE: lshpack_static_hdr_idx = 27;
pub const LSHPACK_HDR_CONTENT_DISPOSITION: lshpack_static_hdr_idx = 25;
pub const LSHPACK_HDR_ACCEPT_CHARSET: lshpack_static_hdr_idx = 15;
pub const LSHPACK_HDR_SCHEME_HTTPS: lshpack_static_hdr_idx = 7;
pub const LSHPACK_HDR_SCHEME_HTTP: lshpack_static_hdr_idx = 6;
pub const LSHPACK_HDR_PATH_INDEX_HTML: lshpack_static_hdr_idx = 5;
pub const LSHPACK_HDR_PATH: lshpack_static_hdr_idx = 4;
pub const LSHPACK_HDR_METHOD_POST: lshpack_static_hdr_idx = 3;
pub const LSHPACK_HDR_METHOD_GET: lshpack_static_hdr_idx = 2;
pub const LSHPACK_HDR_AUTHORITY: lshpack_static_hdr_idx = 1;
pub type C2RustUnnamed_25 = libc::c_uint;
pub type C2RustUnnamed_26 = libc::c_uint;
pub type C2RustUnnamed_27 = libc::c_uint;
pub type C2RustUnnamed_28 = libc::c_uint;
pub const H2_STATE_RESERVED_REMOTE: C2RustUnnamed_28 = 2;
pub const H2_STATE_RESERVED_LOCAL: C2RustUnnamed_28 = 1;
#[derive(Copy, Clone)]
#[repr(C)]
pub struct ev_map {
    pub et: fdevent_handler_t,
    pub name: *const libc::c_char,
}
pub const EPOLL_CLOEXEC: C2RustUnnamed_47 = 524288;
pub const EPOLLHUP: EPOLL_EVENTS = 16;
pub const EPOLLERR: EPOLL_EVENTS = 8;
pub const EPOLLRDHUP: EPOLL_EVENTS = 8192;
pub const EPOLLOUT: EPOLL_EVENTS = 4;
pub const EPOLLPRI: EPOLL_EVENTS = 2;
pub const EPOLLIN: EPOLL_EVENTS = 1;
pub type nfds_t = libc::c_ulong;
pub type stat_cache_st = stat;
pub const STAT_CACHE_ENGINE_INOTIFY: C2RustUnnamed_52 = 2;
#[derive(Copy, Clone)]
#[repr(C)]
pub struct inotify_event {
    pub wd: libc::c_int,
    pub mask: uint32_t,
    pub cookie: uint32_t,
    pub len: uint32_t,
    pub name: [libc::c_char; 0],
}
pub const FAMMoved: FAMCodes = 6;
pub const FAMDeleted: FAMCodes = 2;
pub const FAMChanged: FAMCodes = 1;
pub const FAMCreated: FAMCodes = 5;
pub const IN_CLOEXEC: C2RustUnnamed_53 = 524288;
pub const IN_NONBLOCK: C2RustUnnamed_53 = 2048;
pub const HTTP_PARSEOPT_URL_NORMALIZE_UNRESERVED: burl_opts_e = 16;
pub type pcre2_compile_context_8 = pcre2_real_compile_context_8;
pub const HTTP_PARSEOPT_URL_NORMALIZE_PATH_BACKSLASH_TRANS: burl_opts_e = 128;
#[derive(Copy, Clone)]
#[repr(C)]
pub struct config_t {
    pub srv: *mut server,
    pub ok: libc::c_int,
    pub all_configs: *mut array,
    pub configs_stack: vector_config_weak,
    pub current: *mut data_config,
    pub basedir: *mut buffer,
}
#[derive(Copy, Clone)]
#[repr(C)]
pub struct tokenizer_t {
    pub source: *const libc::c_char,
    pub input: *const libc::c_char,
    pub offset: size_t,
    pub size: size_t,
    pub line_pos: libc::c_int,
    pub line: libc::c_int,
    pub in_key: libc::c_int,
    pub in_brace: libc::c_int,
    pub in_cond: libc::c_int,
    pub simulate_eol: libc::c_int,
}
#[derive(Copy, Clone)]
#[repr(C)]
pub struct yyParser {
    pub yyidx: libc::c_int,
    pub yyerrcnt: libc::c_int,
    pub ctx: *mut config_t,
    pub yystack: [yyStackEntry; 100],
}
#[derive(Copy, Clone)]
#[repr(C)]
pub struct yyStackEntry {
    pub stateno: libc::c_int,
    pub major: libc::c_int,
    pub minor: YYMINORTYPE,
}
#[derive(Copy, Clone)]
#[repr(C)]
pub union YYMINORTYPE {
    pub yy0: *mut buffer,
    pub yy18: *mut data_config,
    pub yy29: *mut buffer,
    pub yy42: *mut array,
    pub yy53: config_cond_t,
    pub yy91: *mut data_unset,
    pub yy101: libc::c_int,
}
#[derive(Copy, Clone)]
#[repr(C)]
pub struct C2RustUnnamed_29 {
    pub lhs: libc::c_uchar,
    pub nrhs: libc::c_uchar,
}
#[derive(Copy, Clone)]
#[repr(C)]
pub struct glob_t {
    pub gl_pathc: __size_t,
    pub gl_pathv: *mut *mut libc::c_char,
    pub gl_offs: __size_t,
    pub gl_flags: libc::c_int,
    pub gl_closedir: Option<unsafe extern "C" fn(*mut libc::c_void) -> ()>,
    pub gl_readdir: Option<unsafe extern "C" fn(*mut libc::c_void) -> *mut dirent>,
    pub gl_opendir: Option<unsafe extern "C" fn(*const libc::c_char) -> *mut libc::c_void>,
    pub gl_lstat: Option<unsafe extern "C" fn(*const libc::c_char, *mut stat) -> libc::c_int>,
    pub gl_stat: Option<unsafe extern "C" fn(*const libc::c_char, *mut stat) -> libc::c_int>,
}
pub type __size_t = libc::c_ulong;
#[derive(Copy, Clone)]
#[repr(C)]
pub struct C2RustUnnamed_30 {
    pub comp: comp_key_t,
    pub len: uint32_t,
    pub comp_tag: *const libc::c_char,
}
pub const _ISspace: C2RustUnnamed_49 = 8192;
pub const _ISalnum: C2RustUnnamed_49 = 8;
pub const _ISdigit: C2RustUnnamed_49 = 2048;
pub const _ISalpha: C2RustUnnamed_49 = 1024;
#[derive(Copy, Clone)]
#[repr(C)]
pub struct facility_name_st {
    pub name: *const libc::c_char,
    pub val: libc::c_int,
}
pub type C2RustUnnamed_31 = libc::c_uint;
pub const PLUGIN_FUNC_HANDLE_REQUEST_ENV: C2RustUnnamed_54 = 7;
pub const PLUGIN_FUNC_HANDLE_TRIGGER: C2RustUnnamed_54 = 11;
pub const PLUGIN_FUNC_HANDLE_WAITPID: C2RustUnnamed_54 = 12;
pub const PLUGIN_FUNC_HANDLE_SIGHUP: C2RustUnnamed_54 = 13;
pub const PLUGIN_FUNC_WORKER_INIT: C2RustUnnamed_54 = 15;
pub const PLUGIN_FUNC_SET_DEFAULTS: C2RustUnnamed_54 = 14;
pub const PLUGIN_FUNC_SIZEOF: C2RustUnnamed_54 = 16;
pub type C2RustUnnamed_32 = libc::c_uint;
pub const BACKEND_AJP13: C2RustUnnamed_32 = 4;
pub const BACKEND_SCGI: C2RustUnnamed_32 = 3;
pub const BACKEND_FASTCGI: C2RustUnnamed_32 = 2;
pub const BACKEND_CGI: C2RustUnnamed_32 = 1;
pub const BACKEND_PROXY: C2RustUnnamed_32 = 0;
#[derive(Copy, Clone)]
#[repr(C)]
pub struct http_response_opts_t {
    pub max_per_read: uint32_t,
    pub fdfmt: libc::c_int,
    pub backend: libc::c_int,
    pub authorizer: libc::c_int,
    pub simple_accum: uint8_t,
    pub local_redir: uint8_t,
    pub xsendfile_allow: uint8_t,
    pub xsendfile_docroot: *const array,
    pub pdata: *mut libc::c_void,
    pub parse: Option<
        unsafe extern "C" fn(
            *mut request_st,
            *mut http_response_opts_t,
            *mut buffer,
            size_t,
        ) -> handler_t,
    >,
    pub headers:
        Option<unsafe extern "C" fn(*mut request_st, *mut http_response_opts_t) -> handler_t>,
}
pub type http_response_opts = http_response_opts_t;
pub type http_response_send_1xx_cb =
    Option<unsafe extern "C" fn(*mut request_st, *mut connection) -> libc::c_int>;
#[derive(Copy, Clone)]
#[repr(C)]
pub struct mtime_cache_type {
    pub mtime: unix_time64_t,
    pub str_0: buffer,
}
pub type C2RustUnnamed_33 = libc::c_uint;
pub const _SC_SIGSTKSZ: C2RustUnnamed_33 = 250;
pub const _SC_MINSIGSTKSZ: C2RustUnnamed_33 = 249;
pub const _SC_THREAD_ROBUST_PRIO_PROTECT: C2RustUnnamed_33 = 248;
pub const _SC_THREAD_ROBUST_PRIO_INHERIT: C2RustUnnamed_33 = 247;
pub const _SC_XOPEN_STREAMS: C2RustUnnamed_33 = 246;
pub const _SC_TRACE_USER_EVENT_MAX: C2RustUnnamed_33 = 245;
pub const _SC_TRACE_SYS_MAX: C2RustUnnamed_33 = 244;
pub const _SC_TRACE_NAME_MAX: C2RustUnnamed_33 = 243;
pub const _SC_TRACE_EVENT_NAME_MAX: C2RustUnnamed_33 = 242;
pub const _SC_SS_REPL_MAX: C2RustUnnamed_33 = 241;
pub const _SC_V7_LPBIG_OFFBIG: C2RustUnnamed_33 = 240;
pub const _SC_V7_LP64_OFF64: C2RustUnnamed_33 = 239;
pub const _SC_V7_ILP32_OFFBIG: C2RustUnnamed_33 = 238;
pub const _SC_V7_ILP32_OFF32: C2RustUnnamed_33 = 237;
pub const _SC_RAW_SOCKETS: C2RustUnnamed_33 = 236;
pub const _SC_IPV6: C2RustUnnamed_33 = 235;
pub const _SC_LEVEL4_CACHE_LINESIZE: C2RustUnnamed_33 = 199;
pub const _SC_LEVEL4_CACHE_ASSOC: C2RustUnnamed_33 = 198;
pub const _SC_LEVEL4_CACHE_SIZE: C2RustUnnamed_33 = 197;
pub const _SC_LEVEL3_CACHE_LINESIZE: C2RustUnnamed_33 = 196;
pub const _SC_LEVEL3_CACHE_ASSOC: C2RustUnnamed_33 = 195;
pub const _SC_LEVEL3_CACHE_SIZE: C2RustUnnamed_33 = 194;
pub const _SC_LEVEL2_CACHE_LINESIZE: C2RustUnnamed_33 = 193;
pub const _SC_LEVEL2_CACHE_ASSOC: C2RustUnnamed_33 = 192;
pub const _SC_LEVEL2_CACHE_SIZE: C2RustUnnamed_33 = 191;
pub const _SC_LEVEL1_DCACHE_LINESIZE: C2RustUnnamed_33 = 190;
pub const _SC_LEVEL1_DCACHE_ASSOC: C2RustUnnamed_33 = 189;
pub const _SC_LEVEL1_DCACHE_SIZE: C2RustUnnamed_33 = 188;
pub const _SC_LEVEL1_ICACHE_LINESIZE: C2RustUnnamed_33 = 187;
pub const _SC_LEVEL1_ICACHE_ASSOC: C2RustUnnamed_33 = 186;
pub const _SC_LEVEL1_ICACHE_SIZE: C2RustUnnamed_33 = 185;
pub const _SC_TRACE_LOG: C2RustUnnamed_33 = 184;
pub const _SC_TRACE_INHERIT: C2RustUnnamed_33 = 183;
pub const _SC_TRACE_EVENT_FILTER: C2RustUnnamed_33 = 182;
pub const _SC_TRACE: C2RustUnnamed_33 = 181;
pub const _SC_HOST_NAME_MAX: C2RustUnnamed_33 = 180;
pub const _SC_V6_LPBIG_OFFBIG: C2RustUnnamed_33 = 179;
pub const _SC_V6_LP64_OFF64: C2RustUnnamed_33 = 178;
pub const _SC_V6_ILP32_OFFBIG: C2RustUnnamed_33 = 177;
pub const _SC_V6_ILP32_OFF32: C2RustUnnamed_33 = 176;
pub const _SC_2_PBS_CHECKPOINT: C2RustUnnamed_33 = 175;
pub const _SC_STREAMS: C2RustUnnamed_33 = 174;
pub const _SC_SYMLOOP_MAX: C2RustUnnamed_33 = 173;
pub const _SC_2_PBS_TRACK: C2RustUnnamed_33 = 172;
pub const _SC_2_PBS_MESSAGE: C2RustUnnamed_33 = 171;
pub const _SC_2_PBS_LOCATE: C2RustUnnamed_33 = 170;
pub const _SC_2_PBS_ACCOUNTING: C2RustUnnamed_33 = 169;
pub const _SC_2_PBS: C2RustUnnamed_33 = 168;
pub const _SC_USER_GROUPS_R: C2RustUnnamed_33 = 167;
pub const _SC_USER_GROUPS: C2RustUnnamed_33 = 166;
pub const _SC_TYPED_MEMORY_OBJECTS: C2RustUnnamed_33 = 165;
pub const _SC_TIMEOUTS: C2RustUnnamed_33 = 164;
pub const _SC_SYSTEM_DATABASE_R: C2RustUnnamed_33 = 163;
pub const _SC_SYSTEM_DATABASE: C2RustUnnamed_33 = 162;
pub const _SC_THREAD_SPORADIC_SERVER: C2RustUnnamed_33 = 161;
pub const _SC_SPORADIC_SERVER: C2RustUnnamed_33 = 160;
pub const _SC_SPAWN: C2RustUnnamed_33 = 159;
pub const _SC_SIGNALS: C2RustUnnamed_33 = 158;
pub const _SC_SHELL: C2RustUnnamed_33 = 157;
pub const _SC_REGEX_VERSION: C2RustUnnamed_33 = 156;
pub const _SC_REGEXP: C2RustUnnamed_33 = 155;
pub const _SC_SPIN_LOCKS: C2RustUnnamed_33 = 154;
pub const _SC_READER_WRITER_LOCKS: C2RustUnnamed_33 = 153;
pub const _SC_NETWORKING: C2RustUnnamed_33 = 152;
pub const _SC_SINGLE_PROCESS: C2RustUnnamed_33 = 151;
pub const _SC_MULTI_PROCESS: C2RustUnnamed_33 = 150;
pub const _SC_MONOTONIC_CLOCK: C2RustUnnamed_33 = 149;
pub const _SC_FILE_SYSTEM: C2RustUnnamed_33 = 148;
pub const _SC_FILE_LOCKING: C2RustUnnamed_33 = 147;
pub const _SC_FILE_ATTRIBUTES: C2RustUnnamed_33 = 146;
pub const _SC_PIPE: C2RustUnnamed_33 = 145;
pub const _SC_FIFO: C2RustUnnamed_33 = 144;
pub const _SC_FD_MGMT: C2RustUnnamed_33 = 143;
pub const _SC_DEVICE_SPECIFIC_R: C2RustUnnamed_33 = 142;
pub const _SC_DEVICE_SPECIFIC: C2RustUnnamed_33 = 141;
pub const _SC_DEVICE_IO: C2RustUnnamed_33 = 140;
pub const _SC_THREAD_CPUTIME: C2RustUnnamed_33 = 139;
pub const _SC_CPUTIME: C2RustUnnamed_33 = 138;
pub const _SC_CLOCK_SELECTION: C2RustUnnamed_33 = 137;
pub const _SC_C_LANG_SUPPORT_R: C2RustUnnamed_33 = 136;
pub const _SC_C_LANG_SUPPORT: C2RustUnnamed_33 = 135;
pub const _SC_BASE: C2RustUnnamed_33 = 134;
pub const _SC_BARRIERS: C2RustUnnamed_33 = 133;
pub const _SC_ADVISORY_INFO: C2RustUnnamed_33 = 132;
pub const _SC_XOPEN_REALTIME_THREADS: C2RustUnnamed_33 = 131;
pub const _SC_XOPEN_REALTIME: C2RustUnnamed_33 = 130;
pub const _SC_XOPEN_LEGACY: C2RustUnnamed_33 = 129;
pub const _SC_XBS5_LPBIG_OFFBIG: C2RustUnnamed_33 = 128;
pub const _SC_XBS5_LP64_OFF64: C2RustUnnamed_33 = 127;
pub const _SC_XBS5_ILP32_OFFBIG: C2RustUnnamed_33 = 126;
pub const _SC_XBS5_ILP32_OFF32: C2RustUnnamed_33 = 125;
pub const _SC_NL_TEXTMAX: C2RustUnnamed_33 = 124;
pub const _SC_NL_SETMAX: C2RustUnnamed_33 = 123;
pub const _SC_NL_NMAX: C2RustUnnamed_33 = 122;
pub const _SC_NL_MSGMAX: C2RustUnnamed_33 = 121;
pub const _SC_NL_LANGMAX: C2RustUnnamed_33 = 120;
pub const _SC_NL_ARGMAX: C2RustUnnamed_33 = 119;
pub const _SC_USHRT_MAX: C2RustUnnamed_33 = 118;
pub const _SC_ULONG_MAX: C2RustUnnamed_33 = 117;
pub const _SC_UINT_MAX: C2RustUnnamed_33 = 116;
pub const _SC_UCHAR_MAX: C2RustUnnamed_33 = 115;
pub const _SC_SHRT_MIN: C2RustUnnamed_33 = 114;
pub const _SC_SHRT_MAX: C2RustUnnamed_33 = 113;
pub const _SC_SCHAR_MIN: C2RustUnnamed_33 = 112;
pub const _SC_SCHAR_MAX: C2RustUnnamed_33 = 111;
pub const _SC_SSIZE_MAX: C2RustUnnamed_33 = 110;
pub const _SC_NZERO: C2RustUnnamed_33 = 109;
pub const _SC_MB_LEN_MAX: C2RustUnnamed_33 = 108;
pub const _SC_WORD_BIT: C2RustUnnamed_33 = 107;
pub const _SC_LONG_BIT: C2RustUnnamed_33 = 106;
pub const _SC_INT_MIN: C2RustUnnamed_33 = 105;
pub const _SC_INT_MAX: C2RustUnnamed_33 = 104;
pub const _SC_CHAR_MIN: C2RustUnnamed_33 = 103;
pub const _SC_CHAR_MAX: C2RustUnnamed_33 = 102;
pub const _SC_CHAR_BIT: C2RustUnnamed_33 = 101;
pub const _SC_XOPEN_XPG4: C2RustUnnamed_33 = 100;
pub const _SC_XOPEN_XPG3: C2RustUnnamed_33 = 99;
pub const _SC_XOPEN_XPG2: C2RustUnnamed_33 = 98;
pub const _SC_2_UPE: C2RustUnnamed_33 = 97;
pub const _SC_2_C_VERSION: C2RustUnnamed_33 = 96;
pub const _SC_2_CHAR_TERM: C2RustUnnamed_33 = 95;
pub const _SC_XOPEN_SHM: C2RustUnnamed_33 = 94;
pub const _SC_XOPEN_ENH_I18N: C2RustUnnamed_33 = 93;
pub const _SC_XOPEN_CRYPT: C2RustUnnamed_33 = 92;
pub const _SC_XOPEN_UNIX: C2RustUnnamed_33 = 91;
pub const _SC_XOPEN_XCU_VERSION: C2RustUnnamed_33 = 90;
pub const _SC_XOPEN_VERSION: C2RustUnnamed_33 = 89;
pub const _SC_PASS_MAX: C2RustUnnamed_33 = 88;
pub const _SC_ATEXIT_MAX: C2RustUnnamed_33 = 87;
pub const _SC_AVPHYS_PAGES: C2RustUnnamed_33 = 86;
pub const _SC_PHYS_PAGES: C2RustUnnamed_33 = 85;
pub const _SC_NPROCESSORS_ONLN: C2RustUnnamed_33 = 84;
pub const _SC_NPROCESSORS_CONF: C2RustUnnamed_33 = 83;
pub const _SC_THREAD_PROCESS_SHARED: C2RustUnnamed_33 = 82;
pub const _SC_THREAD_PRIO_PROTECT: C2RustUnnamed_33 = 81;
pub const _SC_THREAD_PRIO_INHERIT: C2RustUnnamed_33 = 80;
pub const _SC_THREAD_PRIORITY_SCHEDULING: C2RustUnnamed_33 = 79;
pub const _SC_THREAD_ATTR_STACKSIZE: C2RustUnnamed_33 = 78;
pub const _SC_THREAD_ATTR_STACKADDR: C2RustUnnamed_33 = 77;
pub const _SC_THREAD_THREADS_MAX: C2RustUnnamed_33 = 76;
pub const _SC_THREAD_STACK_MIN: C2RustUnnamed_33 = 75;
pub const _SC_THREAD_KEYS_MAX: C2RustUnnamed_33 = 74;
pub const _SC_THREAD_DESTRUCTOR_ITERATIONS: C2RustUnnamed_33 = 73;
pub const _SC_TTY_NAME_MAX: C2RustUnnamed_33 = 72;
pub const _SC_LOGIN_NAME_MAX: C2RustUnnamed_33 = 71;
pub const _SC_GETPW_R_SIZE_MAX: C2RustUnnamed_33 = 70;
pub const _SC_GETGR_R_SIZE_MAX: C2RustUnnamed_33 = 69;
pub const _SC_THREAD_SAFE_FUNCTIONS: C2RustUnnamed_33 = 68;
pub const _SC_THREADS: C2RustUnnamed_33 = 67;
pub const _SC_T_IOV_MAX: C2RustUnnamed_33 = 66;
pub const _SC_PII_OSI_M: C2RustUnnamed_33 = 65;
pub const _SC_PII_OSI_CLTS: C2RustUnnamed_33 = 64;
pub const _SC_PII_OSI_COTS: C2RustUnnamed_33 = 63;
pub const _SC_PII_INTERNET_DGRAM: C2RustUnnamed_33 = 62;
pub const _SC_PII_INTERNET_STREAM: C2RustUnnamed_33 = 61;
pub const _SC_IOV_MAX: C2RustUnnamed_33 = 60;
pub const _SC_UIO_MAXIOV: C2RustUnnamed_33 = 60;
pub const _SC_SELECT: C2RustUnnamed_33 = 59;
pub const _SC_POLL: C2RustUnnamed_33 = 58;
pub const _SC_PII_OSI: C2RustUnnamed_33 = 57;
pub const _SC_PII_INTERNET: C2RustUnnamed_33 = 56;
pub const _SC_PII_SOCKET: C2RustUnnamed_33 = 55;
pub const _SC_PII_XTI: C2RustUnnamed_33 = 54;
pub const _SC_PII: C2RustUnnamed_33 = 53;
pub const _SC_2_LOCALEDEF: C2RustUnnamed_33 = 52;
pub const _SC_2_SW_DEV: C2RustUnnamed_33 = 51;
pub const _SC_2_FORT_RUN: C2RustUnnamed_33 = 50;
pub const _SC_2_FORT_DEV: C2RustUnnamed_33 = 49;
pub const _SC_2_C_DEV: C2RustUnnamed_33 = 48;
pub const _SC_2_C_BIND: C2RustUnnamed_33 = 47;
pub const _SC_2_VERSION: C2RustUnnamed_33 = 46;
pub const _SC_CHARCLASS_NAME_MAX: C2RustUnnamed_33 = 45;
pub const _SC_RE_DUP_MAX: C2RustUnnamed_33 = 44;
pub const _SC_LINE_MAX: C2RustUnnamed_33 = 43;
pub const _SC_EXPR_NEST_MAX: C2RustUnnamed_33 = 42;
pub const _SC_EQUIV_CLASS_MAX: C2RustUnnamed_33 = 41;
pub const _SC_COLL_WEIGHTS_MAX: C2RustUnnamed_33 = 40;
pub const _SC_BC_STRING_MAX: C2RustUnnamed_33 = 39;
pub const _SC_BC_SCALE_MAX: C2RustUnnamed_33 = 38;
pub const _SC_BC_DIM_MAX: C2RustUnnamed_33 = 37;
pub const _SC_BC_BASE_MAX: C2RustUnnamed_33 = 36;
pub const _SC_TIMER_MAX: C2RustUnnamed_33 = 35;
pub const _SC_SIGQUEUE_MAX: C2RustUnnamed_33 = 34;
pub const _SC_SEM_VALUE_MAX: C2RustUnnamed_33 = 33;
pub const _SC_SEM_NSEMS_MAX: C2RustUnnamed_33 = 32;
pub const _SC_RTSIG_MAX: C2RustUnnamed_33 = 31;
pub const _SC_VERSION: C2RustUnnamed_33 = 29;
pub const _SC_MQ_PRIO_MAX: C2RustUnnamed_33 = 28;
pub const _SC_MQ_OPEN_MAX: C2RustUnnamed_33 = 27;
pub const _SC_DELAYTIMER_MAX: C2RustUnnamed_33 = 26;
pub const _SC_AIO_PRIO_DELTA_MAX: C2RustUnnamed_33 = 25;
pub const _SC_AIO_MAX: C2RustUnnamed_33 = 24;
pub const _SC_AIO_LISTIO_MAX: C2RustUnnamed_33 = 23;
pub const _SC_SHARED_MEMORY_OBJECTS: C2RustUnnamed_33 = 22;
pub const _SC_SEMAPHORES: C2RustUnnamed_33 = 21;
pub const _SC_MESSAGE_PASSING: C2RustUnnamed_33 = 20;
pub const _SC_MEMORY_PROTECTION: C2RustUnnamed_33 = 19;
pub const _SC_MEMLOCK_RANGE: C2RustUnnamed_33 = 18;
pub const _SC_MEMLOCK: C2RustUnnamed_33 = 17;
pub const _SC_MAPPED_FILES: C2RustUnnamed_33 = 16;
pub const _SC_FSYNC: C2RustUnnamed_33 = 15;
pub const _SC_SYNCHRONIZED_IO: C2RustUnnamed_33 = 14;
pub const _SC_PRIORITIZED_IO: C2RustUnnamed_33 = 13;
pub const _SC_ASYNCHRONOUS_IO: C2RustUnnamed_33 = 12;
pub const _SC_TIMERS: C2RustUnnamed_33 = 11;
pub const _SC_PRIORITY_SCHEDULING: C2RustUnnamed_33 = 10;
pub const _SC_REALTIME_SIGNALS: C2RustUnnamed_33 = 9;
pub const _SC_SAVED_IDS: C2RustUnnamed_33 = 8;
pub const _SC_JOB_CONTROL: C2RustUnnamed_33 = 7;
pub const _SC_TZNAME_MAX: C2RustUnnamed_33 = 6;
pub const _SC_STREAM_MAX: C2RustUnnamed_33 = 5;
pub const _SC_OPEN_MAX: C2RustUnnamed_33 = 4;
pub const _SC_NGROUPS_MAX: C2RustUnnamed_33 = 3;
pub const _SC_CLK_TCK: C2RustUnnamed_33 = 2;
pub const _SC_CHILD_MAX: C2RustUnnamed_33 = 1;
pub const _SC_ARG_MAX: C2RustUnnamed_33 = 0;
pub type sig_atomic_t = __sig_atomic_t;
#[derive(Copy, Clone)]
#[repr(C)]
pub struct siginfo_t {
    pub si_signo: libc::c_int,
    pub si_errno: libc::c_int,
    pub si_code: libc::c_int,
    pub __pad0: libc::c_int,
    pub _sifields: C2RustUnnamed_34,
}
#[derive(Copy, Clone)]
#[repr(C)]
pub union C2RustUnnamed_34 {
    pub _pad: [libc::c_int; 28],
    pub _kill: C2RustUnnamed_43,
    pub _timer: C2RustUnnamed_42,
    pub _rt: C2RustUnnamed_41,
    pub _sigchld: C2RustUnnamed_40,
    pub _sigfault: C2RustUnnamed_37,
    pub _sigpoll: C2RustUnnamed_36,
    pub _sigsys: C2RustUnnamed_35,
}
#[derive(Copy, Clone)]
#[repr(C)]
pub struct C2RustUnnamed_35 {
    pub _call_addr: *mut libc::c_void,
    pub _syscall: libc::c_int,
    pub _arch: libc::c_uint,
}
#[derive(Copy, Clone)]
#[repr(C)]
pub struct C2RustUnnamed_36 {
    pub si_band: libc::c_long,
    pub si_fd: libc::c_int,
}
#[derive(Copy, Clone)]
#[repr(C)]
pub struct C2RustUnnamed_37 {
    pub si_addr: *mut libc::c_void,
    pub si_addr_lsb: libc::c_short,
    pub _bounds: C2RustUnnamed_38,
}
#[derive(Copy, Clone)]
#[repr(C)]
pub union C2RustUnnamed_38 {
    pub _addr_bnd: C2RustUnnamed_39,
    pub _pkey: __uint32_t,
}
#[derive(Copy, Clone)]
#[repr(C)]
pub struct C2RustUnnamed_39 {
    pub _lower: *mut libc::c_void,
    pub _upper: *mut libc::c_void,
}
#[derive(Copy, Clone)]
#[repr(C)]
pub struct C2RustUnnamed_40 {
    pub si_pid: __pid_t,
    pub si_uid: __uid_t,
    pub si_status: libc::c_int,
    pub si_utime: __clock_t,
    pub si_stime: __clock_t,
}
#[derive(Copy, Clone)]
#[repr(C)]
pub struct C2RustUnnamed_41 {
    pub si_pid: __pid_t,
    pub si_uid: __uid_t,
    pub si_sigval: __sigval_t,
}
#[derive(Copy, Clone)]
#[repr(C)]
pub struct C2RustUnnamed_42 {
    pub si_tid: libc::c_int,
    pub si_overrun: libc::c_int,
    pub si_sigval: __sigval_t,
}
#[derive(Copy, Clone)]
#[repr(C)]
pub struct C2RustUnnamed_43 {
    pub si_pid: __pid_t,
    pub si_uid: __uid_t,
}
#[derive(Copy, Clone)]
#[repr(C)]
pub struct sigaction {
    pub __sigaction_handler: C2RustUnnamed_44,
    pub sa_mask: __sigset_t,
    pub sa_flags: libc::c_int,
    pub sa_restorer: Option<unsafe extern "C" fn() -> ()>,
}
#[derive(Copy, Clone)]
#[repr(C)]
pub union C2RustUnnamed_44 {
    pub sa_handler: __sighandler_t,
    pub sa_sigaction:
        Option<unsafe extern "C" fn(libc::c_int, *mut siginfo_t, *mut libc::c_void) -> ()>,
}
#[derive(Copy, Clone)]
#[repr(C)]
pub struct group {
    pub gr_name: *mut libc::c_char,
    pub gr_passwd: *mut libc::c_char,
    pub gr_gid: __gid_t,
    pub gr_mem: *mut *mut libc::c_char,
}
#[derive(Copy, Clone)]
#[repr(C)]
pub struct passwd {
    pub pw_name: *mut libc::c_char,
    pub pw_passwd: *mut libc::c_char,
    pub pw_uid: __uid_t,
    pub pw_gid: __gid_t,
    pub pw_gecos: *mut libc::c_char,
    pub pw_dir: *mut libc::c_char,
    pub pw_shell: *mut libc::c_char,
}
pub type __rlimit_resource = libc::c_uint;
pub const __RLIM_NLIMITS: __rlimit_resource = 16;
pub const __RLIMIT_NLIMITS: __rlimit_resource = 16;
pub const __RLIMIT_RTTIME: __rlimit_resource = 15;
pub const __RLIMIT_RTPRIO: __rlimit_resource = 14;
pub const __RLIMIT_NICE: __rlimit_resource = 13;
pub const __RLIMIT_MSGQUEUE: __rlimit_resource = 12;
pub const __RLIMIT_SIGPENDING: __rlimit_resource = 11;
pub const __RLIMIT_LOCKS: __rlimit_resource = 10;
pub const __RLIMIT_MEMLOCK: __rlimit_resource = 8;
pub const __RLIMIT_NPROC: __rlimit_resource = 6;
pub const RLIMIT_AS: __rlimit_resource = 9;
pub const __RLIMIT_OFILE: __rlimit_resource = 7;
pub const RLIMIT_NOFILE: __rlimit_resource = 7;
pub const __RLIMIT_RSS: __rlimit_resource = 5;
pub const RLIMIT_CORE: __rlimit_resource = 4;
pub const RLIMIT_STACK: __rlimit_resource = 3;
pub const RLIMIT_DATA: __rlimit_resource = 2;
pub const RLIMIT_FSIZE: __rlimit_resource = 1;
pub const RLIMIT_CPU: __rlimit_resource = 0;
pub type rlim_t = __rlim64_t;
#[derive(Copy, Clone)]
#[repr(C)]
pub struct rlimit {
    pub rlim_cur: rlim_t,
    pub rlim_max: rlim_t,
}
pub type __rlimit_resource_t = __rlimit_resource;
pub type http_header_h2_e = libc::c_int;
#[derive(Copy, Clone)]
#[repr(C)]
pub struct burl_parts_t {
    pub scheme: *const buffer,
    pub authority: *const buffer,
    pub port: libc::c_ushort,
    pub path: *const buffer,
    pub query: *const buffer,
}
pub type burl_opts_e = libc::c_uint;
pub type burl_recoding_e = libc::c_uint;
pub const BURL_DECODE_B64U: burl_recoding_e = 128;
pub const BURL_ENCODE_B64U: burl_recoding_e = 64;
pub const BURL_ENCODE_PSNDE: burl_recoding_e = 32;
pub const BURL_ENCODE_NDE: burl_recoding_e = 16;
pub const BURL_ENCODE_ALL: burl_recoding_e = 8;
pub const BURL_ENCODE_NONE: burl_recoding_e = 4;
pub const BURL_TOUPPER: burl_recoding_e = 2;
pub const BURL_TOLOWER: burl_recoding_e = 1;
pub type C2RustUnnamed_45 = libc::c_uint;
pub type C2RustUnnamed_46 = libc::c_uint;
pub type C2RustUnnamed_47 = libc::c_uint;
pub type EPOLL_EVENTS = libc::c_uint;
pub const EPOLLET: EPOLL_EVENTS = 2147483648;
pub const EPOLLONESHOT: EPOLL_EVENTS = 1073741824;
pub const EPOLLWAKEUP: EPOLL_EVENTS = 536870912;
pub const EPOLLEXCLUSIVE: EPOLL_EVENTS = 268435456;
pub const EPOLLMSG: EPOLL_EVENTS = 1024;
pub const EPOLLWRBAND: EPOLL_EVENTS = 512;
pub const EPOLLWRNORM: EPOLL_EVENTS = 256;
pub const EPOLLRDBAND: EPOLL_EVENTS = 128;
pub const EPOLLRDNORM: EPOLL_EVENTS = 64;
pub type C2RustUnnamed_48 = libc::c_uint;
#[derive(Copy, Clone)]
#[repr(C)]
pub struct pcre_keyvalue {
    pub code: *mut pcre2_code_8,
    pub match_data: *mut pcre2_real_match_data_8,
    pub value: buffer,
}
#[derive(Copy, Clone)]
#[repr(C)]
pub struct pcre_keyvalue_ctx {
    pub cache: *mut cond_match_t,
    pub burl: *mut burl_parts_t,
    pub m: libc::c_int,
    pub n: libc::c_int,
    pub ovec: *mut libc::c_void,
    pub subject: *const libc::c_char,
}
#[derive(Copy, Clone)]
#[repr(C)]
pub struct pcre_keyvalue_buffer {
    pub kv: *mut pcre_keyvalue,
    pub used: uint32_t,
    pub x0: libc::c_int,
    pub x1: libc::c_int,
    pub cfgidx: libc::c_int,
}
pub type C2RustUnnamed_49 = libc::c_uint;
pub const _ISpunct: C2RustUnnamed_49 = 4;
pub const _IScntrl: C2RustUnnamed_49 = 2;
pub const _ISblank: C2RustUnnamed_49 = 1;
pub const _ISgraph: C2RustUnnamed_49 = 32768;
pub const _ISprint: C2RustUnnamed_49 = 16384;
pub const _ISxdigit: C2RustUnnamed_49 = 4096;
pub const _ISlower: C2RustUnnamed_49 = 512;
pub const _ISupper: C2RustUnnamed_49 = 256;
#[derive(Copy, Clone)]
#[repr(C)]
pub struct char_array {
    pub ptr: *mut *mut libc::c_char,
    pub size: uint32_t,
    pub used: uint32_t,
}
#[derive(Copy, Clone)]
#[repr(C)]
pub struct gw_proc {
    pub next: *mut gw_proc,
    pub state: C2RustUnnamed_50,
    pub load: uint32_t,
    pub last_used: unix_time64_t,
    pub stats_load: *mut libc::c_int,
    pub stats_connected: *mut libc::c_int,
    pub pid: pid_t,
    pub is_local: libc::c_int,
    pub id: uint32_t,
    pub saddrlen: socklen_t,
    pub saddr: *mut sockaddr,
    pub disabled_until: unix_time64_t,
    pub prev: *mut gw_proc,
    pub connection_name: *mut buffer,
    pub unixsocket: *mut buffer,
    pub port: libc::c_ushort,
}
pub type C2RustUnnamed_50 = libc::c_uint;
pub const PROC_STATE_KILLED: C2RustUnnamed_50 = 4;
pub const PROC_STATE_DIED: C2RustUnnamed_50 = 3;
pub const PROC_STATE_DIED_WAIT_FOR_PID: C2RustUnnamed_50 = 2;
pub const PROC_STATE_OVERLOADED: C2RustUnnamed_50 = 1;
pub const PROC_STATE_RUNNING: C2RustUnnamed_50 = 0;
#[derive(Copy, Clone)]
#[repr(C)]
pub struct gw_handler_ctx {
    pub proc_0: *mut gw_proc,
    pub host: *mut gw_host,
    pub ext: *mut gw_extension,
    pub ext_auth: *mut gw_extension,
    pub gw_mode: libc::c_ushort,
    pub state: gw_connection_state_t,
    pub rb: *mut chunkqueue,
    pub wb_reqlen: off_t,
    pub wb: chunkqueue,
    pub response: *mut buffer,
    pub ev: *mut fdevents,
    pub fdn: *mut fdnode,
    pub fd: libc::c_int,
    pub revents: libc::c_int,
    pub pid: pid_t,
    pub reconnects: libc::c_int,
    pub request_id: libc::c_int,
    pub send_content_body: libc::c_int,
    pub opts: http_response_opts,
    pub conf: gw_plugin_config,
    pub r: *mut request_st,
    pub con: *mut connection,
    pub plugin_data: *mut gw_plugin_data,
    pub read_ts: unix_time64_t,
    pub write_ts: unix_time64_t,
    pub stdin_append: Option<unsafe extern "C" fn(*mut gw_handler_ctx) -> handler_t>,
    pub create_env: Option<unsafe extern "C" fn(*mut gw_handler_ctx) -> handler_t>,
    pub prev: *mut gw_handler_ctx,
    pub next: *mut gw_handler_ctx,
    pub backend_error: Option<unsafe extern "C" fn(*mut gw_handler_ctx) -> ()>,
    pub handler_ctx_free: Option<unsafe extern "C" fn(*mut libc::c_void) -> ()>,
}
#[derive(Copy, Clone)]
#[repr(C)]
pub struct gw_plugin_data {
    pub id: libc::c_int,
    pub nconfig: libc::c_int,
    pub cvlist: *mut config_plugin_value_t,
    pub self_0: *mut plugin,
    pub srv_pid: pid_t,
    pub conf: gw_plugin_config,
    pub defaults: gw_plugin_config,
}
#[derive(Copy, Clone)]
#[repr(C)]
pub struct gw_plugin_config {
    pub exts: *mut gw_exts,
    pub exts_auth: *mut gw_exts,
    pub exts_resp: *mut gw_exts,
    pub ext_mapping: *const array,
    pub balance: libc::c_int,
    pub proto: libc::c_int,
    pub debug: libc::c_int,
}
#[derive(Copy, Clone)]
#[repr(C)]
pub struct gw_exts {
    pub exts: *mut gw_extension,
    pub used: uint32_t,
    pub size: uint32_t,
}
#[derive(Copy, Clone)]
#[repr(C)]
pub struct gw_extension {
    pub key: buffer,
    pub note_is_sent: libc::c_int,
    pub last_used_ndx: libc::c_int,
    pub hosts: *mut *mut gw_host,
    pub used: uint32_t,
    pub size: uint32_t,
}
#[derive(Copy, Clone)]
#[repr(C)]
pub struct gw_host {
    pub first: *mut gw_proc,
    pub active_procs: uint32_t,
    pub gw_hash: uint32_t,
    pub load: int32_t,
    pub stats_load: *mut libc::c_int,
    pub stats_global_active: *mut libc::c_int,
    pub port: libc::c_ushort,
    pub family: libc::c_ushort,
    pub host: *const buffer,
    pub id: *const buffer,
    pub unused_procs: *mut gw_proc,
    pub min_procs: libc::c_ushort,
    pub max_procs: libc::c_ushort,
    pub num_procs: uint32_t,
    pub max_load_per_proc: libc::c_ushort,
    pub idle_timeout: libc::c_ushort,
    pub disable_time: libc::c_ushort,
    pub read_timeout: libc::c_ushort,
    pub write_timeout: libc::c_ushort,
    pub connect_timeout: libc::c_ushort,
    pub hctxs: *mut gw_handler_ctx,
    pub unixsocket: *const buffer,
    pub bin_path: *const buffer,
    pub bin_env: *const array,
    pub bin_env_copy: *const array,
    pub docroot: *const buffer,
    pub break_scriptfilename_for_php: libc::c_ushort,
    pub check_local: libc::c_ushort,
    pub fix_root_path_name: libc::c_ushort,
    pub xsendfile_allow: libc::c_ushort,
    pub xsendfile_docroot: *const array,
    pub max_id: uint32_t,
    pub strip_request_uri: *const buffer,
    pub tcp_fin_propagate: libc::c_ushort,
    pub kill_signal: libc::c_ushort,
    pub listen_backlog: libc::c_int,
    pub refcount: libc::c_int,
    pub args: char_array,
}
pub type gw_connection_state_t = libc::c_uint;
pub const GW_STATE_READ: gw_connection_state_t = 4;
pub const GW_STATE_WRITE: gw_connection_state_t = 3;
pub const GW_STATE_PREPARE_WRITE: gw_connection_state_t = 2;
pub const GW_STATE_CONNECT_DELAYED: gw_connection_state_t = 1;
pub const GW_STATE_INIT: gw_connection_state_t = 0;
pub const GW_BALANCE_LEAST_CONNECTION: C2RustUnnamed_51 = 0;
pub const GW_BALANCE_STICKY: C2RustUnnamed_51 = 3;
pub const GW_BALANCE_HASH: C2RustUnnamed_51 = 2;
pub const GW_BALANCE_RR: C2RustUnnamed_51 = 1;
pub type C2RustUnnamed_51 = libc::c_uint;
pub type C2RustUnnamed_52 = libc::c_uint;
pub const STAT_CACHE_ENGINE_KQUEUE: C2RustUnnamed_52 = 2;
pub type C2RustUnnamed_53 = libc::c_uint;
pub type FAMCodes = libc::c_uint;
pub type C2RustUnnamed_54 = libc::c_uint;
#[derive(Copy, Clone)]
#[repr(C)]
pub struct MD5_CTX {
    pub state: [uint32_t; 4],
    pub count: [uint32_t; 2],
    pub buffer: [libc::c_uchar; 64],
}
pub type sha1_quadbyte = uint32_t;
pub type sha1_byte = libc::c_uchar;
#[derive(Copy, Clone)]
#[repr(C)]
pub struct _SHA_CTX {
    pub state: [sha1_quadbyte; 5],
    pub count: [sha1_quadbyte; 2],
    pub buffer: [sha1_byte; 64],
}
pub type SHA_CTX = _SHA_CTX;
pub type BYTE64QUAD16 = _BYTE64QUAD16;
#[derive(Copy, Clone)]
#[repr(C)]
pub union _BYTE64QUAD16 {
    pub c: [sha1_byte; 64],
    pub l: [sha1_quadbyte; 16],
}
#[derive(Copy, Clone)]
#[repr(C)]
pub struct http_cgi_opts_t {
    pub authorizer: libc::c_int,
    pub break_scriptfilename_for_php: libc::c_int,
    pub docroot: *const buffer,
    pub strip_request_uri: *const buffer,
}
pub type http_cgi_opts = http_cgi_opts_t;
pub type http_cgi_header_append_cb = Option<
    unsafe extern "C" fn(
        *mut libc::c_void,
        *const libc::c_char,
        size_t,
        *const libc::c_char,
        size_t,
    ) -> libc::c_int,
>;
#[no_mangle]
pub unsafe extern "C" fn XXH32_reset(
    mut statePtr: *mut XXH32_state_t,
    mut seed: XXH32_hash_t,
) -> XXH_errorcode {
    let mut state: XXH32_state_t = XXH32_state_t {
        total_len_32: 0,
        large_len: 0,
        v: [0; 4],
        mem32: [0; 4],
        memsize: 0,
        reserved: 0,
    };
    memset(
        &mut state as *mut XXH32_state_t as *mut libc::c_void,
        0 as libc::c_int,
        ::core::mem::size_of::<XXH32_state_t>() as libc::c_ulong,
    );
    state.v[0 as libc::c_int as usize] = seed
        .wrapping_add(0x9e3779b1 as libc::c_uint)
        .wrapping_add(0x85ebca77 as libc::c_uint);
    state.v[1 as libc::c_int as usize] = seed.wrapping_add(0x85ebca77 as libc::c_uint);
    state.v[2 as libc::c_int as usize] = seed.wrapping_add(0 as libc::c_int as libc::c_uint);
    state.v[3 as libc::c_int as usize] = seed.wrapping_sub(0x9e3779b1 as libc::c_uint);
    XXH_memcpy(
        statePtr as *mut libc::c_void,
        &mut state as *mut XXH32_state_t as *const libc::c_void,
        (::core::mem::size_of::<XXH32_state_t>() as libc::c_ulong)
            .wrapping_sub(::core::mem::size_of::<XXH32_hash_t>() as libc::c_ulong),
    );
    return XXH_OK;
}
unsafe extern "C" fn XXH_readBE32(mut ptr: *const libc::c_void) -> xxh_u32 {
    return if 1 as libc::c_int != 0 {
        XXH_swap32(XXH_read32(ptr))
    } else {
        XXH_read32(ptr)
    };
}
#[no_mangle]
pub unsafe extern "C" fn XXH_versionNumber() -> libc::c_uint {
    return (0 as libc::c_int * 100 as libc::c_int * 100 as libc::c_int
        + 8 as libc::c_int * 100 as libc::c_int
        + 1 as libc::c_int) as libc::c_uint;
}
#[no_mangle]
pub unsafe extern "C" fn XXH32(
    mut input: *const libc::c_void,
    mut len: size_t,
    mut seed: XXH32_hash_t,
) -> XXH32_hash_t {
    return XXH32_endian_align(input as *const xxh_u8, len, seed, XXH_unaligned);
}
#[no_mangle]
pub unsafe extern "C" fn XXH32_copyState(
    mut dstState: *mut XXH32_state_t,
    mut srcState: *const XXH32_state_t,
) {
    XXH_memcpy(
        dstState as *mut libc::c_void,
        srcState as *const libc::c_void,
        ::core::mem::size_of::<XXH32_state_t>() as libc::c_ulong,
    );
}
unsafe extern "C" fn XXH_free(mut p: *mut libc::c_void) {
    free(p);
}
#[no_mangle]
pub unsafe extern "C" fn XXH32_freeState(mut statePtr: *mut XXH32_state_t) -> XXH_errorcode {
    XXH_free(statePtr as *mut libc::c_void);
    return XXH_OK;
}
unsafe extern "C" fn XXH_malloc(mut s: size_t) -> *mut libc::c_void {
    return malloc(s);
}
#[no_mangle]
pub unsafe extern "C" fn XXH32_createState() -> *mut XXH32_state_t {
    return XXH_malloc(::core::mem::size_of::<XXH32_state_t>() as libc::c_ulong)
        as *mut XXH32_state_t;
}
unsafe extern "C" fn XXH32_round(mut acc: xxh_u32, mut input: xxh_u32) -> xxh_u32 {
    acc = (acc as libc::c_uint).wrapping_add(input.wrapping_mul(0x85ebca77 as libc::c_uint))
        as xxh_u32 as xxh_u32;
    acc = ::core::intrinsics::rotate_left(acc, 13 as libc::c_int as libc::c_uint);
    acc = (acc as libc::c_uint).wrapping_mul(0x9e3779b1 as libc::c_uint) as xxh_u32 as xxh_u32;
    return acc;
}
unsafe extern "C" fn XXH_memcpy(
    mut dest: *mut libc::c_void,
    mut src: *const libc::c_void,
    mut size: size_t,
) -> *mut libc::c_void {
    return memcpy(dest, src, size);
}
unsafe extern "C" fn XXH_read32(mut memPtr: *const libc::c_void) -> xxh_u32 {
    let mut val: xxh_u32 = 0;
    XXH_memcpy(
        &mut val as *mut xxh_u32 as *mut libc::c_void,
        memPtr,
        ::core::mem::size_of::<xxh_u32>() as libc::c_ulong,
    );
    return val;
}
unsafe extern "C" fn XXH_readLE32(mut ptr: *const libc::c_void) -> xxh_u32 {
    return if 1 as libc::c_int != 0 {
        XXH_read32(ptr)
    } else {
        XXH_swap32(XXH_read32(ptr))
    };
}
unsafe extern "C" fn XXH_swap32(mut x: xxh_u32) -> xxh_u32 {
    return x << 24 as libc::c_int & 0xff000000 as libc::c_uint
        | x << 8 as libc::c_int & 0xff0000 as libc::c_int as libc::c_uint
        | x >> 8 as libc::c_int & 0xff00 as libc::c_int as libc::c_uint
        | x >> 24 as libc::c_int & 0xff as libc::c_int as libc::c_uint;
}
unsafe extern "C" fn XXH32_endian_align(
    mut input: *const xxh_u8,
    mut len: size_t,
    mut seed: xxh_u32,
    mut align: XXH_alignment,
) -> xxh_u32 {
    let mut h32: xxh_u32 = 0;
    input.is_null();
    if len >= 16 as libc::c_int as libc::c_ulong {
        let bEnd: *const xxh_u8 = input.offset(len as isize);
        let limit: *const xxh_u8 = bEnd.offset(-(15 as libc::c_int as isize));
        let mut v1: xxh_u32 = seed
            .wrapping_add(0x9e3779b1 as libc::c_uint)
            .wrapping_add(0x85ebca77 as libc::c_uint);
        let mut v2: xxh_u32 = seed.wrapping_add(0x85ebca77 as libc::c_uint);
        let mut v3: xxh_u32 = seed.wrapping_add(0 as libc::c_int as libc::c_uint);
        let mut v4: xxh_u32 = seed.wrapping_sub(0x9e3779b1 as libc::c_uint);
        loop {
            v1 = XXH32_round(v1, XXH_readLE32_align(input as *const libc::c_void, align));
            input = input.offset(4 as libc::c_int as isize);
            v2 = XXH32_round(v2, XXH_readLE32_align(input as *const libc::c_void, align));
            input = input.offset(4 as libc::c_int as isize);
            v3 = XXH32_round(v3, XXH_readLE32_align(input as *const libc::c_void, align));
            input = input.offset(4 as libc::c_int as isize);
            v4 = XXH32_round(v4, XXH_readLE32_align(input as *const libc::c_void, align));
            input = input.offset(4 as libc::c_int as isize);
            if !(input < limit) {
                break;
            }
        }
        h32 = (::core::intrinsics::rotate_left(v1, 1 as libc::c_int as libc::c_uint))
            .wrapping_add(::core::intrinsics::rotate_left(
                v2,
                7 as libc::c_int as libc::c_uint,
            ))
            .wrapping_add(::core::intrinsics::rotate_left(
                v3,
                12 as libc::c_int as libc::c_uint,
            ))
            .wrapping_add(::core::intrinsics::rotate_left(
                v4,
                18 as libc::c_int as libc::c_uint,
            ));
    } else {
        h32 = seed.wrapping_add(0x165667b1 as libc::c_uint);
    }
    h32 = (h32 as libc::c_uint).wrapping_add(len as xxh_u32) as xxh_u32 as xxh_u32;
    return XXH32_finalize(h32, input, len & 15 as libc::c_int as libc::c_ulong, align);
}
unsafe extern "C" fn XXH32_finalize(
    mut h32: xxh_u32,
    mut ptr: *const xxh_u8,
    mut len: size_t,
    mut align: XXH_alignment,
) -> xxh_u32 {
    ptr.is_null();
    if 0 as libc::c_int == 0 {
        len &= 15 as libc::c_int as libc::c_ulong;
        while len >= 4 as libc::c_int as libc::c_ulong {
            h32 = (h32 as libc::c_uint).wrapping_add(
                (XXH_readLE32_align(ptr as *const libc::c_void, align))
                    .wrapping_mul(0xc2b2ae3d as libc::c_uint),
            ) as xxh_u32 as xxh_u32;
            ptr = ptr.offset(4 as libc::c_int as isize);
            h32 = (::core::intrinsics::rotate_left(h32, 17 as libc::c_int as libc::c_uint))
                .wrapping_mul(0x27d4eb2f as libc::c_uint);
            len = (len as libc::c_ulong).wrapping_sub(4 as libc::c_int as libc::c_ulong) as size_t
                as size_t;
        }
        while len > 0 as libc::c_int as libc::c_ulong {
            let fresh0 = ptr;
            ptr = ptr.offset(1);
            h32 = (h32 as libc::c_uint)
                .wrapping_add((*fresh0 as libc::c_uint).wrapping_mul(0x165667b1 as libc::c_uint))
                as xxh_u32 as xxh_u32;
            h32 = (::core::intrinsics::rotate_left(h32, 11 as libc::c_int as libc::c_uint))
                .wrapping_mul(0x9e3779b1 as libc::c_uint);
            len = len.wrapping_sub(1);
        }
        return XXH32_avalanche(h32);
    } else {
        's_489: {
            let mut current_block_119: u64;
            match len & 15 as libc::c_int as libc::c_ulong {
                12 => {
                    h32 = (h32 as libc::c_uint).wrapping_add(
                        (XXH_readLE32_align(ptr as *const libc::c_void, align))
                            .wrapping_mul(0xc2b2ae3d as libc::c_uint),
                    ) as xxh_u32 as xxh_u32;
                    ptr = ptr.offset(4 as libc::c_int as isize);
                    h32 = (::core::intrinsics::rotate_left(h32, 17 as libc::c_int as libc::c_uint))
                        .wrapping_mul(0x27d4eb2f as libc::c_uint);
                    current_block_119 = 16961019388298318247;
                }
                8 => {
                    current_block_119 = 16961019388298318247;
                }
                4 => {
                    current_block_119 = 12042873429156728455;
                }
                13 => {
                    h32 = (h32 as libc::c_uint).wrapping_add(
                        (XXH_readLE32_align(ptr as *const libc::c_void, align))
                            .wrapping_mul(0xc2b2ae3d as libc::c_uint),
                    ) as xxh_u32 as xxh_u32;
                    ptr = ptr.offset(4 as libc::c_int as isize);
                    h32 = (::core::intrinsics::rotate_left(h32, 17 as libc::c_int as libc::c_uint))
                        .wrapping_mul(0x27d4eb2f as libc::c_uint);
                    current_block_119 = 14259835374904613827;
                }
                9 => {
                    current_block_119 = 14259835374904613827;
                }
                5 => {
                    current_block_119 = 2634834160384886366;
                }
                14 => {
                    h32 = (h32 as libc::c_uint).wrapping_add(
                        (XXH_readLE32_align(ptr as *const libc::c_void, align))
                            .wrapping_mul(0xc2b2ae3d as libc::c_uint),
                    ) as xxh_u32 as xxh_u32;
                    ptr = ptr.offset(4 as libc::c_int as isize);
                    h32 = (::core::intrinsics::rotate_left(h32, 17 as libc::c_int as libc::c_uint))
                        .wrapping_mul(0x27d4eb2f as libc::c_uint);
                    current_block_119 = 59960464269847415;
                }
                10 => {
                    current_block_119 = 59960464269847415;
                }
                6 => {
                    current_block_119 = 9268170341282637659;
                }
                15 => {
                    h32 = (h32 as libc::c_uint).wrapping_add(
                        (XXH_readLE32_align(ptr as *const libc::c_void, align))
                            .wrapping_mul(0xc2b2ae3d as libc::c_uint),
                    ) as xxh_u32 as xxh_u32;
                    ptr = ptr.offset(4 as libc::c_int as isize);
                    h32 = (::core::intrinsics::rotate_left(h32, 17 as libc::c_int as libc::c_uint))
                        .wrapping_mul(0x27d4eb2f as libc::c_uint);
                    current_block_119 = 562551825988108080;
                }
                11 => {
                    current_block_119 = 562551825988108080;
                }
                7 => {
                    current_block_119 = 6874282208517479873;
                }
                3 => {
                    current_block_119 = 13083062967352662483;
                }
                2 => {
                    current_block_119 = 4057695288589136301;
                }
                1 => {
                    current_block_119 = 16769373571382786912;
                }
                0 => {
                    current_block_119 = 691338069881427067;
                }
                _ => {
                    break 's_489;
                }
            }
            match current_block_119 {
                16961019388298318247 => {
                    h32 = (h32 as libc::c_uint).wrapping_add(
                        (XXH_readLE32_align(ptr as *const libc::c_void, align))
                            .wrapping_mul(0xc2b2ae3d as libc::c_uint),
                    ) as xxh_u32 as xxh_u32;
                    ptr = ptr.offset(4 as libc::c_int as isize);
                    h32 = (::core::intrinsics::rotate_left(h32, 17 as libc::c_int as libc::c_uint))
                        .wrapping_mul(0x27d4eb2f as libc::c_uint);
                    current_block_119 = 12042873429156728455;
                }
                14259835374904613827 => {
                    h32 = (h32 as libc::c_uint).wrapping_add(
                        (XXH_readLE32_align(ptr as *const libc::c_void, align))
                            .wrapping_mul(0xc2b2ae3d as libc::c_uint),
                    ) as xxh_u32 as xxh_u32;
                    ptr = ptr.offset(4 as libc::c_int as isize);
                    h32 = (::core::intrinsics::rotate_left(h32, 17 as libc::c_int as libc::c_uint))
                        .wrapping_mul(0x27d4eb2f as libc::c_uint);
                    current_block_119 = 2634834160384886366;
                }
                59960464269847415 => {
                    h32 = (h32 as libc::c_uint).wrapping_add(
                        (XXH_readLE32_align(ptr as *const libc::c_void, align))
                            .wrapping_mul(0xc2b2ae3d as libc::c_uint),
                    ) as xxh_u32 as xxh_u32;
                    ptr = ptr.offset(4 as libc::c_int as isize);
                    h32 = (::core::intrinsics::rotate_left(h32, 17 as libc::c_int as libc::c_uint))
                        .wrapping_mul(0x27d4eb2f as libc::c_uint);
                    current_block_119 = 9268170341282637659;
                }
                562551825988108080 => {
                    h32 = (h32 as libc::c_uint).wrapping_add(
                        (XXH_readLE32_align(ptr as *const libc::c_void, align))
                            .wrapping_mul(0xc2b2ae3d as libc::c_uint),
                    ) as xxh_u32 as xxh_u32;
                    ptr = ptr.offset(4 as libc::c_int as isize);
                    h32 = (::core::intrinsics::rotate_left(h32, 17 as libc::c_int as libc::c_uint))
                        .wrapping_mul(0x27d4eb2f as libc::c_uint);
                    current_block_119 = 6874282208517479873;
                }
                _ => {}
            }
            match current_block_119 {
                9268170341282637659 => {
                    h32 = (h32 as libc::c_uint).wrapping_add(
                        (XXH_readLE32_align(ptr as *const libc::c_void, align))
                            .wrapping_mul(0xc2b2ae3d as libc::c_uint),
                    ) as xxh_u32 as xxh_u32;
                    ptr = ptr.offset(4 as libc::c_int as isize);
                    h32 = (::core::intrinsics::rotate_left(h32, 17 as libc::c_int as libc::c_uint))
                        .wrapping_mul(0x27d4eb2f as libc::c_uint);
                    let fresh2 = ptr;
                    ptr = ptr.offset(1);
                    h32 = (h32 as libc::c_uint).wrapping_add(
                        (*fresh2 as libc::c_uint).wrapping_mul(0x165667b1 as libc::c_uint),
                    ) as xxh_u32 as xxh_u32;
                    h32 = (::core::intrinsics::rotate_left(h32, 11 as libc::c_int as libc::c_uint))
                        .wrapping_mul(0x9e3779b1 as libc::c_uint);
                    let fresh3 = ptr;
                    ptr = ptr.offset(1);
                    h32 = (h32 as libc::c_uint).wrapping_add(
                        (*fresh3 as libc::c_uint).wrapping_mul(0x165667b1 as libc::c_uint),
                    ) as xxh_u32 as xxh_u32;
                    h32 = (::core::intrinsics::rotate_left(h32, 11 as libc::c_int as libc::c_uint))
                        .wrapping_mul(0x9e3779b1 as libc::c_uint);
                    return XXH32_avalanche(h32);
                }
                2634834160384886366 => {
                    h32 = (h32 as libc::c_uint).wrapping_add(
                        (XXH_readLE32_align(ptr as *const libc::c_void, align))
                            .wrapping_mul(0xc2b2ae3d as libc::c_uint),
                    ) as xxh_u32 as xxh_u32;
                    ptr = ptr.offset(4 as libc::c_int as isize);
                    h32 = (::core::intrinsics::rotate_left(h32, 17 as libc::c_int as libc::c_uint))
                        .wrapping_mul(0x27d4eb2f as libc::c_uint);
                    let fresh1 = ptr;
                    ptr = ptr.offset(1);
                    h32 = (h32 as libc::c_uint).wrapping_add(
                        (*fresh1 as libc::c_uint).wrapping_mul(0x165667b1 as libc::c_uint),
                    ) as xxh_u32 as xxh_u32;
                    h32 = (::core::intrinsics::rotate_left(h32, 11 as libc::c_int as libc::c_uint))
                        .wrapping_mul(0x9e3779b1 as libc::c_uint);
                    return XXH32_avalanche(h32);
                }
                12042873429156728455 => {
                    h32 = (h32 as libc::c_uint).wrapping_add(
                        (XXH_readLE32_align(ptr as *const libc::c_void, align))
                            .wrapping_mul(0xc2b2ae3d as libc::c_uint),
                    ) as xxh_u32 as xxh_u32;
                    ptr = ptr.offset(4 as libc::c_int as isize);
                    h32 = (::core::intrinsics::rotate_left(h32, 17 as libc::c_int as libc::c_uint))
                        .wrapping_mul(0x27d4eb2f as libc::c_uint);
                    return XXH32_avalanche(h32);
                }
                6874282208517479873 => {
                    h32 = (h32 as libc::c_uint).wrapping_add(
                        (XXH_readLE32_align(ptr as *const libc::c_void, align))
                            .wrapping_mul(0xc2b2ae3d as libc::c_uint),
                    ) as xxh_u32 as xxh_u32;
                    ptr = ptr.offset(4 as libc::c_int as isize);
                    h32 = (::core::intrinsics::rotate_left(h32, 17 as libc::c_int as libc::c_uint))
                        .wrapping_mul(0x27d4eb2f as libc::c_uint);
                    current_block_119 = 13083062967352662483;
                }
                _ => {}
            }
            match current_block_119 {
                13083062967352662483 => {
                    let fresh4 = ptr;
                    ptr = ptr.offset(1);
                    h32 = (h32 as libc::c_uint).wrapping_add(
                        (*fresh4 as libc::c_uint).wrapping_mul(0x165667b1 as libc::c_uint),
                    ) as xxh_u32 as xxh_u32;
                    h32 = (::core::intrinsics::rotate_left(h32, 11 as libc::c_int as libc::c_uint))
                        .wrapping_mul(0x9e3779b1 as libc::c_uint);
                    current_block_119 = 4057695288589136301;
                }
                _ => {}
            }
            match current_block_119 {
                4057695288589136301 => {
                    let fresh5 = ptr;
                    ptr = ptr.offset(1);
                    h32 = (h32 as libc::c_uint).wrapping_add(
                        (*fresh5 as libc::c_uint).wrapping_mul(0x165667b1 as libc::c_uint),
                    ) as xxh_u32 as xxh_u32;
                    h32 = (::core::intrinsics::rotate_left(h32, 11 as libc::c_int as libc::c_uint))
                        .wrapping_mul(0x9e3779b1 as libc::c_uint);
                    current_block_119 = 16769373571382786912;
                }
                _ => {}
            }
            match current_block_119 {
                16769373571382786912 => {
                    let fresh6 = ptr;
                    ptr = ptr.offset(1);
                    h32 = (h32 as libc::c_uint).wrapping_add(
                        (*fresh6 as libc::c_uint).wrapping_mul(0x165667b1 as libc::c_uint),
                    ) as xxh_u32 as xxh_u32;
                    h32 = (::core::intrinsics::rotate_left(h32, 11 as libc::c_int as libc::c_uint))
                        .wrapping_mul(0x9e3779b1 as libc::c_uint);
                }
                _ => {}
            }
            return XXH32_avalanche(h32);
        }
        return h32;
    };
}
unsafe extern "C" fn XXH32_avalanche(mut h32: xxh_u32) -> xxh_u32 {
    h32 ^= h32 >> 15 as libc::c_int;
    h32 = (h32 as libc::c_uint).wrapping_mul(0x85ebca77 as libc::c_uint) as xxh_u32 as xxh_u32;
    h32 ^= h32 >> 13 as libc::c_int;
    h32 = (h32 as libc::c_uint).wrapping_mul(0xc2b2ae3d as libc::c_uint) as xxh_u32 as xxh_u32;
    h32 ^= h32 >> 16 as libc::c_int;
    return h32;
}
unsafe extern "C" fn XXH_readLE32_align(
    mut ptr: *const libc::c_void,
    mut align: XXH_alignment,
) -> xxh_u32 {
    if align as libc::c_uint == XXH_unaligned as libc::c_int as libc::c_uint {
        return XXH_readLE32(ptr);
    } else {
        return if 1 as libc::c_int != 0 {
            *(ptr as *const xxh_u32)
        } else {
            XXH_swap32(*(ptr as *const xxh_u32))
        };
    };
}
#[no_mangle]
pub unsafe extern "C" fn XXH32_update(
    mut state: *mut XXH32_state_t,
    mut input: *const libc::c_void,
    mut len: size_t,
) -> XXH_errorcode {
    if input.is_null() {
        return XXH_OK;
    }
    let mut p: *const xxh_u8 = input as *const xxh_u8;
    let bEnd: *const xxh_u8 = p.offset(len as isize);
    (*state).total_len_32 = ((*state).total_len_32 as libc::c_uint)
        .wrapping_add(len as XXH32_hash_t) as XXH32_hash_t
        as XXH32_hash_t;
    (*state).large_len |= ((len >= 16 as libc::c_int as libc::c_ulong) as libc::c_int
        | ((*state).total_len_32 >= 16 as libc::c_int as libc::c_uint) as libc::c_int)
        as XXH32_hash_t;
    if ((*state).memsize as libc::c_ulong).wrapping_add(len) < 16 as libc::c_int as libc::c_ulong {
        XXH_memcpy(
            (((*state).mem32).as_mut_ptr() as *mut xxh_u8).offset((*state).memsize as isize)
                as *mut libc::c_void,
            input,
            len,
        );
        (*state).memsize = ((*state).memsize as libc::c_uint).wrapping_add(len as XXH32_hash_t)
            as XXH32_hash_t as XXH32_hash_t;
        return XXH_OK;
    }
    if (*state).memsize != 0 {
        XXH_memcpy(
            (((*state).mem32).as_mut_ptr() as *mut xxh_u8).offset((*state).memsize as isize)
                as *mut libc::c_void,
            input,
            (16 as libc::c_int as libc::c_uint).wrapping_sub((*state).memsize) as size_t,
        );
        let mut p32: *const xxh_u32 = ((*state).mem32).as_mut_ptr();
        (*state).v[0 as libc::c_int as usize] = XXH32_round(
            (*state).v[0 as libc::c_int as usize],
            XXH_readLE32(p32 as *const libc::c_void),
        );
        p32 = p32.offset(1);
        (*state).v[1 as libc::c_int as usize] = XXH32_round(
            (*state).v[1 as libc::c_int as usize],
            XXH_readLE32(p32 as *const libc::c_void),
        );
        p32 = p32.offset(1);
        (*state).v[2 as libc::c_int as usize] = XXH32_round(
            (*state).v[2 as libc::c_int as usize],
            XXH_readLE32(p32 as *const libc::c_void),
        );
        p32 = p32.offset(1);
        (*state).v[3 as libc::c_int as usize] = XXH32_round(
            (*state).v[3 as libc::c_int as usize],
            XXH_readLE32(p32 as *const libc::c_void),
        );
        p = p.offset((16 as libc::c_int as libc::c_uint).wrapping_sub((*state).memsize) as isize);
        (*state).memsize = 0 as libc::c_int as XXH32_hash_t;
    }
    if p <= bEnd.offset(-(16 as libc::c_int as isize)) {
        let limit: *const xxh_u8 = bEnd.offset(-(16 as libc::c_int as isize));
        loop {
            (*state).v[0 as libc::c_int as usize] = XXH32_round(
                (*state).v[0 as libc::c_int as usize],
                XXH_readLE32(p as *const libc::c_void),
            );
            p = p.offset(4 as libc::c_int as isize);
            (*state).v[1 as libc::c_int as usize] = XXH32_round(
                (*state).v[1 as libc::c_int as usize],
                XXH_readLE32(p as *const libc::c_void),
            );
            p = p.offset(4 as libc::c_int as isize);
            (*state).v[2 as libc::c_int as usize] = XXH32_round(
                (*state).v[2 as libc::c_int as usize],
                XXH_readLE32(p as *const libc::c_void),
            );
            p = p.offset(4 as libc::c_int as isize);
            (*state).v[3 as libc::c_int as usize] = XXH32_round(
                (*state).v[3 as libc::c_int as usize],
                XXH_readLE32(p as *const libc::c_void),
            );
            p = p.offset(4 as libc::c_int as isize);
            if !(p <= limit) {
                break;
            }
        }
    }
    if p < bEnd {
        XXH_memcpy(
            ((*state).mem32).as_mut_ptr() as *mut libc::c_void,
            p as *const libc::c_void,
            bEnd.offset_from(p) as libc::c_long as size_t,
        );
        (*state).memsize = bEnd.offset_from(p) as libc::c_long as libc::c_uint;
    }
    return XXH_OK;
}
#[no_mangle]
pub unsafe extern "C" fn XXH32_digest(mut state: *const XXH32_state_t) -> XXH32_hash_t {
    let mut h32: xxh_u32 = 0;
    if (*state).large_len != 0 {
        h32 = (::core::intrinsics::rotate_left(
            (*state).v[0 as libc::c_int as usize],
            1 as libc::c_int as libc::c_uint,
        ))
        .wrapping_add(::core::intrinsics::rotate_left(
            (*state).v[1 as libc::c_int as usize],
            7 as libc::c_int as libc::c_uint,
        ))
        .wrapping_add(::core::intrinsics::rotate_left(
            (*state).v[2 as libc::c_int as usize],
            12 as libc::c_int as libc::c_uint,
        ))
        .wrapping_add(::core::intrinsics::rotate_left(
            (*state).v[3 as libc::c_int as usize],
            18 as libc::c_int as libc::c_uint,
        ));
    } else {
        h32 = ((*state).v[2 as libc::c_int as usize]).wrapping_add(0x165667b1 as libc::c_uint);
    }
    h32 = (h32 as libc::c_uint).wrapping_add((*state).total_len_32) as xxh_u32 as xxh_u32;
    return XXH32_finalize(
        h32,
        ((*state).mem32).as_ptr() as *const xxh_u8,
        (*state).memsize as size_t,
        XXH_aligned,
    );
}
#[no_mangle]
pub unsafe extern "C" fn XXH32_canonicalFromHash(
    mut dst: *mut XXH32_canonical_t,
    mut hash: XXH32_hash_t,
) {
    hash = XXH_swap32(hash);
    XXH_memcpy(
        dst as *mut libc::c_void,
        &mut hash as *mut XXH32_hash_t as *const libc::c_void,
        ::core::mem::size_of::<XXH32_canonical_t>() as libc::c_ulong,
    );
}
#[no_mangle]
pub unsafe extern "C" fn XXH32_hashFromCanonical(
    mut src: *const XXH32_canonical_t,
) -> XXH32_hash_t {
    return XXH_readBE32(src as *const libc::c_void);
}
#[cold]
unsafe fn main_0(mut argc: libc::c_int, mut argv: *mut *mut libc::c_char) -> libc::c_int {
    if main_init_once() == 0 {
        return -(1 as libc::c_int);
    }
    let mut rc: libc::c_int = 0;
    loop {
        let srv: *mut server = server_init();
        if graceful_restart != 0 {
            server_sockets_restore(srv);
            optind = 1 as libc::c_int;
        }
        rc = server_main_setup(srv, argc, argv);
        if rc > 0 as libc::c_int {
            server_main_loop(srv);
            if graceful_shutdown != 0 || graceful_restart != 0 {
                server_graceful_state(srv);
            }
            if ((*srv).conns).is_null() {
                rc = 0 as libc::c_int;
            }
            if 2 as libc::c_int == graceful_shutdown {
                log_error(
                    (*srv).errh,
                    b"/home/kkysen/work/rust/lighttpd/src/server.c\0" as *const u8
                        as *const libc::c_char,
                    2073 as libc::c_int as libc::c_uint,
                    b"server stopped after idle timeout\0" as *const u8 as *const libc::c_char,
                );
            } else if oneshot_fd == 0 {
                log_error(
                    (*srv).errh,
                    b"/home/kkysen/work/rust/lighttpd/src/server.c\0" as *const u8
                        as *const libc::c_char,
                    2077 as libc::c_int as libc::c_uint,
                    b"server stopped by UID = %d PID = %d\0" as *const u8 as *const libc::c_char,
                    last_sigterm_info._sifields._kill.si_uid as libc::c_int,
                    last_sigterm_info._sifields._kill.si_pid,
                );
            }
        }
        chunkqueue_internal_pipes(0 as libc::c_int);
        remove_pid_file(srv);
        config_log_error_close(srv);
        if graceful_restart != 0 {
            server_sockets_save(srv);
        } else {
            network_close(srv);
        }
        request_pool_free();
        connections_free(srv);
        plugins_free(srv);
        server_free(srv);
        if rc < 0 as libc::c_int || graceful_restart == 0 {
            break;
        }
        while fdevent_waitpid(-(1 as libc::c_int), 0 as *mut libc::c_int, 0 as libc::c_int)
            > 0 as libc::c_int
        {}
        if !(graceful_restart != 0) {
            break;
        }
    }
    return rc;
}
#[cold]
#[inline(never)]
unsafe extern "C" fn main_init_once() -> libc::c_int {
    if 0 as libc::c_int as libc::c_uint != getuid()
        && (geteuid() != getuid() || getegid() != getgid())
    {
        fprintf(
            stderr,
            b"Are you nuts ? Don't apply a SUID bit to this binary\n\0" as *const u8
                as *const libc::c_char,
        );
        return 0 as libc::c_int;
    }
    let mut mallopt_fn: Option<unsafe extern "C" fn(libc::c_int, libc::c_int) -> libc::c_int> =
        None;
    mallopt_fn = ::core::mem::transmute::<
        libc::intptr_t,
        Option<unsafe extern "C" fn(libc::c_int, libc::c_int) -> libc::c_int>,
    >(dlsym(
        0 as *mut libc::c_void,
        b"mallopt\0" as *const u8 as *const libc::c_char,
    ) as intptr_t as libc::intptr_t);
    if mallopt_fn.is_some() {
        mallopt_fn.expect("non-null function pointer")(-(8 as libc::c_int), 2 as libc::c_int);
    }
    malloc_top_pad = 524288 as libc::c_int as size_t;
    let top_pad_str: *const libc::c_char =
        getenv(b"MALLOC_TOP_PAD_\0" as *const u8 as *const libc::c_char);
    if !top_pad_str.is_null() {
        let mut top_pad: libc::c_ulong =
            strtoul(top_pad_str, 0 as *mut *mut libc::c_char, 10 as libc::c_int);
        if top_pad
            != (9223372036854775807 as libc::c_long as libc::c_ulong)
                .wrapping_mul(2 as libc::c_ulong)
                .wrapping_add(1 as libc::c_ulong)
        {
            malloc_top_pad = top_pad;
        }
    }
    malloc_trim_fn = ::core::mem::transmute::<
        libc::intptr_t,
        Option<unsafe extern "C" fn(size_t) -> libc::c_int>,
    >(dlsym(
        0 as *mut libc::c_void,
        b"malloc_trim\0" as *const u8 as *const libc::c_char,
    ) as intptr_t as libc::intptr_t);
    setlocale(2 as libc::c_int, b"C\0" as *const u8 as *const libc::c_char);
    tzset();
    return 1 as libc::c_int;
}
static mut sentinel: *mut connection = 0 as *const connection as *mut connection;
#[inline(never)]
unsafe extern "C" fn server_main_loop(srv: *mut server) {
    let mut last_active_ts: unix_time64_t = server_monotonic_secs();
    log_epoch_secs = server_epoch_secs(srv, 0 as libc::c_int as unix_time64_t);
    while srv_shutdown == 0 {
        if handle_sig_hup != 0 {
            ::core::ptr::write_volatile(&mut handle_sig_hup as *mut sig_atomic_t, 0 as libc::c_int);
            server_handle_sighup(srv);
        }
        let mut mono_ts: unix_time64_t = server_monotonic_secs();
        if mono_ts != log_monotonic_secs {
            server_handle_sigalrm(srv, mono_ts, last_active_ts);
        }
        if handle_sig_child != 0 {
            ::core::ptr::write_volatile(
                &mut handle_sig_child as *mut sig_atomic_t,
                0 as libc::c_int,
            );
            server_handle_sigchld(srv);
        }
        if graceful_shutdown != 0 {
            server_graceful_state(srv);
            if ((*srv).conns).is_null() && graceful_shutdown != 0 {
                ::core::ptr::write_volatile(
                    &mut srv_shutdown as *mut sig_atomic_t,
                    1 as libc::c_int,
                );
                break;
            }
        } else if (*srv).sockets_disabled != 0 {
            server_overload_check(srv);
        } else {
            server_load_check(srv);
        }
        let joblist: *mut connection = log_con_jqueue;
        log_con_jqueue = sentinel;
        server_run_con_queue(joblist, sentinel);
        if fdevent_poll(
            (*srv).ev,
            (if log_con_jqueue != sentinel {
                0 as libc::c_int
            } else {
                1000 as libc::c_int
            }),
        ) > 0 as libc::c_int
        {
            last_active_ts = log_monotonic_secs;
        }
    }
}
unsafe extern "C" fn server_run_con_queue(joblist: *mut connection, sentinel_0: *const connection) {
    let mut con: *mut connection = joblist;
    let mut jqnext: *mut connection = 0 as *mut connection;
    while con != sentinel_0 as *mut connection {
        jqnext = (*con).jqnext;
        (*con).jqnext = 0 as *mut connection;
        connection_state_machine(con);
        con = jqnext;
    }
}
#[inline(never)]
unsafe extern "C" fn server_handle_sigchld(srv: *mut server) {
    let mut pid: pid_t = 0;
    loop {
        let mut status: libc::c_int = 0;
        pid = fdevent_waitpid(-(1 as libc::c_int), &mut status, 1 as libc::c_int);
        if pid > 0 as libc::c_int {
            if !(plugins_call_handle_waitpid(srv, pid, status) as libc::c_uint
                != HANDLER_GO_ON as libc::c_int as libc::c_uint)
            {
                if 0 as libc::c_int == (*srv).srvconf.max_worker as libc::c_int {
                    fdlog_pipes_waitpid_cb(pid) != 0;
                }
            }
        }
        if !(pid > 0 as libc::c_int
            || -(1 as libc::c_int) == pid && *__errno_location() == 4 as libc::c_int)
        {
            break;
        }
    }
}
#[inline(never)]
unsafe extern "C" fn server_handle_sigalrm(
    srv: *mut server,
    mut mono_ts: unix_time64_t,
    mut last_active_ts: unix_time64_t,
) {
    plugins_call_handle_trigger(srv);
    log_monotonic_secs = mono_ts;
    log_epoch_secs = server_epoch_secs(srv, 0 as libc::c_int as unix_time64_t);
    if idle_limit != 0
        && (idle_limit as libc::c_long) < mono_ts - last_active_ts
        && graceful_shutdown == 0
    {
        log_error(
            (*srv).errh,
            b"/home/kkysen/work/rust/lighttpd/src/server.c\0" as *const u8 as *const libc::c_char,
            1867 as libc::c_int as libc::c_uint,
            b"[note] idle timeout %ds exceeded, initiating graceful shutdown\0" as *const u8
                as *const libc::c_char,
            idle_limit,
        );
        ::core::ptr::write_volatile(
            &mut graceful_shutdown as *mut sig_atomic_t,
            2 as libc::c_int,
        );
        if graceful_restart != 0 {
            ::core::ptr::write_volatile(
                &mut graceful_restart as *mut sig_atomic_t,
                0 as libc::c_int,
            );
            if pid_fd < -(2 as libc::c_int) {
                ::core::ptr::write_volatile(&mut pid_fd as *mut libc::c_int, -pid_fd);
            }
            server_sockets_close(srv);
        }
    }
    if ((*srv).loadts + 30 as libc::c_int as libc::c_long) < mono_ts {
        if -(1 as libc::c_int) != getloadavg(((*srv).loadavg).as_mut_ptr(), 3 as libc::c_int) {
            (*srv).loadts = mono_ts;
        }
    }
    if 0 as libc::c_int as libc::c_long == mono_ts & 0x3f as libc::c_int as libc::c_long {
        fdlog_flushall((*srv).errh);
        chunkqueue_chunk_pool_clear();
        request_pool_free();
        connections_pool_clear(srv);
        if malloc_trim_fn.is_some() {
            malloc_trim_fn.expect("non-null function pointer")(malloc_top_pad);
        }
        if 0 as libc::c_int == (*srv).srvconf.max_worker as libc::c_int {
            fdlog_pipes_restart(mono_ts);
        }
    }
    stat_cache_trigger_cleanup();
    config_reset_config_bytes_sec((*srv).config_data_base);
    if graceful_shutdown != 0 && srv_shutdown == 0 {
        server_graceful_shutdown_maint(srv);
    }
    connection_periodic_maint(srv, mono_ts);
}
#[cold]
#[inline(never)]
unsafe extern "C" fn server_handle_sighup(srv: *mut server) {
    plugins_call_handle_sighup(srv);
    fdlog_files_cycle((*srv).errh);
    log_error(
        (*srv).errh,
        b"/home/kkysen/work/rust/lighttpd/src/server.c\0" as *const u8 as *const libc::c_char,
        1847 as libc::c_int as libc::c_uint,
        b"logfiles cycled UID = %d PID = %d\0" as *const u8 as *const libc::c_char,
        last_sighup_info._sifields._kill.si_uid as libc::c_int,
        last_sighup_info._sifields._kill.si_pid,
    );
}
#[cold]
#[inline(never)]
unsafe extern "C" fn server_main_setup(
    srv: *mut server,
    mut argc: libc::c_int,
    mut argv: *mut *mut libc::c_char,
) -> libc::c_int {
    let mut print_config: libc::c_int = 0 as libc::c_int;
    let mut test_config: libc::c_int = 0 as libc::c_int;
    let mut i_am_root: libc::c_int = 0 as libc::c_int;
    let mut o: libc::c_int = 0;
    let mut num_childs: libc::c_int = 0 as libc::c_int;
    let mut i: uint32_t = 0;
    let mut act: sigaction = sigaction {
        __sigaction_handler: C2RustUnnamed_44 { sa_handler: None },
        sa_mask: __sigset_t { __val: [0; 16] },
        sa_flags: 0,
        sa_restorer: None,
    };
    let mut parent_pipe_fd: libc::c_int = -(1 as libc::c_int);
    i_am_root = (0 as libc::c_int as libc::c_uint == getuid()) as libc::c_int;
    oneshot_fd = 0 as libc::c_int;
    oneshot_fdout = -(1 as libc::c_int);
    ::core::ptr::write_volatile(&mut srv_shutdown as *mut sig_atomic_t, 0 as libc::c_int);
    ::core::ptr::write_volatile(
        &mut graceful_shutdown as *mut sig_atomic_t,
        0 as libc::c_int,
    );
    ::core::ptr::write_volatile(&mut handle_sig_alarm as *mut sig_atomic_t, 1 as libc::c_int);
    ::core::ptr::write_volatile(&mut handle_sig_hup as *mut sig_atomic_t, 0 as libc::c_int);
    idle_limit = 0 as libc::c_int;
    chunkqueue_set_tempdirs_default_reset();
    (*srv).argv = argv;
    loop {
        o = getopt(
            argc,
            argv,
            b"f:m:i:hvVD1pt\0" as *const u8 as *const libc::c_char,
        );
        if !(-(1 as libc::c_int) != o) {
            break;
        }
        match o {
            102 => {
                if !((*srv).config_data_base).is_null() {
                    log_error(
                        (*srv).errh,
                        b"/home/kkysen/work/rust/lighttpd/src/server.c\0" as *const u8
                            as *const libc::c_char,
                        1104 as libc::c_int as libc::c_uint,
                        b"Can only read one config file. Use the include command to use multiple config files.\0"
                            as *const u8 as *const libc::c_char,
                    );
                    return -(1 as libc::c_int);
                }
                if config_read(srv, optarg) != 0 {
                    return -(1 as libc::c_int);
                }
            }
            109 => {
                (*srv).srvconf.modules_dir = optarg;
            }
            105 => {
                let mut endptr: *mut libc::c_char = 0 as *mut libc::c_char;
                let mut timeout: libc::c_long = strtol(optarg, &mut endptr, 0 as libc::c_int);
                if *optarg == 0
                    || *endptr as libc::c_int != 0
                    || timeout < 0 as libc::c_int as libc::c_long
                {
                    log_error(
                        (*srv).errh,
                        b"/home/kkysen/work/rust/lighttpd/src/server.c\0" as *const u8
                            as *const libc::c_char,
                        1119 as libc::c_int as libc::c_uint,
                        b"Invalid idle timeout value: %s\0" as *const u8 as *const libc::c_char,
                        optarg,
                    );
                    return -(1 as libc::c_int);
                }
                idle_limit = timeout as libc::c_int;
            }
            112 => {
                print_config = 1 as libc::c_int;
            }
            116 => {
                test_config += 1;
            }
            49 => {
                if 0 as libc::c_int == oneshot_fd {
                    oneshot_fd = dup(0 as libc::c_int);
                }
            }
            68 => {
                (*srv).srvconf.dont_daemonize = 1 as libc::c_int as libc::c_uchar;
            }
            118 => {
                show_version();
                return 0 as libc::c_int;
            }
            86 => {
                show_features();
                return 0 as libc::c_int;
            }
            104 => {
                show_help();
                return 0 as libc::c_int;
            }
            _ => {
                show_help();
                return -(1 as libc::c_int);
            }
        }
    }
    if ((*srv).config_data_base).is_null() {
        log_error(
            (*srv).errh,
            b"/home/kkysen/work/rust/lighttpd/src/server.c\0" as *const u8 as *const libc::c_char,
            1154 as libc::c_int as libc::c_uint,
            b"No configuration available. Try using -f option.\0" as *const u8
                as *const libc::c_char,
        );
        return -(1 as libc::c_int);
    }
    if print_config != 0 {
        config_print(srv);
        puts((*(*srv).tmp_buf).ptr);
    }
    if test_config != 0 {
        (*srv).srvconf.pid_file = 0 as *mut buffer;
        if 1 as libc::c_int == test_config {
            printf(b"Syntax OK\n\0" as *const u8 as *const libc::c_char);
        } else {
            test_config = 0 as libc::c_int;
            (*srv).srvconf.preflight_check = 1 as libc::c_int as libc::c_uchar;
            (*srv).srvconf.dont_daemonize = 1 as libc::c_int as libc::c_uchar;
        }
    }
    if test_config != 0 || print_config != 0 {
        return 0 as libc::c_int;
    }
    if oneshot_fd != 0 {
        if oneshot_fd <= 2 as libc::c_int {
            log_error(
                (*srv).errh,
                b"/home/kkysen/work/rust/lighttpd/src/server.c\0" as *const u8
                    as *const libc::c_char,
                1181 as libc::c_int as libc::c_uint,
                b"Invalid fds at startup with lighttpd -1\0" as *const u8 as *const libc::c_char,
            );
            return -(1 as libc::c_int);
        }
        ::core::ptr::write_volatile(
            &mut graceful_shutdown as *mut sig_atomic_t,
            1 as libc::c_int,
        );
        (*srv).sockets_disabled = 2 as libc::c_int;
        (*srv).srvconf.dont_daemonize = 1 as libc::c_int as libc::c_uchar;
        (*srv).srvconf.pid_file = 0 as *mut buffer;
        if (*srv).srvconf.max_worker != 0 {
            (*srv).srvconf.max_worker = 0 as libc::c_int as libc::c_ushort;
            log_error(
                (*srv).errh,
                b"/home/kkysen/work/rust/lighttpd/src/server.c\0" as *const u8
                    as *const libc::c_char,
                1191 as libc::c_int as libc::c_uint,
                b"server one-shot command line option disables server.max-worker config file option.\0"
                    as *const u8 as *const libc::c_char,
            );
        }
        let mut st: stat = stat {
            st_dev: 0,
            st_ino: 0,
            st_nlink: 0,
            st_mode: 0,
            st_uid: 0,
            st_gid: 0,
            __pad0: 0,
            st_rdev: 0,
            st_size: 0,
            st_blksize: 0,
            st_blocks: 0,
            st_atim: timespec {
                tv_sec: 0,
                tv_nsec: 0,
            },
            st_mtim: timespec {
                tv_sec: 0,
                tv_nsec: 0,
            },
            st_ctim: timespec {
                tv_sec: 0,
                tv_nsec: 0,
            },
            __glibc_reserved: [0; 3],
        };
        if 0 as libc::c_int != fstat(oneshot_fd, &mut st) {
            log_perror(
                (*srv).errh,
                b"/home/kkysen/work/rust/lighttpd/src/server.c\0" as *const u8
                    as *const libc::c_char,
                1197 as libc::c_int as libc::c_uint,
                b"fstat()\0" as *const u8 as *const libc::c_char,
            );
            return -(1 as libc::c_int);
        }
        if st.st_mode & 0o170000 as libc::c_int as libc::c_uint
            == 0o10000 as libc::c_int as libc::c_uint
        {
            oneshot_fdout = dup(1 as libc::c_int);
            if oneshot_fdout <= 2 as libc::c_int {
                log_perror(
                    (*srv).errh,
                    b"/home/kkysen/work/rust/lighttpd/src/server.c\0" as *const u8
                        as *const libc::c_char,
                    1204 as libc::c_int as libc::c_uint,
                    b"dup()\0" as *const u8 as *const libc::c_char,
                );
                return -(1 as libc::c_int);
            }
        } else if !(st.st_mode & 0o170000 as libc::c_int as libc::c_uint
            == 0o140000 as libc::c_int as libc::c_uint)
        {
            log_error(
                (*srv).errh,
                b"/home/kkysen/work/rust/lighttpd/src/server.c\0" as *const u8
                    as *const libc::c_char,
                1211 as libc::c_int as libc::c_uint,
                b"lighttpd -1 stdin is not a socket\0" as *const u8 as *const libc::c_char,
            );
            return -(1 as libc::c_int);
        }
    }
    if !((*srv).srvconf.bindhost).is_null()
        && buffer_eq_slen(
            (*srv).srvconf.bindhost,
            b"/dev/stdin\0" as *const u8 as *const libc::c_char,
            (::core::mem::size_of::<[libc::c_char; 11]>() as libc::c_ulong as uint32_t)
                .wrapping_sub(1 as libc::c_int as libc::c_uint) as size_t,
        ) != 0
    {
        if -(1 as libc::c_int) == (*srv).stdin_fd {
            (*srv).stdin_fd = dup(0 as libc::c_int);
        }
        if (*srv).stdin_fd <= 2 as libc::c_int {
            log_error(
                (*srv).errh,
                b"/home/kkysen/work/rust/lighttpd/src/server.c\0" as *const u8
                    as *const libc::c_char,
                1221 as libc::c_int as libc::c_uint,
                b"Invalid fds at startup\0" as *const u8 as *const libc::c_char,
            );
            return -(1 as libc::c_int);
        }
    }
    let mut st_0: stat = stat {
        st_dev: 0,
        st_ino: 0,
        st_nlink: 0,
        st_mode: 0,
        st_uid: 0,
        st_gid: 0,
        __pad0: 0,
        st_rdev: 0,
        st_size: 0,
        st_blksize: 0,
        st_blocks: 0,
        st_atim: timespec {
            tv_sec: 0,
            tv_nsec: 0,
        },
        st_mtim: timespec {
            tv_sec: 0,
            tv_nsec: 0,
        },
        st_ctim: timespec {
            tv_sec: 0,
            tv_nsec: 0,
        },
        __glibc_reserved: [0; 3],
    };
    let mut devnull: libc::c_int = 0;
    let mut errfd: libc::c_int = 0;
    loop {
        devnull = fdevent_open_devnull();
        if !(-(1 as libc::c_int) != devnull && devnull <= 2 as libc::c_int) {
            break;
        }
    }
    if -(1 as libc::c_int) == devnull {
        log_perror(
            (*srv).errh,
            b"/home/kkysen/work/rust/lighttpd/src/server.c\0" as *const u8 as *const libc::c_char,
            1240 as libc::c_int as libc::c_uint,
            b"opening /dev/null failed\0" as *const u8 as *const libc::c_char,
        );
        return -(1 as libc::c_int);
    }
    errfd = if 0 as libc::c_int == fstat(2 as libc::c_int, &mut st_0) {
        -(1 as libc::c_int)
    } else {
        devnull
    };
    if 0 as libc::c_int != fdevent_set_stdin_stdout_stderr(devnull, devnull, errfd) {
        log_perror(
            (*srv).errh,
            b"/home/kkysen/work/rust/lighttpd/src/server.c\0" as *const u8 as *const libc::c_char,
            1246 as libc::c_int as libc::c_uint,
            b"setting default fds failed\0" as *const u8 as *const libc::c_char,
        );
        if -(1 as libc::c_int) != errfd {
            close(errfd);
        }
        if devnull != errfd {
            close(devnull);
        }
        return -(1 as libc::c_int);
    }
    if -(1 as libc::c_int) != errfd {
        close(errfd);
    }
    if devnull != errfd {
        close(devnull);
    }
    http_response_send_1xx_cb_set(None, HTTP_VERSION_2 as libc::c_int);
    if config_feature_bool(
        srv,
        b"server.h2-discard-backend-1xx\0" as *const u8 as *const libc::c_char,
        0 as libc::c_int,
    ) == 0
    {
        http_response_send_1xx_cb_set(
            Some(
                h2_send_1xx
                    as unsafe extern "C" fn(*mut request_st, *mut connection) -> libc::c_int,
            ),
            HTTP_VERSION_2 as libc::c_int,
        );
    }
    http_response_send_1xx_cb_set(None, HTTP_VERSION_1_1 as libc::c_int);
    if config_feature_bool(
        srv,
        b"server.h1-discard-backend-1xx\0" as *const u8 as *const libc::c_char,
        0 as libc::c_int,
    ) == 0
    {
        http_response_send_1xx_cb_set(
            Some(
                connection_send_1xx
                    as unsafe extern "C" fn(*mut request_st, *mut connection) -> libc::c_int,
            ),
            HTTP_VERSION_1_1 as libc::c_int,
        );
    }
    if 0 as libc::c_int != config_set_defaults(srv) {
        log_error(
            (*srv).errh,
            b"/home/kkysen/work/rust/lighttpd/src/server.c\0" as *const u8 as *const libc::c_char,
            1269 as libc::c_int as libc::c_uint,
            b"setting default values failed\0" as *const u8 as *const libc::c_char,
        );
        return -(1 as libc::c_int);
    }
    if plugins_load(srv) != 0 {
        log_error(
            (*srv).errh,
            b"/home/kkysen/work/rust/lighttpd/src/server.c\0" as *const u8 as *const libc::c_char,
            1275 as libc::c_int as libc::c_uint,
            b"loading plugins finally failed\0" as *const u8 as *const libc::c_char,
        );
        return -(1 as libc::c_int);
    }
    if HANDLER_GO_ON as libc::c_int as libc::c_uint != plugins_call_init(srv) as libc::c_uint {
        log_error(
            (*srv).errh,
            b"/home/kkysen/work/rust/lighttpd/src/server.c\0" as *const u8 as *const libc::c_char,
            1281 as libc::c_int as libc::c_uint,
            b"Initialization of plugins failed. Going down.\0" as *const u8 as *const libc::c_char,
        );
        return -(1 as libc::c_int);
    }
    i = 0 as libc::c_int as uint32_t;
    let mut pname: *const libc::c_char = 0 as *const libc::c_char;
    while i < (*srv).plugins.used {
        let mut p: *mut plugin = *((*srv).plugins.ptr as *mut *mut plugin).offset(i as isize);
        if !pname.is_null()
            && 0 as libc::c_int
                == strcmp(
                    (*p).name,
                    b"indexfile\0" as *const u8 as *const libc::c_char,
                )
        {
            log_error(
                (*srv).errh,
                b"/home/kkysen/work/rust/lighttpd/src/server.c\0" as *const u8
                    as *const libc::c_char,
                1291 as libc::c_int as libc::c_uint,
                b"Warning: mod_indexfile should be listed in server.modules prior to mod_%s\0"
                    as *const u8 as *const libc::c_char,
                pname,
            );
            break;
        } else {
            if ((*p).handle_subrequest_start).is_some() && ((*p).handle_subrequest).is_some() {
                if pname.is_null() {
                    pname = (*p).name;
                }
            }
            i = i.wrapping_add(1);
        }
    }
    if -(2 as libc::c_int) == pid_fd {
        ::core::ptr::write_volatile(&mut pid_fd as *mut libc::c_int, -(1 as libc::c_int));
    }
    if -(1 as libc::c_int) == pid_fd && !((*srv).srvconf.pid_file).is_null() {
        let mut pidfile: *const libc::c_char = (*(*srv).srvconf.pid_file).ptr;
        ::core::ptr::write_volatile(
            &mut pid_fd as *mut libc::c_int,
            fdevent_open_cloexec(
                pidfile,
                0 as libc::c_int,
                0o1 as libc::c_int
                    | 0o100 as libc::c_int
                    | 0o200 as libc::c_int
                    | 0o1000 as libc::c_int,
                (0o400 as libc::c_int
                    | 0o200 as libc::c_int
                    | 0o400 as libc::c_int >> 3 as libc::c_int
                    | 0o400 as libc::c_int >> 3 as libc::c_int >> 3 as libc::c_int)
                    as mode_t,
            ),
        );
        if -(1 as libc::c_int)
            == ::core::ptr::read_volatile::<libc::c_int>(&pid_fd as *const libc::c_int)
        {
            let mut st_1: stat = stat {
                st_dev: 0,
                st_ino: 0,
                st_nlink: 0,
                st_mode: 0,
                st_uid: 0,
                st_gid: 0,
                __pad0: 0,
                st_rdev: 0,
                st_size: 0,
                st_blksize: 0,
                st_blocks: 0,
                st_atim: timespec {
                    tv_sec: 0,
                    tv_nsec: 0,
                },
                st_mtim: timespec {
                    tv_sec: 0,
                    tv_nsec: 0,
                },
                st_ctim: timespec {
                    tv_sec: 0,
                    tv_nsec: 0,
                },
                __glibc_reserved: [0; 3],
            };
            if *__errno_location() != 17 as libc::c_int {
                log_perror(
                    (*srv).errh,
                    b"/home/kkysen/work/rust/lighttpd/src/server.c\0" as *const u8
                        as *const libc::c_char,
                    1307 as libc::c_int as libc::c_uint,
                    b"opening pid-file failed: %s\0" as *const u8 as *const libc::c_char,
                    pidfile,
                );
                return -(1 as libc::c_int);
            }
            if 0 as libc::c_int != stat(pidfile, &mut st_1) {
                log_perror(
                    (*srv).errh,
                    b"/home/kkysen/work/rust/lighttpd/src/server.c\0" as *const u8
                        as *const libc::c_char,
                    1313 as libc::c_int as libc::c_uint,
                    b"stating existing pid-file failed: %s\0" as *const u8 as *const libc::c_char,
                    pidfile,
                );
            }
            if !(st_1.st_mode & 0o170000 as libc::c_int as libc::c_uint
                == 0o100000 as libc::c_int as libc::c_uint)
            {
                log_error(
                    (*srv).errh,
                    b"/home/kkysen/work/rust/lighttpd/src/server.c\0" as *const u8
                        as *const libc::c_char,
                    1318 as libc::c_int as libc::c_uint,
                    b"pid-file exists and isn't regular file: %s\0" as *const u8
                        as *const libc::c_char,
                    pidfile,
                );
                return -(1 as libc::c_int);
            }
            ::core::ptr::write_volatile(
                &mut pid_fd as *mut libc::c_int,
                fdevent_open_cloexec(
                    pidfile,
                    0 as libc::c_int,
                    0o1 as libc::c_int | 0o100 as libc::c_int | 0o1000 as libc::c_int,
                    (0o400 as libc::c_int
                        | 0o200 as libc::c_int
                        | 0o400 as libc::c_int >> 3 as libc::c_int
                        | 0o400 as libc::c_int >> 3 as libc::c_int >> 3 as libc::c_int)
                        as mode_t,
                ),
            );
            if -(1 as libc::c_int)
                == ::core::ptr::read_volatile::<libc::c_int>(&pid_fd as *const libc::c_int)
            {
                log_perror(
                    (*srv).errh,
                    b"/home/kkysen/work/rust/lighttpd/src/server.c\0" as *const u8
                        as *const libc::c_char,
                    1324 as libc::c_int as libc::c_uint,
                    b"opening pid-file failed: %s\0" as *const u8 as *const libc::c_char,
                    pidfile,
                );
                return -(1 as libc::c_int);
            }
        }
    }
    let mut rlim: rlimit = {
        let mut init = rlimit {
            rlim_cur: 4096 as libc::c_int as rlim_t,
            rlim_max: 4096 as libc::c_int as rlim_t,
        };
        init
    };
    let mut use_rlimit: libc::c_int = 1 as libc::c_int;
    if 0 as libc::c_int != getrlimit(RLIMIT_NOFILE, &mut rlim) {
        log_perror(
            (*srv).errh,
            b"/home/kkysen/work/rust/lighttpd/src/server.c\0" as *const u8 as *const libc::c_char,
            1340 as libc::c_int as libc::c_uint,
            b"getrlimit()\0" as *const u8 as *const libc::c_char,
        );
        use_rlimit = 0 as libc::c_int;
    }
    if use_rlimit != 0
        && (*srv).srvconf.max_fds as libc::c_int != 0
        && (i_am_root != 0 || (*srv).srvconf.max_fds as libc::c_ulong <= rlim.rlim_max)
    {
        let mut rlim_cur: rlim_t = rlim.rlim_cur;
        rlim.rlim_cur = (*srv).srvconf.max_fds as rlim_t;
        if i_am_root != 0 {
            rlim.rlim_max = (*srv).srvconf.max_fds as rlim_t;
        }
        if 0 as libc::c_int != setrlimit(RLIMIT_NOFILE, &mut rlim) {
            log_perror(
                (*srv).errh,
                b"/home/kkysen/work/rust/lighttpd/src/server.c\0" as *const u8
                    as *const libc::c_char,
                1356 as libc::c_int as libc::c_uint,
                b"setrlimit()\0" as *const u8 as *const libc::c_char,
            );
            log_error(
                (*srv).errh,
                b"/home/kkysen/work/rust/lighttpd/src/server.c\0" as *const u8
                    as *const libc::c_char,
                1357 as libc::c_int as libc::c_uint,
                b"setrlimit() may need root to run once: setsebool -P httpd_setrlimit on\0"
                    as *const u8 as *const libc::c_char,
            );
            use_rlimit = 0 as libc::c_int;
            if (*srv).srvconf.max_fds as libc::c_ulong > rlim_cur {
                (*srv).srvconf.max_fds = rlim_cur as libc::c_ushort;
            }
        }
    }
    if 0 as libc::c_int == (*srv).srvconf.max_fds as libc::c_int {
        (*srv).srvconf.max_fds = (if rlim.rlim_cur <= 4096 as libc::c_int as libc::c_ulong {
            rlim.rlim_cur as libc::c_ushort as libc::c_int
        } else {
            4096 as libc::c_int
        }) as libc::c_ushort;
    }
    if use_rlimit != 0
        && (*srv).srvconf.enable_cores as libc::c_int != 0
        && getrlimit(RLIMIT_CORE, &mut rlim) == 0 as libc::c_int
    {
        rlim.rlim_cur = rlim.rlim_max;
        setrlimit(RLIMIT_CORE, &mut rlim);
    }
    if 0 as libc::c_int != network_init(srv, (*srv).stdin_fd) {
        return -(1 as libc::c_int);
    }
    (*srv).stdin_fd = -(1 as libc::c_int);
    if i_am_root != 0 {
        let mut grp: *mut group = 0 as *mut group;
        let mut pwd: *mut passwd = 0 as *mut passwd;
        if !((*srv).srvconf.groupname).is_null() {
            grp = getgrnam((*(*srv).srvconf.groupname).ptr);
            if grp.is_null() {
                log_error(
                    (*srv).errh,
                    b"/home/kkysen/work/rust/lighttpd/src/server.c\0" as *const u8
                        as *const libc::c_char,
                    1392 as libc::c_int as libc::c_uint,
                    b"can't find groupname %s\0" as *const u8 as *const libc::c_char,
                    (*(*srv).srvconf.groupname).ptr,
                );
                return -(1 as libc::c_int);
            }
        }
        if !((*srv).srvconf.username).is_null() {
            pwd = getpwnam((*(*srv).srvconf.username).ptr);
            if pwd.is_null() {
                log_error(
                    (*srv).errh,
                    b"/home/kkysen/work/rust/lighttpd/src/server.c\0" as *const u8
                        as *const libc::c_char,
                    1400 as libc::c_int as libc::c_uint,
                    b"can't find username %s\0" as *const u8 as *const libc::c_char,
                    (*(*srv).srvconf.username).ptr,
                );
                return -(1 as libc::c_int);
            }
            if (*pwd).pw_uid == 0 as libc::c_int as libc::c_uint {
                log_error(
                    (*srv).errh,
                    b"/home/kkysen/work/rust/lighttpd/src/server.c\0" as *const u8
                        as *const libc::c_char,
                    1406 as libc::c_int as libc::c_uint,
                    b"I will not set uid to 0\n\0" as *const u8 as *const libc::c_char,
                );
                return -(1 as libc::c_int);
            }
            if grp.is_null() && {
                grp = getgrgid((*pwd).pw_gid);
                grp.is_null()
            } {
                log_error(
                    (*srv).errh,
                    b"/home/kkysen/work/rust/lighttpd/src/server.c\0" as *const u8
                        as *const libc::c_char,
                    1412 as libc::c_int as libc::c_uint,
                    b"can't find group id %d\0" as *const u8 as *const libc::c_char,
                    (*pwd).pw_gid as libc::c_int,
                );
                return -(1 as libc::c_int);
            }
        }
        if !grp.is_null() {
            if (*grp).gr_gid == 0 as libc::c_int as libc::c_uint {
                log_error(
                    (*srv).errh,
                    b"/home/kkysen/work/rust/lighttpd/src/server.c\0" as *const u8
                        as *const libc::c_char,
                    1420 as libc::c_int as libc::c_uint,
                    b"I will not set gid to 0\n\0" as *const u8 as *const libc::c_char,
                );
                return -(1 as libc::c_int);
            }
        }
        if !grp.is_null() {
            if -(1 as libc::c_int) == setgid((*grp).gr_gid) {
                log_perror(
                    (*srv).errh,
                    b"/home/kkysen/work/rust/lighttpd/src/server.c\0" as *const u8
                        as *const libc::c_char,
                    1432 as libc::c_int as libc::c_uint,
                    b"setgid()\0" as *const u8 as *const libc::c_char,
                );
                return -(1 as libc::c_int);
            }
            if -(1 as libc::c_int) == setgroups(0 as libc::c_int as size_t, 0 as *const __gid_t) {
                log_perror(
                    (*srv).errh,
                    b"/home/kkysen/work/rust/lighttpd/src/server.c\0" as *const u8
                        as *const libc::c_char,
                    1436 as libc::c_int as libc::c_uint,
                    b"setgroups()\0" as *const u8 as *const libc::c_char,
                );
                return -(1 as libc::c_int);
            }
            if !((*srv).srvconf.username).is_null() {
                initgroups((*(*srv).srvconf.username).ptr, (*grp).gr_gid);
            }
        }
        if !((*srv).srvconf.changeroot).is_null() {
            tzset();
            if -(1 as libc::c_int) == chroot((*(*srv).srvconf.changeroot).ptr) {
                log_perror(
                    (*srv).errh,
                    b"/home/kkysen/work/rust/lighttpd/src/server.c\0" as *const u8
                        as *const libc::c_char,
                    1449 as libc::c_int as libc::c_uint,
                    b"chroot()\0" as *const u8 as *const libc::c_char,
                );
                return -(1 as libc::c_int);
            }
            if -(1 as libc::c_int) == chdir(b"/\0" as *const u8 as *const libc::c_char) {
                log_perror(
                    (*srv).errh,
                    b"/home/kkysen/work/rust/lighttpd/src/server.c\0" as *const u8
                        as *const libc::c_char,
                    1453 as libc::c_int as libc::c_uint,
                    b"chdir()\0" as *const u8 as *const libc::c_char,
                );
                return -(1 as libc::c_int);
            }
        }
        if !pwd.is_null() {
            if -(1 as libc::c_int) == setuid((*pwd).pw_uid) {
                log_perror(
                    (*srv).errh,
                    b"/home/kkysen/work/rust/lighttpd/src/server.c\0" as *const u8
                        as *const libc::c_char,
                    1462 as libc::c_int as libc::c_uint,
                    b"setuid()\0" as *const u8 as *const libc::c_char,
                );
                return -(1 as libc::c_int);
            }
        }
        if (*srv).srvconf.enable_cores != 0 {
            prctl(
                4 as libc::c_int,
                1 as libc::c_int,
                0 as libc::c_int,
                0 as libc::c_int,
                0 as libc::c_int,
            );
        }
    }
    if 0 as libc::c_int == (*srv).srvconf.dont_daemonize as libc::c_int
        && 0 as libc::c_int == graceful_restart
    {
        parent_pipe_fd = daemonize();
    }
    ::core::ptr::write_volatile(&mut graceful_restart as *mut sig_atomic_t, 0 as libc::c_int);
    if 0 as libc::c_int == oneshot_fd {
        ::core::ptr::write_volatile(
            &mut graceful_shutdown as *mut sig_atomic_t,
            0 as libc::c_int,
        );
    }
    memset(
        &mut act as *mut sigaction as *mut libc::c_void,
        0 as libc::c_int,
        ::core::mem::size_of::<sigaction>() as libc::c_ulong,
    );
    act.__sigaction_handler.sa_handler = ::core::mem::transmute::<libc::intptr_t, __sighandler_t>(
        1 as libc::c_int as libc::intptr_t,
    );
    sigaction(13 as libc::c_int, &mut act, 0 as *mut sigaction);
    ::core::ptr::write_volatile(
        &mut last_sighup_info._sifields._kill.si_uid as *mut __uid_t,
        0 as libc::c_int as __uid_t,
    );
    ::core::ptr::write_volatile(
        &mut last_sighup_info._sifields._kill.si_pid as *mut __pid_t,
        0 as libc::c_int,
    );
    ::core::ptr::write_volatile(
        &mut last_sigterm_info._sifields._kill.si_uid as *mut __uid_t,
        0 as libc::c_int as __uid_t,
    );
    ::core::ptr::write_volatile(
        &mut last_sigterm_info._sifields._kill.si_pid as *mut __pid_t,
        0 as libc::c_int,
    );
    act.__sigaction_handler.sa_sigaction = Some(
        sigaction_handler
            as unsafe extern "C" fn(libc::c_int, *mut siginfo_t, *mut libc::c_void) -> (),
    );
    sigemptyset(&mut act.sa_mask);
    act.sa_flags = 4 as libc::c_int;
    sigaction(2 as libc::c_int, &mut act, 0 as *mut sigaction);
    sigaction(15 as libc::c_int, &mut act, 0 as *mut sigaction);
    sigaction(1 as libc::c_int, &mut act, 0 as *mut sigaction);
    sigaction(14 as libc::c_int, &mut act, 0 as *mut sigaction);
    sigaction(10 as libc::c_int, &mut act, 0 as *mut sigaction);
    act.sa_flags |= 0x10000000 as libc::c_int | 1 as libc::c_int;
    sigaction(17 as libc::c_int, &mut act, 0 as *mut sigaction);
    (*srv).gid = getgid();
    (*srv).uid = getuid();
    (*srv).pid = getpid();
    if pid_fd > 2 as libc::c_int {
        let tb: *mut buffer = (*srv).tmp_buf;
        buffer_clear(tb);
        buffer_append_int(tb, (*srv).pid as intmax_t);
        buffer_append_string_len(
            tb,
            b"\n\0" as *const u8 as *const libc::c_char,
            (::core::mem::size_of::<[libc::c_char; 2]>() as libc::c_ulong as uint32_t)
                .wrapping_sub(1 as libc::c_int as libc::c_uint) as size_t,
        );
        if -(1 as libc::c_int) as libc::c_long
            == write_all(
                pid_fd,
                (*tb).ptr as *const libc::c_void,
                buffer_clen(tb) as size_t,
            )
        {
            log_perror(
                (*srv).errh,
                b"/home/kkysen/work/rust/lighttpd/src/server.c\0" as *const u8
                    as *const libc::c_char,
                1551 as libc::c_int as libc::c_uint,
                b"Couldn't write pid file\0" as *const u8 as *const libc::c_char,
            );
            close(pid_fd);
            ::core::ptr::write_volatile(&mut pid_fd as *mut libc::c_int, -(1 as libc::c_int));
            return -(1 as libc::c_int);
        }
    } else if pid_fd < -(2 as libc::c_int) {
        ::core::ptr::write_volatile(&mut pid_fd as *mut libc::c_int, -pid_fd);
    }
    if (*srv).srvconf.preflight_check == 0 {
        if -(1 as libc::c_int) == config_log_error_open(srv) {
            log_error(
                (*srv).errh,
                b"/home/kkysen/work/rust/lighttpd/src/server.c\0" as *const u8
                    as *const libc::c_char,
                1564 as libc::c_int as libc::c_uint,
                b"Opening errorlog failed. Going down.\0" as *const u8 as *const libc::c_char,
            );
            return -(1 as libc::c_int);
        }
        if oneshot_fd == 0 {
            log_error(
                (*srv).errh,
                b"/home/kkysen/work/rust/lighttpd/src/server.c\0" as *const u8
                    as *const libc::c_char,
                1568 as libc::c_int as libc::c_uint,
                b"server started (lighttpd/1.4.64)\0" as *const u8 as *const libc::c_char,
            );
        }
    }
    if HANDLER_GO_ON as libc::c_int as libc::c_uint
        != plugins_call_set_defaults(srv) as libc::c_uint
    {
        log_error(
            (*srv).errh,
            b"/home/kkysen/work/rust/lighttpd/src/server.c\0" as *const u8 as *const libc::c_char,
            1572 as libc::c_int as libc::c_uint,
            b"Configuration of plugins failed. Going down.\0" as *const u8 as *const libc::c_char,
        );
        return -(1 as libc::c_int);
    }
    if config_finalize(srv, &default_server_tag) == 0 {
        return -(1 as libc::c_int);
    }
    if (*srv).srvconf.preflight_check != 0 {
        return 0 as libc::c_int;
    }
    if 0 as libc::c_int == (*srv).srvconf.dont_daemonize as libc::c_int
        && -(1 as libc::c_int) != parent_pipe_fd
    {
        if 0 as libc::c_int as libc::c_long
            > write(
                parent_pipe_fd,
                b"\0" as *const u8 as *const libc::c_char as *const libc::c_void,
                1 as libc::c_int as size_t,
            )
        {
            return -(1 as libc::c_int);
        }
        close(parent_pipe_fd);
    }
    if idle_limit != 0 && (*srv).srvconf.max_worker as libc::c_int != 0 {
        (*srv).srvconf.max_worker = 0 as libc::c_int as libc::c_ushort;
        log_error(
            (*srv).errh,
            b"/home/kkysen/work/rust/lighttpd/src/server.c\0" as *const u8
                as *const libc::c_char,
            1598 as libc::c_int as libc::c_uint,
            b"server idle time limit command line option disables server.max-worker config file option.\0"
                as *const u8 as *const libc::c_char,
        );
    }
    num_childs = (*srv).srvconf.max_worker as libc::c_int;
    if num_childs > 0 as libc::c_int {
        let vla = num_childs as usize;
        let mut pids: Vec<pid_t> = ::std::vec::from_elem(0, vla);
        let mut pid: pid_t = 0;
        let npids: libc::c_int = num_childs;
        let mut child: libc::c_int = 0 as libc::c_int;
        let mut timer: libc::c_uint = 0 as libc::c_int as libc::c_uint;
        let mut n: libc::c_int = 0 as libc::c_int;
        while n < npids {
            *pids.as_mut_ptr().offset(n as isize) = -(1 as libc::c_int);
            n += 1;
        }
        server_graceful_signal_prev_generation();
        while child == 0 && srv_shutdown == 0 && graceful_shutdown == 0 {
            if num_childs > 0 as libc::c_int {
                pid = fork();
                match pid {
                    -1 => return -(1 as libc::c_int),
                    0 => {
                        child = 1 as libc::c_int;
                        alarm(0 as libc::c_int as libc::c_uint);
                    }
                    _ => {
                        num_childs -= 1;
                        let mut n_0: libc::c_int = 0 as libc::c_int;
                        while n_0 < npids {
                            if -(1 as libc::c_int) == *pids.as_mut_ptr().offset(n_0 as isize) {
                                *pids.as_mut_ptr().offset(n_0 as isize) = pid;
                                break;
                            } else {
                                n_0 += 1;
                            }
                        }
                    }
                }
            } else {
                let mut status: libc::c_int = 0;
                let mut mono_ts: unix_time64_t = 0;
                pid = fdevent_waitpid_intr(-(1 as libc::c_int), &mut status);
                if -(1 as libc::c_int) != pid {
                    mono_ts = log_monotonic_secs;
                    log_monotonic_secs = server_monotonic_secs();
                    log_epoch_secs = server_epoch_secs(srv, log_monotonic_secs - mono_ts);
                    if plugins_call_handle_waitpid(srv, pid, status) as libc::c_uint
                        != HANDLER_GO_ON as libc::c_int as libc::c_uint
                    {
                        if timer == 0 {
                            timer = 5 as libc::c_int as libc::c_uint;
                            alarm(timer);
                        }
                    } else {
                        match fdlog_pipes_waitpid_cb(pid) {
                            -1 => {
                                if timer == 0 {
                                    timer = 5 as libc::c_int as libc::c_uint;
                                    alarm(timer);
                                }
                            }
                            1 => {}
                            _ => {
                                let mut n_1: libc::c_int = 0 as libc::c_int;
                                while n_1 < npids {
                                    if pid == *pids.as_mut_ptr().offset(n_1 as isize) {
                                        *pids.as_mut_ptr().offset(n_1 as isize) =
                                            -(1 as libc::c_int);
                                        num_childs += 1;
                                        break;
                                    } else {
                                        n_1 += 1;
                                    }
                                }
                            }
                        }
                    }
                } else {
                    match *__errno_location() {
                        4 => {
                            mono_ts = log_monotonic_secs;
                            log_monotonic_secs = server_monotonic_secs();
                            log_epoch_secs = server_epoch_secs(srv, log_monotonic_secs - mono_ts);
                            if handle_sig_hup != 0 {
                                ::core::ptr::write_volatile(
                                    &mut handle_sig_hup as *mut sig_atomic_t,
                                    0 as libc::c_int,
                                );
                                fdlog_files_cycle((*srv).errh);
                                let mut n_2: libc::c_int = 0 as libc::c_int;
                                while n_2 < npids {
                                    if *pids.as_mut_ptr().offset(n_2 as isize) > 0 as libc::c_int {
                                        kill(
                                            *pids.as_mut_ptr().offset(n_2 as isize),
                                            1 as libc::c_int,
                                        );
                                    }
                                    n_2 += 1;
                                }
                            }
                            if handle_sig_alarm != 0 {
                                ::core::ptr::write_volatile(
                                    &mut handle_sig_alarm as *mut sig_atomic_t,
                                    0 as libc::c_int,
                                );
                                timer = 0 as libc::c_int as libc::c_uint;
                                plugins_call_handle_trigger(srv);
                                fdlog_pipes_restart(log_monotonic_secs);
                            }
                        }
                        _ => {}
                    }
                }
            }
        }
        if child == 0 {
            if graceful_shutdown != 0 || graceful_restart != 0 {
                if graceful_restart != 0 {
                    ::core::ptr::write_volatile(
                        &mut graceful_restart as *mut sig_atomic_t,
                        2 as libc::c_int,
                    );
                }
                kill(0 as libc::c_int, 2 as libc::c_int);
                server_graceful_state(srv);
            } else if srv_shutdown != 0 {
                kill(0 as libc::c_int, 15 as libc::c_int);
            }
            return 0 as libc::c_int;
        }
        let mut actignore: sigaction = sigaction {
            __sigaction_handler: C2RustUnnamed_44 { sa_handler: None },
            sa_mask: __sigset_t { __val: [0; 16] },
            sa_flags: 0,
            sa_restorer: None,
        };
        memset(
            &mut actignore as *mut sigaction as *mut libc::c_void,
            0 as libc::c_int,
            ::core::mem::size_of::<sigaction>() as libc::c_ulong,
        );
        actignore.__sigaction_handler.sa_handler = ::core::mem::transmute::<
            libc::intptr_t,
            __sighandler_t,
        >(1 as libc::c_int as libc::intptr_t);
        sigaction(10 as libc::c_int, &mut actignore, 0 as *mut sigaction);
        if 0 as libc::c_int <= pid_fd {
            close(pid_fd);
            ::core::ptr::write_volatile(&mut pid_fd as *mut libc::c_int, -(1 as libc::c_int));
        }
        (*srv).srvconf.pid_file = 0 as *mut buffer;
        fdlog_pipes_abandon_pids();
        (*srv).pid = getpid();
        li_rand_reseed();
    }
    (*srv).max_fds = (*srv).srvconf.max_fds as libc::c_int;
    if (*srv).max_fds < 32 as libc::c_int {
        (*srv).max_fds = 32 as libc::c_int;
    }
    (*srv).ev = fdevent_init(
        (*srv).srvconf.event_handler,
        &mut (*srv).max_fds,
        &mut (*srv).cur_fds,
        (*srv).errh,
    );
    if ((*srv).ev).is_null() {
        log_error(
            (*srv).errh,
            b"/home/kkysen/work/rust/lighttpd/src/server.c\0" as *const u8 as *const libc::c_char,
            1743 as libc::c_int as libc::c_uint,
            b"fdevent_init failed\0" as *const u8 as *const libc::c_char,
        );
        return -(1 as libc::c_int);
    }
    (*srv).max_fds_lowat = (*srv).max_fds * 8 as libc::c_int / 10 as libc::c_int;
    (*srv).max_fds_hiwat = (*srv).max_fds * 9 as libc::c_int / 10 as libc::c_int;
    if (*srv).srvconf.max_conns as libc::c_int > (*srv).max_fds / 2 as libc::c_int {
        log_error(
            (*srv).errh,
            b"/home/kkysen/work/rust/lighttpd/src/server.c\0" as *const u8 as *const libc::c_char,
            1753 as libc::c_int as libc::c_uint,
            b"can't have more connections than fds/2: %hu %d\0" as *const u8 as *const libc::c_char,
            (*srv).srvconf.max_conns as libc::c_int,
            (*srv).max_fds,
        );
        (*srv).srvconf.max_conns = ((*srv).max_fds / 2 as libc::c_int) as libc::c_ushort;
        (*srv).lim_conns = (*srv).srvconf.max_conns as uint32_t;
    } else if (*srv).srvconf.max_conns != 0 {
        (*srv).lim_conns = (*srv).srvconf.max_conns as uint32_t;
    } else {
        (*srv).srvconf.max_conns = ((*srv).max_fds / 3 as libc::c_int) as libc::c_ushort;
        (*srv).lim_conns = (*srv).srvconf.max_conns as uint32_t;
    }
    sigaction(17 as libc::c_int, &mut act, 0 as *mut sigaction);
    if 0 as libc::c_int != network_register_fdevents(srv) {
        return -(1 as libc::c_int);
    }
    chunkqueue_internal_pipes(config_feature_bool(
        srv,
        b"chunkqueue.splice\0" as *const u8 as *const libc::c_char,
        1 as libc::c_int,
    ));
    if stat_cache_init((*srv).ev, (*srv).errh) == 0 {
        log_error(
            (*srv).errh,
            b"/home/kkysen/work/rust/lighttpd/src/server.c\0" as *const u8 as *const libc::c_char,
            1785 as libc::c_int as libc::c_uint,
            b"stat-cache could not be setup, dying.\0" as *const u8 as *const libc::c_char,
        );
        return -(1 as libc::c_int);
    }
    let mut fd: libc::c_int = fdevent_open_devnull();
    if fd >= 0 as libc::c_int {
        (*srv).cur_fds = fd;
        close(fd);
    }
    if 0 as libc::c_int != server_sockets_set_nb_cloexec(srv) {
        return -(1 as libc::c_int);
    }
    if HANDLER_GO_ON as libc::c_int as libc::c_uint != plugins_call_worker_init(srv) as libc::c_uint
    {
        return -(1 as libc::c_int);
    }
    if oneshot_fdout > 0 as libc::c_int {
        if server_oneshot_init_pipe(srv, oneshot_fd, oneshot_fdout) != 0 {
            oneshot_fd = -(1 as libc::c_int);
            oneshot_fdout = -(1 as libc::c_int);
        }
    } else if oneshot_fd != 0 && server_oneshot_init(srv, oneshot_fd) != 0 {
        oneshot_fd = -(1 as libc::c_int);
    }
    if 0 as libc::c_int == (*srv).srvconf.max_worker as libc::c_int {
        server_graceful_signal_prev_generation();
    }
    return 1 as libc::c_int;
}
unsafe extern "C" fn server_load_check(mut srv: *mut server) {
    if (*srv).cur_fds > (*srv).max_fds_hiwat || 0 as libc::c_int as libc::c_uint == (*srv).lim_conns
    {
        server_sockets_disable(srv);
    }
}
#[cold]
unsafe extern "C" fn server_overload_check(mut srv: *mut server) {
    if (*srv).cur_fds < (*srv).max_fds_lowat && 0 as libc::c_int as libc::c_uint != (*srv).lim_conns
    {
        server_sockets_enable(srv);
    }
}
#[cold]
#[inline(never)]
unsafe extern "C" fn server_sockets_disable(mut srv: *mut server) {
    server_sockets_set_event(srv, 0 as libc::c_int);
    (*srv).sockets_disabled = 1 as libc::c_int;
    log_error(
        (*srv).errh,
        b"/home/kkysen/work/rust/lighttpd/src/server.c\0" as *const u8 as *const libc::c_char,
        1043 as libc::c_int as libc::c_uint,
        if 0 as libc::c_int as libc::c_uint == (*srv).lim_conns {
            b"[note] sockets disabled, connection limit reached\0" as *const u8
                as *const libc::c_char
        } else {
            b"[note] sockets disabled, out-of-fds\0" as *const u8 as *const libc::c_char
        },
    );
}
#[cold]
#[inline(never)]
unsafe extern "C" fn server_sockets_enable(mut srv: *mut server) {
    server_sockets_set_event(srv, 0x1 as libc::c_int);
    (*srv).sockets_disabled = 0 as libc::c_int;
    log_error(
        (*srv).errh,
        b"/home/kkysen/work/rust/lighttpd/src/server.c\0" as *const u8 as *const libc::c_char,
        1035 as libc::c_int as libc::c_uint,
        b"[note] sockets enabled again\0" as *const u8 as *const libc::c_char,
    );
}
#[cold]
#[inline(never)]
unsafe extern "C" fn server_graceful_state(mut srv: *mut server) {
    if srv_shutdown == 0 {
        if 0 as libc::c_int as libc::c_long == (*srv).graceful_expire_ts {
            (*srv).graceful_expire_ts = config_feature_int(
                srv,
                b"server.graceful-shutdown-timeout\0" as *const u8 as *const libc::c_char,
                8 as libc::c_int,
            ) as unix_time64_t;
            if (*srv).graceful_expire_ts != 0 {
                (*srv).graceful_expire_ts += log_monotonic_secs;
            }
        }
        server_graceful_shutdown_maint(srv);
    }
    if 2 as libc::c_int == (*srv).sockets_disabled || 3 as libc::c_int == (*srv).sockets_disabled {
        if oneshot_fd != 0 {
            ::core::ptr::write_volatile(
                &mut graceful_restart as *mut sig_atomic_t,
                0 as libc::c_int,
            );
        }
        return;
    }
    log_error(
        (*srv).errh,
        b"/home/kkysen/work/rust/lighttpd/src/server.c\0" as *const u8 as *const libc::c_char,
        1011 as libc::c_int as libc::c_uint,
        b"[note] graceful shutdown started\0" as *const u8 as *const libc::c_char,
    );
    if !((*srv).srvconf.changeroot).is_null()
        || oneshot_fd != 0
        || 2 as libc::c_int == graceful_shutdown
    {
        ::core::ptr::write_volatile(&mut graceful_restart as *mut sig_atomic_t, 0 as libc::c_int);
    }
    if graceful_restart != 0 {
        if server_graceful_state_bg(srv) == 0 {
            server_sockets_unregister(srv);
        }
        if pid_fd > 0 as libc::c_int {
            ::core::ptr::write_volatile(&mut pid_fd as *mut libc::c_int, -pid_fd);
        }
    } else {
        server_sockets_close(srv);
        remove_pid_file(srv);
        (*srv).srvconf.pid_file = 0 as *mut buffer;
    };
}
#[cold]
#[inline(never)]
unsafe extern "C" fn server_graceful_shutdown_maint(mut srv: *mut server) {
    if oneshot_fd != 0 {
        if (*srv).graceful_expire_ts == 0 {
            return;
        }
        if (*srv).graceful_expire_ts >= log_monotonic_secs {
            return;
        }
    }
    connection_graceful_shutdown_maint(srv);
}
#[cold]
unsafe extern "C" fn server_graceful_state_bg(mut srv: *mut server) -> libc::c_int {
    if srv_shutdown != 0 {
        return 0 as libc::c_int;
    }
    if config_feature_bool(
        srv,
        b"server.graceful-restart-bg\0" as *const u8 as *const libc::c_char,
        0 as libc::c_int,
    ) == 0
    {
        return 0 as libc::c_int;
    }
    let du: *mut data_unset = array_get_data_unset(
        (*srv).srvconf.feature_flags,
        b"server.graceful-restart-bg\0" as *const u8 as *const libc::c_char,
        (::core::mem::size_of::<[libc::c_char; 27]>() as libc::c_ulong as uint32_t)
            .wrapping_sub(1 as libc::c_int as libc::c_uint),
    );
    if (*du).type_0 as libc::c_uint == TYPE_STRING as libc::c_int as libc::c_uint {
        buffer_copy_string_len(
            &mut (*(du as *mut data_string)).value,
            b"false\0" as *const u8 as *const libc::c_char,
            (::core::mem::size_of::<[libc::c_char; 6]>() as libc::c_ulong as uint32_t)
                .wrapping_sub(1 as libc::c_int as libc::c_uint) as size_t,
        );
    } else {
        (*(du as *mut data_integer)).value = 0 as libc::c_int;
    }
    let argv: *mut *mut libc::c_char = (*srv).argv;
    if if 0 as libc::c_int == (*srv).srvconf.dont_daemonize as libc::c_int {
        (*(*argv.offset(0 as libc::c_int as isize)).offset(0 as libc::c_int as isize)
            as libc::c_int
            != '/' as i32) as libc::c_int
    } else {
        (0 as *mut libc::c_void as *mut libc::c_char
            == strchr(*argv.offset(0 as libc::c_int as isize), '/' as i32)) as libc::c_int
    } != 0
    {
        return 0 as libc::c_int;
    }
    plugins_call_handle_sighup(srv);
    fdlog_files_cycle((*srv).errh);
    let mut pid: pid_t = fork();
    if pid != 0 {
        if pid < 0 as libc::c_int {
            return 0 as libc::c_int;
        }
        network_socket_activation_to_env(srv);
        server_graceful_signal_prev_generation();
        if 0 as libc::c_int == (*srv).srvconf.max_worker as libc::c_int {
            let tb: *mut buffer = (*srv).tmp_buf;
            buffer_clear(tb);
            buffer_append_int(tb, pid as intmax_t);
            setenv(
                b"LIGHTTPD_PREV_GEN\0" as *const u8 as *const libc::c_char,
                (*tb).ptr,
                1 as libc::c_int,
            );
        }
        execv(
            *argv.offset(0 as libc::c_int as isize),
            argv as *const *mut libc::c_char,
        );
        _exit(1 as libc::c_int);
    }
    if 0 as libc::c_int != (*srv).srvconf.max_worker as libc::c_int {
        server_sockets_close(srv);
    }
    if 0 as libc::c_int <= pid_fd {
        close(pid_fd);
        ::core::ptr::write_volatile(&mut pid_fd as *mut libc::c_int, -(1 as libc::c_int));
    }
    (*srv).srvconf.pid_file = 0 as *mut buffer;
    log_error(
        (*srv).errh,
        b"/home/kkysen/work/rust/lighttpd/src/server.c\0" as *const u8 as *const libc::c_char,
        968 as libc::c_int as libc::c_uint,
        b"[note] pid %lld continuing to handle %u connection(s) in progress\0" as *const u8
            as *const libc::c_char,
        getpid() as libc::c_longlong,
        ((*srv).srvconf.max_conns as libc::c_uint).wrapping_sub((*srv).lim_conns),
    );
    if 0 as libc::c_int == (*srv).srvconf.max_worker as libc::c_int {
        (*srv).graceful_expire_ts = 0 as libc::c_int as unix_time64_t;
        ::core::ptr::write_volatile(
            &mut graceful_shutdown as *mut sig_atomic_t,
            0 as libc::c_int,
        );
    }
    ::core::ptr::write_volatile(&mut graceful_restart as *mut sig_atomic_t, 0 as libc::c_int);
    return 1 as libc::c_int;
}
#[cold]
unsafe extern "C" fn server_graceful_signal_prev_generation() {
    let prev_gen: *const libc::c_char =
        getenv(b"LIGHTTPD_PREV_GEN\0" as *const u8 as *const libc::c_char);
    if prev_gen.is_null() {
        return;
    }
    let mut pid: pid_t = strtol(prev_gen, 0 as *mut *mut libc::c_char, 10 as libc::c_int) as pid_t;
    unsetenv(b"LIGHTTPD_PREV_GEN\0" as *const u8 as *const libc::c_char);
    if pid <= 0 as libc::c_int {
        return;
    }
    if pid == fdevent_waitpid(pid, 0 as *mut libc::c_int, 1 as libc::c_int) {
        return;
    }
    kill(pid, 2 as libc::c_int);
}
#[cold]
unsafe extern "C" fn server_sockets_close(mut srv: *mut server) {
    if 3 as libc::c_int == (*srv).sockets_disabled {
        return;
    }
    let mut i: uint32_t = 0 as libc::c_int as uint32_t;
    while i < (*srv).srv_sockets.used {
        let mut srv_socket: *mut server_socket = *((*srv).srv_sockets.ptr).offset(i as isize);
        if !(-(1 as libc::c_int) == (*srv_socket).fd) {
            if 2 as libc::c_int != (*srv).sockets_disabled {
                network_unregister_sock(srv, srv_socket);
            }
            close((*srv_socket).fd);
            (*srv_socket).fd = -(1 as libc::c_int);
        }
        i = i.wrapping_add(1);
    }
    (*srv).sockets_disabled = 3 as libc::c_int;
}
#[cold]
unsafe extern "C" fn server_sockets_unregister(mut srv: *mut server) {
    if 2 as libc::c_int == (*srv).sockets_disabled {
        return;
    }
    (*srv).sockets_disabled = 2 as libc::c_int;
    let mut i: uint32_t = 0 as libc::c_int as uint32_t;
    while i < (*srv).srv_sockets.used {
        network_unregister_sock(srv, *((*srv).srv_sockets.ptr).offset(i as isize));
        i = i.wrapping_add(1);
    }
}
#[cold]
unsafe extern "C" fn server_sockets_set_event(mut srv: *mut server, mut event: libc::c_int) {
    let mut i: uint32_t = 0 as libc::c_int as uint32_t;
    while i < (*srv).srv_sockets.used {
        let mut srv_socket: *mut server_socket = *((*srv).srv_sockets.ptr).offset(i as isize);
        fdevent_fdnode_event_set((*srv).ev, (*srv_socket).fdn, event);
        i = i.wrapping_add(1);
    }
}
#[cold]
unsafe extern "C" fn server_sockets_set_nb_cloexec(mut srv: *mut server) -> libc::c_int {
    if (*srv).sockets_disabled != 0 {
        return 0 as libc::c_int;
    }
    let mut i: uint32_t = 0 as libc::c_int as uint32_t;
    while i < (*srv).srv_sockets.used {
        let mut srv_socket: *mut server_socket = *((*srv).srv_sockets.ptr).offset(i as isize);
        if -(1 as libc::c_int) == fdevent_fcntl_set_nb_cloexec_sock((*srv_socket).fd) {
            log_perror(
                (*srv).errh,
                b"/home/kkysen/work/rust/lighttpd/src/server.c\0" as *const u8
                    as *const libc::c_char,
                796 as libc::c_int as libc::c_uint,
                b"fcntl()\0" as *const u8 as *const libc::c_char,
            );
            return -(1 as libc::c_int);
        }
        i = i.wrapping_add(1);
    }
    return 0 as libc::c_int;
}
#[cold]
#[inline(never)]
unsafe extern "C" fn server_sockets_restore(mut srv: *mut server) {
    memcpy(
        &mut (*srv).srv_sockets as *mut server_socket_array as *mut libc::c_void,
        &mut graceful_sockets as *mut server_socket_array as *const libc::c_void,
        ::core::mem::size_of::<server_socket_array>() as libc::c_ulong,
    );
    memset(
        &mut graceful_sockets as *mut server_socket_array as *mut libc::c_void,
        0 as libc::c_int,
        ::core::mem::size_of::<server_socket_array>() as libc::c_ulong,
    );
    memcpy(
        &mut (*srv).srv_sockets_inherited as *mut server_socket_array as *mut libc::c_void,
        &mut inherited_sockets as *mut server_socket_array as *const libc::c_void,
        ::core::mem::size_of::<server_socket_array>() as libc::c_ulong,
    );
    memset(
        &mut inherited_sockets as *mut server_socket_array as *mut libc::c_void,
        0 as libc::c_int,
        ::core::mem::size_of::<server_socket_array>() as libc::c_ulong,
    );
    let mut i: uint32_t = 0 as libc::c_int as uint32_t;
    while i < (*srv).srv_sockets.used {
        let ref mut fresh7 = (**((*srv).srv_sockets.ptr).offset(i as isize)).srv;
        *fresh7 = srv;
        i = i.wrapping_add(1);
    }
    let mut i_0: uint32_t = 0 as libc::c_int as uint32_t;
    while i_0 < (*srv).srv_sockets_inherited.used {
        let ref mut fresh8 = (**((*srv).srv_sockets_inherited.ptr).offset(i_0 as isize)).srv;
        *fresh8 = srv;
        i_0 = i_0.wrapping_add(1);
    }
}
#[cold]
#[inline(never)]
unsafe extern "C" fn server_sockets_save(mut srv: *mut server) {
    let mut i: uint32_t = 0 as libc::c_int as uint32_t;
    while i < (*srv).srv_sockets.used {
        let ref mut fresh9 = (**((*srv).srv_sockets.ptr).offset(i as isize)).srv;
        *fresh9 = 0 as *mut server;
        i = i.wrapping_add(1);
    }
    let mut i_0: uint32_t = 0 as libc::c_int as uint32_t;
    while i_0 < (*srv).srv_sockets_inherited.used {
        let ref mut fresh10 = (**((*srv).srv_sockets_inherited.ptr).offset(i_0 as isize)).srv;
        *fresh10 = 0 as *mut server;
        i_0 = i_0.wrapping_add(1);
    }
    memcpy(
        &mut graceful_sockets as *mut server_socket_array as *mut libc::c_void,
        &mut (*srv).srv_sockets as *mut server_socket_array as *const libc::c_void,
        ::core::mem::size_of::<server_socket_array>() as libc::c_ulong,
    );
    memset(
        &mut (*srv).srv_sockets as *mut server_socket_array as *mut libc::c_void,
        0 as libc::c_int,
        ::core::mem::size_of::<server_socket_array>() as libc::c_ulong,
    );
    memcpy(
        &mut inherited_sockets as *mut server_socket_array as *mut libc::c_void,
        &mut (*srv).srv_sockets_inherited as *mut server_socket_array as *const libc::c_void,
        ::core::mem::size_of::<server_socket_array>() as libc::c_ulong,
    );
    memset(
        &mut (*srv).srv_sockets_inherited as *mut server_socket_array as *mut libc::c_void,
        0 as libc::c_int,
        ::core::mem::size_of::<server_socket_array>() as libc::c_ulong,
    );
}
#[cold]
unsafe extern "C" fn show_help() {
    let mut b: *mut libc::c_char = b"lighttpd/1.4.64 - a light and fast webserver\nusage:\n -f <name>  filename of the config-file\n -m <name>  module directory (default: /usr/local/lib/lighttpd)\n -i <secs>  graceful shutdown after <secs> of inactivity\n -1         process single (one) request on stdin socket, then exit\n -p         print the parsed config-file in internal form, and exit\n -t         test config-file syntax, then exit\n -tt        test config-file syntax, load and init modules, then exit\n -D         don't go to background (default: go to background)\n -v         show version\n -V         show compile-time features\n -h         show this help\n\n\0"
        as *const u8 as *const libc::c_char as *mut libc::c_char;
    write_all(1 as libc::c_int, b as *const libc::c_void, strlen(b));
}
#[cold]
unsafe extern "C" fn show_features() {
    static mut features: [libc::c_char; 407] = unsafe {
        *::core::mem::transmute::<
            &[u8; 407],
            &[libc::c_char; 407],
        >(
            b"\nFeatures:\n\n\t+ IPv6 support\n\t+ zlib support\n\t- zstd support\n\t- bzip2 support\n\t- brotli support\n\t+ crypt support\n\t- OpenSSL support\n\t- mbedTLS support\n\t- NSS crypto support\n\t- GnuTLS support\n\t- WolfSSL support\n\t- Nettle support\n\t+ PCRE support\n\t- MySQL support\n\t- PgSQL support\n\t- DBI support\n\t- Kerberos support\n\t- LDAP support\n\t- PAM support\n\t- FAM support\n\t- LUA support\n\t- xml support\n\t- SQLite support\n\0",
        )
    };
    show_version();
    printf(
        b"%s%s%s%s\n\0" as *const u8 as *const libc::c_char,
        fdevent_show_event_handlers(),
        network_write_show_handlers(),
        features.as_ptr(),
        if ::core::mem::size_of::<time_t>() as libc::c_ulong > 4 as libc::c_int as libc::c_ulong
            || ::core::mem::size_of::<time_t>() as libc::c_ulong
                == 4 as libc::c_int as libc::c_ulong
                && -(1 as libc::c_int) as time_t > 1 as libc::c_int as time_t
        {
            b"\t+ Y2038 support\n\0" as *const u8 as *const libc::c_char
        } else {
            b"\t- Y2038 support (unsafe 32-bit signed time_t)\n\0" as *const u8
                as *const libc::c_char
        },
    );
}
#[cold]
unsafe extern "C" fn show_version() {
    let mut b: *mut libc::c_char = b"lighttpd/1.4.64 - a light and fast webserver\n\0" as *const u8
        as *const libc::c_char as *mut libc::c_char;
    write_all(1 as libc::c_int, b as *const libc::c_void, strlen(b));
}
#[cold]
unsafe extern "C" fn server_oneshot_init(mut srv: *mut server, mut fd: libc::c_int) -> libc::c_int {
    let mut con: *mut connection = 0 as *mut connection;
    let mut srv_socket: *const server_socket = 0 as *const server_socket;
    let mut cnt_addr: sock_addr = sock_addr {
        ipv6: sockaddr_in6 {
            sin6_family: 0,
            sin6_port: 0,
            sin6_flowinfo: 0,
            sin6_addr: in6_addr {
                __in6_u: C2RustUnnamed_0 {
                    __u6_addr8: [0; 16],
                },
            },
            sin6_scope_id: 0,
        },
    };
    let mut cnt_len: socklen_t = 0;
    cnt_len = ::core::mem::size_of::<sock_addr>() as libc::c_ulong as socklen_t;
    if 0 as libc::c_int
        != getsockname(
            fd,
            __SOCKADDR_ARG {
                __sockaddr__: &mut cnt_addr as *mut sock_addr as *mut sockaddr,
            },
            &mut cnt_len,
        )
    {
        log_perror(
            (*srv).errh,
            b"/home/kkysen/work/rust/lighttpd/src/server.c\0" as *const u8 as *const libc::c_char,
            565 as libc::c_int as libc::c_uint,
            b"getsockname()\0" as *const u8 as *const libc::c_char,
        );
        return 0 as libc::c_int;
    }
    srv_socket = server_oneshot_getsock(srv, &mut cnt_addr);
    if srv_socket.is_null() {
        return 0 as libc::c_int;
    }
    cnt_len = ::core::mem::size_of::<sock_addr>() as libc::c_ulong as socklen_t;
    if 0 as libc::c_int
        != getpeername(
            fd,
            __SOCKADDR_ARG {
                __sockaddr__: &mut cnt_addr as *mut sock_addr as *mut sockaddr,
            },
            &mut cnt_len,
        )
    {
        log_perror(
            (*srv).errh,
            b"/home/kkysen/work/rust/lighttpd/src/server.c\0" as *const u8 as *const libc::c_char,
            577 as libc::c_int as libc::c_uint,
            b"getpeername()\0" as *const u8 as *const libc::c_char,
        );
        return 0 as libc::c_int;
    }
    if -(1 as libc::c_int) == fdevent_fcntl_set_nb_cloexec(fd) {
        log_perror(
            (*srv).errh,
            b"/home/kkysen/work/rust/lighttpd/src/server.c\0" as *const u8 as *const libc::c_char,
            583 as libc::c_int as libc::c_uint,
            b"fcntl()\0" as *const u8 as *const libc::c_char,
        );
        return 0 as libc::c_int;
    }
    if sock_addr_get_family(&mut cnt_addr) != 1 as libc::c_int {
        network_accept_tcp_nagle_disable(fd);
    }
    con = connection_accepted(srv, srv_socket, &mut cnt_addr, fd);
    if con.is_null() {
        return 0 as libc::c_int;
    }
    connection_state_machine(con);
    return 1 as libc::c_int;
}
#[cold]
unsafe extern "C" fn server_oneshot_init_pipe(
    mut srv: *mut server,
    mut fdin: libc::c_int,
    mut fdout: libc::c_int,
) -> libc::c_int {
    let mut con: *mut connection = 0 as *mut connection;
    let mut srv_socket: *const server_socket = 0 as *const server_socket;
    let mut cnt_addr: sock_addr = sock_addr {
        ipv6: sockaddr_in6 {
            sin6_family: 0,
            sin6_port: 0,
            sin6_flowinfo: 0,
            sin6_addr: in6_addr {
                __in6_u: C2RustUnnamed_0 {
                    __u6_addr8: [0; 16],
                },
            },
            sin6_scope_id: 0,
        },
    };
    let ncat: *const libc::c_char =
        getenv(b"NCAT_LOCAL_ADDR\0" as *const u8 as *const libc::c_char);
    let ncat_local_addr: *const libc::c_char = if !ncat.is_null() {
        ncat
    } else {
        b"127.0.0.1\0" as *const u8 as *const libc::c_char
    };
    let ncat_local_port: *const libc::c_char = if !ncat.is_null() {
        getenv(b"NCAT_LOCAL_PORT\0" as *const u8 as *const libc::c_char) as *const libc::c_char
    } else {
        b"80\0" as *const u8 as *const libc::c_char
    };
    let ncat_remote_addr: *const libc::c_char = if !ncat.is_null() {
        getenv(b"NCAT_REMOTE_ADDR\0" as *const u8 as *const libc::c_char) as *const libc::c_char
    } else {
        b"127.0.0.1\0" as *const u8 as *const libc::c_char
    };
    let ncat_remote_port: *const libc::c_char = if !ncat.is_null() {
        getenv(b"NCAT_REMOTE_PORT\0" as *const u8 as *const libc::c_char) as *const libc::c_char
    } else {
        b"48080\0" as *const u8 as *const libc::c_char
    };
    if ncat_local_addr.is_null() || ncat_local_port.is_null() {
        return 0 as libc::c_int;
    }
    if ncat_remote_addr.is_null() || ncat_remote_port.is_null() {
        return 0 as libc::c_int;
    }
    let family: libc::c_int = if !ncat.is_null() && !(strchr(ncat_local_addr, ':' as i32)).is_null()
    {
        10 as libc::c_int
    } else {
        2 as libc::c_int
    };
    let mut port: libc::c_ushort = 0;
    port = strtol(
        ncat_local_port,
        0 as *mut *mut libc::c_char,
        10 as libc::c_int,
    ) as libc::c_ushort;
    if 1 as libc::c_int != sock_addr_inet_pton(&mut cnt_addr, ncat_local_addr, family, port) {
        log_error(
            (*srv).errh,
            b"/home/kkysen/work/rust/lighttpd/src/server.c\0" as *const u8 as *const libc::c_char,
            508 as libc::c_int as libc::c_uint,
            b"invalid local addr\0" as *const u8 as *const libc::c_char,
        );
        return 0 as libc::c_int;
    }
    srv_socket = server_oneshot_getsock(srv, &mut cnt_addr);
    if srv_socket.is_null() {
        return 0 as libc::c_int;
    }
    port = strtol(
        ncat_remote_port,
        0 as *mut *mut libc::c_char,
        10 as libc::c_int,
    ) as libc::c_ushort;
    if 1 as libc::c_int != sock_addr_inet_pton(&mut cnt_addr, ncat_remote_addr, family, port) {
        log_error(
            (*srv).errh,
            b"/home/kkysen/work/rust/lighttpd/src/server.c\0" as *const u8 as *const libc::c_char,
            517 as libc::c_int as libc::c_uint,
            b"invalid remote addr\0" as *const u8 as *const libc::c_char,
        );
        return 0 as libc::c_int;
    }
    if -(1 as libc::c_int) == fdevent_fcntl_set_nb_cloexec(fdin) {
        log_perror(
            (*srv).errh,
            b"/home/kkysen/work/rust/lighttpd/src/server.c\0" as *const u8 as *const libc::c_char,
            523 as libc::c_int as libc::c_uint,
            b"fcntl()\0" as *const u8 as *const libc::c_char,
        );
        return 0 as libc::c_int;
    }
    if -(1 as libc::c_int) == fdevent_fcntl_set_nb_cloexec(fdout) {
        log_perror(
            (*srv).errh,
            b"/home/kkysen/work/rust/lighttpd/src/server.c\0" as *const u8 as *const libc::c_char,
            527 as libc::c_int as libc::c_uint,
            b"fcntl()\0" as *const u8 as *const libc::c_char,
        );
        return 0 as libc::c_int;
    }
    con = connection_accepted(srv, srv_socket, &mut cnt_addr, fdout);
    if con.is_null() {
        return 0 as libc::c_int;
    }
    oneshot_read_cq = (*con).network_read;
    (*con).network_read = Some(
        server_oneshot_read_cq
            as unsafe extern "C" fn(*mut connection, *mut chunkqueue, off_t) -> libc::c_int,
    );
    oneshot_fdn = fdevent_register(
        (*srv).ev,
        fdin,
        Some(
            server_oneshot_handle_fdevent
                as unsafe extern "C" fn(*mut libc::c_void, libc::c_int) -> handler_t,
        ),
        con as *mut libc::c_void,
    );
    fdevent_fdnode_event_set((*srv).ev, oneshot_fdn, 0x2000 as libc::c_int);
    connection_state_machine(con);
    return 1 as libc::c_int;
}
unsafe extern "C" fn server_oneshot_handle_fdevent(
    mut context: *mut libc::c_void,
    mut revents: libc::c_int,
) -> handler_t {
    let mut con: *mut connection = context as *mut connection;
    let mut rdhup: libc::c_int = 0 as libc::c_int;
    let mut n: libc::c_int = if !oneshot_fdn.is_null() {
        (*oneshot_fdn).events
    } else {
        0 as libc::c_int
    };
    if revents & 0x1 as libc::c_int != 0 {
        n &= !(0x1 as libc::c_int);
    }
    let r: *mut request_st = &mut (*con).request;
    if (*r).state as libc::c_uint != CON_STATE_ERROR as libc::c_int as libc::c_uint
        && revents & (0x10 as libc::c_int | 0x2000 as libc::c_int) != 0
    {
        revents &= !(0x10 as libc::c_int | 0x2000 as libc::c_int);
        n &= !(0x1 as libc::c_int | 0x2000 as libc::c_int);
        rdhup = 1 as libc::c_int;
    }
    fdevent_fdnode_event_set((*(*con).srv).ev, oneshot_fdn, n);
    let fdn: *mut fdnode = (*con).fdn;
    let mut rc: handler_t = (if !fdn.is_null() && ((*fdn).handler).is_some() {
        (Some(((*fdn).handler).expect("non-null function pointer")))
            .expect("non-null function pointer")(con as *mut libc::c_void, revents)
            as libc::c_uint
    } else {
        HANDLER_FINISHED as libc::c_int as libc::c_uint
    }) as handler_t;
    if rdhup != 0 {
        (*r).conf.stream_request_body = ((*r).conf.stream_request_body as libc::c_int
            & !((1 as libc::c_int) << 1 as libc::c_int | (1 as libc::c_int) << 15 as libc::c_int))
            as libc::c_ushort;
        (*r).conf.stream_request_body = ((*r).conf.stream_request_body as libc::c_int
            | (1 as libc::c_int) << 12 as libc::c_int)
            as libc::c_ushort;
        (*r).conf.stream_request_body = ((*r).conf.stream_request_body as libc::c_int
            | (1 as libc::c_int) << 13 as libc::c_int)
            as libc::c_ushort;
        (*con).is_readable = 1 as libc::c_int as libc::c_schar;
        if chunkqueue_is_empty((*con).read_queue) != 0 {
            (*r).keep_alive = 0 as libc::c_int as int8_t;
        }
        if (*r).reqbody_length < -(1 as libc::c_int) as libc::c_long {
            (*r).reqbody_length = (*r).reqbody_queue.bytes_in;
        }
    }
    return rc;
}
unsafe extern "C" fn server_oneshot_read_cq(
    mut con: *mut connection,
    mut cq: *mut chunkqueue,
    mut max_bytes: off_t,
) -> libc::c_int {
    let mut fd: libc::c_int = (*con).fd;
    (*con).fd = (*oneshot_fdn).fd;
    let mut rc: libc::c_int =
        oneshot_read_cq.expect("non-null function pointer")(con, cq, max_bytes);
    (*con).fd = fd;
    let events: libc::c_int = if !oneshot_fdn.is_null() {
        (*oneshot_fdn).events
    } else {
        0 as libc::c_int
    };
    let mut n: libc::c_int = if (*con).is_readable as libc::c_int > 0 as libc::c_int {
        0 as libc::c_int
    } else {
        0x1 as libc::c_int
    };
    if events & 0x2000 as libc::c_int != 0 {
        n |= 0x2000 as libc::c_int;
    }
    fdevent_fdnode_event_set((*(*con).srv).ev, oneshot_fdn, n);
    return rc;
}
#[cold]
unsafe extern "C" fn server_oneshot_getsock(
    mut srv: *mut server,
    mut cnt_addr: *mut sock_addr,
) -> *mut server_socket {
    let mut srv_socket: *mut server_socket = 0 as *mut server_socket;
    let mut srv_socket_wild: *mut server_socket = 0 as *mut server_socket;
    let mut i: uint32_t = 0 as libc::c_int as uint32_t;
    while i < (*srv).srv_sockets.used {
        srv_socket = *((*srv).srv_sockets.ptr).offset(i as isize);
        if !(sock_addr_is_port_eq(&mut (*srv_socket).addr, cnt_addr) == 0) {
            if sock_addr_is_addr_eq(&mut (*srv_socket).addr, cnt_addr) != 0 {
                return srv_socket;
            }
            if srv_socket_wild.is_null() {
                if sock_addr_is_addr_wildcard(&mut (*srv_socket).addr) != 0 {
                    srv_socket_wild = srv_socket;
                }
            }
        }
        i = i.wrapping_add(1);
    }
    if !srv_socket_wild.is_null() {
        return srv_socket_wild;
    } else if (*srv).srv_sockets.used != 0 {
        return *((*srv).srv_sockets.ptr).offset(0 as libc::c_int as isize);
    } else {
        log_error(
            (*srv).errh,
            b"/home/kkysen/work/rust/lighttpd/src/server.c\0" as *const u8 as *const libc::c_char,
            410 as libc::c_int as libc::c_uint,
            b"no sockets configured\0" as *const u8 as *const libc::c_char,
        );
        return 0 as *mut server_socket;
    };
}
#[cold]
#[inline(never)]
unsafe extern "C" fn remove_pid_file(mut srv: *mut server) {
    if pid_fd <= -(2 as libc::c_int) {
        return;
    }
    if !((*srv).srvconf.pid_file).is_null() && 0 as libc::c_int <= pid_fd {
        if 0 as libc::c_int != ftruncate(pid_fd, 0 as libc::c_int as __off64_t) {
            log_perror(
                (*srv).errh,
                b"/home/kkysen/work/rust/lighttpd/src/server.c\0" as *const u8
                    as *const libc::c_char,
                372 as libc::c_int as libc::c_uint,
                b"ftruncate failed for: %s\0" as *const u8 as *const libc::c_char,
                (*(*srv).srvconf.pid_file).ptr,
            );
        }
    }
    if 0 as libc::c_int <= pid_fd {
        close(pid_fd);
        ::core::ptr::write_volatile(&mut pid_fd as *mut libc::c_int, -(1 as libc::c_int));
    }
    if !((*srv).srvconf.pid_file).is_null() && ((*srv).srvconf.changeroot).is_null() {
        if 0 as libc::c_int != unlink((*(*srv).srvconf.pid_file).ptr) {
            if *__errno_location() != 13 as libc::c_int && *__errno_location() != 1 as libc::c_int {
                log_perror(
                    (*srv).errh,
                    b"/home/kkysen/work/rust/lighttpd/src/server.c\0" as *const u8
                        as *const libc::c_char,
                    383 as libc::c_int as libc::c_uint,
                    b"unlink failed for: %s\0" as *const u8 as *const libc::c_char,
                    (*(*srv).srvconf.pid_file).ptr,
                );
            }
        }
    }
}
#[cold]
#[inline(never)]
unsafe extern "C" fn server_free(mut srv: *mut server) {
    if oneshot_fd > 0 as libc::c_int {
        if !oneshot_fdn.is_null() {
            fdevent_fdnode_event_del((*srv).ev, oneshot_fdn);
            fdevent_unregister((*srv).ev, oneshot_fd);
            oneshot_fdn = 0 as *mut fdnode;
        }
        close(oneshot_fd);
    }
    if oneshot_fdout >= 0 as libc::c_int {
        close(oneshot_fdout);
    }
    if (*srv).stdin_fd >= 0 as libc::c_int {
        close((*srv).stdin_fd);
    }
    buffer_free((*srv).tmp_buf);
    fdevent_free((*srv).ev);
    config_free(srv);
    stat_cache_free();
    li_rand_cleanup();
    chunkqueue_chunk_pool_free();
    if (*srv).errh != log_set_global_errh(0 as *mut log_error_st, 0 as libc::c_int) {
        fdlog_free((*srv).errh);
    }
    free(srv as *mut libc::c_void);
}
#[cold]
#[inline(never)]
unsafe extern "C" fn server_init() -> *mut server {
    let mut srv: *mut server = calloc(
        1 as libc::c_int as libc::c_ulong,
        ::core::mem::size_of::<server>() as libc::c_ulong,
    ) as *mut server;
    if srv.is_null() {
        ck_assert_failed(
            b"/home/kkysen/work/rust/lighttpd/src/server.c\0" as *const u8 as *const libc::c_char,
            285 as libc::c_int as libc::c_uint,
            b"srv\0" as *const u8 as *const libc::c_char,
        );
    }
    (*srv).tmp_buf = buffer_init();
    strftime_cache_reset();
    li_rand_reseed();
    log_epoch_secs = time(0 as *mut time_t);
    (*srv).startup_ts = log_epoch_secs;
    let mut ts: unix_timespec64_t = timespec {
        tv_sec: 0,
        tv_nsec: 0,
    };
    if 0 as libc::c_int == clock_gettime(6 as libc::c_int, &mut ts) {
        clockid_mono_coarse = 6 as libc::c_int;
    } else if 0 as libc::c_int == clock_gettime(4 as libc::c_int, &mut ts) {
        clockid_mono_coarse = 4 as libc::c_int;
    } else {
        clockid_mono_coarse = 1 as libc::c_int;
    }
    log_monotonic_secs = server_monotonic_secs();
    (*srv).errh = log_set_global_errh(0 as *mut log_error_st, 0 as libc::c_int);
    config_init(srv);
    (*srv).request_env =
        Some(plugins_call_handle_request_env as unsafe extern "C" fn(*mut request_st) -> handler_t);
    (*srv).loadavg[0 as libc::c_int as usize] = 0.0f64;
    (*srv).loadavg[1 as libc::c_int as usize] = 0.0f64;
    (*srv).loadavg[2 as libc::c_int as usize] = 0.0f64;
    (*srv).stdin_fd = -(1 as libc::c_int);
    log_con_jqueue = &mut log_con_jqueue as *mut *mut connection as uintptr_t as *mut connection;
    return srv;
}
#[inline]
unsafe extern "C" fn ck_memzero(mut s: *mut libc::c_void, mut n: rsize_t) -> errno_t {
    return ck_memclear_s(s, n, n);
}
#[inline]
unsafe extern "C" fn array_set_key_value(
    a: *mut array,
    k: *const libc::c_char,
    klen: uint32_t,
    v: *const libc::c_char,
    vlen: uint32_t,
) {
    buffer_copy_string_len(array_get_buf_ptr(a, k, klen), v, vlen as size_t);
}
unsafe extern "C" fn server_epoch_secs(
    srv: *mut server,
    mut mono_ts_delta: unix_time64_t,
) -> unix_time64_t {
    let cur_ts: unix_time64_t = log_epoch_secs;
    let new_ts: unix_time64_t = time(0 as *mut time_t);
    let new_ts_adj: unix_time64_t = new_ts - mono_ts_delta;
    if new_ts_adj < cur_ts || new_ts_adj - cur_ts > 300 as libc::c_int as libc::c_long {
        log_error(
            (*srv).errh,
            b"/home/kkysen/work/rust/lighttpd/src/server.c\0" as *const u8 as *const libc::c_char,
            263 as libc::c_int as libc::c_uint,
            b"warning: clock jumped %lld secs\0" as *const u8 as *const libc::c_char,
            (new_ts_adj - cur_ts) as libc::c_longlong,
        );
        let mut delta: libc::c_int = config_feature_int(
            srv,
            b"server.clock-jump-restart\0" as *const u8 as *const libc::c_char,
            1800 as libc::c_int,
        );
        if delta != 0
            && (if new_ts_adj > cur_ts {
                new_ts_adj - cur_ts
            } else {
                cur_ts - new_ts_adj
            }) > delta as libc::c_long
        {
            log_error(
                (*srv).errh,
                b"/home/kkysen/work/rust/lighttpd/src/server.c\0" as *const u8
                    as *const libc::c_char,
                271 as libc::c_int as libc::c_uint,
                b"attempting graceful restart in < ~5 seconds, else hard restart\0" as *const u8
                    as *const libc::c_char,
            );
            (*srv).graceful_expire_ts = log_monotonic_secs + 5 as libc::c_int as libc::c_long;
            raise(10 as libc::c_int);
        }
    }
    return new_ts;
}
unsafe extern "C" fn server_monotonic_secs() -> unix_time64_t {
    let mut ts: unix_timespec64_t = timespec {
        tv_sec: 0,
        tv_nsec: 0,
    };
    return if 0 as libc::c_int == clock_gettime(clockid_mono_coarse, &mut ts) {
        ts.tv_sec
    } else {
        log_monotonic_secs
    };
}
static mut clockid_mono_coarse: libc::c_int = 0 as libc::c_int;
unsafe extern "C" fn daemonize() -> libc::c_int {
    let mut pipefd: [libc::c_int; 2] = [0; 2];
    let mut pid: pid_t = 0;
    signal(
        22 as libc::c_int,
        ::core::mem::transmute::<libc::intptr_t, __sighandler_t>(
            1 as libc::c_int as libc::intptr_t,
        ),
    );
    signal(
        21 as libc::c_int,
        ::core::mem::transmute::<libc::intptr_t, __sighandler_t>(
            1 as libc::c_int as libc::intptr_t,
        ),
    );
    signal(
        20 as libc::c_int,
        ::core::mem::transmute::<libc::intptr_t, __sighandler_t>(
            1 as libc::c_int as libc::intptr_t,
        ),
    );
    if fdevent_pipe_cloexec(pipefd.as_mut_ptr(), 64 as libc::c_int as libc::c_uint)
        < 0 as libc::c_int
    {
        exit(-(1 as libc::c_int));
    }
    pid = fork();
    if 0 as libc::c_int > pid {
        exit(-(1 as libc::c_int));
    }
    if (0 as libc::c_int) < pid {
        let mut buf: libc::c_char = 0;
        let mut bytes: ssize_t = 0;
        close(pipefd[1 as libc::c_int as usize]);
        loop {
            bytes = read(
                pipefd[0 as libc::c_int as usize],
                &mut buf as *mut libc::c_char as *mut libc::c_void,
                ::core::mem::size_of::<libc::c_char>() as libc::c_ulong,
            );
            if !(bytes < 0 as libc::c_int as libc::c_long
                && 4 as libc::c_int == *__errno_location())
            {
                break;
            }
        }
        close(pipefd[0 as libc::c_int as usize]);
        if bytes <= 0 as libc::c_int as libc::c_long {
            fputs(
                b"daemonized server failed to start; check error log for details\n\0" as *const u8
                    as *const libc::c_char,
                stderr,
            );
            exit(-(1 as libc::c_int));
        }
        exit(0 as libc::c_int);
    }
    close(pipefd[0 as libc::c_int as usize]);
    if -(1 as libc::c_int) == setsid() {
        exit(0 as libc::c_int);
    }
    signal(
        1 as libc::c_int,
        ::core::mem::transmute::<libc::intptr_t, __sighandler_t>(
            1 as libc::c_int as libc::intptr_t,
        ),
    );
    if 0 as libc::c_int != fork() {
        exit(0 as libc::c_int);
    }
    if 0 as libc::c_int != chdir(b"/\0" as *const u8 as *const libc::c_char) {
        exit(0 as libc::c_int);
    }
    return pipefd[1 as libc::c_int as usize];
}
unsafe extern "C" fn sigaction_handler(
    mut sig: libc::c_int,
    mut si: *mut siginfo_t,
    mut context: *mut libc::c_void,
) {
    static mut empty_siginfo: siginfo_t = siginfo_t {
        si_signo: 0,
        si_errno: 0,
        si_code: 0,
        __pad0: 0,
        _sifields: C2RustUnnamed_34 { _pad: [0; 28] },
    };
    if si.is_null() {
        let ref mut fresh11 = *(&mut si as *mut *mut siginfo_t as *mut *const siginfo_t);
        *fresh11 = &empty_siginfo;
    }
    match sig {
        15 => {
            ::core::ptr::write_volatile(&mut srv_shutdown as *mut sig_atomic_t, 1 as libc::c_int);
            ::core::ptr::write_volatile(&mut last_sigterm_info as *mut siginfo_t, *si);
        }
        10 => {
            if graceful_shutdown == 0 {
                ::core::ptr::write_volatile(
                    &mut graceful_restart as *mut sig_atomic_t,
                    1 as libc::c_int,
                );
                ::core::ptr::write_volatile(
                    &mut graceful_shutdown as *mut sig_atomic_t,
                    1 as libc::c_int,
                );
                ::core::ptr::write_volatile(&mut last_sigterm_info as *mut siginfo_t, *si);
            }
        }
        2 => {
            if graceful_shutdown != 0 {
                if 2 as libc::c_int == graceful_restart {
                    ::core::ptr::write_volatile(
                        &mut graceful_restart as *mut sig_atomic_t,
                        1 as libc::c_int,
                    );
                } else {
                    ::core::ptr::write_volatile(
                        &mut srv_shutdown as *mut sig_atomic_t,
                        1 as libc::c_int,
                    );
                }
            } else {
                ::core::ptr::write_volatile(
                    &mut graceful_shutdown as *mut sig_atomic_t,
                    1 as libc::c_int,
                );
            }
            ::core::ptr::write_volatile(&mut last_sigterm_info as *mut siginfo_t, *si);
        }
        14 => {
            ::core::ptr::write_volatile(
                &mut handle_sig_alarm as *mut sig_atomic_t,
                1 as libc::c_int,
            );
        }
        1 => {
            ::core::ptr::write_volatile(&mut handle_sig_hup as *mut sig_atomic_t, 1 as libc::c_int);
            ::core::ptr::write_volatile(&mut last_sighup_info as *mut siginfo_t, *si);
        }
        17 => {
            ::core::ptr::write_volatile(
                &mut handle_sig_child as *mut sig_atomic_t,
                1 as libc::c_int,
            );
        }
        _ => {}
    };
}
static mut last_sighup_info: siginfo_t = siginfo_t {
    si_signo: 0,
    si_errno: 0,
    si_code: 0,
    __pad0: 0,
    _sifields: C2RustUnnamed_34 { _pad: [0; 28] },
};
static mut last_sigterm_info: siginfo_t = siginfo_t {
    si_signo: 0,
    si_errno: 0,
    si_code: 0,
    __pad0: 0,
    _sifields: C2RustUnnamed_34 { _pad: [0; 28] },
};
static mut idle_limit: libc::c_int = 0 as libc::c_int;
static mut handle_sig_hup: sig_atomic_t = 0 as libc::c_int;
static mut handle_sig_alarm: sig_atomic_t = 1 as libc::c_int;
static mut handle_sig_child: sig_atomic_t = 0 as libc::c_int;
static mut srv_shutdown: sig_atomic_t = 0 as libc::c_int;
static mut graceful_shutdown: sig_atomic_t = 0 as libc::c_int;
static mut graceful_restart: sig_atomic_t = 0 as libc::c_int;
static mut inherited_sockets: server_socket_array = server_socket_array {
    ptr: 0 as *const *mut server_socket as *mut *mut server_socket,
    size: 0,
    used: 0,
};
static mut graceful_sockets: server_socket_array = server_socket_array {
    ptr: 0 as *const *mut server_socket as *mut *mut server_socket,
    size: 0,
    used: 0,
};
static mut pid_fd: libc::c_int = -(2 as libc::c_int);
static mut oneshot_read_cq: Option<
    unsafe extern "C" fn(*mut connection, *mut chunkqueue, off_t) -> libc::c_int,
> = None;
static mut oneshot_fdn: *mut fdnode = 0 as *const fdnode as *mut fdnode;
static mut oneshot_fdout: libc::c_int = -(1 as libc::c_int);
static mut oneshot_fd: libc::c_int = 0 as libc::c_int;
static mut malloc_top_pad: size_t = 0;
static mut malloc_trim_fn: Option<unsafe extern "C" fn(size_t) -> libc::c_int> = None;
#[inline]
unsafe extern "C" fn chunkqueue_length(mut cq: *const chunkqueue) -> off_t {
    return (*cq).bytes_in - (*cq).bytes_out;
}
#[inline]
unsafe extern "C" fn chunkqueue_is_empty(mut cq: *const chunkqueue) -> libc::c_int {
    return (0 as *mut libc::c_void as *mut chunk == (*cq).first) as libc::c_int;
}
#[inline]
unsafe extern "C" fn sock_addr_get_family(mut saddr: *const sock_addr) -> libc::c_int {
    return (*saddr).plain.sa_family as libc::c_int;
}
#[inline]
unsafe extern "C" fn connection_jq_append(con: *mut connection) {
    if ((*con).jqnext).is_null() {
        (*con).jqnext = log_con_jqueue;
        log_con_jqueue = con;
    }
}
#[inline]
unsafe extern "C" fn lsxpack_header_get_name(
    mut hdr: *const lsxpack_header_t,
) -> *const libc::c_char {
    return if (*hdr).name_len as libc::c_int != 0 {
        ((*hdr).buf).offset((*hdr).name_offset as libc::c_int as isize)
    } else {
        0 as *mut libc::c_char
    };
}
#[inline]
unsafe extern "C" fn lsxpack_header_get_value(
    mut hdr: *const lsxpack_header_t,
) -> *const libc::c_char {
    return ((*hdr).buf).offset((*hdr).val_offset as libc::c_int as isize);
}
static mut default_server_tag: buffer = buffer {
    ptr: 0 as *const libc::c_char as *mut libc::c_char,
    used: 0,
    size: 0,
};
#[inline]
unsafe extern "C" fn buffer_truncate(mut b: *mut buffer, mut len: uint32_t) {
    *((*b).ptr).offset(len as isize) = '\0' as i32 as libc::c_char;
    (*b).used = len.wrapping_add(1 as libc::c_int as libc::c_uint);
}
#[inline]
unsafe extern "C" fn buffer_append_buffer(mut b: *mut buffer, mut src: *const buffer) {
    buffer_append_string_len(b, (*src).ptr, buffer_clen(src) as size_t);
}
#[inline]
unsafe extern "C" fn buffer_copy_buffer(mut b: *mut buffer, mut src: *const buffer) {
    buffer_copy_string_len(b, (*src).ptr, buffer_clen(src) as size_t);
}
#[inline]
unsafe extern "C" fn buffer_string_space(mut b: *const buffer) -> uint32_t {
    return if (*b).size != 0 {
        ((*b).size).wrapping_sub(
            (*b).used
                | (0 as libc::c_int as libc::c_uint == (*b).used) as libc::c_int as libc::c_uint,
        )
    } else {
        0 as libc::c_int as libc::c_uint
    };
}
#[inline]
unsafe extern "C" fn buffer_is_unset(mut b: *const buffer) -> libc::c_int {
    return (0 as libc::c_int as libc::c_uint == (*b).used) as libc::c_int;
}
#[inline]
unsafe extern "C" fn light_isalnum(mut c: libc::c_int) -> libc::c_int {
    return (light_isdigit(c) != 0 || light_isalpha(c) != 0) as libc::c_int;
}
#[inline]
unsafe extern "C" fn light_isalpha(mut c: libc::c_int) -> libc::c_int {
    return ((c as uint32_t | 0x20 as libc::c_int as libc::c_uint)
        .wrapping_sub('a' as i32 as libc::c_uint)
        <= ('z' as i32 - 'a' as i32) as libc::c_uint) as libc::c_int;
}
#[inline]
unsafe extern "C" fn light_isxdigit(mut c: libc::c_int) -> libc::c_int {
    return (light_isdigit(c) != 0
        || (c as uint32_t | 0x20 as libc::c_int as libc::c_uint)
            .wrapping_sub('a' as i32 as libc::c_uint)
            <= ('f' as i32 - 'a' as i32) as libc::c_uint) as libc::c_int;
}
#[inline]
unsafe extern "C" fn light_isdigit(mut c: libc::c_int) -> libc::c_int {
    return ((c as uint32_t).wrapping_sub('0' as i32 as libc::c_uint)
        <= ('9' as i32 - '0' as i32) as libc::c_uint) as libc::c_int;
}
#[inline]
unsafe extern "C" fn buffer_is_blank(mut b: *const buffer) -> libc::c_int {
    return ((*b).used < 2 as libc::c_int as libc::c_uint) as libc::c_int;
}
#[inline]
unsafe extern "C" fn buffer_clen(mut b: *const buffer) -> uint32_t {
    return ((*b).used).wrapping_sub(
        (0 as libc::c_int as libc::c_uint != (*b).used) as libc::c_int as libc::c_uint,
    );
}
#[inline]
unsafe extern "C" fn buffer_clear(mut b: *mut buffer) {
    (*b).used = 0 as libc::c_int as uint32_t;
}
#[inline]
unsafe extern "C" fn buffer_blank(mut b: *mut buffer) {
    if !((*b).ptr).is_null() {
        buffer_truncate(b, 0 as libc::c_int as uint32_t);
    } else {
        buffer_extend(b, 0 as libc::c_int as size_t);
    };
}
#[inline]
unsafe extern "C" fn buffer_append_slash(mut b: *mut buffer) {
    let len: uint32_t = buffer_clen(b);
    if len > 0 as libc::c_int as libc::c_uint
        && '/' as i32
            != *((*b).ptr).offset(len.wrapping_sub(1 as libc::c_int as libc::c_uint) as isize)
                as libc::c_int
    {
        buffer_append_string_len(
            b,
            b"/\0" as *const u8 as *const libc::c_char,
            (::core::mem::size_of::<[libc::c_char; 2]>() as libc::c_ulong as uint32_t)
                .wrapping_sub(1 as libc::c_int as libc::c_uint) as size_t,
        );
    }
}
#[inline]
unsafe extern "C" fn buffer_has_slash_suffix(b: *const buffer) -> libc::c_int {
    return ((*b).used > 1 as libc::c_int as libc::c_uint
        && *((*b).ptr).offset(((*b).used).wrapping_sub(2 as libc::c_int as libc::c_uint) as isize)
            as libc::c_int
            == '/' as i32) as libc::c_int;
}
#[inline]
unsafe extern "C" fn buffer_has_pathsep_suffix(b: *const buffer) -> libc::c_int {
    return ((*b).used > 1 as libc::c_int as libc::c_uint
        && *((*b).ptr).offset(((*b).used).wrapping_sub(2 as libc::c_int as libc::c_uint) as isize)
            as libc::c_int
            == '/' as i32) as libc::c_int;
}
#[inline]
unsafe extern "C" fn buffer_reset(mut b: *mut buffer) {
    (*b).used = 0 as libc::c_int as uint32_t;
    if (*b).size > 4096 as libc::c_int as libc::c_uint {
        buffer_free_ptr(b);
    }
}
#[no_mangle]
#[cold]
pub unsafe extern "C" fn http_response_omit_header(
    r: *mut request_st,
    ds: *const data_string,
) -> libc::c_int {
    let klen: size_t = buffer_clen(&(*ds).key) as size_t;
    if klen
        == (::core::mem::size_of::<[libc::c_char; 11]>() as libc::c_ulong)
            .wrapping_sub(1 as libc::c_int as libc::c_ulong)
        && buffer_eq_icase_ssn(
            (*ds).key.ptr,
            b"X-Sendfile\0" as *const u8 as *const libc::c_char,
            (::core::mem::size_of::<[libc::c_char; 11]>() as libc::c_ulong as uint32_t)
                .wrapping_sub(1 as libc::c_int as libc::c_uint) as size_t,
        ) != 0
    {
        return 1 as libc::c_int;
    }
    if klen
        >= (::core::mem::size_of::<[libc::c_char; 12]>() as libc::c_ulong)
            .wrapping_sub(1 as libc::c_int as libc::c_ulong)
        && buffer_eq_icase_ssn(
            (*ds).key.ptr,
            b"X-LIGHTTPD-\0" as *const u8 as *const libc::c_char,
            (::core::mem::size_of::<[libc::c_char; 12]>() as libc::c_ulong as uint32_t)
                .wrapping_sub(1 as libc::c_int as libc::c_uint) as size_t,
        ) != 0
    {
        if klen
            == (::core::mem::size_of::<[libc::c_char; 29]>() as libc::c_ulong)
                .wrapping_sub(1 as libc::c_int as libc::c_ulong)
            && buffer_eq_icase_ssn(
                ((*ds).key.ptr)
                    .offset(::core::mem::size_of::<[libc::c_char; 12]>() as libc::c_ulong as isize)
                    .offset(-(1 as libc::c_int as isize)),
                b"KBytes-per-second\0" as *const u8 as *const libc::c_char,
                (::core::mem::size_of::<[libc::c_char; 18]>() as libc::c_ulong as uint32_t)
                    .wrapping_sub(1 as libc::c_int as libc::c_uint) as size_t,
            ) != 0
        {
            let mut limit: off_t = strtol(
                (*ds).value.ptr,
                0 as *mut *mut libc::c_char,
                10 as libc::c_int,
            ) << 10 as libc::c_int;
            if limit > 0 as libc::c_int as libc::c_long
                && (limit < (*r).conf.bytes_per_second as libc::c_long
                    || 0 as libc::c_int as libc::c_uint == (*r).conf.bytes_per_second)
            {
                (*r).conf.bytes_per_second = limit as libc::c_uint;
            }
        }
        return 1 as libc::c_int;
    }
    return 0 as libc::c_int;
}
#[cold]
unsafe extern "C" fn http_response_write_header_partial_1xx(r: *mut request_st, b: *mut buffer) {
    let con: *mut connection = (*r).con;
    let cq: *mut chunkqueue = (*con).write_queue;
    (*con).write_queue = &mut (*r).write_queue;
    let mut len: uint32_t = chunkqueue_length(cq) as uint32_t;
    if chunkqueue_read_data(
        cq,
        buffer_string_prepare_append(b, len as size_t),
        len,
        (*r).conf.errh,
    ) < 0 as libc::c_int
    {
        len = 0 as libc::c_int as uint32_t;
    }
    buffer_truncate(b, len);
    chunkqueue_free(cq);
}
#[no_mangle]
pub unsafe extern "C" fn http_response_write_header(r: *mut request_st) {
    (*(*r).con).keep_alive_idle = (*r).conf.max_keep_alive_idle as libc::c_int;
    if (0 as libc::c_int == (*r).conf.max_keep_alive_idle as libc::c_int) as libc::c_int
        as libc::c_long
        != 0
        || (*(*r).con).request_count > (*r).conf.max_keep_alive_requests as libc::c_uint
    {
        (*r).keep_alive = 0 as libc::c_int as int8_t;
    } else if 0 as libc::c_int as libc::c_long != (*r).reqbody_length
        && (*r).reqbody_length != (*r).reqbody_queue.bytes_in
        && (((*r).handler_module).is_null()
            || 0 as libc::c_int
                == (*r).conf.stream_request_body as libc::c_int
                    & ((1 as libc::c_int) << 0 as libc::c_int
                        | (1 as libc::c_int) << 1 as libc::c_int))
    {
        (*r).keep_alive = 0 as libc::c_int as int8_t;
    }
    if (*r).resp_htags & (1 as libc::c_ulong) << HTTP_HEADER_UPGRADE as libc::c_int != 0
        && (*r).http_version as libc::c_int == HTTP_VERSION_1_1 as libc::c_int
    {
        http_header_response_set(
            r,
            HTTP_HEADER_CONNECTION,
            b"Connection\0" as *const u8 as *const libc::c_char,
            (::core::mem::size_of::<[libc::c_char; 11]>() as libc::c_ulong as uint32_t)
                .wrapping_sub(1 as libc::c_int as libc::c_uint),
            b"upgrade\0" as *const u8 as *const libc::c_char,
            (::core::mem::size_of::<[libc::c_char; 8]>() as libc::c_ulong as uint32_t)
                .wrapping_sub(1 as libc::c_int as libc::c_uint),
        );
    } else if (*r).keep_alive as libc::c_int <= 0 as libc::c_int {
        http_header_response_set(
            r,
            HTTP_HEADER_CONNECTION,
            b"Connection\0" as *const u8 as *const libc::c_char,
            (::core::mem::size_of::<[libc::c_char; 11]>() as libc::c_ulong as uint32_t)
                .wrapping_sub(1 as libc::c_int as libc::c_uint),
            b"close\0" as *const u8 as *const libc::c_char,
            (::core::mem::size_of::<[libc::c_char; 6]>() as libc::c_ulong as uint32_t)
                .wrapping_sub(1 as libc::c_int as libc::c_uint),
        );
    } else if (*r).http_version as libc::c_int == HTTP_VERSION_1_0 as libc::c_int {
        http_header_response_set(
            r,
            HTTP_HEADER_CONNECTION,
            b"Connection\0" as *const u8 as *const libc::c_char,
            (::core::mem::size_of::<[libc::c_char; 11]>() as libc::c_ulong as uint32_t)
                .wrapping_sub(1 as libc::c_int as libc::c_uint),
            b"keep-alive\0" as *const u8 as *const libc::c_char,
            (::core::mem::size_of::<[libc::c_char; 11]>() as libc::c_ulong as uint32_t)
                .wrapping_sub(1 as libc::c_int as libc::c_uint),
        );
    }
    if 304 as libc::c_int == (*r).http_status
        && (*r).resp_htags & (1 as libc::c_ulong) << HTTP_HEADER_CONTENT_ENCODING as libc::c_int
            != 0
    {
        http_header_response_unset(
            r,
            HTTP_HEADER_CONTENT_ENCODING,
            b"Content-Encoding\0" as *const u8 as *const libc::c_char,
            (::core::mem::size_of::<[libc::c_char; 17]>() as libc::c_ulong as uint32_t)
                .wrapping_sub(1 as libc::c_int as libc::c_uint),
        );
    }
    let cq: *mut chunkqueue = &mut (*r).write_queue;
    let b: *mut buffer = chunkqueue_prepend_buffer_open(cq);
    if cq != (*(*r).con).write_queue {
        http_response_write_header_partial_1xx(r, b);
    }
    buffer_append_string_len(
        b,
        if (*r).http_version as libc::c_int == HTTP_VERSION_1_1 as libc::c_int {
            b"HTTP/1.1 \0" as *const u8 as *const libc::c_char
        } else {
            b"HTTP/1.0 \0" as *const u8 as *const libc::c_char
        },
        (::core::mem::size_of::<[libc::c_char; 10]>() as libc::c_ulong)
            .wrapping_sub(1 as libc::c_int as libc::c_ulong),
    );
    http_status_append(b, (*r).http_status);
    let mut i: size_t = 0 as libc::c_int as size_t;
    let mut used: size_t = (*r).resp_headers.used as size_t;
    while i < used {
        let ds: *const data_string =
            *((*r).resp_headers.data).offset(i as isize) as *mut data_string;
        let klen: uint32_t = buffer_clen(&(*ds).key);
        let vlen: uint32_t = buffer_clen(&(*ds).value);
        if !((0 as libc::c_int as libc::c_uint == klen) as libc::c_int as libc::c_long != 0) {
            if !((0 as libc::c_int as libc::c_uint == vlen) as libc::c_int as libc::c_long != 0) {
                if !(*((*ds).key.ptr).offset(0 as libc::c_int as isize) as libc::c_int
                    & 0xdf as libc::c_int
                    == 'X' as i32
                    && http_response_omit_header(r, ds) != 0)
                {
                    let mut s: *mut libc::c_char = buffer_extend(
                        b,
                        klen.wrapping_add(vlen)
                            .wrapping_add(4 as libc::c_int as libc::c_uint)
                            as size_t,
                    );
                    *s.offset(0 as libc::c_int as isize) = '\r' as i32 as libc::c_char;
                    *s.offset(1 as libc::c_int as isize) = '\n' as i32 as libc::c_char;
                    memcpy(
                        s.offset(2 as libc::c_int as isize) as *mut libc::c_void,
                        (*ds).key.ptr as *const libc::c_void,
                        klen as libc::c_ulong,
                    );
                    s = s.offset((2 as libc::c_int as libc::c_uint).wrapping_add(klen) as isize);
                    *s.offset(0 as libc::c_int as isize) = ':' as i32 as libc::c_char;
                    *s.offset(1 as libc::c_int as isize) = ' ' as i32 as libc::c_char;
                    memcpy(
                        s.offset(2 as libc::c_int as isize) as *mut libc::c_void,
                        (*ds).value.ptr as *const libc::c_void,
                        vlen as libc::c_ulong,
                    );
                }
            }
        }
        i = i.wrapping_add(1);
    }
    if (*r).resp_htags & (1 as libc::c_ulong) << HTTP_HEADER_DATE as libc::c_int == 0 {
        static mut tlast: unix_time64_t = 0 as libc::c_int as unix_time64_t;
        static mut tstr: [libc::c_char; 40] = unsafe {
            *::core::mem::transmute::<&[u8; 40], &mut [libc::c_char; 40]>(
                b"\r\nDate: \0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0",
            )
        };
        let cur_ts: unix_time64_t = log_epoch_secs;
        if (tlast != cur_ts) as libc::c_int as libc::c_long != 0 {
            tlast = cur_ts;
            http_date_time_to_str(
                tstr.as_mut_ptr().offset(8 as libc::c_int as isize),
                (::core::mem::size_of::<[libc::c_char; 40]>() as libc::c_ulong)
                    .wrapping_sub(8 as libc::c_int as libc::c_ulong),
                tlast,
            );
        }
        buffer_append_string_len(b, tstr.as_mut_ptr(), 37 as libc::c_int as size_t);
    }
    if (*r).resp_htags & (1 as libc::c_ulong) << HTTP_HEADER_SERVER as libc::c_int == 0
        && !((*r).conf.server_tag).is_null()
    {
        buffer_append_str2(
            b,
            b"\r\nServer: \0" as *const u8 as *const libc::c_char,
            (::core::mem::size_of::<[libc::c_char; 11]>() as libc::c_ulong as uint32_t)
                .wrapping_sub(1 as libc::c_int as libc::c_uint) as size_t,
            (*(*r).conf.server_tag).ptr,
            buffer_clen((*r).conf.server_tag) as size_t,
        );
    }
    buffer_append_string_len(
        b,
        b"\r\n\r\n\0" as *const u8 as *const libc::c_char,
        (::core::mem::size_of::<[libc::c_char; 5]>() as libc::c_ulong as uint32_t)
            .wrapping_sub(1 as libc::c_int as libc::c_uint) as size_t,
    );
    (*r).resp_header_len = buffer_clen(b);
    if (*r).conf.log_response_header != 0 {
        log_error_multiline(
            (*r).conf.errh,
            b"/home/kkysen/work/rust/lighttpd/src/response.c\0" as *const u8 as *const libc::c_char,
            164 as libc::c_int as libc::c_uint,
            (*b).ptr,
            buffer_clen(b) as size_t,
            b"fd:%d resp: \0" as *const u8 as *const libc::c_char,
            (*(*r).con).fd,
        );
    }
    chunkqueue_prepend_buffer_commit(cq);
    let mut cqlen: off_t = 0;
    if (*r).resp_body_finished as libc::c_int != 0
        && (*r).resp_htags & (1 as libc::c_ulong) << HTTP_HEADER_CONTENT_LENGTH as libc::c_int != 0
        && {
            cqlen = chunkqueue_length(cq) - (*r).resp_header_len as libc::c_long;
            cqlen > 0 as libc::c_int as libc::c_long
        }
        && cqlen < 16384 as libc::c_int as libc::c_long
    {
        chunkqueue_small_resp_optim(cq);
    }
}
#[cold]
unsafe extern "C" fn http_response_physical_path_error(
    r: *mut request_st,
    code: libc::c_int,
    msg: *const libc::c_char,
) -> handler_t {
    (*r).http_status = code;
    if code == 404 as libc::c_int && (*r).conf.log_file_not_found as libc::c_int != 0
        || (*r).conf.log_request_handling as libc::c_int != 0
    {
        if msg.is_null() {
            log_perror(
                (*r).conf.errh,
                b"/home/kkysen/work/rust/lighttpd/src/response.c\0" as *const u8
                    as *const libc::c_char,
                188 as libc::c_int as libc::c_uint,
                b"-- \0" as *const u8 as *const libc::c_char,
            );
        } else {
            log_error(
                (*r).conf.errh,
                b"/home/kkysen/work/rust/lighttpd/src/response.c\0" as *const u8
                    as *const libc::c_char,
                190 as libc::c_int as libc::c_uint,
                b"%s\0" as *const u8 as *const libc::c_char,
                msg,
            );
        }
        log_error(
            (*r).conf.errh,
            b"/home/kkysen/work/rust/lighttpd/src/response.c\0" as *const u8 as *const libc::c_char,
            191 as libc::c_int as libc::c_uint,
            b"Path         : %s\0" as *const u8 as *const libc::c_char,
            (*r).physical.path.ptr,
        );
        log_error(
            (*r).conf.errh,
            b"/home/kkysen/work/rust/lighttpd/src/response.c\0" as *const u8 as *const libc::c_char,
            193 as libc::c_int as libc::c_uint,
            b"URI          : %s\0" as *const u8 as *const libc::c_char,
            (*r).uri.path.ptr,
        );
    }
    return HANDLER_FINISHED;
}
unsafe extern "C" fn http_response_physical_path_check(r: *mut request_st) -> handler_t {
    let mut sce: *mut stat_cache_entry = stat_cache_get_entry(&mut (*r).physical.path);
    if !((sce != 0 as *mut libc::c_void as *mut stat_cache_entry) as libc::c_int as libc::c_long
        != 0)
    {
        match *__errno_location() {
            20 => {}
            13 => {
                return http_response_physical_path_error(
                    r,
                    403 as libc::c_int,
                    0 as *const libc::c_char,
                );
            }
            36 | 2 => {
                if (*r).http_method as libc::c_int == HTTP_METHOD_OPTIONS as libc::c_int
                    && (*r).resp_htags & (1 as libc::c_ulong) << HTTP_HEADER_ALLOW as libc::c_int
                        != 0
                {
                    (*r).http_status = 200 as libc::c_int;
                    return HANDLER_FINISHED;
                }
                return http_response_physical_path_error(
                    r,
                    404 as libc::c_int,
                    0 as *const libc::c_char,
                );
            }
            _ => {
                return http_response_physical_path_error(
                    r,
                    500 as libc::c_int,
                    0 as *const libc::c_char,
                );
            }
        }
        let mut pathinfo: *mut libc::c_char = 0 as *mut libc::c_char;
        let mut len: size_t = (buffer_clen(&mut (*r).physical.basedir))
            .wrapping_sub(buffer_has_pathsep_suffix(&mut (*r).physical.basedir) as libc::c_uint)
            as size_t;
        pathinfo = ((*r).physical.path.ptr).offset(len as isize);
        if '/' as i32 != *pathinfo as libc::c_int {
            pathinfo = 0 as *mut libc::c_char;
        } else if pathinfo == (*r).physical.path.ptr {
            pathinfo = strchr(pathinfo.offset(1 as libc::c_int as isize), '/' as i32);
        }
        let pathused: uint32_t = (*r).physical.path.used;
        let mut pprev: *mut libc::c_char = pathinfo;
        while !pathinfo.is_null() {
            (*r).physical.path.used = (pathinfo.offset_from((*r).physical.path.ptr) as libc::c_long
                + 1 as libc::c_int as libc::c_long)
                as uint32_t;
            *pathinfo = '\0' as i32 as libc::c_char;
            let nsce: *mut stat_cache_entry = stat_cache_get_entry(&mut (*r).physical.path);
            *pathinfo = '/' as i32 as libc::c_char;
            (*r).physical.path.used = pathused;
            if nsce.is_null() {
                pathinfo = if pathinfo != pprev {
                    pprev
                } else {
                    0 as *mut libc::c_char
                };
                break;
            } else {
                sce = nsce;
                if !((*sce).st.st_mode & 0o170000 as libc::c_int as libc::c_uint
                    == 0o40000 as libc::c_int as libc::c_uint)
                {
                    break;
                }
                pprev = pathinfo;
                pathinfo = strchr(pathinfo.offset(1 as libc::c_int as isize), '/' as i32);
            }
        }
        if pathinfo.is_null()
            || !((*sce).st.st_mode & 0o170000 as libc::c_int as libc::c_uint
                == 0o100000 as libc::c_int as libc::c_uint)
        {
            return http_response_physical_path_error(
                r,
                404 as libc::c_int,
                b"-- file not found\0" as *const u8 as *const libc::c_char,
            );
        }
        if !pathinfo.is_null() {
            let mut len_0: size_t = ((*r).physical.path.ptr)
                .offset(pathused as isize)
                .offset(-(1 as libc::c_int as isize))
                .offset_from(pathinfo) as libc::c_long
                as size_t;
            let mut reqlen: size_t = 0;
            if (*r).conf.force_lowercase_filenames as libc::c_int != 0
                && {
                    reqlen = buffer_clen(&mut (*r).target) as size_t;
                    len_0 <= reqlen
                }
                && buffer_eq_icase_ssn(
                    ((*r).target.ptr)
                        .offset(reqlen as isize)
                        .offset(-(len_0 as isize)),
                    pathinfo,
                    len_0,
                ) != 0
            {
                buffer_copy_string_len(
                    &mut (*r).pathinfo,
                    ((*r).target.ptr)
                        .offset(reqlen as isize)
                        .offset(-(len_0 as isize)),
                    len_0,
                );
            } else {
                buffer_copy_string_len(&mut (*r).pathinfo, pathinfo, len_0);
            }
            buffer_truncate(
                &mut (*r).uri.path,
                (buffer_clen(&mut (*r).uri.path) as libc::c_ulong).wrapping_sub(len_0) as uint32_t,
            );
            buffer_truncate(
                &mut (*r).physical.path,
                pathinfo.offset_from((*r).physical.path.ptr) as libc::c_long as size_t as uint32_t,
            );
        }
    }
    if (*r).conf.follow_symlink == 0
        && 0 as libc::c_int
            != stat_cache_path_contains_symlink(&mut (*r).physical.path, (*r).conf.errh)
    {
        return http_response_physical_path_error(
            r,
            403 as libc::c_int,
            b"-- access denied due to symlink restriction\0" as *const u8 as *const libc::c_char,
        );
    }
    (*r).tmp_sce = sce;
    if (*sce).st.st_mode & 0o170000 as libc::c_int as libc::c_uint
        == 0o100000 as libc::c_int as libc::c_uint
    {
        return HANDLER_GO_ON;
    }
    if (*sce).st.st_mode & 0o170000 as libc::c_int as libc::c_uint
        == 0o40000 as libc::c_int as libc::c_uint
    {
        if buffer_has_slash_suffix(&mut (*r).uri.path) == 0 {
            http_response_redirect_to_directory(r, 301 as libc::c_int);
            return HANDLER_FINISHED;
        }
    }
    return HANDLER_GO_ON;
}
#[cold]
#[inline(never)]
unsafe extern "C" fn http_status_set_error_close(
    r: *mut request_st,
    mut status: libc::c_int,
) -> handler_t {
    (*r).keep_alive = 0 as libc::c_int as int8_t;
    (*r).resp_body_finished = 1 as libc::c_int as libc::c_char;
    (*r).handler_module = 0 as *const plugin;
    (*r).http_status = status;
    return HANDLER_FINISHED;
}
#[cold]
unsafe extern "C" fn http_response_prepare_options_star(r: *mut request_st) -> handler_t {
    (*r).http_status = 200 as libc::c_int;
    (*r).resp_body_finished = 1 as libc::c_int as libc::c_char;
    http_header_response_append(
        r,
        HTTP_HEADER_ALLOW,
        b"Allow\0" as *const u8 as *const libc::c_char,
        (::core::mem::size_of::<[libc::c_char; 6]>() as libc::c_ulong as uint32_t)
            .wrapping_sub(1 as libc::c_int as libc::c_uint),
        b"OPTIONS, GET, HEAD, POST\0" as *const u8 as *const libc::c_char,
        (::core::mem::size_of::<[libc::c_char; 25]>() as libc::c_ulong as uint32_t)
            .wrapping_sub(1 as libc::c_int as libc::c_uint),
    );
    return HANDLER_FINISHED;
}
#[cold]
unsafe extern "C" fn http_response_prepare_connect(r: *mut request_st) -> handler_t {
    return (if !((*r).handler_module).is_null() {
        HANDLER_GO_ON as libc::c_int as libc::c_uint
    } else {
        http_status_set_error_close(r, 405 as libc::c_int) as libc::c_uint
    }) as handler_t;
}
unsafe extern "C" fn http_response_config(r: *mut request_st) -> handler_t {
    config_cond_cache_reset(r);
    config_patch_config(r);
    (*r).server_name = if !((*r).conf.server_name).is_null() {
        (*r).conf.server_name
    } else {
        &mut (*r).uri.authority as *mut buffer as *const buffer
    };
    if ((*r).conf.allow_http11 == 0) as libc::c_int as libc::c_long != 0
        && (*r).http_version as libc::c_int == HTTP_VERSION_1_1 as libc::c_int
    {
        (*r).http_version = HTTP_VERSION_1_0;
    }
    if ((*r).reqbody_length > 0 as libc::c_int as libc::c_long) as libc::c_int as libc::c_long != 0
        && 0 as libc::c_int as libc::c_uint != (*r).conf.max_request_size
        && (*r).reqbody_length > ((*r).conf.max_request_size as off_t) << 10 as libc::c_int
    {
        log_error(
            (*r).conf.errh,
            b"/home/kkysen/work/rust/lighttpd/src/response.c\0" as *const u8 as *const libc::c_char,
            359 as libc::c_int as libc::c_uint,
            b"request-size too long: %lld -> 413\0" as *const u8 as *const libc::c_char,
            (*r).reqbody_length as libc::c_longlong,
        );
        return http_status_set_error_close(r, 413 as libc::c_int);
    }
    return HANDLER_GO_ON;
}
#[inline(never)]
unsafe extern "C" fn http_response_prepare(r: *mut request_st) -> handler_t {
    let mut rc: handler_t = HANDLER_GO_ON;
    if ((*r).http_status > 200 as libc::c_int) as libc::c_int as libc::c_long != 0 {
        if 0 as libc::c_int == (*r).resp_body_finished as libc::c_int {
            http_response_body_clear(r, 0 as libc::c_int);
        }
        return HANDLER_FINISHED;
    }
    if buffer_is_unset(&mut (*r).physical.path) != 0 {
        if ((*r).async_callback == 0) as libc::c_int as libc::c_long != 0 {
            rc = http_response_config(r);
            if HANDLER_GO_ON as libc::c_int as libc::c_uint != rc as libc::c_uint {
                return rc;
            }
        } else {
            (*r).async_callback = 0 as libc::c_int as libc::c_char;
        }
        if (*r).conf.log_request_handling != 0 {
            log_error(
                (*r).conf.errh,
                b"/home/kkysen/work/rust/lighttpd/src/response.c\0" as *const u8
                    as *const libc::c_char,
                402 as libc::c_int as libc::c_uint,
                b"-- parsed Request-URI\0" as *const u8 as *const libc::c_char,
            );
            log_error(
                (*r).conf.errh,
                b"/home/kkysen/work/rust/lighttpd/src/response.c\0" as *const u8
                    as *const libc::c_char,
                404 as libc::c_int as libc::c_uint,
                b"Request-URI     : %s\0" as *const u8 as *const libc::c_char,
                (*r).target.ptr,
            );
            log_error(
                (*r).conf.errh,
                b"/home/kkysen/work/rust/lighttpd/src/response.c\0" as *const u8
                    as *const libc::c_char,
                406 as libc::c_int as libc::c_uint,
                b"URI-scheme      : %s\0" as *const u8 as *const libc::c_char,
                (*r).uri.scheme.ptr,
            );
            log_error(
                (*r).conf.errh,
                b"/home/kkysen/work/rust/lighttpd/src/response.c\0" as *const u8
                    as *const libc::c_char,
                408 as libc::c_int as libc::c_uint,
                b"URI-authority   : %s\0" as *const u8 as *const libc::c_char,
                (*r).uri.authority.ptr,
            );
            log_error(
                (*r).conf.errh,
                b"/home/kkysen/work/rust/lighttpd/src/response.c\0" as *const u8
                    as *const libc::c_char,
                410 as libc::c_int as libc::c_uint,
                b"URI-path (clean): %s\0" as *const u8 as *const libc::c_char,
                (*r).uri.path.ptr,
            );
            log_error(
                (*r).conf.errh,
                b"/home/kkysen/work/rust/lighttpd/src/response.c\0" as *const u8
                    as *const libc::c_char,
                412 as libc::c_int as libc::c_uint,
                b"URI-query       : %.*s\0" as *const u8 as *const libc::c_char,
                buffer_clen(&mut (*r).uri.query) as libc::c_int,
                (*r).uri.query.ptr,
            );
        }
        rc = plugins_call_handle_uri_clean(r);
        if HANDLER_GO_ON as libc::c_int as libc::c_uint != rc as libc::c_uint {
            return rc;
        }
        if ((*r).http_method as libc::c_int == HTTP_METHOD_OPTIONS as libc::c_int) as libc::c_int
            as libc::c_long
            != 0
            && *((*r).uri.path.ptr).offset(0 as libc::c_int as isize) as libc::c_int == '*' as i32
            && *((*r).uri.path.ptr).offset(1 as libc::c_int as isize) as libc::c_int == '\0' as i32
        {
            return http_response_prepare_options_star(r);
        }
        if ((*r).http_method as libc::c_int == HTTP_METHOD_CONNECT as libc::c_int) as libc::c_int
            as libc::c_long
            != 0
        {
            return http_response_prepare_connect(r);
        }
        buffer_clear(&mut (*r).physical.doc_root);
        rc = plugins_call_handle_docroot(r);
        if HANDLER_GO_ON as libc::c_int as libc::c_uint != rc as libc::c_uint {
            return rc;
        }
        buffer_copy_buffer(&mut (*r).physical.rel_path, &mut (*r).uri.path);
        if (*r).conf.force_lowercase_filenames != 0 {
            buffer_to_lower(&mut (*r).physical.rel_path);
        }
        if buffer_is_unset(&mut (*r).physical.doc_root) != 0 {
            buffer_copy_buffer(&mut (*r).physical.doc_root, (*r).conf.document_root);
        }
        buffer_copy_buffer(&mut (*r).physical.basedir, &mut (*r).physical.doc_root);
        buffer_copy_path_len2(
            &mut (*r).physical.path,
            (*r).physical.doc_root.ptr,
            buffer_clen(&mut (*r).physical.doc_root) as size_t,
            (*r).physical.rel_path.ptr,
            buffer_clen(&mut (*r).physical.rel_path) as size_t,
        );
        rc = plugins_call_handle_physical(r);
        if HANDLER_GO_ON as libc::c_int as libc::c_uint != rc as libc::c_uint {
            return rc;
        }
        if (*r).conf.log_request_handling != 0 {
            log_error(
                (*r).conf.errh,
                b"/home/kkysen/work/rust/lighttpd/src/response.c\0" as *const u8
                    as *const libc::c_char,
                490 as libc::c_int as libc::c_uint,
                b"-- logical -> physical\0" as *const u8 as *const libc::c_char,
            );
            log_error(
                (*r).conf.errh,
                b"/home/kkysen/work/rust/lighttpd/src/response.c\0" as *const u8
                    as *const libc::c_char,
                492 as libc::c_int as libc::c_uint,
                b"Doc-Root     : %s\0" as *const u8 as *const libc::c_char,
                (*r).physical.doc_root.ptr,
            );
            log_error(
                (*r).conf.errh,
                b"/home/kkysen/work/rust/lighttpd/src/response.c\0" as *const u8
                    as *const libc::c_char,
                494 as libc::c_int as libc::c_uint,
                b"Basedir      : %s\0" as *const u8 as *const libc::c_char,
                (*r).physical.basedir.ptr,
            );
            log_error(
                (*r).conf.errh,
                b"/home/kkysen/work/rust/lighttpd/src/response.c\0" as *const u8
                    as *const libc::c_char,
                496 as libc::c_int as libc::c_uint,
                b"Rel-Path     : %s\0" as *const u8 as *const libc::c_char,
                (*r).physical.rel_path.ptr,
            );
            log_error(
                (*r).conf.errh,
                b"/home/kkysen/work/rust/lighttpd/src/response.c\0" as *const u8
                    as *const libc::c_char,
                498 as libc::c_int as libc::c_uint,
                b"Path         : %s\0" as *const u8 as *const libc::c_char,
                (*r).physical.path.ptr,
            );
        }
    }
    if !((*r).handler_module).is_null() {
        return HANDLER_GO_ON;
    }
    rc = http_response_physical_path_check(r);
    if HANDLER_GO_ON as libc::c_int as libc::c_uint != rc as libc::c_uint {
        return rc;
    }
    if (*r).conf.log_request_handling != 0 {
        log_error(
            (*r).conf.errh,
            b"/home/kkysen/work/rust/lighttpd/src/response.c\0" as *const u8 as *const libc::c_char,
            517 as libc::c_int as libc::c_uint,
            b"-- handling subrequest\0" as *const u8 as *const libc::c_char,
        );
        log_error(
            (*r).conf.errh,
            b"/home/kkysen/work/rust/lighttpd/src/response.c\0" as *const u8 as *const libc::c_char,
            519 as libc::c_int as libc::c_uint,
            b"Path         : %s\0" as *const u8 as *const libc::c_char,
            (*r).physical.path.ptr,
        );
        log_error(
            (*r).conf.errh,
            b"/home/kkysen/work/rust/lighttpd/src/response.c\0" as *const u8 as *const libc::c_char,
            521 as libc::c_int as libc::c_uint,
            b"URI          : %s\0" as *const u8 as *const libc::c_char,
            (*r).uri.path.ptr,
        );
        log_error(
            (*r).conf.errh,
            b"/home/kkysen/work/rust/lighttpd/src/response.c\0" as *const u8 as *const libc::c_char,
            523 as libc::c_int as libc::c_uint,
            b"Pathinfo     : %s\0" as *const u8 as *const libc::c_char,
            if !((*r).pathinfo.ptr).is_null() {
                (*r).pathinfo.ptr as *const libc::c_char
            } else {
                b"\0" as *const u8 as *const libc::c_char
            },
        );
    }
    rc = plugins_call_handle_subrequest_start(r);
    if HANDLER_GO_ON as libc::c_int as libc::c_uint != rc as libc::c_uint {
        return rc;
    }
    if (0 as *mut libc::c_void as *const plugin == (*r).handler_module) as libc::c_int
        as libc::c_long
        != 0
    {
        if (0 as libc::c_int == (*r).http_status) as libc::c_int as libc::c_long != 0 {
            if (*r).http_method as libc::c_int == HTTP_METHOD_OPTIONS as libc::c_int {
                http_response_body_clear(r, 0 as libc::c_int);
                http_response_prepare_options_star(r);
            } else if !((*r).http_method as libc::c_int <= HTTP_METHOD_POST as libc::c_int) {
                (*r).http_status = 501 as libc::c_int;
            } else {
                (*r).http_status = 403 as libc::c_int;
            }
        }
        return HANDLER_FINISHED;
    }
    return HANDLER_GO_ON;
}
#[cold]
#[inline(never)]
unsafe extern "C" fn http_response_comeback(r: *mut request_st) -> handler_t {
    if !((*r).handler_module).is_null() || buffer_is_unset(&mut (*r).physical.path) == 0 {
        return HANDLER_GO_ON;
    }
    request_config_reset(r);
    if ((*r).http_host != 0 as *mut libc::c_void as *mut buffer) as libc::c_int as libc::c_long != 0
    {
        buffer_copy_string_len_lc(
            &mut (*r).uri.authority,
            (*(*r).http_host).ptr,
            buffer_clen((*r).http_host) as size_t,
        );
    } else {
        buffer_copy_string_len(
            &mut (*r).uri.authority,
            b"\0" as *const u8 as *const libc::c_char,
            (::core::mem::size_of::<[libc::c_char; 1]>() as libc::c_ulong as uint32_t)
                .wrapping_sub(1 as libc::c_int as libc::c_uint) as size_t,
        );
    }
    let mut status: libc::c_int =
        http_request_parse_target(r, (*(*r).con).proto_default_port as libc::c_int);
    if 0 as libc::c_int == status {
        (*r).conditional_is_valid = ((1 as libc::c_int) << COMP_SERVER_SOCKET as libc::c_int
            | (1 as libc::c_int) << COMP_HTTP_SCHEME as libc::c_int
            | (1 as libc::c_int) << COMP_HTTP_HOST as libc::c_int
            | (1 as libc::c_int) << COMP_HTTP_REMOTE_IP as libc::c_int
            | (1 as libc::c_int) << COMP_HTTP_REQUEST_METHOD as libc::c_int
            | (1 as libc::c_int) << COMP_HTTP_URL as libc::c_int
            | (1 as libc::c_int) << COMP_HTTP_QUERY_STRING as libc::c_int
            | (1 as libc::c_int) << COMP_HTTP_REQUEST_HEADER as libc::c_int)
            as uint32_t;
        return HANDLER_GO_ON;
    } else {
        (*r).conditional_is_valid = ((1 as libc::c_int) << COMP_SERVER_SOCKET as libc::c_int
            | (1 as libc::c_int) << COMP_HTTP_REMOTE_IP as libc::c_int)
            as uint32_t;
        config_cond_cache_reset(r);
        return http_status_set_error_close(r, status);
    };
}
#[cold]
unsafe extern "C" fn http_response_errdoc_init(r: *mut request_st) {
    let mut www_auth: *mut buffer = 0 as *mut buffer;
    if 401 as libc::c_int == (*r).http_status {
        let vb: *const buffer = http_header_response_get(
            r,
            HTTP_HEADER_WWW_AUTHENTICATE,
            b"WWW-Authenticate\0" as *const u8 as *const libc::c_char,
            (::core::mem::size_of::<[libc::c_char; 17]>() as libc::c_ulong as uint32_t)
                .wrapping_sub(1 as libc::c_int as libc::c_uint),
        );
        if !vb.is_null() {
            www_auth = buffer_init();
            buffer_copy_buffer(www_auth, vb);
        }
    }
    buffer_reset(&mut (*r).physical.path);
    (*r).resp_htags = 0 as libc::c_int as uint64_t;
    array_reset_data_strings(&mut (*r).resp_headers);
    http_response_body_clear(r, 0 as libc::c_int);
    if !www_auth.is_null() {
        http_header_response_set(
            r,
            HTTP_HEADER_WWW_AUTHENTICATE,
            b"WWW-Authenticate\0" as *const u8 as *const libc::c_char,
            (::core::mem::size_of::<[libc::c_char; 17]>() as libc::c_ulong as uint32_t)
                .wrapping_sub(1 as libc::c_int as libc::c_uint),
            (*www_auth).ptr,
            buffer_clen(www_auth),
        );
        buffer_free(www_auth);
    }
}
#[cold]
unsafe extern "C" fn http_response_static_errdoc(r: *mut request_st) {
    if if ((*r).handler_module).is_null() {
        ((*r).error_handler_saved_status >= 65535 as libc::c_int) as libc::c_int
    } else {
        ((*r).conf.error_intercept == 0 || (*r).error_handler_saved_status != 0) as libc::c_int
    } != 0
    {
        return;
    }
    http_response_errdoc_init(r);
    (*r).resp_body_finished = 1 as libc::c_int as libc::c_char;
    if !((*r).conf.errorfile_prefix).is_null() {
        buffer_copy_buffer(&mut (*r).physical.path, (*r).conf.errorfile_prefix);
        buffer_append_int(&mut (*r).physical.path, (*r).http_status as intmax_t);
        buffer_append_string_len(
            &mut (*r).physical.path,
            b".html\0" as *const u8 as *const libc::c_char,
            (::core::mem::size_of::<[libc::c_char; 6]>() as libc::c_ulong as uint32_t)
                .wrapping_sub(1 as libc::c_int as libc::c_uint) as size_t,
        );
        let mut sce: *mut stat_cache_entry = stat_cache_get_entry_open(
            &mut (*r).physical.path,
            (*r).conf.follow_symlink as libc::c_int,
        );
        if !sce.is_null() && 0 as libc::c_int == http_chunk_append_file_ref(r, sce) {
            let mut content_type: *const buffer =
                stat_cache_content_type_get_by_ext(sce, (*r).conf.mimetypes);
            if !content_type.is_null() {
                http_header_response_set(
                    r,
                    HTTP_HEADER_CONTENT_TYPE,
                    b"Content-Type\0" as *const u8 as *const libc::c_char,
                    (::core::mem::size_of::<[libc::c_char; 13]>() as libc::c_ulong as uint32_t)
                        .wrapping_sub(1 as libc::c_int as libc::c_uint),
                    (*content_type).ptr,
                    buffer_clen(content_type),
                );
            }
            return;
        }
        buffer_clear(&mut (*r).physical.path);
    }
    let b: *mut buffer = chunkqueue_append_buffer_open(&mut (*r).write_queue);
    buffer_copy_string_len(
        b,
        b"<?xml version=\"1.0\" encoding=\"iso-8859-1\"?>\n<!DOCTYPE html PUBLIC \"-//W3C//DTD XHTML 1.0 Transitional//EN\"\n         \"http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd\">\n<html xmlns=\"http://www.w3.org/1999/xhtml\" xml:lang=\"en\" lang=\"en\">\n <head>\n  <title>\0"
            as *const u8 as *const libc::c_char,
        (::core::mem::size_of::<[libc::c_char; 261]>() as libc::c_ulong as uint32_t)
            .wrapping_sub(1 as libc::c_int as libc::c_uint) as size_t,
    );
    http_status_append(b, (*r).http_status);
    buffer_append_string_len(
        b,
        b"</title>\n </head>\n <body>\n  <h1>\0" as *const u8 as *const libc::c_char,
        (::core::mem::size_of::<[libc::c_char; 33]>() as libc::c_ulong as uint32_t)
            .wrapping_sub(1 as libc::c_int as libc::c_uint) as size_t,
    );
    http_status_append(b, (*r).http_status);
    buffer_append_string_len(
        b,
        b"</h1>\n </body>\n</html>\n\0" as *const u8 as *const libc::c_char,
        (::core::mem::size_of::<[libc::c_char; 24]>() as libc::c_ulong as uint32_t)
            .wrapping_sub(1 as libc::c_int as libc::c_uint) as size_t,
    );
    chunkqueue_append_buffer_commit(&mut (*r).write_queue);
    http_header_response_set(
        r,
        HTTP_HEADER_CONTENT_TYPE,
        b"Content-Type\0" as *const u8 as *const libc::c_char,
        (::core::mem::size_of::<[libc::c_char; 13]>() as libc::c_ulong as uint32_t)
            .wrapping_sub(1 as libc::c_int as libc::c_uint),
        b"text/html\0" as *const u8 as *const libc::c_char,
        (::core::mem::size_of::<[libc::c_char; 10]>() as libc::c_ulong as uint32_t)
            .wrapping_sub(1 as libc::c_int as libc::c_uint),
    );
}
#[cold]
unsafe extern "C" fn http_response_call_error_handler(
    r: *mut request_st,
    error_handler: *const buffer,
) -> libc::c_int {
    buffer_append_int(
        http_header_env_set_ptr(
            r,
            b"REDIRECT_STATUS\0" as *const u8 as *const libc::c_char,
            (::core::mem::size_of::<[libc::c_char; 16]>() as libc::c_ulong as uint32_t)
                .wrapping_sub(1 as libc::c_int as libc::c_uint),
        ),
        (*r).http_status as intmax_t,
    );
    if error_handler == (*r).conf.error_handler {
        plugins_call_handle_request_reset(r);
        if (*r).reqbody_length != 0 {
            if (*r).reqbody_length != (*r).reqbody_queue.bytes_in {
                (*r).keep_alive = 0 as libc::c_int as int8_t;
            }
            (*r).reqbody_length = 0 as libc::c_int as off_t;
            chunkqueue_reset(&mut (*r).reqbody_queue);
        }
        (*(*r).con).is_writable = 1 as libc::c_int as libc::c_schar;
        (*r).resp_body_finished = 0 as libc::c_int as libc::c_char;
        (*r).resp_body_started = 0 as libc::c_int as libc::c_char;
        (*r).error_handler_saved_status = (*r).http_status;
        (*r).error_handler_saved_method = (*r).http_method;
        (*r).http_method = HTTP_METHOD_GET;
    } else {
        (*r).error_handler_saved_status = -(*r).http_status;
    }
    if (*r).http_version as libc::c_int == HTTP_VERSION_UNSET as libc::c_int {
        (*r).http_version = HTTP_VERSION_1_0;
    }
    buffer_copy_buffer(&mut (*r).target, error_handler);
    http_response_errdoc_init(r);
    (*r).http_status = 0 as libc::c_int;
    return 1 as libc::c_int;
}
#[cold]
#[inline(never)]
unsafe extern "C" fn http_response_has_error_handler(r: *mut request_st) -> libc::c_int {
    if (*r).error_handler_saved_status > 0 as libc::c_int {
        (*r).http_method = (*r).error_handler_saved_method;
    }
    if ((*r).handler_module).is_null() || (*r).conf.error_intercept as libc::c_int != 0 {
        if (*r).error_handler_saved_status as libc::c_long != 0 {
            let subreq_status: libc::c_int = (*r).http_status;
            if (*r).error_handler_saved_status > 0 as libc::c_int {
                (*r).http_status = (*r).error_handler_saved_status;
            } else if (*r).http_status == 404 as libc::c_int
                || (*r).http_status == 403 as libc::c_int
            {
                (*r).http_status = -(*r).error_handler_saved_status;
            }
            if 200 as libc::c_int <= subreq_status && subreq_status <= 299 as libc::c_int {
                (*r).error_handler_saved_status = 65535 as libc::c_int;
            }
        } else if ((*r).http_status >= 400 as libc::c_int) as libc::c_int as libc::c_long != 0 {
            let mut error_handler: *const buffer = 0 as *const buffer;
            if !((*r).conf.error_handler).is_null() {
                error_handler = (*r).conf.error_handler;
            } else if ((*r).http_status == 404 as libc::c_int
                || (*r).http_status == 403 as libc::c_int)
                && !((*r).conf.error_handler_404).is_null()
            {
                error_handler = (*r).conf.error_handler_404;
            }
            if !error_handler.is_null() {
                return http_response_call_error_handler(r, error_handler);
            }
        }
    }
    return 0 as libc::c_int;
}
#[cold]
unsafe extern "C" fn http_response_merge_trailers(r: *mut request_st) {
    if buffer_is_blank(&mut (*(*r).gw_dechunk).b) != 0 {
        return;
    }
    let done: libc::c_int = (*(*r).gw_dechunk).done;
    if done == 0 {
        return;
    }
    if done < 400 as libc::c_int && (*r).http_status >= 400 as libc::c_int {
        return;
    }
    let mut k: *const libc::c_char = strchr((*(*r).gw_dechunk).b.ptr, '\n' as i32);
    if k.is_null() {
        return;
    }
    k = k.offset(1);
    let mut v: *const libc::c_char = 0 as *const libc::c_char;
    let mut e: *const libc::c_char = 0 as *const libc::c_char;
    loop {
        e = strchr(k, '\n' as i32);
        if e.is_null() {
            break;
        }
        v = memchr(
            k as *const libc::c_void,
            ':' as i32,
            e.offset_from(k) as libc::c_long as size_t,
        ) as *const libc::c_char;
        if !(v.is_null()
            || v == k
            || *k as libc::c_int == ' ' as i32
            || *k as libc::c_int == '\t' as i32)
        {
            let mut klen: uint32_t = v.offset_from(k) as libc::c_long as uint32_t;
            loop {
                v = v.offset(1);
                if !(*v as libc::c_int == ' ' as i32 || *v as libc::c_int == '\t' as i32) {
                    break;
                }
            }
            if !(*v as libc::c_int == '\r' as i32 || *v as libc::c_int == '\n' as i32) {
                let mut id: http_header_e = http_header_hkey_get(k, klen as size_t);
                http_header_response_insert(
                    r,
                    id,
                    k,
                    klen,
                    v,
                    e.offset_from(v) as libc::c_long as size_t as uint32_t,
                );
            }
        }
        k = e.offset(1 as libc::c_int as isize);
    }
    http_header_response_unset(
        r,
        HTTP_HEADER_OTHER,
        b"Trailer\0" as *const u8 as *const libc::c_char,
        (::core::mem::size_of::<[libc::c_char; 8]>() as libc::c_ulong as uint32_t)
            .wrapping_sub(1 as libc::c_int as libc::c_uint),
    );
    buffer_clear(&mut (*(*r).gw_dechunk).b);
}
#[no_mangle]
pub unsafe extern "C" fn http_response_handler(r: *mut request_st) -> handler_t {
    let mut rc: libc::c_int = 0;
    let mut current_block_12: u64;
    loop {
        let mut p: *const plugin = (*r).handler_module;
        if !p.is_null() || {
            rc = http_response_prepare(r) as libc::c_int;
            rc == HANDLER_GO_ON as libc::c_int && {
                p = (*r).handler_module;
                !p.is_null()
            }
        } {
            rc = ((*p).handle_subrequest).expect("non-null function pointer")(r, (*p).data)
                as libc::c_int;
        }
        match rc {
            3 => {
                if (*r).resp_body_finished == 0
                    && ((*r).resp_body_started == 0
                        || 0 as libc::c_int
                            == (*r).conf.stream_response_body as libc::c_int
                                & ((1 as libc::c_int) << 0 as libc::c_int
                                    | (1 as libc::c_int) << 1 as libc::c_int))
                {
                    return HANDLER_WAIT_FOR_EVENT;
                }
                current_block_12 = 14850774847907953766;
            }
            0 | 1 => {
                current_block_12 = 14850774847907953766;
            }
            2 => {
                current_block_12 = 16642277268253888400;
            }
            _ => return HANDLER_ERROR,
        }
        match current_block_12 {
            14850774847907953766 => {
                if (*r).http_status == 0 as libc::c_int {
                    (*r).http_status = 200 as libc::c_int;
                }
                if ((*r).http_status < 400 as libc::c_int) as libc::c_int as libc::c_long != 0
                    && (0 as libc::c_int == (*r).error_handler_saved_status) as libc::c_int
                        as libc::c_long
                        != 0
                    || (http_response_has_error_handler(r) == 0) as libc::c_int as libc::c_long != 0
                {
                    return http_response_write_prepare(r);
                }
            }
            _ => {}
        }
        http_response_comeback(r);
        rc = HANDLER_COMEBACK as libc::c_int;
        if !(rc == HANDLER_COMEBACK as libc::c_int) {
            break;
        }
    }
    return HANDLER_ERROR;
}
#[inline(never)]
unsafe extern "C" fn http_response_write_prepare(r: *mut request_st) -> handler_t {
    match (*r).http_status {
        200 => {}
        204 | 205 | 304 => {
            http_response_body_clear(r, 1 as libc::c_int);
            http_header_response_unset(
                r,
                HTTP_HEADER_CONTENT_LENGTH,
                b"Content-Length\0" as *const u8 as *const libc::c_char,
                (::core::mem::size_of::<[libc::c_char; 15]>() as libc::c_ulong as uint32_t)
                    .wrapping_sub(1 as libc::c_int as libc::c_uint),
            );
            (*r).resp_body_finished = 1 as libc::c_int as libc::c_char;
        }
        _ => {
            if (*r).http_status >= 400 as libc::c_int && (*r).http_status < 600 as libc::c_int {
                http_response_static_errdoc(r);
            }
        }
    }
    if !((*r).gw_dechunk).is_null() {
        http_response_merge_trailers(r);
    }
    match plugins_call_handle_response_start(r) as libc::c_uint {
        0 | 1 => {}
        _ => {
            log_error(
                (*r).conf.errh,
                b"/home/kkysen/work/rust/lighttpd/src/response.c\0" as *const u8
                    as *const libc::c_char,
                746 as libc::c_int as libc::c_uint,
                b"response_start plugin failed\0" as *const u8 as *const libc::c_char,
            );
            return HANDLER_ERROR;
        }
    }
    if (*r).resp_body_finished != 0 {
        if (*r).conf.range_requests as libc::c_int != 0
            && http_range_rfc7233(r) >= 400 as libc::c_int
        {
            http_response_static_errdoc(r);
        }
        if (*r).resp_htags
            & ((1 as libc::c_ulong) << HTTP_HEADER_CONTENT_LENGTH as libc::c_int
                | (1 as libc::c_ulong) << HTTP_HEADER_TRANSFER_ENCODING as libc::c_int)
            == 0
        {
            let mut qlen: off_t = chunkqueue_length(&mut (*r).write_queue);
            if qlen > 0 as libc::c_int as libc::c_long {
                buffer_append_int(
                    http_header_response_set_ptr(
                        r,
                        HTTP_HEADER_CONTENT_LENGTH,
                        b"Content-Length\0" as *const u8 as *const libc::c_char,
                        (::core::mem::size_of::<[libc::c_char; 15]>() as libc::c_ulong as uint32_t)
                            .wrapping_sub(1 as libc::c_int as libc::c_uint),
                    ),
                    qlen,
                );
            } else if (*r).http_method as libc::c_int != HTTP_METHOD_HEAD as libc::c_int
                && (*r).http_status != 204 as libc::c_int
                && (*r).http_status != 304 as libc::c_int
            {
                http_header_response_set(
                    r,
                    HTTP_HEADER_CONTENT_LENGTH,
                    b"Content-Length\0" as *const u8 as *const libc::c_char,
                    (::core::mem::size_of::<[libc::c_char; 15]>() as libc::c_ulong as uint32_t)
                        .wrapping_sub(1 as libc::c_int as libc::c_uint),
                    b"0\0" as *const u8 as *const libc::c_char,
                    (::core::mem::size_of::<[libc::c_char; 2]>() as libc::c_ulong as uint32_t)
                        .wrapping_sub(1 as libc::c_int as libc::c_uint),
                );
            }
        }
    } else if !((*r).http_version as libc::c_int == HTTP_VERSION_2 as libc::c_int) {
        if (*r).resp_htags
            & ((1 as libc::c_ulong) << HTTP_HEADER_CONTENT_LENGTH as libc::c_int
                | (1 as libc::c_ulong) << HTTP_HEADER_TRANSFER_ENCODING as libc::c_int
                | (1 as libc::c_ulong) << HTTP_HEADER_UPGRADE as libc::c_int)
            == 0
        {
            if !((*r).http_method as libc::c_int == HTTP_METHOD_CONNECT as libc::c_int
                && (*r).http_status == 200 as libc::c_int)
            {
                if (*r).http_version as libc::c_int == HTTP_VERSION_1_1 as libc::c_int {
                    let mut qlen_0: off_t = chunkqueue_length(&mut (*r).write_queue);
                    (*r).resp_send_chunked = 1 as libc::c_int as libc::c_char;
                    if (*r).resp_decode_chunked != 0 {
                        let mut gw_chunked: off_t = (*(*r).gw_dechunk).gw_chunked;
                        if gw_chunked >= 2 as libc::c_int as libc::c_long {
                            qlen_0 += gw_chunked - 2 as libc::c_int as libc::c_long;
                        } else if 1 as libc::c_int as libc::c_long == gw_chunked {
                            chunkqueue_append_mem(
                                &mut (*r).write_queue,
                                b"\r\0" as *const u8 as *const libc::c_char,
                                (::core::mem::size_of::<[libc::c_char; 2]>() as libc::c_ulong
                                    as uint32_t)
                                    .wrapping_sub(1 as libc::c_int as libc::c_uint)
                                    as size_t,
                            );
                        } else {
                            if qlen_0 != 0 {
                                chunkqueue_append_mem(
                                    &mut (*r).write_queue,
                                    b"\r\n\0" as *const u8 as *const libc::c_char,
                                    (::core::mem::size_of::<[libc::c_char; 3]>() as libc::c_ulong
                                        as uint32_t)
                                        .wrapping_sub(1 as libc::c_int as libc::c_uint)
                                        as size_t,
                                );
                            }
                            let hdr: *const buffer = &mut (*(*r).gw_dechunk).b;
                            if buffer_is_blank(hdr) == 0 {
                                chunkqueue_append_mem(
                                    &mut (*r).write_queue,
                                    (*hdr).ptr,
                                    buffer_clen(hdr) as size_t,
                                );
                            }
                        }
                    } else if qlen_0 != 0 {
                        chunkqueue_append_mem(
                            &mut (*r).write_queue,
                            b"\r\n\0" as *const u8 as *const libc::c_char,
                            (::core::mem::size_of::<[libc::c_char; 3]>() as libc::c_ulong
                                as uint32_t)
                                .wrapping_sub(1 as libc::c_int as libc::c_uint)
                                as size_t,
                        );
                    }
                    if qlen_0 != 0 {
                        let b: *mut buffer = chunkqueue_prepend_buffer_open(&mut (*r).write_queue);
                        buffer_append_uint_hex_lc(b, qlen_0 as uintmax_t);
                        buffer_append_string_len(
                            b,
                            b"\r\n\0" as *const u8 as *const libc::c_char,
                            (::core::mem::size_of::<[libc::c_char; 3]>() as libc::c_ulong
                                as uint32_t)
                                .wrapping_sub(1 as libc::c_int as libc::c_uint)
                                as size_t,
                        );
                        chunkqueue_prepend_buffer_commit(&mut (*r).write_queue);
                    }
                    http_header_response_append(
                        r,
                        HTTP_HEADER_TRANSFER_ENCODING,
                        b"Transfer-Encoding\0" as *const u8 as *const libc::c_char,
                        (::core::mem::size_of::<[libc::c_char; 18]>() as libc::c_ulong as uint32_t)
                            .wrapping_sub(1 as libc::c_int as libc::c_uint),
                        b"chunked\0" as *const u8 as *const libc::c_char,
                        (::core::mem::size_of::<[libc::c_char; 8]>() as libc::c_ulong as uint32_t)
                            .wrapping_sub(1 as libc::c_int as libc::c_uint),
                    );
                } else {
                    (*r).keep_alive = 0 as libc::c_int as int8_t;
                }
            }
        }
    }
    if (*r).http_method as libc::c_int == HTTP_METHOD_HEAD as libc::c_int {
        http_response_body_clear(r, 1 as libc::c_int);
        (*r).resp_body_finished = 1 as libc::c_int as libc::c_char;
    }
    return HANDLER_GO_ON;
}
#[cold]
unsafe extern "C" fn connection_set_state_error(r: *mut request_st, state: request_state_t) {
    (*r).state = state;
}
unsafe extern "C" fn connections_get_new_connection(mut srv: *mut server) -> *mut connection {
    let mut con: *mut connection = 0 as *mut connection;
    (*srv).lim_conns = ((*srv).lim_conns).wrapping_sub(1);
    if !((*srv).conns_pool).is_null() {
        con = (*srv).conns_pool;
        (*srv).conns_pool = (*con).next;
    } else {
        con = connection_init(srv);
        connection_reset(con);
    }
    (*con).next = (*srv).conns;
    if !((*con).next).is_null() {
        (*(*con).next).prev = con;
    }
    (*srv).conns = con;
    return (*srv).conns;
}
unsafe extern "C" fn connection_del(mut srv: *mut server, mut con: *mut connection) {
    if !((*con).next).is_null() {
        (*(*con).next).prev = (*con).prev;
    }
    if !((*con).prev).is_null() {
        (*(*con).prev).next = (*con).next;
    } else {
        (*srv).conns = (*con).next;
    }
    (*con).prev = 0 as *mut connection;
    (*con).next = (*srv).conns_pool;
    (*srv).conns_pool = con;
    (*srv).lim_conns = ((*srv).lim_conns).wrapping_add(1);
}
unsafe extern "C" fn connection_close(mut con: *mut connection) {
    if (*con).fd < 0 as libc::c_int {
        (*con).fd = -(*con).fd;
    }
    plugins_call_handle_connection_close(con);
    let srv: *mut server = (*con).srv;
    let r: *mut request_st = &mut (*con).request;
    request_reset_ex(r);
    (*r).state = CON_STATE_CONNECT;
    chunkqueue_reset((*con).read_queue);
    (*con).request_count = 0 as libc::c_int as uint32_t;
    (*con).is_ssl_sock = 0 as libc::c_int as libc::c_char;
    (*con).revents_err = 0 as libc::c_int as uint16_t;
    fdevent_fdnode_event_del((*srv).ev, (*con).fdn);
    fdevent_unregister((*srv).ev, (*con).fd);
    (*con).fdn = 0 as *mut fdnode;
    if 0 as libc::c_int == close((*con).fd) {
        (*srv).cur_fds -= 1;
    } else {
        log_perror(
            (*r).conf.errh,
            b"/home/kkysen/work/rust/lighttpd/src/connections.c\0" as *const u8
                as *const libc::c_char,
            101 as libc::c_int as libc::c_uint,
            b"(warning) close: %d\0" as *const u8 as *const libc::c_char,
            (*con).fd,
        );
    }
    if (*r).conf.log_state_handling != 0 {
        log_error(
            (*r).conf.errh,
            b"/home/kkysen/work/rust/lighttpd/src/connections.c\0" as *const u8
                as *const libc::c_char,
            105 as libc::c_int as libc::c_uint,
            b"connection closed for fd %d\0" as *const u8 as *const libc::c_char,
            (*con).fd,
        );
    }
    (*con).fd = -(1 as libc::c_int);
    connection_del(srv, con);
}
unsafe extern "C" fn connection_read_for_eos_plain(con: *mut connection) {
    let mut len: ssize_t = 0;
    let type_0: libc::c_int = sock_addr_get_family(&mut (*con).dst_addr);
    let mut buf: [libc::c_char; 16384] = [0; 16384];
    loop {
        len = fdevent_socket_read_discard(
            (*con).fd,
            buf.as_mut_ptr(),
            ::core::mem::size_of::<[libc::c_char; 16384]>() as libc::c_ulong,
            type_0,
            SOCK_STREAM as libc::c_int,
        );
        if !(len > 0 as libc::c_int as libc::c_long
            || len < 0 as libc::c_int as libc::c_long && *__errno_location() == 4 as libc::c_int)
        {
            break;
        }
    }
    if len < 0 as libc::c_int as libc::c_long && *__errno_location() == 11 as libc::c_int {
        return;
    }
    (*con).close_timeout_ts =
        log_monotonic_secs - (5 as libc::c_int + 1 as libc::c_int) as libc::c_long;
}
unsafe extern "C" fn connection_read_for_eos_ssl(con: *mut connection) {
    if ((*con).network_read).expect("non-null function pointer")(
        con,
        (*con).read_queue,
        (256 as libc::c_int * 1024 as libc::c_int) as off_t,
    ) < 0 as libc::c_int
    {
        (*con).close_timeout_ts =
            log_monotonic_secs - (5 as libc::c_int + 1 as libc::c_int) as libc::c_long;
    }
    chunkqueue_reset((*con).read_queue);
}
unsafe extern "C" fn connection_read_for_eos(con: *mut connection) {
    if (*con).is_ssl_sock == 0 {
        connection_read_for_eos_plain(con);
    } else {
        connection_read_for_eos_ssl(con);
    };
}
unsafe extern "C" fn connection_handle_close_state(mut con: *mut connection) {
    connection_read_for_eos(con);
    if log_monotonic_secs - (*con).close_timeout_ts > 5 as libc::c_int as libc::c_long {
        connection_close(con);
    }
}
unsafe extern "C" fn connection_handle_shutdown(mut con: *mut connection) {
    plugins_call_handle_connection_shut_wr(con);
    connection_reset(con);
    (*(*con).srv).con_closed += 1;
    if (*con).fd >= 0 as libc::c_int
        && ((*con).is_ssl_sock as libc::c_int != 0
            || 0 as libc::c_int == shutdown((*con).fd, SHUT_WR as libc::c_int))
    {
        (*con).close_timeout_ts = log_monotonic_secs;
        let r: *mut request_st = &mut (*con).request;
        (*r).state = CON_STATE_CLOSE;
        if (*r).conf.log_state_handling != 0 {
            log_error(
                (*r).conf.errh,
                b"/home/kkysen/work/rust/lighttpd/src/connections.c\0" as *const u8
                    as *const libc::c_char,
                170 as libc::c_int as libc::c_uint,
                b"shutdown for fd %d\0" as *const u8 as *const libc::c_char,
                (*con).fd,
            );
        }
    } else {
        connection_close(con);
    };
}
unsafe extern "C" fn connection_handle_response_end_state(
    r: *mut request_st,
    con: *mut connection,
) {
    if (*r).http_version as libc::c_int > HTTP_VERSION_1_1 as libc::c_int {
        h2_retire_con(r, con);
        (*r).keep_alive = 0 as libc::c_int as int8_t;
        (*r).http_status = 100 as libc::c_int;
    }
    if (*r).http_status != 0 {
        plugins_call_handle_request_done(r);
    }
    if (*r).state as libc::c_uint != CON_STATE_ERROR as libc::c_int as libc::c_uint {
        (*(*con).srv).con_written += 1;
    }
    if (*r).reqbody_length != (*r).reqbody_queue.bytes_in
        || (*r).state as libc::c_uint == CON_STATE_ERROR as libc::c_int as libc::c_uint
    {
        (*r).keep_alive = 0 as libc::c_int as int8_t;
        if &mut (*r).write_queue as *mut chunkqueue != (*con).write_queue {
            chunkqueue_free((*con).write_queue);
            (*con).write_queue = &mut (*r).write_queue;
        }
    }
    if (*r).keep_alive as libc::c_int > 0 as libc::c_int {
        request_reset(r);
        (*con).is_readable = 1 as libc::c_int as libc::c_schar;
        (*r).bytes_read_ckpt = (*con).bytes_read;
        (*r).bytes_written_ckpt = (*con).bytes_written;
        (*r).state = CON_STATE_REQUEST_START;
    } else {
        connection_handle_shutdown(con);
    };
}
unsafe extern "C" fn connection_write_throttled(
    con: *const connection,
    mut max_bytes: off_t,
) -> off_t {
    let rconf: *const request_config = &(*con).request.conf;
    if 0 as libc::c_int as libc::c_uint == (*rconf).global_bytes_per_second
        && 0 as libc::c_int as libc::c_uint == (*rconf).bytes_per_second
    {
        return max_bytes;
    }
    if (*rconf).global_bytes_per_second != 0 {
        let mut limit: off_t =
            (*rconf).global_bytes_per_second as off_t - *(*rconf).global_bytes_per_second_cnt_ptr;
        if max_bytes > limit {
            max_bytes = limit;
        }
    }
    if (*rconf).bytes_per_second != 0 {
        let mut limit_0: off_t =
            (*rconf).bytes_per_second as off_t - (*con).bytes_written_cur_second;
        if max_bytes > limit_0 {
            max_bytes = limit_0;
        }
    }
    return if max_bytes > 0 as libc::c_int as libc::c_long {
        max_bytes
    } else {
        0 as libc::c_int as libc::c_long
    };
}
unsafe extern "C" fn connection_write_throttle(
    con: *mut connection,
    mut max_bytes: off_t,
) -> off_t {
    max_bytes = connection_write_throttled(con, max_bytes);
    if 0 as libc::c_int as libc::c_long == max_bytes {
        (*con).traffic_limit_reached = 1 as libc::c_int as libc::c_char;
    }
    return max_bytes;
}
unsafe extern "C" fn connection_write_chunkqueue(
    con: *mut connection,
    cq: *mut chunkqueue,
    mut max_bytes: off_t,
) -> libc::c_int {
    (*con).write_request_ts = log_monotonic_secs;
    max_bytes = connection_write_throttle(con, max_bytes);
    if 0 as libc::c_int as libc::c_long == max_bytes {
        return 1 as libc::c_int;
    }
    let mut written: off_t = (*cq).bytes_out;
    let mut ret: libc::c_int = 0;
    let mut corked: libc::c_int = 0 as libc::c_int;
    if !((*(*cq).first).next).is_null()
        && (*(*cq).first).type_0 as libc::c_uint == MEM_CHUNK as libc::c_int as libc::c_uint
    {
        let mut c: *const chunk = (*cq).first;
        loop {
            c = (*c).next;
            if !(!c.is_null()
                && (*c).type_0 as libc::c_uint == MEM_CHUNK as libc::c_int as libc::c_uint)
            {
                break;
            }
        }
        if !c.is_null()
            || max_bytes > 16384 as libc::c_int as libc::c_long
                && (*con).is_ssl_sock as libc::c_int != 0
        {
            let sa_family: libc::c_int = sock_addr_get_family(&(*(*con).srv_socket).addr);
            if sa_family == 2 as libc::c_int || sa_family == 10 as libc::c_int {
                corked = 1 as libc::c_int;
                setsockopt(
                    (*con).fd,
                    IPPROTO_TCP as libc::c_int,
                    3 as libc::c_int,
                    &mut corked as *mut libc::c_int as *const libc::c_void,
                    ::core::mem::size_of::<libc::c_int>() as libc::c_ulong as socklen_t,
                );
            }
        }
    }
    ret = ((*con).network_write).expect("non-null function pointer")(con, cq, max_bytes);
    if ret >= 0 as libc::c_int {
        ret = if chunkqueue_is_empty(cq) != 0 {
            0 as libc::c_int
        } else {
            1 as libc::c_int
        };
    }
    if corked != 0 {
        corked = 0 as libc::c_int;
        setsockopt(
            (*con).fd,
            IPPROTO_TCP as libc::c_int,
            3 as libc::c_int,
            &mut corked as *mut libc::c_int as *const libc::c_void,
            ::core::mem::size_of::<libc::c_int>() as libc::c_ulong as socklen_t,
        );
    }
    written = (*cq).bytes_out - written;
    (*con).bytes_written += written;
    (*con).bytes_written_cur_second += written;
    let r: *mut request_st = &mut (*con).request;
    if !((*r).conf.global_bytes_per_second_cnt_ptr).is_null() {
        *(*r).conf.global_bytes_per_second_cnt_ptr += written;
    }
    return ret;
}
unsafe extern "C" fn connection_write_1xx_info(
    r: *mut request_st,
    con: *mut connection,
) -> libc::c_int {
    let cq: *mut chunkqueue = (*con).write_queue;
    let mut written: off_t = (*cq).bytes_out;
    let mut rc: libc::c_int = ((*con).network_write).expect("non-null function pointer")(
        con,
        cq,
        (256 as libc::c_int * 1024 as libc::c_int) as off_t,
    );
    written = (*cq).bytes_out - written;
    (*con).bytes_written += written;
    (*con).bytes_written_cur_second += written;
    if !((*r).conf.global_bytes_per_second_cnt_ptr).is_null() {
        *(*r).conf.global_bytes_per_second_cnt_ptr += written;
    }
    if rc < 0 as libc::c_int {
        connection_set_state_error(r, CON_STATE_ERROR);
        return 0 as libc::c_int;
    }
    if chunkqueue_is_empty(cq) == 0 {
        (*con).is_writable = 0 as libc::c_int as libc::c_schar;
        if cq == &mut (*r).write_queue as *mut chunkqueue {
            (*con).write_queue = chunkqueue_init(0 as *mut chunkqueue);
            chunkqueue_append_chunkqueue((*con).write_queue, cq);
        }
    }
    return 1 as libc::c_int;
}
#[no_mangle]
pub unsafe extern "C" fn connection_send_1xx(
    r: *mut request_st,
    con: *mut connection,
) -> libc::c_int {
    let cq: *mut chunkqueue = (*con).write_queue;
    let b: *mut buffer = chunkqueue_append_buffer_open(cq);
    buffer_copy_string_len(
        b,
        b"HTTP/1.1 \0" as *const u8 as *const libc::c_char,
        (::core::mem::size_of::<[libc::c_char; 10]>() as libc::c_ulong as uint32_t)
            .wrapping_sub(1 as libc::c_int as libc::c_uint) as size_t,
    );
    http_status_append(b, (*r).http_status);
    let mut i: uint32_t = 0 as libc::c_int as uint32_t;
    while i < (*r).resp_headers.used {
        let ds: *const data_string =
            *((*r).resp_headers.data).offset(i as isize) as *mut data_string;
        let klen: uint32_t = buffer_clen(&(*ds).key);
        let vlen: uint32_t = buffer_clen(&(*ds).value);
        if !(0 as libc::c_int as libc::c_uint == klen || 0 as libc::c_int as libc::c_uint == vlen) {
            buffer_append_str2(
                b,
                b"\r\n\0" as *const u8 as *const libc::c_char,
                (::core::mem::size_of::<[libc::c_char; 3]>() as libc::c_ulong as uint32_t)
                    .wrapping_sub(1 as libc::c_int as libc::c_uint) as size_t,
                (*ds).key.ptr,
                klen as size_t,
            );
            buffer_append_str2(
                b,
                b": \0" as *const u8 as *const libc::c_char,
                (::core::mem::size_of::<[libc::c_char; 3]>() as libc::c_ulong as uint32_t)
                    .wrapping_sub(1 as libc::c_int as libc::c_uint) as size_t,
                (*ds).value.ptr,
                vlen as size_t,
            );
        }
        i = i.wrapping_add(1);
    }
    buffer_append_string_len(
        b,
        b"\r\n\r\n\0" as *const u8 as *const libc::c_char,
        (::core::mem::size_of::<[libc::c_char; 5]>() as libc::c_ulong as uint32_t)
            .wrapping_sub(1 as libc::c_int as libc::c_uint) as size_t,
    );
    chunkqueue_append_buffer_commit(cq);
    if (*con).traffic_limit_reached != 0 {
        return 1 as libc::c_int;
    }
    return connection_write_1xx_info(r, con);
}
unsafe extern "C" fn connection_write_100_continue(
    r: *mut request_st,
    con: *mut connection,
) -> libc::c_int {
    static mut http_100_continue: [libc::c_char; 26] = unsafe {
        *::core::mem::transmute::<&[u8; 26], &[libc::c_char; 26]>(
            b"HTTP/1.1 100 Continue\r\n\r\n\0",
        )
    };
    if (*con).traffic_limit_reached != 0 {
        return 1 as libc::c_int;
    }
    let cq: *mut chunkqueue = (*con).write_queue;
    chunkqueue_append_mem(
        cq,
        http_100_continue.as_ptr(),
        (::core::mem::size_of::<[libc::c_char; 26]>() as libc::c_ulong)
            .wrapping_sub(1 as libc::c_int as libc::c_ulong),
    );
    return connection_write_1xx_info(r, con);
}
unsafe extern "C" fn connection_handle_write(
    r: *mut request_st,
    con: *mut connection,
) -> libc::c_int {
    if (*con).is_writable as libc::c_int <= 0 as libc::c_int {
        return CON_STATE_WRITE as libc::c_int;
    }
    let mut rc: libc::c_int = connection_write_chunkqueue(
        con,
        (*con).write_queue,
        (256 as libc::c_int * 1024 as libc::c_int) as off_t,
    );
    let mut current_block_11: u64;
    match rc {
        0 => {
            if (*r).resp_body_finished != 0 {
                (*r).state = CON_STATE_RESPONSE_END;
                return CON_STATE_RESPONSE_END as libc::c_int;
            }
            current_block_11 = 7746791466490516765;
        }
        -1 => {
            log_error(
                (*r).conf.errh,
                b"/home/kkysen/work/rust/lighttpd/src/connections.c\0" as *const u8
                    as *const libc::c_char,
                437 as libc::c_int as libc::c_uint,
                b"connection closed: write failed on fd %d\0" as *const u8 as *const libc::c_char,
                (*con).fd,
            );
            current_block_11 = 9411678013323872345;
        }
        -2 => {
            current_block_11 = 9411678013323872345;
        }
        1 => {
            if (*(*con).write_queue).bytes_out != 0 {
                (*con).is_writable = 0 as libc::c_int as libc::c_schar;
            }
            current_block_11 = 7746791466490516765;
        }
        _ => {
            current_block_11 = 7746791466490516765;
        }
    }
    match current_block_11 {
        7746791466490516765 => {}
        _ => {
            connection_set_state_error(r, CON_STATE_ERROR);
            return CON_STATE_ERROR as libc::c_int;
        }
    }
    return CON_STATE_WRITE as libc::c_int;
}
unsafe extern "C" fn connection_handle_write_state(
    r: *mut request_st,
    con: *mut connection,
) -> libc::c_int {
    loop {
        if chunkqueue_is_empty(&mut (*r).write_queue) == 0 {
            if (*r).http_version as libc::c_int <= HTTP_VERSION_1_1 as libc::c_int {
                let mut rc: libc::c_int = connection_handle_write(r, con);
                if rc != CON_STATE_WRITE as libc::c_int {
                    return rc;
                }
            }
        } else if (*r).resp_body_finished != 0 {
            (*r).state = CON_STATE_RESPONSE_END;
            return CON_STATE_RESPONSE_END as libc::c_int;
        }
        if !((*r).handler_module).is_null() && (*r).resp_body_finished == 0 {
            let p: *const plugin = (*r).handler_module;
            let mut rc_0: libc::c_int =
                ((*p).handle_subrequest).expect("non-null function pointer")(r, (*p).data)
                    as libc::c_int;
            's_80: {
                match rc_0 {
                    3 | 1 | 0 => {
                        break 's_80;
                    }
                    4 => {}
                    2 | _ => {
                        log_error(
                            (*r).conf.errh,
                            b"/home/kkysen/work/rust/lighttpd/src/connections.c\0" as *const u8
                                as *const libc::c_char,
                            479 as libc::c_int as libc::c_uint,
                            b"unexpected subrequest handler ret-value: %d %d\0" as *const u8
                                as *const libc::c_char,
                            (*con).fd,
                            rc_0,
                        );
                    }
                }
                connection_set_state_error(r, CON_STATE_ERROR);
                return CON_STATE_ERROR as libc::c_int;
            }
        }
        if !((*r).http_version as libc::c_int <= HTTP_VERSION_1_1 as libc::c_int
            && (if chunkqueue_is_empty(&mut (*r).write_queue) == 0 {
                ((*con).is_writable as libc::c_int > 0 as libc::c_int
                    && 0 as libc::c_int == (*con).traffic_limit_reached as libc::c_int)
                    as libc::c_int
            } else {
                (*r).resp_body_finished as libc::c_int
            }) != 0)
        {
            break;
        }
    }
    return CON_STATE_WRITE as libc::c_int;
}
#[cold]
unsafe extern "C" fn connection_init(mut srv: *mut server) -> *mut connection {
    let con: *mut connection = calloc(
        1 as libc::c_int as libc::c_ulong,
        ::core::mem::size_of::<connection>() as libc::c_ulong,
    ) as *mut connection;
    if con.is_null() {
        ck_assert_failed(
            b"/home/kkysen/work/rust/lighttpd/src/connections.c\0" as *const u8
                as *const libc::c_char,
            500 as libc::c_int as libc::c_uint,
            b"((void*)0) != con\0" as *const u8 as *const libc::c_char,
        );
    }
    (*con).srv = srv;
    (*con).plugin_slots = (*srv).plugin_slots;
    (*con).config_data_base = (*srv).config_data_base;
    let r: *mut request_st = &mut (*con).request;
    request_init_data(r, con, srv);
    (*con).write_queue = &mut (*r).write_queue;
    (*con).read_queue = &mut (*r).read_queue;
    (*con).plugin_ctx = calloc(
        1 as libc::c_int as libc::c_ulong,
        (((*srv).plugins.used).wrapping_add(1 as libc::c_int as libc::c_uint) as libc::c_ulong)
            .wrapping_mul(::core::mem::size_of::<*mut libc::c_void>() as libc::c_ulong),
    ) as *mut *mut libc::c_void;
    if ((*con).plugin_ctx).is_null() {
        ck_assert_failed(
            b"/home/kkysen/work/rust/lighttpd/src/connections.c\0" as *const u8
                as *const libc::c_char,
            513 as libc::c_int as libc::c_uint,
            b"((void*)0) != con->plugin_ctx\0" as *const u8 as *const libc::c_char,
        );
    }
    return con;
}
unsafe extern "C" fn connection_free(con: *mut connection) {
    let r: *mut request_st = &mut (*con).request;
    connection_reset(con);
    if (*con).write_queue != &mut (*r).write_queue as *mut chunkqueue {
        chunkqueue_free((*con).write_queue);
    }
    if (*con).read_queue != &mut (*r).read_queue as *mut chunkqueue {
        chunkqueue_free((*con).read_queue);
    }
    request_free_data(r);
    free((*con).plugin_ctx as *mut libc::c_void);
    free((*con).dst_addr_buf.ptr as *mut libc::c_void);
    free(con as *mut libc::c_void);
}
#[no_mangle]
pub unsafe extern "C" fn connections_pool_clear(srv: *mut server) {
    let mut con: *mut connection = 0 as *mut connection;
    loop {
        con = (*srv).conns_pool;
        if con.is_null() {
            break;
        }
        (*srv).conns_pool = (*con).next;
        connection_free(con);
    }
}
#[no_mangle]
#[cold]
pub unsafe extern "C" fn connections_free(mut srv: *mut server) {
    connections_pool_clear(srv);
    let mut con: *mut connection = 0 as *mut connection;
    loop {
        con = (*srv).conns;
        if con.is_null() {
            break;
        }
        (*srv).conns = (*con).next;
        connection_free(con);
    }
}
unsafe extern "C" fn connection_reset(mut con: *mut connection) {
    let r: *mut request_st = &mut (*con).request;
    request_reset(r);
    (*r).bytes_read_ckpt = 0 as libc::c_int as off_t;
    (*r).bytes_written_ckpt = 0 as libc::c_int as off_t;
    (*con).is_readable = 1 as libc::c_int as libc::c_schar;
    (*con).bytes_written = 0 as libc::c_int as off_t;
    (*con).bytes_written_cur_second = 0 as libc::c_int as off_t;
    (*con).bytes_read = 0 as libc::c_int as off_t;
}
#[cold]
unsafe extern "C" fn connection_discard_blank_line(
    cq: *mut chunkqueue,
    mut header_len: uint32_t,
) -> *mut chunk {
    chunkqueue_mark_written(cq, header_len as off_t);
    return (*cq).first;
}
unsafe extern "C" fn connection_read_header_more(
    mut con: *mut connection,
    mut cq: *mut chunkqueue,
    mut c: *mut chunk,
    olen: size_t,
) -> *mut chunk {
    if (c.is_null() || ((*c).next).is_null())
        && (*con).is_readable as libc::c_int > 0 as libc::c_int
    {
        (*con).read_idle_ts = log_monotonic_secs;
        if 0 as libc::c_int
            != ((*con).network_read).expect("non-null function pointer")(
                con,
                cq,
                (256 as libc::c_int * 1024 as libc::c_int) as off_t,
            )
        {
            let r: *mut request_st = &mut (*con).request;
            connection_set_state_error(r, CON_STATE_ERROR);
        }
        let r_0: *mut request_st = &mut (*con).request;
        if (*r_0).http_version as libc::c_int == HTTP_VERSION_2 as libc::c_int {
            return 0 as *mut chunk;
        }
    }
    if (*cq).first != (*cq).last && 0 as libc::c_int as libc::c_ulong != olen {
        let clen: size_t = chunkqueue_length(cq) as size_t;
        let mut block: size_t = olen
            .wrapping_add((16384 as libc::c_int - 1 as libc::c_int) as libc::c_ulong)
            & !(16384 as libc::c_int - 1 as libc::c_int) as libc::c_ulong;
        block = (block as libc::c_ulong).wrapping_add(
            (if block.wrapping_sub(olen) > 1024 as libc::c_int as libc::c_ulong {
                0 as libc::c_int
            } else {
                16384 as libc::c_int
            }) as libc::c_ulong,
        ) as size_t as size_t;
        chunkqueue_compact_mem(cq, if block > clen { clen } else { block });
    }
    c = (*cq).first;
    return if !c.is_null()
        && ((*c).offset as size_t).wrapping_add(olen) < buffer_clen((*c).mem) as libc::c_ulong
    {
        c
    } else {
        0 as *mut chunk
    };
}
#[cold]
unsafe extern "C" fn connection_transition_h2(h2r: *mut request_st, con: *mut connection) {
    buffer_copy_string_len(
        &mut (*h2r).target,
        b"*\0" as *const u8 as *const libc::c_char,
        (::core::mem::size_of::<[libc::c_char; 2]>() as libc::c_ulong as uint32_t)
            .wrapping_sub(1 as libc::c_int as libc::c_uint) as size_t,
    );
    buffer_copy_string_len(
        &mut (*h2r).target_orig,
        b"*\0" as *const u8 as *const libc::c_char,
        (::core::mem::size_of::<[libc::c_char; 2]>() as libc::c_ulong as uint32_t)
            .wrapping_sub(1 as libc::c_int as libc::c_uint) as size_t,
    );
    buffer_copy_string_len(
        &mut (*h2r).uri.path,
        b"*\0" as *const u8 as *const libc::c_char,
        (::core::mem::size_of::<[libc::c_char; 2]>() as libc::c_ulong as uint32_t)
            .wrapping_sub(1 as libc::c_int as libc::c_uint) as size_t,
    );
    (*h2r).http_method = HTTP_METHOD_PRI;
    (*h2r).reqbody_length = -(1 as libc::c_int) as off_t;
    (*h2r).conf.stream_request_body = ((*h2r).conf.stream_request_body as libc::c_int
        | (1 as libc::c_int) << 15 as libc::c_int)
        as libc::c_ushort;
    if (*h2r).state as libc::c_uint != CON_STATE_ERROR as libc::c_int as libc::c_uint {
        (*h2r).state = CON_STATE_WRITE;
    }
    if ((*con).h2).is_null() {
        h2_init_con(h2r, con, 0 as *const buffer);
    }
}
#[inline(never)]
unsafe extern "C" fn connection_handle_read_state(con: *mut connection) -> libc::c_int {
    let cq: *mut chunkqueue = (*con).read_queue;
    let mut c: *mut chunk = (*cq).first;
    let mut clen: uint32_t = 0 as libc::c_int as uint32_t;
    let mut header_len: uint32_t = 0 as libc::c_int as uint32_t;
    let r: *mut request_st = &mut (*con).request;
    let mut keepalive_request_start: uint8_t = 0 as libc::c_int as uint8_t;
    let mut pipelined_request_start: uint8_t = 0 as libc::c_int as uint8_t;
    let mut discard_blank: uint8_t = 0 as libc::c_int as uint8_t;
    let mut hoff: [libc::c_ushort; 8192] = [0; 8192];
    if (*con).request_count > 1 as libc::c_int as libc::c_uint {
        discard_blank = 1 as libc::c_int as uint8_t;
        if (*con).bytes_read == (*r).bytes_read_ckpt {
            keepalive_request_start = 1 as libc::c_int as uint8_t;
            if !c.is_null() {
                pipelined_request_start = 1 as libc::c_int as uint8_t;
                (*con).is_readable = 1 as libc::c_int as libc::c_schar;
            }
        }
    }
    let mut current_block_30: u64;
    loop {
        if !c.is_null() {
            clen = (buffer_clen((*c).mem) as libc::c_long - (*c).offset) as uint32_t;
            if !(0 as libc::c_int as libc::c_uint == clen) {
                if ((*c).offset
                    > (32767 as libc::c_int * 2 as libc::c_int + 1 as libc::c_int) as libc::c_long)
                    as libc::c_int as libc::c_long
                    != 0
                {
                    chunkqueue_compact_mem_offset(cq);
                }
                hoff[0 as libc::c_int as usize] = 1 as libc::c_int as libc::c_ushort;
                hoff[1 as libc::c_int as usize] = (*c).offset as libc::c_ushort;
                header_len = http_header_parse_hoff(
                    ((*(*c).mem).ptr).offset((*c).offset as isize),
                    clen,
                    hoff.as_mut_ptr(),
                );
                let max_request_field_size: uint32_t = (*r).conf.max_request_field_size;
                if (if header_len != 0 { header_len } else { clen }) > max_request_field_size
                    || hoff[0 as libc::c_int as usize] as libc::c_ulong
                        >= (::core::mem::size_of::<[libc::c_ushort; 8192]>() as libc::c_ulong)
                            .wrapping_div(::core::mem::size_of::<libc::c_ushort>() as libc::c_ulong)
                            .wrapping_sub(1 as libc::c_int as libc::c_ulong)
                {
                    log_error(
                        (*r).conf.errh,
                        b"/home/kkysen/work/rust/lighttpd/src/connections.c\0" as *const u8
                            as *const libc::c_char,
                        689 as libc::c_int as libc::c_uint,
                        b"%s\0" as *const u8 as *const libc::c_char,
                        b"oversized request-header -> sending Status 431\0" as *const u8
                            as *const libc::c_char,
                    );
                    (*r).http_status = 431 as libc::c_int;
                    (*r).keep_alive = 0 as libc::c_int as int8_t;
                    return 1 as libc::c_int;
                }
                if (0 as libc::c_int as libc::c_uint != header_len) as libc::c_int as libc::c_long
                    != 0
                {
                    if (hoff[0 as libc::c_int as usize] as libc::c_int > 1 as libc::c_int)
                        as libc::c_int as libc::c_long
                        != 0
                    {
                        break;
                    }
                    if discard_blank != 0 {
                        if header_len == clen {
                            current_block_30 = 2968425633554183086;
                        } else {
                            let ch: libc::c_int = *((*(*c).mem).ptr)
                                .offset(((*c).offset + header_len as libc::c_long) as isize)
                                as libc::c_int;
                            if ch != '\r' as i32 && ch != '\n' as i32 {
                                discard_blank = 0 as libc::c_int as uint8_t;
                                clen = 0 as libc::c_int as uint32_t;
                                c = connection_discard_blank_line(cq, header_len);
                                current_block_30 = 2968425633554183086;
                            } else {
                                current_block_30 = 8693738493027456495;
                            }
                        }
                    } else {
                        current_block_30 = 8693738493027456495;
                    }
                } else {
                    current_block_30 = 8693738493027456495;
                }
                match current_block_30 {
                    2968425633554183086 => {}
                    _ => {
                        if (*((*(*c).mem).ptr as *mut libc::c_uchar).offset((*c).offset as isize)
                            as libc::c_int)
                            < 32 as libc::c_int
                        {
                            log_error(
                                (*r).conf.errh,
                                b"/home/kkysen/work/rust/lighttpd/src/connections.c\0" as *const u8
                                    as *const libc::c_char,
                                717 as libc::c_int as libc::c_uint,
                                b"%s (%s)\0" as *const u8 as *const libc::c_char,
                                if *((*(*c).mem).ptr).offset((*c).offset as isize) as libc::c_int
                                    == 0x16 as libc::c_int
                                {
                                    b"unexpected TLS ClientHello on clear port\0" as *const u8
                                        as *const libc::c_char
                                } else {
                                    b"invalid request-line -> sending Status 400\0" as *const u8
                                        as *const libc::c_char
                                },
                                (*con).dst_addr_buf.ptr,
                            );
                            (*r).http_status = 400 as libc::c_int;
                            (*r).keep_alive = 0 as libc::c_int as int8_t;
                            return 1 as libc::c_int;
                        }
                    }
                }
            }
        }
        c = connection_read_header_more(con, cq, c, clen as size_t);
        if c.is_null() {
            break;
        }
    }
    if keepalive_request_start != 0 {
        if (*con).bytes_read > (*r).bytes_read_ckpt {
            (*r).start_hp.tv_sec = log_epoch_secs;
            if (*r).conf.high_precision_timestamps != 0 {
                clock_gettime(0 as libc::c_int, &mut (*r).start_hp);
            }
        }
        if pipelined_request_start as libc::c_int != 0 && !c.is_null() {
            (*con).read_idle_ts = log_monotonic_secs;
        }
    }
    if c.is_null() {
        return 0 as libc::c_int;
    }
    let hdrs: *mut libc::c_char =
        ((*(*c).mem).ptr).offset(hoff[1 as libc::c_int as usize] as libc::c_int as isize);
    if (*con).request_count > 1 as libc::c_int as libc::c_uint {
        request_reset_ex(r);
    } else if (*con).is_ssl_sock == 0
        && (*r).conf.h2proto as libc::c_int != 0
        && hoff[0 as libc::c_int as usize] as libc::c_int == 2 as libc::c_int
        && hoff[2 as libc::c_int as usize] as libc::c_int == 16 as libc::c_int
        && *hdrs.offset(0 as libc::c_int as isize) as libc::c_int == 'P' as i32
        && *hdrs.offset(1 as libc::c_int as isize) as libc::c_int == 'R' as i32
        && *hdrs.offset(2 as libc::c_int as isize) as libc::c_int == 'I' as i32
        && *hdrs.offset(3 as libc::c_int as isize) as libc::c_int == ' ' as i32
    {
        (*r).http_version = HTTP_VERSION_2;
        return 0 as libc::c_int;
    }
    (*r).rqst_header_len = header_len;
    if (*r).conf.log_request_header != 0 {
        log_error_multiline(
            (*r).conf.errh,
            b"/home/kkysen/work/rust/lighttpd/src/connections.c\0" as *const u8
                as *const libc::c_char,
            770 as libc::c_int as libc::c_uint,
            hdrs,
            header_len as size_t,
            b"fd:%d rqst: \0" as *const u8 as *const libc::c_char,
            (*con).fd,
        );
    }
    http_request_headers_process(
        r,
        hdrs,
        hoff.as_mut_ptr(),
        (*con).proto_default_port as libc::c_int,
    );
    chunkqueue_mark_written(cq, (*r).rqst_header_len as off_t);
    if (*r).rqst_htags & (1 as libc::c_ulong) << HTTP_HEADER_UPGRADE as libc::c_int != 0
        && 0 as libc::c_int == (*r).http_status
        && h2_check_con_upgrade_h2c(r) != 0
    {
        (*r).conditional_is_valid = ((1 as libc::c_int) << COMP_SERVER_SOCKET as libc::c_int
            | (1 as libc::c_int) << COMP_HTTP_REMOTE_IP as libc::c_int)
            as uint32_t;
        return 0 as libc::c_int;
    }
    return 1 as libc::c_int;
}
unsafe extern "C" fn connection_handle_fdevent(
    context: *mut libc::c_void,
    revents: libc::c_int,
) -> handler_t {
    let mut con: *mut connection = context as *mut connection;
    let is_ssl_sock: libc::c_int = (*con).is_ssl_sock as libc::c_int;
    connection_jq_append(con);
    if revents & !(0x1 as libc::c_int | 0x4 as libc::c_int) != 0 {
        (*con).revents_err = ((*con).revents_err as libc::c_int
            | revents & !(0x1 as libc::c_int | 0x4 as libc::c_int))
            as uint16_t;
    }
    if revents & (0x1 as libc::c_int | 0x4 as libc::c_int) != 0 {
        if is_ssl_sock != 0 {
            (*con).is_writable = 1 as libc::c_int as libc::c_schar;
            (*con).is_readable = (*con).is_writable;
        } else {
            if revents & 0x1 as libc::c_int != 0 {
                (*con).is_readable = 1 as libc::c_int as libc::c_schar;
            }
            if revents & 0x4 as libc::c_int != 0 {
                (*con).is_writable = 1 as libc::c_int as libc::c_schar;
            }
        }
    }
    return HANDLER_FINISHED;
}
#[cold]
unsafe extern "C" fn connection_read_cq_err(mut con: *mut connection) -> libc::c_int {
    let r: *mut request_st = &mut (*con).request;
    match *__errno_location() {
        11 => return 0 as libc::c_int,
        4 => {
            (*con).is_readable = 1 as libc::c_int as libc::c_schar;
            return 0 as libc::c_int;
        }
        104 => {}
        _ => {
            log_perror(
                (*r).conf.errh,
                b"/home/kkysen/work/rust/lighttpd/src/connections.c\0" as *const u8
                    as *const libc::c_char,
                845 as libc::c_int as libc::c_uint,
                b"connection closed - read failed\0" as *const u8 as *const libc::c_char,
            );
        }
    }
    connection_set_state_error(r, CON_STATE_ERROR);
    return -(1 as libc::c_int);
}
unsafe extern "C" fn connection_read_cq(
    mut con: *mut connection,
    mut cq: *mut chunkqueue,
    mut max_bytes: off_t,
) -> libc::c_int {
    let mut len: ssize_t = 0;
    let mut mem_len: size_t = 0 as libc::c_int as size_t;
    loop {
        let mut ckpt: *mut chunk = (*cq).last;
        let mem: *mut libc::c_char = chunkqueue_get_memory(cq, &mut mem_len);
        if mem_len > max_bytes as size_t {
            mem_len = max_bytes as size_t;
        }
        len = read((*con).fd, mem as *mut libc::c_void, mem_len);
        chunkqueue_use_memory(
            cq,
            ckpt,
            (if len > 0 as libc::c_int as libc::c_long {
                len
            } else {
                0 as libc::c_int as libc::c_long
            }) as size_t,
        );
        if len != mem_len as ssize_t {
            (*con).is_readable = 0 as libc::c_int as libc::c_schar;
            if len > 0 as libc::c_int as libc::c_long {
                (*con).bytes_read += len;
                return 0 as libc::c_int;
            } else if 0 as libc::c_int as libc::c_long == len {
                return -(2 as libc::c_int);
            } else {
                return connection_read_cq_err(con);
            }
        }
        (*con).bytes_read += len;
        max_bytes -= len;
        let mut frd: libc::c_int = 0;
        mem_len = if 0 as libc::c_int
            == fdevent_ioctl_fionread((*con).fd, 0o140000 as libc::c_int, &mut frd)
        {
            if (frd as libc::c_long) < max_bytes {
                frd as size_t
            } else {
                max_bytes as size_t
            }
        } else {
            0 as libc::c_int as libc::c_ulong
        };
        if !(max_bytes != 0) {
            break;
        }
    }
    return 0 as libc::c_int;
}
unsafe extern "C" fn connection_write_cq(
    mut con: *mut connection,
    mut cq: *mut chunkqueue,
    mut max_bytes: off_t,
) -> libc::c_int {
    let r: *mut request_st = &mut (*con).request;
    return ((*(*con).srv).network_backend_write).expect("non-null function pointer")(
        (*con).fd,
        cq,
        max_bytes,
        (*r).conf.errh,
    );
}
#[no_mangle]
pub unsafe extern "C" fn connection_accepted(
    mut srv: *mut server,
    mut srv_socket: *const server_socket,
    mut cnt_addr: *mut sock_addr,
    mut cnt: libc::c_int,
) -> *mut connection {
    let mut con: *mut connection = 0 as *mut connection;
    (*srv).cur_fds += 1;
    (*srv).con_opened += 1;
    con = connections_get_new_connection(srv);
    (*con).fd = cnt;
    (*con).fdn = fdevent_register(
        (*srv).ev,
        (*con).fd,
        Some(
            connection_handle_fdevent
                as unsafe extern "C" fn(*mut libc::c_void, libc::c_int) -> handler_t,
        ),
        con as *mut libc::c_void,
    );
    (*con).network_read = Some(
        connection_read_cq
            as unsafe extern "C" fn(*mut connection, *mut chunkqueue, off_t) -> libc::c_int,
    );
    (*con).network_write = Some(
        connection_write_cq
            as unsafe extern "C" fn(*mut connection, *mut chunkqueue, off_t) -> libc::c_int,
    );
    (*con).reqbody_read = Some(
        connection_handle_read_post_state as unsafe extern "C" fn(*mut request_st) -> handler_t,
    );
    let r: *mut request_st = &mut (*con).request;
    (*r).state = CON_STATE_REQUEST_START;
    (*con).connection_start = log_monotonic_secs;
    (*con).dst_addr = *cnt_addr;
    sock_addr_cache_inet_ntop_copy_buffer(&mut (*con).dst_addr_buf, &mut (*con).dst_addr);
    (*con).srv_socket = srv_socket;
    (*con).is_ssl_sock = (*srv_socket).is_ssl as libc::c_char;
    (*con).proto_default_port = 80 as libc::c_int as uint16_t;
    config_cond_cache_reset(r);
    (*r).conditional_is_valid = ((1 as libc::c_int) << COMP_SERVER_SOCKET as libc::c_int
        | (1 as libc::c_int) << COMP_HTTP_REMOTE_IP as libc::c_int)
        as uint32_t;
    if HANDLER_GO_ON as libc::c_int as libc::c_uint
        != plugins_call_handle_connection_accept(con) as libc::c_uint
    {
        connection_reset(con);
        connection_close(con);
        return 0 as *mut connection;
    }
    if (*r).http_status < 0 as libc::c_int {
        (*r).state = CON_STATE_WRITE;
    }
    return con;
}
#[cold]
#[inline(never)]
unsafe extern "C" fn connection_get_state(mut state: request_state_t) -> *const libc::c_char {
    match state as libc::c_uint {
        0 => return b"connect\0" as *const u8 as *const libc::c_char,
        2 => return b"read\0" as *const u8 as *const libc::c_char,
        4 => return b"readpost\0" as *const u8 as *const libc::c_char,
        7 => return b"write\0" as *const u8 as *const libc::c_char,
        10 => return b"close\0" as *const u8 as *const libc::c_char,
        9 => return b"error\0" as *const u8 as *const libc::c_char,
        5 => return b"handle-req\0" as *const u8 as *const libc::c_char,
        1 => return b"req-start\0" as *const u8 as *const libc::c_char,
        3 => return b"req-end\0" as *const u8 as *const libc::c_char,
        6 => return b"resp-start\0" as *const u8 as *const libc::c_char,
        8 => return b"resp-end\0" as *const u8 as *const libc::c_char,
        _ => return b"(unknown)\0" as *const u8 as *const libc::c_char,
    };
}
unsafe extern "C" fn connection_state_machine_loop(r: *mut request_st, con: *mut connection) {
    let mut ostate: request_state_t = CON_STATE_CONNECT;
    let mut current_block_34: u64;
    loop {
        if (*r).conf.log_state_handling != 0 {
            log_error(
                (*r).conf.errh,
                b"/home/kkysen/work/rust/lighttpd/src/connections.c\0" as *const u8
                    as *const libc::c_char,
                987 as libc::c_int as libc::c_uint,
                b"state for fd:%d id:%d %s\0" as *const u8 as *const libc::c_char,
                (*con).fd,
                (*r).h2id,
                connection_get_state((*r).state),
            );
        }
        ostate = (*r).state;
        match ostate as libc::c_uint {
            1 => {
                (*r).start_hp.tv_sec = log_epoch_secs;
                (*con).read_idle_ts = log_monotonic_secs;
                if (*r).conf.high_precision_timestamps != 0 {
                    clock_gettime(0 as libc::c_int, &mut (*r).start_hp);
                }
                (*con).request_count = ((*con).request_count).wrapping_add(1);
                (*r).loops_per_request = 0 as libc::c_int as libc::c_char;
                (*r).state = CON_STATE_READ;
                current_block_34 = 10812489618260056270;
            }
            2 => {
                current_block_34 = 10812489618260056270;
            }
            3 => {
                current_block_34 = 8408407732042155054;
            }
            4 | 5 => {
                current_block_34 = 4168299148304325780;
            }
            7 => {
                current_block_34 = 7904287085116935934;
            }
            8 | 9 => {
                current_block_34 = 12089945892375683188;
            }
            10 => {
                connection_handle_close_state(con);
                current_block_34 = 792017965103506125;
            }
            0 => {
                current_block_34 = 792017965103506125;
            }
            _ => {
                log_error(
                    (*r).conf.errh,
                    b"/home/kkysen/work/rust/lighttpd/src/connections.c\0" as *const u8
                        as *const libc::c_char,
                    1064 as libc::c_int as libc::c_uint,
                    b"unknown state: %d %d\0" as *const u8 as *const libc::c_char,
                    (*con).fd,
                    (*r).state as libc::c_uint,
                );
                current_block_34 = 792017965103506125;
            }
        }
        match current_block_34 {
            10812489618260056270 => {
                if connection_handle_read_state(con) == 0 {
                    if (*r).http_version as libc::c_int == HTTP_VERSION_2 as libc::c_int {
                        connection_transition_h2(r, con);
                        connection_state_machine_h2(r, con);
                        return;
                    }
                    current_block_34 = 792017965103506125;
                } else {
                    current_block_34 = 8408407732042155054;
                }
            }
            _ => {}
        }
        match current_block_34 {
            8408407732042155054 => {
                (*r).state = (if 0 as libc::c_int as libc::c_long == (*r).reqbody_length {
                    CON_STATE_HANDLE_REQUEST as libc::c_int
                } else {
                    CON_STATE_READ_POST as libc::c_int
                }) as request_state_t;
                current_block_34 = 4168299148304325780;
            }
            _ => {}
        }
        match current_block_34 {
            4168299148304325780 => match http_response_handler(r) as libc::c_uint {
                0 | 1 => {
                    if (*r).http_version as libc::c_int > HTTP_VERSION_1_1 as libc::c_int {
                        h2_send_headers(r, con);
                    } else {
                        http_response_write_header(r);
                    }
                    (*r).state = CON_STATE_WRITE;
                    current_block_34 = 7904287085116935934;
                }
                3 => return,
                _ => {
                    connection_set_state_error(r, CON_STATE_ERROR);
                    current_block_34 = 792017965103506125;
                }
            },
            _ => {}
        }
        match current_block_34 {
            7904287085116935934 => {
                if connection_handle_write_state(r, con) == CON_STATE_WRITE as libc::c_int {
                    return;
                }
                current_block_34 = 12089945892375683188;
            }
            _ => {}
        }
        match current_block_34 {
            12089945892375683188 => {
                if (*r).http_version as libc::c_int > HTTP_VERSION_1_1 as libc::c_int
                    && r != &mut (*con).request as *mut request_st
                {
                    return;
                }
                connection_handle_response_end_state(r, con);
                ostate = CON_STATE_RESPONSE_END;
            }
            _ => {}
        }
        if !(ostate as libc::c_uint != (*r).state as libc::c_uint) {
            break;
        }
    }
}
#[cold]
unsafe extern "C" fn connection_revents_err(r: *mut request_st, con: *mut connection) {
    let revents: libc::c_int = (*con).revents_err as libc::c_int;
    (*con).revents_err = 0 as libc::c_int as uint16_t;
    if (*r).state as libc::c_uint == CON_STATE_CLOSE as libc::c_int as libc::c_uint {
        (*con).close_timeout_ts =
            log_monotonic_secs - (5 as libc::c_int + 1 as libc::c_int) as libc::c_long;
    } else if revents & 0x10 as libc::c_int != 0 {
        connection_set_state_error(r, CON_STATE_ERROR);
    } else if revents & 0x2000 as libc::c_int != 0 {
        let mut events: libc::c_int = if !((*con).fdn).is_null() {
            (*(*con).fdn).events
        } else {
            0 as libc::c_int
        };
        events &= !(0x1 as libc::c_int | 0x2000 as libc::c_int);
        (*r).conf.stream_request_body = ((*r).conf.stream_request_body as libc::c_int
            & !((1 as libc::c_int) << 1 as libc::c_int | (1 as libc::c_int) << 15 as libc::c_int))
            as libc::c_ushort;
        (*r).conf.stream_request_body = ((*r).conf.stream_request_body as libc::c_int
            | (1 as libc::c_int) << 12 as libc::c_int)
            as libc::c_ushort;
        (*con).is_readable = 1 as libc::c_int as libc::c_schar;
        if chunkqueue_is_empty((*con).read_queue) != 0 {
            (*r).keep_alive = 0 as libc::c_int as int8_t;
        }
        if (*r).reqbody_length < -(1 as libc::c_int) as libc::c_long {
            (*r).reqbody_length = (*r).reqbody_queue.bytes_in;
        }
        if sock_addr_get_family(&mut (*con).dst_addr) == 1 as libc::c_int {
            fdevent_fdnode_event_set((*(*con).srv).ev, (*con).fdn, events);
        } else if fdevent_is_tcp_half_closed((*con).fd) != 0 {
            (*r).conf.stream_request_body = ((*r).conf.stream_request_body as libc::c_int
                | (1 as libc::c_int) << 13 as libc::c_int)
                as libc::c_ushort;
            fdevent_fdnode_event_set((*(*con).srv).ev, (*con).fdn, events);
        } else {
            connection_set_state_error(r, CON_STATE_ERROR);
        }
    } else if revents & 0x8 as libc::c_int != 0 {
        connection_set_state_error(r, CON_STATE_ERROR);
    } else {
        log_error(
            (*r).conf.errh,
            b"/home/kkysen/work/rust/lighttpd/src/connections.c\0" as *const u8
                as *const libc::c_char,
            1123 as libc::c_int as libc::c_uint,
            b"connection closed: poll() -> ??? %d\0" as *const u8 as *const libc::c_char,
            revents,
        );
    };
}
unsafe extern "C" fn connection_set_fdevent_interest(r: *mut request_st, con: *mut connection) {
    if (*con).fd < 0 as libc::c_int {
        return;
    }
    if (*con).revents_err as libc::c_int != 0
        && (*r).state as libc::c_uint != CON_STATE_ERROR as libc::c_int as libc::c_uint
    {
        connection_revents_err(r, con);
        connection_state_machine(con);
        return;
    }
    let mut n: libc::c_int = 0 as libc::c_int;
    let mut current_block_18: u64;
    match (*r).state as libc::c_uint {
        2 => {
            n = 0x1 as libc::c_int;
            if (*r).conf.stream_request_body as libc::c_int
                & (1 as libc::c_int) << 12 as libc::c_int
                == 0
            {
                n |= 0x2000 as libc::c_int;
            }
            current_block_18 = 6009453772311597924;
        }
        7 => {
            if chunkqueue_is_empty((*con).write_queue) == 0
                && 0 as libc::c_int == (*con).is_writable as libc::c_int
                && 0 as libc::c_int == (*con).traffic_limit_reached as libc::c_int
            {
                n |= 0x4 as libc::c_int;
            }
            current_block_18 = 10485137304145741672;
        }
        4 => {
            current_block_18 = 10485137304145741672;
        }
        10 => {
            n = 0x1 as libc::c_int;
            current_block_18 = 6009453772311597924;
        }
        0 => return,
        _ => {
            current_block_18 = 6009453772311597924;
        }
    }
    match current_block_18 {
        10485137304145741672 => {
            if (*r).conf.stream_request_body as libc::c_int
                & (1 as libc::c_int) << 15 as libc::c_int
                != 0
            {
                n |= 0x1 as libc::c_int;
            }
            if (*r).conf.stream_request_body as libc::c_int
                & (1 as libc::c_int) << 12 as libc::c_int
                == 0
            {
                n |= 0x2000 as libc::c_int;
            }
        }
        _ => {}
    }
    let events: libc::c_int = if !((*con).fdn).is_null() {
        (*(*con).fdn).events
    } else {
        0 as libc::c_int
    };
    if ((*con).is_readable as libc::c_int) < 0 as libc::c_int {
        (*con).is_readable = 0 as libc::c_int as libc::c_schar;
        n |= 0x1 as libc::c_int;
    }
    if ((*con).is_writable as libc::c_int) < 0 as libc::c_int {
        (*con).is_writable = 0 as libc::c_int as libc::c_schar;
        n |= 0x4 as libc::c_int;
    }
    if events & 0x2000 as libc::c_int != 0 {
        n |= 0x2000 as libc::c_int;
    }
    if n == events {
        return;
    }
    if n & 0x1 as libc::c_int != 0 && events & 0x1 as libc::c_int == 0 {
        (*con).read_idle_ts = log_monotonic_secs;
    }
    if n & 0x4 as libc::c_int != 0 && events & 0x4 as libc::c_int == 0 {
        (*con).write_request_ts = log_monotonic_secs;
    }
    fdevent_fdnode_event_set((*(*con).srv).ev, (*con).fdn, n);
}
#[cold]
unsafe extern "C" fn connection_request_end_h2(h2r: *mut request_st, con: *mut connection) {
    if (*h2r).keep_alive as libc::c_int >= 0 as libc::c_int {
        (*h2r).keep_alive = -(1 as libc::c_int) as int8_t;
        h2_send_goaway(con, H2_E_NO_ERROR);
    } else {
        h2_send_goaway(con, H2_E_ENHANCE_YOUR_CALM);
    };
}
unsafe extern "C" fn connection_state_machine_h2(h2r: *mut request_st, con: *mut connection) {
    let h2c: *mut h2con = (*con).h2;
    if (*h2c).sent_goaway <= 0 as libc::c_int
        && (chunkqueue_is_empty((*con).read_queue) != 0 || h2_parse_frames(con) != 0)
        && (*con).is_readable as libc::c_int > 0 as libc::c_int
    {
        let cq: *mut chunkqueue = (*con).read_queue;
        let mark: off_t = (*cq).bytes_in;
        if 0 as libc::c_int
            == ((*con).network_read).expect("non-null function pointer")(
                con,
                cq,
                (256 as libc::c_int * 1024 as libc::c_int) as off_t,
            )
        {
            if mark < (*cq).bytes_in {
                h2_parse_frames(con);
            }
        } else {
            (*h2c).sent_goaway = H2_E_CONNECT_ERROR as libc::c_int;
            connection_set_state_error(h2r, CON_STATE_ERROR);
        }
    }
    let mut resched: libc::c_int = 0 as libc::c_int;
    if (*h2c).sent_goaway <= 0 as libc::c_int && (*h2c).rused != 0 {
        let mut max_bytes: off_t = if (*con).is_writable as libc::c_int > 0 as libc::c_int {
            connection_write_throttle(con, (256 as libc::c_int * 1024 as libc::c_int) as off_t)
        } else {
            0 as libc::c_int as libc::c_long
        };
        let cqlen: off_t = chunkqueue_length((*con).write_queue);
        if cqlen > 8192 as libc::c_int as libc::c_long
            && max_bytes > 65536 as libc::c_int as libc::c_long
        {
            max_bytes = 65536 as libc::c_int as off_t;
        }
        max_bytes -= cqlen;
        if max_bytes < 0 as libc::c_int as libc::c_long {
            max_bytes = 0 as libc::c_int as off_t;
        }
        let mut current_block_33: u64;
        let mut i: uint32_t = 0 as libc::c_int as uint32_t;
        while i < (*h2c).rused {
            let r: *mut request_st = (*h2c).r[i as usize];
            connection_state_machine_loop(r, con);
            if !(((*r).state as libc::c_uint) < CON_STATE_WRITE as libc::c_int as libc::c_uint) {
                if (*r).state as libc::c_uint == CON_STATE_WRITE as libc::c_int as libc::c_uint {
                    if (chunkqueue_is_empty(&mut (*r).write_queue) == 0) as libc::c_int
                        as libc::c_long
                        != 0
                        && max_bytes != 0
                        && ((*r).resp_body_finished as libc::c_int != 0
                            || (*r).conf.stream_response_body as libc::c_int
                                & ((1 as libc::c_int) << 0 as libc::c_int
                                    | (1 as libc::c_int) << 1 as libc::c_int)
                                != 0)
                    {
                        let mut dlen: uint32_t = if max_bytes > 32768 as libc::c_int as libc::c_long
                        {
                            32768 as libc::c_int as libc::c_uint
                        } else {
                            max_bytes as uint32_t
                        };
                        dlen = h2_send_cqdata(r, con, &mut (*r).write_queue, dlen);
                        if dlen != 0 {
                            max_bytes -= dlen as off_t;
                            if chunkqueue_is_empty(&mut (*r).write_queue) == 0 {
                                resched |= 1 as libc::c_int;
                            }
                        }
                    }
                    if chunkqueue_is_empty(&mut (*r).write_queue) == 0
                        || (*r).resp_body_finished == 0
                    {
                        current_block_33 = 8236137900636309791;
                    } else {
                        (*r).state = CON_STATE_RESPONSE_END;
                        if (*r).conf.log_state_handling as libc::c_long != 0 {
                            connection_state_machine_loop(r, con);
                        }
                        current_block_33 = 4775909272756257391;
                    }
                } else {
                    current_block_33 = 4775909272756257391;
                }
                match current_block_33 {
                    8236137900636309791 => {}
                    _ => {
                        if (*h2c).rused as libc::c_ulong
                            == (::core::mem::size_of::<[*mut request_st; 8]>() as libc::c_ulong)
                                .wrapping_div(
                                    ::core::mem::size_of::<*mut request_st>() as libc::c_ulong
                                )
                            && chunkqueue_is_empty((*con).read_queue) == 0
                        {
                            resched |= 2 as libc::c_int;
                        }
                        h2_send_end_stream(r, con);
                        let alive: libc::c_int = (*r).keep_alive as libc::c_int;
                        h2_retire_stream(r, con);
                        i = i.wrapping_sub(1);
                        if alive < 0 as libc::c_int {
                            connection_request_end_h2(h2r, con);
                        }
                    }
                }
            }
            i = i.wrapping_add(1);
        }
        if 0 as libc::c_int as libc::c_long == max_bytes {
            resched |= 1 as libc::c_int;
        }
    }
    if (*h2c).sent_goaway > 0 as libc::c_int && (*h2c).rused != 0 {
        let mut i_0: uint32_t = 0 as libc::c_int as uint32_t;
        while i_0 < (*h2c).rused {
            let r_0: *mut request_st = (*h2c).r[i_0 as usize];
            h2_retire_stream(r_0, con);
            i_0 = i_0.wrapping_sub(1);
            i_0 = i_0.wrapping_add(1);
        }
    }
    if (*h2r).state as libc::c_uint == CON_STATE_WRITE as libc::c_int as libc::c_uint {
        if chunkqueue_is_empty((*con).write_queue) == 0 {
            connection_handle_write(h2r, con);
        }
        if chunkqueue_is_empty((*con).write_queue) != 0
            && 0 as libc::c_int as libc::c_uint == (*h2c).rused
            && (*h2c).sent_goaway != 0
        {
            (*h2r).state = CON_STATE_RESPONSE_END;
        }
    }
    if (*h2r).state as libc::c_uint == CON_STATE_WRITE as libc::c_int as libc::c_uint {
        if resched & 1 as libc::c_int != 0
            && (*con).is_writable as libc::c_int > 0 as libc::c_int
            && (*con).traffic_limit_reached == 0
            || resched & 2 as libc::c_int != 0
        {
            connection_jq_append(con);
        }
        if h2_want_read(con) != 0 {
            (*h2r).conf.stream_request_body = ((*h2r).conf.stream_request_body as libc::c_int
                | (1 as libc::c_int) << 15 as libc::c_int)
                as libc::c_ushort;
        } else {
            (*h2r).conf.stream_request_body = ((*h2r).conf.stream_request_body as libc::c_int
                & !((1 as libc::c_int) << 15 as libc::c_int))
                as libc::c_ushort;
        }
    } else {
        connection_state_machine_loop(h2r, con);
    }
    connection_set_fdevent_interest(h2r, con);
}
unsafe extern "C" fn connection_state_machine_h1(r: *mut request_st, con: *mut connection) {
    let log_state_handling: libc::c_int = (*r).conf.log_state_handling as libc::c_int;
    if log_state_handling != 0 {
        log_error(
            (*r).conf.errh,
            b"/home/kkysen/work/rust/lighttpd/src/connections.c\0" as *const u8
                as *const libc::c_char,
            1368 as libc::c_int as libc::c_uint,
            b"state at enter %d %s\0" as *const u8 as *const libc::c_char,
            (*con).fd,
            connection_get_state((*r).state),
        );
    }
    connection_state_machine_loop(r, con);
    if log_state_handling != 0 {
        log_error(
            (*r).conf.errh,
            b"/home/kkysen/work/rust/lighttpd/src/connections.c\0" as *const u8
                as *const libc::c_char,
            1375 as libc::c_int as libc::c_uint,
            b"state at exit: %d %s\0" as *const u8 as *const libc::c_char,
            (*con).fd,
            connection_get_state((*r).state),
        );
    }
    connection_set_fdevent_interest(r, con);
}
#[no_mangle]
pub unsafe extern "C" fn connection_state_machine(con: *mut connection) {
    let r: *mut request_st = &mut (*con).request;
    if (*r).http_version as libc::c_int == HTTP_VERSION_2 as libc::c_int {
        connection_state_machine_h2(r, con);
    } else {
        connection_state_machine_h1(r, con);
    };
}
unsafe extern "C" fn connection_check_timeout(con: *mut connection, cur_ts: unix_time64_t) {
    let waitevents: libc::c_int = if !((*con).fdn).is_null() {
        (*(*con).fdn).events
    } else {
        0 as libc::c_int
    };
    let mut changed: libc::c_int = 0 as libc::c_int;
    let mut t_diff: libc::c_int = 0;
    let r: *mut request_st = &mut (*con).request;
    if (*r).state as libc::c_uint == CON_STATE_CLOSE as libc::c_int as libc::c_uint {
        if cur_ts - (*con).close_timeout_ts > 5 as libc::c_int as libc::c_long {
            changed = 1 as libc::c_int;
        }
    } else if !((*con).h2).is_null()
        && (*r).state as libc::c_uint == CON_STATE_WRITE as libc::c_int as libc::c_uint
    {
        let h2c: *mut h2con = (*con).h2;
        if (*h2c).rused != 0 {
            let mut i: uint32_t = 0 as libc::c_int as uint32_t;
            while i < (*h2c).rused {
                let rr: *mut request_st = (*h2c).r[i as usize];
                if (*rr).state as libc::c_uint == CON_STATE_ERROR as libc::c_int as libc::c_uint {
                    changed = 1 as libc::c_int;
                } else {
                    if (*rr).reqbody_length != (*rr).reqbody_queue.bytes_in {
                        if cur_ts - (*con).read_idle_ts > (*rr).conf.max_read_idle as libc::c_long {
                            if (*rr).conf.log_request_handling != 0 {
                                log_error(
                                    (*rr).conf.errh,
                                    b"/home/kkysen/work/rust/lighttpd/src/connections.c\0"
                                        as *const u8
                                        as *const libc::c_char,
                                    1423 as libc::c_int as libc::c_uint,
                                    b"request aborted - read timeout: %d\0" as *const u8
                                        as *const libc::c_char,
                                    (*con).fd,
                                );
                            }
                            connection_set_state_error(r, CON_STATE_ERROR);
                            changed = 1 as libc::c_int;
                        }
                    }
                    if (*rr).state as libc::c_uint
                        != CON_STATE_READ_POST as libc::c_int as libc::c_uint
                        && (*con).write_request_ts != 0 as libc::c_int as libc::c_long
                    {
                        if cur_ts - (*con).write_request_ts
                            > (*r).conf.max_write_idle as libc::c_long
                        {
                            if (*r).conf.log_timeouts != 0 {
                                log_error(
                                    (*r).conf.errh,
                                    b"/home/kkysen/work/rust/lighttpd/src/connections.c\0"
                                        as *const u8 as *const libc::c_char,
                                    1441 as libc::c_int as libc::c_uint,
                                    b"NOTE: a request from %s for %.*s timed out after writing %lld bytes. We waited %d seconds. If this is a problem, increase server.max-write-idle\0"
                                        as *const u8 as *const libc::c_char,
                                    (*con).dst_addr_buf.ptr,
                                    buffer_clen(&mut (*r).target) as libc::c_int,
                                    (*r).target.ptr,
                                    (*r).write_queue.bytes_out as libc::c_longlong,
                                    (*r).conf.max_write_idle as libc::c_int,
                                );
                            }
                            connection_set_state_error(r, CON_STATE_ERROR);
                            changed = 1 as libc::c_int;
                        }
                    }
                }
                i = i.wrapping_add(1);
            }
        } else if cur_ts - (*con).read_idle_ts > (*con).keep_alive_idle as libc::c_long {
            if (*r).conf.log_request_handling != 0 {
                log_error(
                    (*r).conf.errh,
                    b"/home/kkysen/work/rust/lighttpd/src/connections.c\0" as *const u8
                        as *const libc::c_char,
                    1461 as libc::c_int as libc::c_uint,
                    b"connection closed - keep-alive timeout: %d\0" as *const u8
                        as *const libc::c_char,
                    (*con).fd,
                );
            }
            (*r).state = CON_STATE_RESPONSE_END;
            changed = 1 as libc::c_int;
        }
        if changed != 0 {
            (*con).is_readable = 0 as libc::c_int as libc::c_schar;
        }
    } else if waitevents & 0x1 as libc::c_int != 0 {
        if (*con).request_count == 1 as libc::c_int as libc::c_uint
            || (*r).state as libc::c_uint != CON_STATE_READ as libc::c_int as libc::c_uint
        {
            if cur_ts - (*con).read_idle_ts > (*r).conf.max_read_idle as libc::c_long {
                if (*r).conf.log_request_handling != 0 {
                    log_error(
                        (*r).conf.errh,
                        b"/home/kkysen/work/rust/lighttpd/src/connections.c\0" as *const u8
                            as *const libc::c_char,
                        1479 as libc::c_int as libc::c_uint,
                        b"connection closed - read timeout: %d\0" as *const u8
                            as *const libc::c_char,
                        (*con).fd,
                    );
                }
                connection_set_state_error(r, CON_STATE_ERROR);
                changed = 1 as libc::c_int;
            }
        } else if cur_ts - (*con).read_idle_ts > (*con).keep_alive_idle as libc::c_long {
            if (*r).conf.log_request_handling != 0 {
                log_error(
                    (*r).conf.errh,
                    b"/home/kkysen/work/rust/lighttpd/src/connections.c\0" as *const u8
                        as *const libc::c_char,
                    1490 as libc::c_int as libc::c_uint,
                    b"connection closed - keep-alive timeout: %d\0" as *const u8
                        as *const libc::c_char,
                    (*con).fd,
                );
            }
            connection_set_state_error(r, CON_STATE_ERROR);
            changed = 1 as libc::c_int;
        }
    }
    if (*r).http_version as libc::c_int <= HTTP_VERSION_1_1 as libc::c_int
        && (*r).state as libc::c_uint == CON_STATE_WRITE as libc::c_int as libc::c_uint
        && (*con).write_request_ts != 0 as libc::c_int as libc::c_long
    {
        if cur_ts - (*con).write_request_ts > (*r).conf.max_write_idle as libc::c_long {
            if (*r).conf.log_timeouts != 0 {
                log_error(
                    (*r).conf.errh,
                    b"/home/kkysen/work/rust/lighttpd/src/connections.c\0" as *const u8
                        as *const libc::c_char,
                    1526 as libc::c_int as libc::c_uint,
                    b"NOTE: a request from %s for %.*s timed out after writing %lld bytes. We waited %d seconds. If this is a problem, increase server.max-write-idle\0"
                        as *const u8 as *const libc::c_char,
                    (*con).dst_addr_buf.ptr,
                    buffer_clen(&mut (*r).target) as libc::c_int,
                    (*r).target.ptr,
                    (*con).bytes_written as libc::c_longlong,
                    (*r).conf.max_write_idle as libc::c_int,
                );
            }
            connection_set_state_error(r, CON_STATE_ERROR);
            changed = 1 as libc::c_int;
        }
    }
    t_diff = (cur_ts - (*con).connection_start) as libc::c_int;
    if 0 as libc::c_int == t_diff {
        t_diff = 1 as libc::c_int;
    }
    if (*con).traffic_limit_reached as libc::c_int != 0
        && ((*r).conf.bytes_per_second == 0 as libc::c_int as libc::c_uint
            || (*con).bytes_written < (*r).conf.bytes_per_second as off_t * t_diff as libc::c_long)
    {
        (*con).traffic_limit_reached = 0 as libc::c_int as libc::c_char;
        changed = 1 as libc::c_int;
    }
    (*con).bytes_written_cur_second = 0 as libc::c_int as off_t;
    if changed != 0 {
        connection_state_machine(con);
    }
}
#[no_mangle]
pub unsafe extern "C" fn connection_periodic_maint(srv: *mut server, cur_ts: unix_time64_t) {
    let mut con: *mut connection = (*srv).conns;
    let mut tc: *mut connection = 0 as *mut connection;
    while !con.is_null() {
        tc = (*con).next;
        connection_check_timeout(con, cur_ts);
        con = tc;
    }
}
#[no_mangle]
#[cold]
pub unsafe extern "C" fn connection_graceful_shutdown_maint(mut srv: *mut server) {
    let graceful_expire: libc::c_int = ((*srv).graceful_expire_ts != 0
        && (*srv).graceful_expire_ts < log_monotonic_secs)
        as libc::c_int;
    let mut con: *mut connection = (*srv).conns;
    let mut tc: *mut connection = 0 as *mut connection;
    while !con.is_null() {
        tc = (*con).next;
        let mut changed: libc::c_int = 0 as libc::c_int;
        let r: *mut request_st = &mut (*con).request;
        if (*r).state as libc::c_uint == CON_STATE_CLOSE as libc::c_int as libc::c_uint {
            if 5 as libc::c_int > 1 as libc::c_int {
                (*con).close_timeout_ts -= (5 as libc::c_int - 1 as libc::c_int) as libc::c_long;
            }
            if log_monotonic_secs - (*con).close_timeout_ts > 5 as libc::c_int as libc::c_long {
                changed = 1 as libc::c_int;
            }
        } else if !((*con).h2).is_null()
            && (*r).state as libc::c_uint == CON_STATE_WRITE as libc::c_int as libc::c_uint
        {
            h2_send_goaway(con, H2_E_NO_ERROR);
            if 0 as libc::c_int as libc::c_uint == (*(*con).h2).rused
                && chunkqueue_is_empty((*con).write_queue) != 0
            {
                (*r).state = CON_STATE_RESPONSE_END;
                changed = 1 as libc::c_int;
            }
        } else if (*r).state as libc::c_uint == CON_STATE_READ as libc::c_int as libc::c_uint
            && (*con).request_count > 1 as libc::c_int as libc::c_uint
            && chunkqueue_is_empty((*con).read_queue) != 0
        {
            connection_set_state_error(r, CON_STATE_ERROR);
            changed = 1 as libc::c_int;
        }
        if graceful_expire != 0 {
            connection_set_state_error(r, CON_STATE_ERROR);
            changed = 1 as libc::c_int;
        }
        (*r).keep_alive = 0 as libc::c_int as int8_t;
        (*r).conf.bytes_per_second = 0 as libc::c_int as libc::c_uint;
        (*r).conf.global_bytes_per_second = 0 as libc::c_int as libc::c_uint;
        if (*con).traffic_limit_reached != 0 {
            (*con).traffic_limit_reached = 0 as libc::c_int as libc::c_char;
            changed = 1 as libc::c_int;
        }
        if changed != 0 {
            connection_state_machine(con);
        }
        con = tc;
    }
}
unsafe extern "C" fn connection_handle_read_post_cq_compact(cq: *mut chunkqueue) -> libc::c_int {
    let mut c: *mut chunk = (*cq).first;
    if c.is_null() {
        return 0 as libc::c_int;
    }
    let mlen: uint32_t =
        (buffer_clen((*c).mem) as libc::c_ulong).wrapping_sub((*c).offset as size_t) as uint32_t;
    loop {
        c = (*c).next;
        if c.is_null() {
            break;
        }
        let blen: uint32_t = (buffer_clen((*c).mem) as libc::c_ulong)
            .wrapping_sub((*c).offset as size_t) as uint32_t;
        if 0 as libc::c_int as libc::c_uint == blen {
            continue;
        }
        chunkqueue_compact_mem(cq, mlen.wrapping_add(blen) as size_t);
        return 1 as libc::c_int;
    }
    return 0 as libc::c_int;
}
unsafe extern "C" fn connection_handle_read_post_chunked_crlf(cq: *mut chunkqueue) -> libc::c_int {
    let mut c: *mut chunk = 0 as *mut chunk;
    let mut b: *mut buffer = 0 as *mut buffer;
    let mut p: *mut libc::c_char = 0 as *mut libc::c_char;
    let mut len: size_t = 0;
    if chunkqueue_is_empty(cq) != 0 {
        return 0 as libc::c_int;
    }
    c = (*cq).first;
    b = (*c).mem;
    p = ((*b).ptr).offset((*c).offset as isize);
    if *p.offset(0 as libc::c_int as isize) as libc::c_int != '\r' as i32 {
        return -(1 as libc::c_int);
    }
    if *p.offset(1 as libc::c_int as isize) as libc::c_int == '\n' as i32 {
        return 1 as libc::c_int;
    }
    len = (buffer_clen(b) as libc::c_ulong).wrapping_sub((*c).offset as size_t);
    if 1 as libc::c_int as libc::c_ulong != len {
        return -(1 as libc::c_int);
    }
    loop {
        c = (*c).next;
        if c.is_null() {
            break;
        }
        b = (*c).mem;
        len = (buffer_clen(b) as libc::c_ulong).wrapping_sub((*c).offset as size_t);
        if 0 as libc::c_int as libc::c_ulong == len {
            continue;
        }
        p = ((*b).ptr).offset((*c).offset as isize);
        return if *p.offset(0 as libc::c_int as isize) as libc::c_int == '\n' as i32 {
            1 as libc::c_int
        } else {
            -(1 as libc::c_int)
        };
    }
    return 0 as libc::c_int;
}
unsafe extern "C" fn connection_handle_read_post_chunked(
    r: *mut request_st,
    cq: *mut chunkqueue,
    dst_cq: *mut chunkqueue,
) -> handler_t {
    let max_request_size: off_t = ((*r).conf.max_request_size as off_t) << 10 as libc::c_int;
    let mut te_chunked: off_t = (*r).te_chunked;
    loop {
        let mut len: off_t = chunkqueue_length(cq);
        while 0 as libc::c_int as libc::c_long == te_chunked {
            let mut p: *mut libc::c_char = 0 as *mut libc::c_char;
            let mut c: *mut chunk = (*cq).first;
            if c.is_null() {
                break;
            }
            if !((*c).type_0 as libc::c_uint == MEM_CHUNK as libc::c_int as libc::c_uint) {
                ck_assert_failed(
                    b"/home/kkysen/work/rust/lighttpd/src/connections.c\0" as *const u8
                        as *const libc::c_char,
                    1685 as libc::c_int as libc::c_uint,
                    b"c->type == MEM_CHUNK\0" as *const u8 as *const libc::c_char,
                );
            }
            p = strchr(((*(*c).mem).ptr).offset((*c).offset as isize), '\n' as i32);
            if !p.is_null() {
                let mut hsz: off_t = p
                    .offset(1 as libc::c_int as isize)
                    .offset_from(((*(*c).mem).ptr).offset((*c).offset as isize))
                    as libc::c_long;
                let mut s: *mut libc::c_uchar =
                    ((*(*c).mem).ptr as *mut libc::c_uchar).offset((*c).offset as isize);
                let mut u: libc::c_uchar = 0;
                loop {
                    u = hex2int(*s) as libc::c_uchar;
                    if !(u as libc::c_int != 0xff as libc::c_int) {
                        break;
                    }
                    if te_chunked
                        > ((1 as libc::c_ulonglong)
                            << (8 as libc::c_int as libc::c_ulong)
                                .wrapping_mul(::core::mem::size_of::<off_t>() as libc::c_ulong)
                                .wrapping_sub(5 as libc::c_int as libc::c_ulong))
                            as off_t
                            - 1 as libc::c_int as libc::c_long
                            - 2 as libc::c_int as libc::c_long
                    {
                        log_error(
                            (*r).conf.errh,
                            b"/home/kkysen/work/rust/lighttpd/src/connections.c\0" as *const u8
                                as *const libc::c_char,
                            1692 as libc::c_int as libc::c_uint,
                            b"chunked data size too large -> 400\0" as *const u8
                                as *const libc::c_char,
                        );
                        return http_response_reqbody_read_error(r, 400 as libc::c_int);
                    }
                    te_chunked <<= 4 as libc::c_int;
                    te_chunked |= u as libc::c_long;
                    s = s.offset(1);
                }
                if s == ((*(*c).mem).ptr as *mut libc::c_uchar).offset((*c).offset as isize) {
                    log_error(
                        (*r).conf.errh,
                        b"/home/kkysen/work/rust/lighttpd/src/connections.c\0" as *const u8
                            as *const libc::c_char,
                        1701 as libc::c_int as libc::c_uint,
                        b"chunked header invalid chars -> 400\0" as *const u8
                            as *const libc::c_char,
                    );
                    return http_response_reqbody_read_error(r, 400 as libc::c_int);
                }
                while *s as libc::c_int == ' ' as i32 || *s as libc::c_int == '\t' as i32 {
                    s = s.offset(1);
                }
                if *s as libc::c_int != '\r' as i32 && *s as libc::c_int != ';' as i32 {
                    log_error(
                        (*r).conf.errh,
                        b"/home/kkysen/work/rust/lighttpd/src/connections.c\0" as *const u8
                            as *const libc::c_char,
                        1708 as libc::c_int as libc::c_uint,
                        b"chunked header invalid chars -> 400\0" as *const u8
                            as *const libc::c_char,
                    );
                    return http_response_reqbody_read_error(r, 400 as libc::c_int);
                }
                if hsz >= 1024 as libc::c_int as libc::c_long {
                    log_error(
                        (*r).conf.errh,
                        b"/home/kkysen/work/rust/lighttpd/src/connections.c\0" as *const u8
                            as *const libc::c_char,
                        1717 as libc::c_int as libc::c_uint,
                        b"chunked header line too long -> 400\0" as *const u8
                            as *const libc::c_char,
                    );
                    return http_response_reqbody_read_error(r, 400 as libc::c_int);
                }
                if 0 as libc::c_int as libc::c_long == te_chunked {
                    if *p.offset(0 as libc::c_int as isize) as libc::c_int == '\r' as i32
                        && *p.offset(1 as libc::c_int as isize) as libc::c_int == '\n' as i32
                    {
                        hsz += 2 as libc::c_int as libc::c_long;
                    } else {
                        hsz -= 2 as libc::c_int as libc::c_long;
                        loop {
                            c = (*cq).first;
                            p = strstr(
                                ((*(*c).mem).ptr)
                                    .offset((*c).offset as isize)
                                    .offset(hsz as isize),
                                b"\r\n\r\n\0" as *const u8 as *const libc::c_char,
                            );
                            if !(p.is_null() && connection_handle_read_post_cq_compact(cq) != 0) {
                                break;
                            }
                        }
                        if p.is_null() {
                            if buffer_clen((*c).mem) as off_t - (*c).offset
                                < (*r).conf.max_request_field_size as off_t
                            {
                                break;
                            }
                            (*r).keep_alive = 0 as libc::c_int as int8_t;
                            p = ((*(*c).mem).ptr)
                                .offset(buffer_clen((*c).mem) as isize)
                                .offset(-(4 as libc::c_int as isize));
                        }
                        hsz = p
                            .offset(4 as libc::c_int as isize)
                            .offset_from(((*(*c).mem).ptr).offset((*c).offset as isize))
                            as libc::c_long;
                    }
                    chunkqueue_mark_written(cq, hsz as size_t as off_t);
                    (*r).reqbody_length = (*dst_cq).bytes_in;
                    break;
                } else {
                    chunkqueue_mark_written(cq, hsz as size_t as off_t);
                    len = chunkqueue_length(cq);
                    if 0 as libc::c_int as libc::c_long != max_request_size
                        && (max_request_size < te_chunked
                            || max_request_size - te_chunked < (*dst_cq).bytes_in)
                    {
                        log_error(
                            (*r).conf.errh,
                            b"/home/kkysen/work/rust/lighttpd/src/connections.c\0" as *const u8
                                as *const libc::c_char,
                            1775 as libc::c_int as libc::c_uint,
                            b"request-size too long: %lld -> 413\0" as *const u8
                                as *const libc::c_char,
                            ((*dst_cq).bytes_in + te_chunked) as libc::c_longlong,
                        );
                        return http_response_reqbody_read_error(r, 413 as libc::c_int);
                    }
                    te_chunked += 2 as libc::c_int as libc::c_long;
                    break;
                }
            } else if buffer_clen((*c).mem) as off_t - (*c).offset
                >= 1024 as libc::c_int as libc::c_long
            {
                log_error(
                    (*r).conf.errh,
                    b"/home/kkysen/work/rust/lighttpd/src/connections.c\0" as *const u8
                        as *const libc::c_char,
                    1790 as libc::c_int as libc::c_uint,
                    b"chunked header line too long -> 400\0" as *const u8 as *const libc::c_char,
                );
                return http_response_reqbody_read_error(r, 400 as libc::c_int);
            } else if connection_handle_read_post_cq_compact(cq) == 0 {
                break;
            }
        }
        if 0 as libc::c_int as libc::c_long == te_chunked {
            break;
        }
        if te_chunked > 2 as libc::c_int as libc::c_long {
            if len > te_chunked - 2 as libc::c_int as libc::c_long {
                len = te_chunked - 2 as libc::c_int as libc::c_long;
            }
            if (*dst_cq).bytes_in + te_chunked
                <= (64 as libc::c_int * 1024 as libc::c_int) as libc::c_long
            {
                chunkqueue_steal(dst_cq, cq, len);
            } else if 0 as libc::c_int
                != chunkqueue_steal_with_tempfiles(dst_cq, cq, len, (*r).conf.errh)
            {
                return http_response_reqbody_read_error(r, 500 as libc::c_int);
            }
            te_chunked -= len;
            len = chunkqueue_length(cq);
        }
        if len < te_chunked {
            break;
        }
        if 2 as libc::c_int as libc::c_long == te_chunked {
            if -(1 as libc::c_int) == connection_handle_read_post_chunked_crlf(cq) {
                log_error(
                    (*r).conf.errh,
                    b"/home/kkysen/work/rust/lighttpd/src/connections.c\0" as *const u8
                        as *const libc::c_char,
                    1820 as libc::c_int as libc::c_uint,
                    b"chunked data missing end CRLF -> 400\0" as *const u8 as *const libc::c_char,
                );
                return http_response_reqbody_read_error(r, 400 as libc::c_int);
            }
            chunkqueue_mark_written(cq, 2 as libc::c_int as off_t);
            te_chunked -= 2 as libc::c_int as libc::c_long;
        }
        if !(chunkqueue_is_empty(cq) == 0) {
            break;
        }
    }
    (*r).te_chunked = te_chunked;
    return HANDLER_GO_ON;
}
unsafe extern "C" fn connection_handle_read_body_unknown(
    r: *mut request_st,
    cq: *mut chunkqueue,
    dst_cq: *mut chunkqueue,
) -> handler_t {
    let max_request_size: off_t = ((*r).conf.max_request_size as off_t) << 10 as libc::c_int;
    chunkqueue_append_chunkqueue(dst_cq, cq);
    if 0 as libc::c_int as libc::c_long != max_request_size && (*dst_cq).bytes_in > max_request_size
    {
        log_error(
            (*r).conf.errh,
            b"/home/kkysen/work/rust/lighttpd/src/connections.c\0" as *const u8
                as *const libc::c_char,
            1843 as libc::c_int as libc::c_uint,
            b"request-size too long: %lld -> 413\0" as *const u8 as *const libc::c_char,
            (*dst_cq).bytes_in as libc::c_longlong,
        );
        return http_response_reqbody_read_error(r, 413 as libc::c_int);
    }
    return HANDLER_GO_ON;
}
#[cold]
unsafe extern "C" fn connection_check_expect_100(
    r: *mut request_st,
    con: *mut connection,
) -> libc::c_int {
    if (*con).is_writable as libc::c_int <= 0 as libc::c_int {
        return 1 as libc::c_int;
    }
    let vb: *const buffer = http_header_request_get(
        r,
        HTTP_HEADER_EXPECT,
        b"Expect\0" as *const u8 as *const libc::c_char,
        (::core::mem::size_of::<[libc::c_char; 7]>() as libc::c_ulong as uint32_t)
            .wrapping_sub(1 as libc::c_int as libc::c_uint),
    );
    if vb.is_null() {
        return 1 as libc::c_int;
    }
    let mut rc: libc::c_int = buffer_eq_icase_slen(
        vb,
        b"100-continue\0" as *const u8 as *const libc::c_char,
        (::core::mem::size_of::<[libc::c_char; 13]>() as libc::c_ulong as uint32_t)
            .wrapping_sub(1 as libc::c_int as libc::c_uint) as size_t,
    );
    http_header_request_unset(
        r,
        HTTP_HEADER_EXPECT,
        b"Expect\0" as *const u8 as *const libc::c_char,
        (::core::mem::size_of::<[libc::c_char; 7]>() as libc::c_ulong as uint32_t)
            .wrapping_sub(1 as libc::c_int as libc::c_uint),
    );
    if rc == 0
        || 0 as libc::c_int as libc::c_long != (*r).reqbody_queue.bytes_in
        || chunkqueue_is_empty(&mut (*r).read_queue) == 0
        || chunkqueue_is_empty(&mut (*r).write_queue) == 0
    {
        return 1 as libc::c_int;
    }
    if (*r).http_version as libc::c_int > HTTP_VERSION_1_1 as libc::c_int {
        h2_send_100_continue(r, con);
    } else if (*r).http_version as libc::c_int == HTTP_VERSION_1_1 as libc::c_int {
        return connection_write_100_continue(r, con);
    }
    return 1 as libc::c_int;
}
unsafe extern "C" fn connection_handle_read_post_state(r: *mut request_st) -> handler_t {
    let con: *mut connection = (*r).con;
    let cq: *mut chunkqueue = &mut (*r).read_queue;
    let dst_cq: *mut chunkqueue = &mut (*r).reqbody_queue;
    let mut is_closed: libc::c_int = 0 as libc::c_int;
    if (*r).http_version as libc::c_int > HTTP_VERSION_1_1 as libc::c_int {
        if (*r).h2state >= H2_STATE_HALF_CLOSED_REMOTE as libc::c_int as libc::c_uint {
            is_closed = 1 as libc::c_int;
        }
    } else if (*con).is_readable as libc::c_int > 0 as libc::c_int {
        (*con).read_idle_ts = log_monotonic_secs;
        let max_per_read: off_t = (if (*r).conf.stream_request_body as libc::c_int
            & ((1 as libc::c_int) << 0 as libc::c_int | (1 as libc::c_int) << 1 as libc::c_int)
            == 0
        {
            256 as libc::c_int * 1024 as libc::c_int
        } else if (*r).conf.stream_request_body as libc::c_int
            & (1 as libc::c_int) << 1 as libc::c_int
            != 0
        {
            16384 as libc::c_int
        } else {
            65536 as libc::c_int
        }) as off_t;
        match ((*con).network_read).expect("non-null function pointer")(con, cq, max_per_read) {
            -1 => {
                connection_set_state_error(r, CON_STATE_ERROR);
                return HANDLER_ERROR;
            }
            -2 => {
                is_closed = 1 as libc::c_int;
            }
            _ => {}
        }
        chunkqueue_remove_finished_chunks(cq);
    }
    if (*r).rqst_htags & (1 as libc::c_ulong) << HTTP_HEADER_EXPECT as libc::c_int != 0
        && connection_check_expect_100(r, con) == 0
    {
        return HANDLER_ERROR;
    }
    if !((*r).http_version as libc::c_int > HTTP_VERSION_1_1 as libc::c_int) {
        if (*r).reqbody_length < 0 as libc::c_int as libc::c_long {
            let mut rc: handler_t = (if -(1 as libc::c_int) as libc::c_long == (*r).reqbody_length {
                connection_handle_read_post_chunked(r, cq, dst_cq) as libc::c_uint
            } else {
                connection_handle_read_body_unknown(r, cq, dst_cq) as libc::c_uint
            }) as handler_t;
            if HANDLER_GO_ON as libc::c_int as libc::c_uint != rc as libc::c_uint {
                return rc;
            }
            chunkqueue_remove_finished_chunks(cq);
        } else {
            let mut len: off_t = (*r).reqbody_length - (*dst_cq).bytes_in;
            if (*r).reqbody_length <= (64 as libc::c_int * 1024 as libc::c_int) as libc::c_long {
                chunkqueue_steal(dst_cq, cq, len);
            } else if 0 as libc::c_int
                != chunkqueue_steal_with_tempfiles(dst_cq, cq, len, (*r).conf.errh)
            {
                return http_response_reqbody_read_error(r, 500 as libc::c_int);
            }
            chunkqueue_remove_finished_chunks(cq);
        }
    }
    if (*dst_cq).bytes_in == (*r).reqbody_length {
        (*r).conf.stream_request_body = ((*r).conf.stream_request_body as libc::c_int
            & !((1 as libc::c_int) << 15 as libc::c_int))
            as libc::c_ushort;
        if (*r).state as libc::c_uint == CON_STATE_READ_POST as libc::c_int as libc::c_uint {
            (*r).state = CON_STATE_HANDLE_REQUEST;
        }
        return HANDLER_GO_ON;
    } else if is_closed != 0 {
        return HANDLER_ERROR;
    } else {
        (*r).conf.stream_request_body = ((*r).conf.stream_request_body as libc::c_int
            | (1 as libc::c_int) << 15 as libc::c_int)
            as libc::c_ushort;
        return (if (*r).conf.stream_request_body as libc::c_int
            & (1 as libc::c_int) << 0 as libc::c_int
            != 0
        {
            HANDLER_GO_ON as libc::c_int
        } else {
            HANDLER_WAIT_FOR_EVENT as libc::c_int
        }) as handler_t;
    };
}
static mut http_header_lc: [[libc::c_char; 32]; 59] = unsafe {
    [
        *::core::mem::transmute::<&[u8; 32], &[libc::c_char; 32]>(
            b"\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0",
        ),
        *::core::mem::transmute::<&[u8; 32], &[libc::c_char; 32]>(
            b"accept\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0",
        ),
        *::core::mem::transmute::<&[u8; 32], &[libc::c_char; 32]>(
            b"accept-encoding\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0",
        ),
        *::core::mem::transmute::<&[u8; 32], &[libc::c_char; 32]>(
            b"accept-language\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0",
        ),
        *::core::mem::transmute::<&[u8; 32], &[libc::c_char; 32]>(
            b"accept-ranges\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0",
        ),
        *::core::mem::transmute::<&[u8; 32], &[libc::c_char; 32]>(
            b"access-control-allow-origin\0\0\0\0\0",
        ),
        *::core::mem::transmute::<&[u8; 32], &[libc::c_char; 32]>(
            b"age\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0",
        ),
        *::core::mem::transmute::<&[u8; 32], &[libc::c_char; 32]>(
            b"allow\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0",
        ),
        *::core::mem::transmute::<&[u8; 32], &[libc::c_char; 32]>(
            b"alt-svc\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0",
        ),
        *::core::mem::transmute::<&[u8; 32], &[libc::c_char; 32]>(
            b"alt-used\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0",
        ),
        *::core::mem::transmute::<&[u8; 32], &[libc::c_char; 32]>(
            b"authorization\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0",
        ),
        *::core::mem::transmute::<&[u8; 32], &[libc::c_char; 32]>(
            b"cache-control\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0",
        ),
        *::core::mem::transmute::<&[u8; 32], &[libc::c_char; 32]>(
            b"connection\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0",
        ),
        *::core::mem::transmute::<&[u8; 32], &[libc::c_char; 32]>(
            b"content-encoding\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0",
        ),
        *::core::mem::transmute::<&[u8; 32], &[libc::c_char; 32]>(
            b"content-length\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0",
        ),
        *::core::mem::transmute::<&[u8; 32], &[libc::c_char; 32]>(
            b"content-location\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0",
        ),
        *::core::mem::transmute::<&[u8; 32], &[libc::c_char; 32]>(
            b"content-range\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0",
        ),
        *::core::mem::transmute::<&[u8; 32], &[libc::c_char; 32]>(
            b"content-security-policy\0\0\0\0\0\0\0\0\0",
        ),
        *::core::mem::transmute::<&[u8; 32], &[libc::c_char; 32]>(
            b"content-type\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0",
        ),
        *::core::mem::transmute::<&[u8; 32], &[libc::c_char; 32]>(
            b"cookie\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0",
        ),
        *::core::mem::transmute::<&[u8; 32], &[libc::c_char; 32]>(
            b"date\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0",
        ),
        *::core::mem::transmute::<&[u8; 32], &[libc::c_char; 32]>(
            b"dnt\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0",
        ),
        *::core::mem::transmute::<&[u8; 32], &[libc::c_char; 32]>(
            b"etag\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0",
        ),
        *::core::mem::transmute::<&[u8; 32], &[libc::c_char; 32]>(
            b"expect\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0",
        ),
        *::core::mem::transmute::<&[u8; 32], &[libc::c_char; 32]>(
            b"expect-ct\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0",
        ),
        *::core::mem::transmute::<&[u8; 32], &[libc::c_char; 32]>(
            b"expires\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0",
        ),
        *::core::mem::transmute::<&[u8; 32], &[libc::c_char; 32]>(
            b"forwarded\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0",
        ),
        *::core::mem::transmute::<&[u8; 32], &[libc::c_char; 32]>(
            b"host\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0",
        ),
        *::core::mem::transmute::<&[u8; 32], &[libc::c_char; 32]>(
            b"http2-settings\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0",
        ),
        *::core::mem::transmute::<&[u8; 32], &[libc::c_char; 32]>(
            b"if-match\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0",
        ),
        *::core::mem::transmute::<&[u8; 32], &[libc::c_char; 32]>(
            b"if-modified-since\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0",
        ),
        *::core::mem::transmute::<&[u8; 32], &[libc::c_char; 32]>(
            b"if-none-match\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0",
        ),
        *::core::mem::transmute::<&[u8; 32], &[libc::c_char; 32]>(
            b"if-range\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0",
        ),
        *::core::mem::transmute::<&[u8; 32], &[libc::c_char; 32]>(
            b"if-unmodified-since\0\0\0\0\0\0\0\0\0\0\0\0\0",
        ),
        *::core::mem::transmute::<&[u8; 32], &[libc::c_char; 32]>(
            b"last-modified\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0",
        ),
        *::core::mem::transmute::<&[u8; 32], &[libc::c_char; 32]>(
            b"link\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0",
        ),
        *::core::mem::transmute::<&[u8; 32], &[libc::c_char; 32]>(
            b"location\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0",
        ),
        *::core::mem::transmute::<&[u8; 32], &[libc::c_char; 32]>(
            b"onion-location\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0",
        ),
        *::core::mem::transmute::<&[u8; 32], &[libc::c_char; 32]>(
            b"p3p\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0",
        ),
        *::core::mem::transmute::<&[u8; 32], &[libc::c_char; 32]>(
            b"pragma\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0",
        ),
        *::core::mem::transmute::<&[u8; 32], &[libc::c_char; 32]>(
            b"range\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0",
        ),
        *::core::mem::transmute::<&[u8; 32], &[libc::c_char; 32]>(
            b"referer\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0",
        ),
        *::core::mem::transmute::<&[u8; 32], &[libc::c_char; 32]>(
            b"referrer-policy\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0",
        ),
        *::core::mem::transmute::<&[u8; 32], &[libc::c_char; 32]>(
            b"server\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0",
        ),
        *::core::mem::transmute::<&[u8; 32], &[libc::c_char; 32]>(
            b"set-cookie\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0",
        ),
        *::core::mem::transmute::<&[u8; 32], &[libc::c_char; 32]>(
            b"status\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0",
        ),
        *::core::mem::transmute::<&[u8; 32], &[libc::c_char; 32]>(
            b"strict-transport-security\0\0\0\0\0\0\0",
        ),
        *::core::mem::transmute::<&[u8; 32], &[libc::c_char; 32]>(
            b"te\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0",
        ),
        *::core::mem::transmute::<&[u8; 32], &[libc::c_char; 32]>(
            b"transfer-encoding\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0",
        ),
        *::core::mem::transmute::<&[u8; 32], &[libc::c_char; 32]>(
            b"upgrade\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0",
        ),
        *::core::mem::transmute::<&[u8; 32], &[libc::c_char; 32]>(
            b"upgrade-insecure-requests\0\0\0\0\0\0\0",
        ),
        *::core::mem::transmute::<&[u8; 32], &[libc::c_char; 32]>(
            b"user-agent\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0",
        ),
        *::core::mem::transmute::<&[u8; 32], &[libc::c_char; 32]>(
            b"vary\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0",
        ),
        *::core::mem::transmute::<&[u8; 32], &[libc::c_char; 32]>(
            b"www-authenticate\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0",
        ),
        *::core::mem::transmute::<&[u8; 32], &[libc::c_char; 32]>(
            b"x-content-type-options\0\0\0\0\0\0\0\0\0\0",
        ),
        *::core::mem::transmute::<&[u8; 32], &[libc::c_char; 32]>(
            b"x-forwarded-for\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0",
        ),
        *::core::mem::transmute::<&[u8; 32], &[libc::c_char; 32]>(
            b"x-forwarded-proto\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0",
        ),
        *::core::mem::transmute::<&[u8; 32], &[libc::c_char; 32]>(
            b"x-frame-options\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0",
        ),
        *::core::mem::transmute::<&[u8; 32], &[libc::c_char; 32]>(
            b"x-xss-protection\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0",
        ),
    ]
};
static mut http_header_lshpack_idx: [uint8_t; 59] = [
    LSHPACK_HDR_UNKNOWN as libc::c_int as uint8_t,
    LSHPACK_HDR_ACCEPT as libc::c_int as uint8_t,
    LSHPACK_HDR_ACCEPT_ENCODING as libc::c_int as uint8_t,
    LSHPACK_HDR_ACCEPT_LANGUAGE as libc::c_int as uint8_t,
    LSHPACK_HDR_ACCEPT_RANGES as libc::c_int as uint8_t,
    LSHPACK_HDR_ACCESS_CONTROL_ALLOW_ORIGIN as libc::c_int as uint8_t,
    LSHPACK_HDR_AGE as libc::c_int as uint8_t,
    LSHPACK_HDR_ALLOW as libc::c_int as uint8_t,
    LSHPACK_HDR_UNKNOWN as libc::c_int as uint8_t,
    LSHPACK_HDR_UNKNOWN as libc::c_int as uint8_t,
    LSHPACK_HDR_AUTHORIZATION as libc::c_int as uint8_t,
    LSHPACK_HDR_CACHE_CONTROL as libc::c_int as uint8_t,
    LSHPACK_HDR_UNKNOWN as libc::c_int as uint8_t,
    LSHPACK_HDR_CONTENT_ENCODING as libc::c_int as uint8_t,
    LSHPACK_HDR_CONTENT_LENGTH as libc::c_int as uint8_t,
    LSHPACK_HDR_CONTENT_LOCATION as libc::c_int as uint8_t,
    LSHPACK_HDR_CONTENT_RANGE as libc::c_int as uint8_t,
    LSHPACK_HDR_UNKNOWN as libc::c_int as uint8_t,
    LSHPACK_HDR_CONTENT_TYPE as libc::c_int as uint8_t,
    LSHPACK_HDR_COOKIE as libc::c_int as uint8_t,
    LSHPACK_HDR_DATE as libc::c_int as uint8_t,
    LSHPACK_HDR_UNKNOWN as libc::c_int as uint8_t,
    LSHPACK_HDR_ETAG as libc::c_int as uint8_t,
    LSHPACK_HDR_EXPECT as libc::c_int as uint8_t,
    LSHPACK_HDR_UNKNOWN as libc::c_int as uint8_t,
    LSHPACK_HDR_EXPIRES as libc::c_int as uint8_t,
    LSHPACK_HDR_UNKNOWN as libc::c_int as uint8_t,
    LSHPACK_HDR_HOST as libc::c_int as uint8_t,
    LSHPACK_HDR_UNKNOWN as libc::c_int as uint8_t,
    LSHPACK_HDR_IF_MATCH as libc::c_int as uint8_t,
    LSHPACK_HDR_IF_MODIFIED_SINCE as libc::c_int as uint8_t,
    LSHPACK_HDR_IF_NONE_MATCH as libc::c_int as uint8_t,
    LSHPACK_HDR_IF_RANGE as libc::c_int as uint8_t,
    LSHPACK_HDR_IF_UNMODIFIED_SINCE as libc::c_int as uint8_t,
    LSHPACK_HDR_LAST_MODIFIED as libc::c_int as uint8_t,
    LSHPACK_HDR_LINK as libc::c_int as uint8_t,
    LSHPACK_HDR_LOCATION as libc::c_int as uint8_t,
    LSHPACK_HDR_UNKNOWN as libc::c_int as uint8_t,
    LSHPACK_HDR_UNKNOWN as libc::c_int as uint8_t,
    LSHPACK_HDR_UNKNOWN as libc::c_int as uint8_t,
    LSHPACK_HDR_RANGE as libc::c_int as uint8_t,
    LSHPACK_HDR_REFERER as libc::c_int as uint8_t,
    LSHPACK_HDR_UNKNOWN as libc::c_int as uint8_t,
    LSHPACK_HDR_SERVER as libc::c_int as uint8_t,
    LSHPACK_HDR_SET_COOKIE as libc::c_int as uint8_t,
    LSHPACK_HDR_UNKNOWN as libc::c_int as uint8_t,
    LSHPACK_HDR_STRICT_TRANSPORT_SECURITY as libc::c_int as uint8_t,
    LSHPACK_HDR_UNKNOWN as libc::c_int as uint8_t,
    LSHPACK_HDR_TRANSFER_ENCODING as libc::c_int as uint8_t,
    LSHPACK_HDR_UNKNOWN as libc::c_int as uint8_t,
    LSHPACK_HDR_UNKNOWN as libc::c_int as uint8_t,
    LSHPACK_HDR_USER_AGENT as libc::c_int as uint8_t,
    LSHPACK_HDR_VARY as libc::c_int as uint8_t,
    LSHPACK_HDR_WWW_AUTHENTICATE as libc::c_int as uint8_t,
    LSHPACK_HDR_UNKNOWN as libc::c_int as uint8_t,
    LSHPACK_HDR_UNKNOWN as libc::c_int as uint8_t,
    LSHPACK_HDR_UNKNOWN as libc::c_int as uint8_t,
    LSHPACK_HDR_UNKNOWN as libc::c_int as uint8_t,
    LSHPACK_HDR_UNKNOWN as libc::c_int as uint8_t,
];
static mut lshpack_idx_http_header: [int8_t; 62] = [
    HTTP_HEADER_H2_UNKNOWN as libc::c_int as int8_t,
    HTTP_HEADER_H2_AUTHORITY as libc::c_int as int8_t,
    HTTP_HEADER_H2_METHOD_GET as libc::c_int as int8_t,
    HTTP_HEADER_H2_METHOD_POST as libc::c_int as int8_t,
    HTTP_HEADER_H2_PATH as libc::c_int as int8_t,
    HTTP_HEADER_H2_PATH_INDEX_HTML as libc::c_int as int8_t,
    HTTP_HEADER_H2_SCHEME_HTTP as libc::c_int as int8_t,
    HTTP_HEADER_H2_SCHEME_HTTPS as libc::c_int as int8_t,
    HTTP_HEADER_H2_UNKNOWN as libc::c_int as int8_t,
    HTTP_HEADER_H2_UNKNOWN as libc::c_int as int8_t,
    HTTP_HEADER_H2_UNKNOWN as libc::c_int as int8_t,
    HTTP_HEADER_H2_UNKNOWN as libc::c_int as int8_t,
    HTTP_HEADER_H2_UNKNOWN as libc::c_int as int8_t,
    HTTP_HEADER_H2_UNKNOWN as libc::c_int as int8_t,
    HTTP_HEADER_H2_UNKNOWN as libc::c_int as int8_t,
    HTTP_HEADER_OTHER as libc::c_int as int8_t,
    HTTP_HEADER_ACCEPT_ENCODING as libc::c_int as int8_t,
    HTTP_HEADER_ACCEPT_LANGUAGE as libc::c_int as int8_t,
    HTTP_HEADER_ACCEPT_RANGES as libc::c_int as int8_t,
    HTTP_HEADER_ACCEPT as libc::c_int as int8_t,
    HTTP_HEADER_ACCESS_CONTROL_ALLOW_ORIGIN as libc::c_int as int8_t,
    HTTP_HEADER_AGE as libc::c_int as int8_t,
    HTTP_HEADER_ALLOW as libc::c_int as int8_t,
    HTTP_HEADER_AUTHORIZATION as libc::c_int as int8_t,
    HTTP_HEADER_CACHE_CONTROL as libc::c_int as int8_t,
    HTTP_HEADER_OTHER as libc::c_int as int8_t,
    HTTP_HEADER_CONTENT_ENCODING as libc::c_int as int8_t,
    HTTP_HEADER_OTHER as libc::c_int as int8_t,
    HTTP_HEADER_CONTENT_LENGTH as libc::c_int as int8_t,
    HTTP_HEADER_CONTENT_LOCATION as libc::c_int as int8_t,
    HTTP_HEADER_CONTENT_RANGE as libc::c_int as int8_t,
    HTTP_HEADER_CONTENT_TYPE as libc::c_int as int8_t,
    HTTP_HEADER_COOKIE as libc::c_int as int8_t,
    HTTP_HEADER_DATE as libc::c_int as int8_t,
    HTTP_HEADER_ETAG as libc::c_int as int8_t,
    HTTP_HEADER_EXPECT as libc::c_int as int8_t,
    HTTP_HEADER_EXPIRES as libc::c_int as int8_t,
    HTTP_HEADER_OTHER as libc::c_int as int8_t,
    HTTP_HEADER_HOST as libc::c_int as int8_t,
    HTTP_HEADER_IF_MATCH as libc::c_int as int8_t,
    HTTP_HEADER_IF_MODIFIED_SINCE as libc::c_int as int8_t,
    HTTP_HEADER_IF_NONE_MATCH as libc::c_int as int8_t,
    HTTP_HEADER_IF_RANGE as libc::c_int as int8_t,
    HTTP_HEADER_IF_UNMODIFIED_SINCE as libc::c_int as int8_t,
    HTTP_HEADER_LAST_MODIFIED as libc::c_int as int8_t,
    HTTP_HEADER_LINK as libc::c_int as int8_t,
    HTTP_HEADER_LOCATION as libc::c_int as int8_t,
    HTTP_HEADER_OTHER as libc::c_int as int8_t,
    HTTP_HEADER_OTHER as libc::c_int as int8_t,
    HTTP_HEADER_OTHER as libc::c_int as int8_t,
    HTTP_HEADER_RANGE as libc::c_int as int8_t,
    HTTP_HEADER_REFERER as libc::c_int as int8_t,
    HTTP_HEADER_OTHER as libc::c_int as int8_t,
    HTTP_HEADER_OTHER as libc::c_int as int8_t,
    HTTP_HEADER_SERVER as libc::c_int as int8_t,
    HTTP_HEADER_SET_COOKIE as libc::c_int as int8_t,
    HTTP_HEADER_STRICT_TRANSPORT_SECURITY as libc::c_int as int8_t,
    HTTP_HEADER_TRANSFER_ENCODING as libc::c_int as int8_t,
    HTTP_HEADER_USER_AGENT as libc::c_int as int8_t,
    HTTP_HEADER_VARY as libc::c_int as int8_t,
    HTTP_HEADER_OTHER as libc::c_int as int8_t,
    HTTP_HEADER_WWW_AUTHENTICATE as libc::c_int as int8_t,
];
#[inline]
unsafe extern "C" fn h2_u32(s: *const uint8_t) -> uint32_t {
    return (*s.offset(0 as libc::c_int as isize) as uint32_t) << 24 as libc::c_int
        | (*s.offset(1 as libc::c_int as isize) as uint32_t) << 16 as libc::c_int
        | (*s.offset(2 as libc::c_int as isize) as uint32_t) << 8 as libc::c_int
        | *s.offset(3 as libc::c_int as isize) as uint32_t;
}
#[inline]
unsafe extern "C" fn h2_u31(s: *const uint8_t) -> uint32_t {
    return h2_u32(s) & !(0x80000000 as libc::c_uint);
}
#[inline]
unsafe extern "C" fn h2_u24(s: *const uint8_t) -> uint32_t {
    return h2_u32(s) >> 8 as libc::c_int;
}
#[inline]
unsafe extern "C" fn h2_u16(s: *const uint8_t) -> uint16_t {
    return ((*s.offset(0 as libc::c_int as isize) as uint16_t as libc::c_int) << 8 as libc::c_int
        | *s.offset(1 as libc::c_int as isize) as uint16_t as libc::c_int) as uint16_t;
}
unsafe extern "C" fn h2_send_settings_ack(con: *mut connection) {
    static mut settings_ack: [uint8_t; 9] = [
        0 as libc::c_int as uint8_t,
        0 as libc::c_int as uint8_t,
        0 as libc::c_int as uint8_t,
        H2_FTYPE_SETTINGS as libc::c_int as uint8_t,
        H2_FLAG_ACK as libc::c_int as uint8_t,
        0 as libc::c_int as uint8_t,
        0 as libc::c_int as uint8_t,
        0 as libc::c_int as uint8_t,
        0 as libc::c_int as uint8_t,
    ];
    chunkqueue_append_mem(
        (*con).write_queue,
        settings_ack.as_ptr() as *const libc::c_char,
        ::core::mem::size_of::<[uint8_t; 9]>() as libc::c_ulong,
    );
}
#[cold]
unsafe extern "C" fn h2_send_rst_stream_id(
    mut h2id: uint32_t,
    con: *mut connection,
    e: request_h2error_t,
) {
    let mut rst_stream: C2RustUnnamed_19 = C2RustUnnamed_19 {
        c: [
            0 as libc::c_int as uint8_t,
            0 as libc::c_int as uint8_t,
            0 as libc::c_int as uint8_t,
            0 as libc::c_int as uint8_t,
            0 as libc::c_int as uint8_t,
            0x4 as libc::c_int as uint8_t,
            H2_FTYPE_RST_STREAM as libc::c_int as uint8_t,
            0 as libc::c_int as uint8_t,
            0 as libc::c_int as uint8_t,
            0 as libc::c_int as uint8_t,
            0 as libc::c_int as uint8_t,
            0 as libc::c_int as uint8_t,
            0 as libc::c_int as uint8_t,
            0 as libc::c_int as uint8_t,
            0 as libc::c_int as uint8_t,
            0 as libc::c_int as uint8_t,
        ],
    };
    rst_stream.u[2 as libc::c_int as usize] = htonl(h2id);
    rst_stream.u[3 as libc::c_int as usize] = htonl(e as uint32_t);
    chunkqueue_append_mem(
        (*con).write_queue,
        ((rst_stream.c).as_mut_ptr() as *const libc::c_char).offset(3 as libc::c_int as isize),
        (::core::mem::size_of::<C2RustUnnamed_19>() as libc::c_ulong)
            .wrapping_sub(3 as libc::c_int as libc::c_ulong),
    );
}
#[cold]
unsafe extern "C" fn h2_send_rst_stream_state(r: *mut request_st, h2c: *mut h2con) {
    if (*r).h2state != H2_STATE_HALF_CLOSED_REMOTE as libc::c_int as libc::c_uint
        && (*r).h2state != H2_STATE_CLOSED as libc::c_int as libc::c_uint
    {
        (*h2c).half_closed_ts = log_monotonic_secs;
    }
    (*r).state = CON_STATE_ERROR;
    (*r).h2state = H2_STATE_CLOSED as libc::c_int as uint32_t;
}
#[cold]
unsafe extern "C" fn h2_send_rst_stream(
    r: *mut request_st,
    con: *mut connection,
    e: request_h2error_t,
) {
    h2_send_rst_stream_state(r, (*con).h2);
    h2_send_rst_stream_id((*r).h2id, con, e);
}
#[cold]
unsafe extern "C" fn h2_send_goaway_rst_stream(con: *mut connection) {
    let h2c: *mut h2con = (*con).h2;
    let sent_goaway: libc::c_int = (*h2c).sent_goaway;
    let mut i: uint32_t = 0 as libc::c_int as uint32_t;
    let mut rused: uint32_t = (*h2c).rused;
    while i < rused {
        let r: *mut request_st = (*h2c).r[i as usize];
        if !((*r).h2state == H2_STATE_CLOSED as libc::c_int as libc::c_uint) {
            h2_send_rst_stream_state(r, h2c);
            if sent_goaway != 0 {
                h2_send_rst_stream_id((*r).h2id, con, H2_E_PROTOCOL_ERROR);
            }
        }
        i = i.wrapping_add(1);
    }
}
#[no_mangle]
pub unsafe extern "C" fn h2_send_goaway(con: *mut connection, e: request_h2error_t) {
    if e as libc::c_uint != H2_E_NO_ERROR as libc::c_int as libc::c_uint {
        h2_send_goaway_rst_stream(con);
    }
    let h2c: *mut h2con = (*con).h2;
    if (*h2c).sent_goaway != 0
        && ((*h2c).sent_goaway > 0 as libc::c_int
            || e as libc::c_uint == H2_E_NO_ERROR as libc::c_int as libc::c_uint)
    {
        return;
    }
    (*h2c).sent_goaway = if e as libc::c_uint == H2_E_NO_ERROR as libc::c_int as libc::c_uint {
        -(1 as libc::c_int)
    } else {
        e as int32_t
    };
    let mut goaway: C2RustUnnamed_21 = C2RustUnnamed_21 {
        c: [
            0 as libc::c_int as uint8_t,
            0 as libc::c_int as uint8_t,
            0 as libc::c_int as uint8_t,
            0 as libc::c_int as uint8_t,
            0 as libc::c_int as uint8_t,
            0x8 as libc::c_int as uint8_t,
            H2_FTYPE_GOAWAY as libc::c_int as uint8_t,
            0 as libc::c_int as uint8_t,
            0 as libc::c_int as uint8_t,
            0 as libc::c_int as uint8_t,
            0 as libc::c_int as uint8_t,
            0 as libc::c_int as uint8_t,
            0 as libc::c_int as uint8_t,
            0 as libc::c_int as uint8_t,
            0 as libc::c_int as uint8_t,
            0 as libc::c_int as uint8_t,
            0 as libc::c_int as uint8_t,
            0 as libc::c_int as uint8_t,
            0 as libc::c_int as uint8_t,
            0 as libc::c_int as uint8_t,
        ],
    };
    goaway.u[3 as libc::c_int as usize] = htonl((*h2c).h2_cid);
    goaway.u[4 as libc::c_int as usize] = htonl(e as uint32_t);
    chunkqueue_append_mem(
        (*con).write_queue,
        ((goaway.c).as_mut_ptr() as *const libc::c_char).offset(3 as libc::c_int as isize),
        (::core::mem::size_of::<C2RustUnnamed_21>() as libc::c_ulong)
            .wrapping_sub(3 as libc::c_int as libc::c_ulong),
    );
}
#[cold]
unsafe extern "C" fn h2_send_goaway_e(con: *mut connection, e: request_h2error_t) {
    h2_send_goaway(con, e);
}
#[cold]
unsafe extern "C" fn h2_send_refused_stream(
    mut h2id: uint32_t,
    con: *mut connection,
) -> libc::c_int {
    let h2c: *mut h2con = (*con).h2;
    if (*h2c).sent_settings != 0 {
        let mut i: uint32_t = 0 as libc::c_int as uint32_t;
        let mut rused: uint32_t = (*h2c).rused;
        while i < rused {
            let r: *const request_st = (*h2c).r[i as usize];
            if (*r).reqbody_length == (*r).reqbody_queue.bytes_in {
                return -(1 as libc::c_int);
            }
            i = i.wrapping_add(1);
        }
    }
    (*h2c).h2_cid = h2id;
    h2_send_rst_stream_id(h2id, con, H2_E_REFUSED_STREAM);
    return 1 as libc::c_int;
}
unsafe extern "C" fn h2_recv_goaway(
    con: *mut connection,
    s: *const uint8_t,
    mut len: uint32_t,
) -> libc::c_int {
    if 0 as libc::c_int as libc::c_uint != h2_u31(s.offset(5 as libc::c_int as isize)) {
        h2_send_goaway_e(con, H2_E_PROTOCOL_ERROR);
        return 0 as libc::c_int;
    }
    let e: uint32_t = h2_u32(s.offset(13 as libc::c_int as isize));
    h2_send_goaway(
        con,
        (if e == H2_E_NO_ERROR as libc::c_int as libc::c_uint {
            H2_E_NO_ERROR as libc::c_int
        } else {
            H2_E_PROTOCOL_ERROR as libc::c_int
        }) as request_h2error_t,
    );
    let h2c: *mut h2con = (*con).h2;
    if 0 as libc::c_int as libc::c_uint == (*h2c).rused {
        return 0 as libc::c_int;
    }
    return 1 as libc::c_int;
}
unsafe extern "C" fn h2_recv_rst_stream(con: *mut connection, s: *const uint8_t, len: uint32_t) {
    if 4 as libc::c_int as libc::c_uint != len {
        h2_send_goaway_e(con, H2_E_FRAME_SIZE_ERROR);
        return;
    }
    let id: uint32_t = h2_u31(s.offset(5 as libc::c_int as isize));
    if 0 as libc::c_int as libc::c_uint == id {
        h2_send_goaway_e(con, H2_E_PROTOCOL_ERROR);
        return;
    }
    let h2c: *mut h2con = (*con).h2;
    let mut i: uint32_t = 0 as libc::c_int as uint32_t;
    let mut rused: uint32_t = (*h2c).rused;
    while i < rused {
        let r: *mut request_st = (*h2c).r[i as usize];
        if (*r).h2id != id {
            i = i.wrapping_add(1);
        } else {
            if (*r).h2state == H2_STATE_IDLE as libc::c_int as libc::c_uint {
                h2_send_goaway_e(con, H2_E_PROTOCOL_ERROR);
                return;
            }
            (*r).state = CON_STATE_ERROR;
            (*r).h2state = H2_STATE_CLOSED as libc::c_int as uint32_t;
            return;
        }
    }
    if (*h2c).h2_cid < id {
        h2_send_goaway_e(con, H2_E_PROTOCOL_ERROR);
        return;
    }
}
unsafe extern "C" fn h2_recv_ping(con: *mut connection, s: *mut uint8_t, len: uint32_t) {
    if 8 as libc::c_int as libc::c_uint != len {
        h2_send_goaway_e(con, H2_E_FRAME_SIZE_ERROR);
        return;
    }
    let ref mut fresh12 = *s.offset(5 as libc::c_int as isize);
    *fresh12 = (*fresh12 as libc::c_int & !(0x80 as libc::c_int)) as uint8_t;
    if 0 as libc::c_int as libc::c_uint != h2_u31(s.offset(5 as libc::c_int as isize)) {
        h2_send_goaway_e(con, H2_E_PROTOCOL_ERROR);
        return;
    }
    if *s.offset(4 as libc::c_int as isize) as libc::c_int & H2_FLAG_ACK as libc::c_int != 0 {
        return;
    }
    *s.offset(4 as libc::c_int as isize) = H2_FLAG_ACK as libc::c_int as uint8_t;
    chunkqueue_append_mem(
        (*con).write_queue,
        s as *const libc::c_char,
        17 as libc::c_int as size_t,
    );
}
unsafe extern "C" fn h2_recv_priority(con: *mut connection, s: *const uint8_t, len: uint32_t) {
    if 5 as libc::c_int as libc::c_uint != len {
        h2_send_goaway_e(con, H2_E_FRAME_SIZE_ERROR);
        return;
    }
    let id: uint32_t = h2_u31(s.offset(5 as libc::c_int as isize));
    if 0 as libc::c_int as libc::c_uint == id {
        h2_send_goaway_e(con, H2_E_PROTOCOL_ERROR);
        return;
    }
    let prio: uint32_t = h2_u31(s.offset(9 as libc::c_int as isize));
    let h2c: *mut h2con = (*con).h2;
    let mut i: uint32_t = 0 as libc::c_int as uint32_t;
    let mut rused: uint32_t = (*h2c).rused;
    while i < rused {
        let r: *mut request_st = (*h2c).r[i as usize];
        if (*r).h2id != id {
            i = i.wrapping_add(1);
        } else {
            if prio == id {
                h2_send_rst_stream(r, con, H2_E_PROTOCOL_ERROR);
                return;
            }
            return;
        }
    }
    if prio == id {
        h2_send_rst_stream_id(id, con, H2_E_PROTOCOL_ERROR);
        return;
    }
}
unsafe extern "C" fn h2_recv_window_update(con: *mut connection, s: *const uint8_t, len: uint32_t) {
    if 4 as libc::c_int as libc::c_uint != len {
        h2_send_goaway_e(con, H2_E_FRAME_SIZE_ERROR);
        return;
    }
    let id: uint32_t = h2_u31(s.offset(5 as libc::c_int as isize));
    let v: int32_t = h2_u31(s.offset(9 as libc::c_int as isize)) as int32_t;
    let mut r: *mut request_st = 0 as *mut request_st;
    if 0 as libc::c_int as libc::c_uint == id {
        r = &mut (*con).request;
    } else {
        let h2c: *mut h2con = (*con).h2;
        let mut i: uint32_t = 0 as libc::c_int as uint32_t;
        let mut rused: uint32_t = (*h2c).rused;
        while i < rused {
            let rr: *mut request_st = (*h2c).r[i as usize];
            if (*rr).h2id != id {
                i = i.wrapping_add(1);
            } else {
                r = rr;
                break;
            }
        }
        if r.is_null() {
            if (*h2c).h2_cid < id && 0 as libc::c_int == (*h2c).sent_goaway {
                h2_send_goaway_e(con, H2_E_PROTOCOL_ERROR);
            }
            return;
        }
        if (*r).h2state == H2_STATE_CLOSED as libc::c_int as libc::c_uint
            || (*r).h2state == H2_STATE_HALF_CLOSED_LOCAL as libc::c_int as libc::c_uint
        {
            return;
        }
    }
    if 0 as libc::c_int == v || (*r).h2_swin > 2147483647 as libc::c_int - v {
        let mut e: request_h2error_t = (if 0 as libc::c_int == v {
            H2_E_PROTOCOL_ERROR as libc::c_int
        } else {
            H2_E_FLOW_CONTROL_ERROR as libc::c_int
        }) as request_h2error_t;
        if 0 as libc::c_int as libc::c_uint == id {
            h2_send_goaway_e(con, e);
        } else {
            h2_send_rst_stream(r, con, e);
        }
        return;
    }
    (*r).h2_swin += v;
}
#[inline(never)]
unsafe extern "C" fn h2_send_window_update(
    con: *mut connection,
    mut h2id: uint32_t,
    len: uint32_t,
) {
    if 0 as libc::c_int as libc::c_uint == len {
        return;
    }
    let mut window_upd: C2RustUnnamed_24 = C2RustUnnamed_24 {
        c: [
            0 as libc::c_int as uint8_t,
            0 as libc::c_int as uint8_t,
            0 as libc::c_int as uint8_t,
            0 as libc::c_int as uint8_t,
            0 as libc::c_int as uint8_t,
            0x4 as libc::c_int as uint8_t,
            H2_FTYPE_WINDOW_UPDATE as libc::c_int as uint8_t,
            0 as libc::c_int as uint8_t,
            0 as libc::c_int as uint8_t,
            0 as libc::c_int as uint8_t,
            0 as libc::c_int as uint8_t,
            0 as libc::c_int as uint8_t,
            0 as libc::c_int as uint8_t,
            0 as libc::c_int as uint8_t,
            0 as libc::c_int as uint8_t,
            0 as libc::c_int as uint8_t,
        ],
    };
    window_upd.u[2 as libc::c_int as usize] = htonl(h2id);
    window_upd.u[3 as libc::c_int as usize] = htonl(len);
    chunkqueue_append_mem(
        (*con).write_queue,
        ((window_upd.c).as_mut_ptr() as *const libc::c_char).offset(3 as libc::c_int as isize),
        (::core::mem::size_of::<C2RustUnnamed_24>() as libc::c_ulong)
            .wrapping_sub(3 as libc::c_int as libc::c_ulong),
    );
}
unsafe extern "C" fn h2_parse_frame_settings(
    con: *mut connection,
    mut s: *const uint8_t,
    mut len: uint32_t,
) {
    let h2c: *mut h2con = (*con).h2;
    while len >= 6 as libc::c_int as libc::c_uint {
        let mut v: uint32_t = h2_u32(s.offset(2 as libc::c_int as isize));
        match h2_u16(s) as libc::c_int {
            1 => {
                if v > 4096 as libc::c_int as libc::c_uint {
                    v = 4096 as libc::c_int as uint32_t;
                }
                if !(v == (*h2c).s_header_table_size) {
                    (*h2c).s_header_table_size = v;
                    lshpack_enc_set_max_capacity(&mut (*h2c).encoder, v);
                }
            }
            2 => {
                if v | 1 as libc::c_int as libc::c_uint != 1 as libc::c_int as libc::c_uint {
                    h2_send_goaway_e(con, H2_E_PROTOCOL_ERROR);
                    return;
                }
                (*h2c).s_enable_push = v;
            }
            3 => {
                (*h2c).s_max_concurrent_streams = v;
            }
            4 => {
                if v > 2147483647 as libc::c_int as libc::c_uint {
                    h2_send_goaway_e(con, H2_E_FLOW_CONTROL_ERROR);
                    return;
                } else {
                    if (*h2c).rused != 0 {
                        let mut diff: int32_t =
                            v.wrapping_sub((*h2c).s_initial_window_size as uint32_t) as int32_t;
                        let mut i: uint32_t = 0 as libc::c_int as uint32_t;
                        let mut rused: uint32_t = (*h2c).rused;
                        while i < rused {
                            let r: *mut request_st = (*h2c).r[i as usize];
                            let swin: int32_t = (*r).h2_swin;
                            if !((*r).h2state
                                == H2_STATE_HALF_CLOSED_LOCAL as libc::c_int as libc::c_uint
                                || (*r).h2state == H2_STATE_CLOSED as libc::c_int as libc::c_uint)
                            {
                                if if diff >= 0 as libc::c_int {
                                    (swin > 2147483647 as libc::c_int - diff) as libc::c_int
                                } else {
                                    (swin < -(2147483647 as libc::c_int) - 1 as libc::c_int - diff)
                                        as libc::c_int
                                } != 0
                                {
                                    h2_send_rst_stream(r, con, H2_E_FLOW_CONTROL_ERROR);
                                } else {
                                    (*r).h2_swin += diff;
                                }
                            }
                            i = i.wrapping_add(1);
                        }
                    }
                }
                (*h2c).s_initial_window_size = v as int32_t;
            }
            5 => {
                if v < 16384 as libc::c_int as libc::c_uint
                    || v > 16777215 as libc::c_int as libc::c_uint
                {
                    h2_send_goaway_e(con, H2_E_PROTOCOL_ERROR);
                    return;
                }
                (*h2c).s_max_frame_size = v;
            }
            6 => {
                (*h2c).s_max_header_list_size = v;
            }
            _ => {}
        }
        len = (len as libc::c_uint).wrapping_sub(6 as libc::c_int as libc::c_uint) as uint32_t
            as uint32_t;
        s = s.offset(6 as libc::c_int as isize);
    }
    if len != 0 {
        h2_send_goaway_e(con, H2_E_FRAME_SIZE_ERROR);
        return;
    }
}
unsafe extern "C" fn h2_recv_settings(con: *mut connection, s: *const uint8_t, len: uint32_t) {
    if 0 as libc::c_int as libc::c_uint != h2_u31(s.offset(5 as libc::c_int as isize)) {
        h2_send_goaway_e(con, H2_E_PROTOCOL_ERROR);
        return;
    }
    let h2c: *mut h2con = (*con).h2;
    if *s.offset(4 as libc::c_int as isize) as libc::c_int & H2_FLAG_ACK as libc::c_int == 0 {
        h2_parse_frame_settings(con, s.offset(9 as libc::c_int as isize), len);
        if (*h2c).sent_goaway <= 0 as libc::c_int {
            h2_send_settings_ack(con);
        }
    } else if 0 as libc::c_int as libc::c_uint != len {
        h2_send_goaway_e(con, H2_E_FRAME_SIZE_ERROR);
    } else if (*h2c).sent_settings != 0 {
        (*h2c).sent_settings = 0 as libc::c_int as unix_time64_t;
    } else {
        h2_send_goaway_e(con, H2_E_PROTOCOL_ERROR);
    };
}
unsafe extern "C" fn h2_recv_end_data(
    r: *mut request_st,
    con: *mut connection,
    alen: uint32_t,
) -> libc::c_int {
    let reqbody_queue: *mut chunkqueue = &mut (*r).reqbody_queue;
    (*r).h2state = (if (*r).h2state == H2_STATE_OPEN as libc::c_int as libc::c_uint {
        H2_STATE_HALF_CLOSED_REMOTE as libc::c_int
    } else {
        H2_STATE_CLOSED as libc::c_int
    }) as uint32_t;
    if (*r).reqbody_length == -(1 as libc::c_int) as libc::c_long {
        (*r).reqbody_length = (*reqbody_queue).bytes_in + alen as off_t;
    } else if (*r).reqbody_length != (*reqbody_queue).bytes_in + alen as off_t {
        if 0 as libc::c_int as libc::c_long == (*reqbody_queue).bytes_out {
            h2_send_rst_stream(r, con, H2_E_PROTOCOL_ERROR);
            return 0 as libc::c_int;
        }
    }
    return 1 as libc::c_int;
}
unsafe extern "C" fn h2_recv_data(
    con: *mut connection,
    s: *const uint8_t,
    len: uint32_t,
) -> libc::c_int {
    let h2c: *mut h2con = (*con).h2;
    let id: uint32_t = h2_u31(s.offset(5 as libc::c_int as isize));
    if 0 as libc::c_int as libc::c_uint == id || (*h2c).h2_cid < id {
        h2_send_goaway_e(con, H2_E_PROTOCOL_ERROR);
        return 0 as libc::c_int;
    }
    let mut alen: uint32_t = len;
    let mut pad: uint32_t = 0 as libc::c_int as uint32_t;
    if *s.offset(4 as libc::c_int as isize) as libc::c_int & H2_FLAG_PADDED as libc::c_int != 0 {
        pad = *s.offset(9 as libc::c_int as isize) as uint32_t;
        if pad >= len {
            h2_send_goaway_e(con, H2_E_PROTOCOL_ERROR);
            return 0 as libc::c_int;
        }
        alen = (alen as libc::c_uint)
            .wrapping_sub((1 as libc::c_int as libc::c_uint).wrapping_add(pad))
            as uint32_t as uint32_t;
    }
    let h2r: *mut request_st = &mut (*con).request;
    if (*h2r).h2_rwin <= 0 as libc::c_int && 0 as libc::c_int as libc::c_uint != alen {
        return 0 as libc::c_int;
    }
    let mut r: *mut request_st = 0 as *mut request_st;
    let mut i: uint32_t = 0 as libc::c_int as uint32_t;
    let mut rused: uint32_t = (*h2c).rused;
    while i < rused {
        let rr: *mut request_st = (*h2c).r[i as usize];
        if (*rr).h2id != id {
            i = i.wrapping_add(1);
        } else {
            r = rr;
            break;
        }
    }
    let cq: *mut chunkqueue = (*con).read_queue;
    if r.is_null() {
        chunkqueue_mark_written(
            cq,
            (9 as libc::c_int as libc::c_uint).wrapping_add(len) as off_t,
        );
        if (*h2c).half_closed_ts + 2 as libc::c_int as libc::c_long >= log_monotonic_secs {
            h2_send_window_update(con, 0 as libc::c_int as uint32_t, len);
            return 1 as libc::c_int;
        } else {
            if (*h2c).sent_goaway == 0 && 0 as libc::c_int as libc::c_uint != alen {
                h2_send_goaway_e(con, H2_E_NO_ERROR);
            }
            return 0 as libc::c_int;
        }
    }
    if (*r).h2state == H2_STATE_CLOSED as libc::c_int as libc::c_uint
        || (*r).h2state == H2_STATE_HALF_CLOSED_REMOTE as libc::c_int as libc::c_uint
    {
        h2_send_rst_stream_id(id, con, H2_E_STREAM_CLOSED);
        chunkqueue_mark_written(
            cq,
            (9 as libc::c_int as libc::c_uint).wrapping_add(len) as off_t,
        );
        h2_send_window_update(con, 0 as libc::c_int as uint32_t, len);
        return 1 as libc::c_int;
    }
    if (*r).h2_rwin <= 0 as libc::c_int && 0 as libc::c_int as libc::c_uint != alen {
        if (*r).conf.stream_request_body as libc::c_int & (1 as libc::c_int) << 1 as libc::c_int
            != 0
        {
            return 0 as libc::c_int;
        }
    }
    h2_send_window_update(con, 0 as libc::c_int as uint32_t, len);
    let dst: *mut chunkqueue = &mut (*r).reqbody_queue;
    if (*r).reqbody_length >= 0 as libc::c_int as libc::c_long
        && (*r).reqbody_length < (*dst).bytes_in + alen as libc::c_long
    {
        h2_send_rst_stream(r, con, H2_E_PROTOCOL_ERROR);
        chunkqueue_mark_written(
            cq,
            (9 as libc::c_int as libc::c_uint).wrapping_add(len) as off_t,
        );
        return 1 as libc::c_int;
    }
    let rq: *mut chunkqueue = &mut (*r).read_queue;
    (*rq).bytes_in += alen as off_t;
    (*rq).bytes_out += alen as off_t;
    let mut wupd: uint32_t = 0 as libc::c_int as uint32_t;
    if *s.offset(4 as libc::c_int as isize) as libc::c_int & H2_FLAG_END_STREAM as libc::c_int != 0
    {
        if h2_recv_end_data(r, con, alen) == 0 {
            chunkqueue_mark_written(
                cq,
                (9 as libc::c_int as libc::c_uint).wrapping_add(len) as off_t,
            );
            return 1 as libc::c_int;
        }
    } else if 0 as libc::c_int as libc::c_uint == (*r).conf.max_request_size {
        wupd = len;
    } else {
        let max_request_size: off_t = ((*r).conf.max_request_size as off_t) << 10 as libc::c_int;
        let mut n: off_t = max_request_size - (*dst).bytes_in - alen as off_t;
        let mut rwin: int32_t = (*r).h2_rwin - len as int32_t;
        if rwin < 0 as libc::c_int {
            rwin = 0 as libc::c_int;
        }
        if (n >= 0 as libc::c_int as libc::c_long) as libc::c_int as libc::c_long != 0 {
            wupd = if n >= rwin as libc::c_long {
                n -= rwin as libc::c_long;
                if n > len as int32_t as libc::c_long {
                    len
                } else {
                    (n as uint32_t).wrapping_add(8 as libc::c_int as libc::c_uint)
                }
            } else {
                0 as libc::c_int as libc::c_uint
            };
        } else if -n > 65536 as libc::c_int as libc::c_long || 0 as libc::c_int == (*r).http_status
        {
            if 0 as libc::c_int == (*r).http_status {
                (*r).http_status = 413 as libc::c_int;
                (*r).handler_module = 0 as *const plugin;
                log_error(
                    (*r).conf.errh,
                    b"/home/kkysen/work/rust/lighttpd/src/h2.c\0" as *const u8
                        as *const libc::c_char,
                    967 as libc::c_int as libc::c_uint,
                    b"request-size too long: %lld -> 413\0" as *const u8 as *const libc::c_char,
                    ((*dst).bytes_in + alen as off_t) as libc::c_longlong,
                );
            } else {
                h2_send_rst_stream_id(id, con, H2_E_STREAM_CLOSED);
            }
            chunkqueue_mark_written(
                cq,
                (9 as libc::c_int as libc::c_uint).wrapping_add(len) as off_t,
            );
            return 1 as libc::c_int;
        }
    }
    h2_send_window_update(con, (*r).h2id, wupd);
    chunkqueue_mark_written(
        cq,
        (9 as libc::c_int
            + (if *s.offset(4 as libc::c_int as isize) as libc::c_int
                & H2_FLAG_PADDED as libc::c_int
                != 0
            {
                1 as libc::c_int
            } else {
                0 as libc::c_int
            })) as off_t,
    );
    let c: *const chunk = (*dst).last;
    if !c.is_null()
        && (*c).type_0 as libc::c_uint == FILE_CHUNK as libc::c_int as libc::c_uint
        && (*c).file.is_temp != 0
        || chunkqueue_length(dst) + alen as libc::c_long > 65536 as libc::c_int as libc::c_long
    {
        let errh: *mut log_error_st = (*r).conf.errh;
        if 0 as libc::c_int != chunkqueue_steal_with_tempfiles(dst, cq, alen as off_t, errh) {
            h2_send_rst_stream(r, con, H2_E_INTERNAL_ERROR);
            return 0 as libc::c_int;
        }
    } else {
        chunkqueue_steal(dst, cq, alen as off_t);
    }
    if pad != 0 {
        chunkqueue_mark_written(cq, pad as off_t);
    }
    return 1 as libc::c_int;
}
#[cold]
unsafe extern "C" fn h2_frame_cq_compact(cq: *mut chunkqueue, mut len: uint32_t) -> uint32_t {
    chunkqueue_compact_mem(cq, len as size_t);
    return (buffer_clen((*(*cq).first).mem)).wrapping_sub((*(*cq).first).offset as uint32_t);
}
#[cold]
unsafe extern "C" fn h2_recv_continuation(
    mut n: uint32_t,
    mut clen: uint32_t,
    cqlen: off_t,
    cq: *mut chunkqueue,
    con: *mut connection,
) -> uint32_t {
    let mut c: *mut chunk = (*cq).first;
    let mut s: *mut uint8_t = ((*(*c).mem).ptr).offset((*c).offset as isize) as *mut uint8_t;
    let mut m: uint32_t = n;
    let mut flags: uint32_t = 0;
    let h2c: *mut h2con = (*con).h2;
    let fsize: uint32_t = (*h2c).s_max_frame_size;
    let id: uint32_t = h2_u31(s.offset(5 as libc::c_int as isize));
    loop {
        if cqlen < n.wrapping_add(9 as libc::c_int as libc::c_uint) as libc::c_long {
            return n.wrapping_add(9 as libc::c_int as libc::c_uint);
        }
        if clen < n.wrapping_add(9 as libc::c_int as libc::c_uint) {
            clen = h2_frame_cq_compact(cq, n.wrapping_add(9 as libc::c_int as libc::c_uint));
            c = (*cq).first;
            s = ((*(*c).mem).ptr).offset((*c).offset as isize) as *mut uint8_t;
        }
        if *s.offset(n.wrapping_add(3 as libc::c_int as libc::c_uint) as isize) as libc::c_int
            != H2_FTYPE_CONTINUATION as libc::c_int
        {
            h2_send_goaway_e(con, H2_E_PROTOCOL_ERROR);
            return 0 as libc::c_int as uint32_t;
        }
        flags = *s.offset(n.wrapping_add(4 as libc::c_int as libc::c_uint) as isize) as uint32_t;
        let flen: uint32_t = h2_u24(s.offset(n as isize));
        if id != h2_u32(s.offset(n as isize).offset(5 as libc::c_int as isize)) {
            h2_send_goaway_e(con, H2_E_PROTOCOL_ERROR);
            return 0 as libc::c_int as uint32_t;
        }
        if flen > fsize {
            h2_send_goaway_e(con, H2_E_FRAME_SIZE_ERROR);
            return 0 as libc::c_int as uint32_t;
        }
        n = (n as libc::c_uint).wrapping_add((9 as libc::c_int as libc::c_uint).wrapping_add(flen))
            as uint32_t as uint32_t;
        if n >= 65536 as libc::c_int as libc::c_uint {
            h2_send_goaway_e(con, H2_E_FRAME_SIZE_ERROR);
            return 0 as libc::c_int as uint32_t;
        }
        if clen < n {
            clen = h2_frame_cq_compact(cq, n);
            if clen < n {
                return n;
            }
            c = (*cq).first;
            s = ((*(*c).mem).ptr).offset((*c).offset as isize) as *mut uint8_t;
        }
        if !(flags & H2_FLAG_END_HEADERS as libc::c_int as libc::c_uint == 0) {
            break;
        }
    }
    n = m;
    if *s.offset(4 as libc::c_int as isize) as libc::c_int & H2_FLAG_PADDED as libc::c_int != 0 {
        let plen: uint32_t = *s.offset(9 as libc::c_int as isize) as uint32_t;
        let flen_0: uint32_t = h2_u24(s);
        if flen_0
            < (1 as libc::c_int as libc::c_uint)
                .wrapping_add(plen)
                .wrapping_add(
                    (if *s.offset(n.wrapping_add(4 as libc::c_int as libc::c_uint) as isize)
                        as libc::c_int
                        & H2_FLAG_PRIORITY as libc::c_int
                        != 0
                    {
                        5 as libc::c_int
                    } else {
                        0 as libc::c_int
                    }) as libc::c_uint,
                )
        {
            h2_send_goaway_e(con, H2_E_PROTOCOL_ERROR);
            return 0 as libc::c_int as uint32_t;
        }
        *s.offset(9 as libc::c_int as isize) = 0 as libc::c_int as uint8_t;
        m = (m as libc::c_uint).wrapping_sub(plen) as uint32_t as uint32_t;
        (*cq).bytes_out += plen as libc::c_long;
    }
    loop {
        let flen_1: uint32_t = h2_u24(s.offset(n as isize));
        flags = *s.offset(n.wrapping_add(4 as libc::c_int as libc::c_uint) as isize) as uint32_t;
        memmove(
            s.offset(m as isize) as *mut libc::c_void,
            s.offset(n as isize).offset(9 as libc::c_int as isize) as *const libc::c_void,
            flen_1 as libc::c_ulong,
        );
        m = (m as libc::c_uint).wrapping_add(flen_1) as uint32_t as uint32_t;
        n = (n as libc::c_uint)
            .wrapping_add((9 as libc::c_int as libc::c_uint).wrapping_add(flen_1))
            as uint32_t as uint32_t;
        (*cq).bytes_out += 9 as libc::c_int as libc::c_long;
        if !(flags & H2_FLAG_END_HEADERS as libc::c_int as libc::c_uint == 0) {
            break;
        }
    }
    m = (m as libc::c_uint).wrapping_sub(9 as libc::c_int as libc::c_uint) as uint32_t as uint32_t;
    *s.offset(0 as libc::c_int as isize) =
        (m >> 16 as libc::c_int & 0xff as libc::c_int as libc::c_uint) as uint8_t;
    *s.offset(1 as libc::c_int as isize) =
        (m >> 8 as libc::c_int & 0xff as libc::c_int as libc::c_uint) as uint8_t;
    *s.offset(2 as libc::c_int as isize) = (m & 0xff as libc::c_int as libc::c_uint) as uint8_t;
    m = (m as libc::c_uint).wrapping_add(9 as libc::c_int as libc::c_uint) as uint32_t as uint32_t;
    if n < clen {
        memmove(
            s.offset(m as isize) as *mut libc::c_void,
            s.offset(n as isize) as *const libc::c_void,
            clen.wrapping_sub(n) as libc::c_ulong,
        );
        n = m.wrapping_add(clen.wrapping_sub(n));
    } else {
        n = m;
    }
    buffer_truncate((*c).mem, n.wrapping_add((*c).offset as uint32_t));
    return m;
}
#[cold]
unsafe extern "C" fn h2_recv_trailers_r(
    con: *mut connection,
    h2c: *mut h2con,
    id: uint32_t,
    flags: uint32_t,
) -> *mut request_st {
    let mut r: *mut request_st = 0 as *mut request_st;
    let mut i: uint32_t = 0 as libc::c_int as uint32_t;
    let mut rused: uint32_t = (*h2c).rused;
    while i < rused {
        let rr: *mut request_st = (*h2c).r[i as usize];
        if (*rr).h2id != id {
            i = i.wrapping_add(1);
        } else {
            r = rr;
            break;
        }
    }
    if r.is_null() {
        h2_send_goaway_e(con, H2_E_PROTOCOL_ERROR);
        return 0 as *mut request_st;
    }
    if (*r).h2state != H2_STATE_OPEN as libc::c_int as libc::c_uint
        && (*r).h2state != H2_STATE_HALF_CLOSED_LOCAL as libc::c_int as libc::c_uint
    {
        h2_send_rst_stream(r, con, H2_E_STREAM_CLOSED);
        return 0 as *mut request_st;
    }
    if flags & H2_FLAG_END_STREAM as libc::c_int as libc::c_uint == 0 {
        h2_send_rst_stream(r, con, H2_E_PROTOCOL_ERROR);
        return 0 as *mut request_st;
    }
    return if h2_recv_end_data(r, con, 0 as libc::c_int as uint32_t) != 0 {
        r
    } else {
        0 as *mut request_st
    };
}
unsafe extern "C" fn h2_parse_headers_frame(
    r: *mut request_st,
    mut psrc: *const libc::c_uchar,
    plen: uint32_t,
    trailers: libc::c_int,
) {
    let h2c: *mut h2con = (*(*r).con).h2;
    let decoder: *mut lshpack_dec = &mut (*h2c).decoder;
    let endp: *const libc::c_uchar = psrc.offset(plen as isize);
    let mut hpctx: http_header_parse_ctx = http_header_parse_ctx {
        k: 0 as *mut libc::c_char,
        v: 0 as *mut libc::c_char,
        klen: 0,
        vlen: 0,
        hlen: 0,
        pseudo: 0,
        scheme: 0,
        trailers: 0,
        id: 0,
        max_request_field_size: 0,
        http_parseopts: 0,
    };
    hpctx.hlen = 0 as libc::c_int as uint32_t;
    hpctx.pseudo = 1 as libc::c_int as uint8_t;
    hpctx.scheme = 0 as libc::c_int as uint8_t;
    hpctx.trailers = trailers as uint8_t;
    hpctx.max_request_field_size = (*r).conf.max_request_field_size;
    hpctx.http_parseopts = (*r).conf.http_parseopts;
    let log_request_header: libc::c_int = (*r).conf.log_request_header as libc::c_int;
    let mut rc: libc::c_int = 0 as libc::c_int;
    let tb: *mut buffer = (*r).tmp_buf;
    if !((*tb).size >= 65536 as libc::c_int as libc::c_uint) {
        ck_assert_failed(
            b"/home/kkysen/work/rust/lighttpd/src/h2.c\0" as *const u8 as *const libc::c_char,
            1234 as libc::c_int as libc::c_uint,
            b"tb->size >= 65536\0" as *const u8 as *const libc::c_char,
        );
    }
    let tbptr: *mut libc::c_char = (*tb).ptr;
    let tbsz: lsxpack_strlen_t = (if (*tb).size <= 65535 as libc::c_int as libc::c_uint {
        (*tb).size
    } else {
        65535 as libc::c_int as libc::c_uint
    }) as lsxpack_strlen_t;
    let mut lsx: lsxpack_header_t = lsxpack_header_t {
        buf: 0 as *mut libc::c_char,
        name_hash: 0,
        nameval_hash: 0,
        name_offset: 0,
        name_len: 0,
        val_offset: 0,
        val_len: 0,
        chain_next_idx: 0,
        hpack_index: 0,
        qpack_index: 0,
        app_index: 0,
        flags: [0; 1],
        indexed_type: 0,
        dec_overhead: 0,
    };
    while psrc < endp {
        memset(
            &mut lsx as *mut lsxpack_header_t as *mut libc::c_void,
            0 as libc::c_int,
            ::core::mem::size_of::<lsxpack_header_t>() as libc::c_ulong,
        );
        lsx.buf = tbptr;
        lsx.val_len = tbsz;
        rc = lshpack_dec_decode(decoder, &mut psrc, endp, &mut lsx);
        if 0 as libc::c_int == lsx.name_len as libc::c_int {
            rc = -(1 as libc::c_int);
        }
        if (rc == 0 as libc::c_int) as libc::c_int as libc::c_long != 0 {
            hpctx.k = (lsx.buf).offset(lsx.name_offset as libc::c_int as isize);
            hpctx.v = (lsx.buf).offset(lsx.val_offset as libc::c_int as isize);
            hpctx.klen = lsx.name_len as uint32_t;
            hpctx.vlen = lsx.val_len as uint32_t;
            hpctx.id = lshpack_idx_http_header[lsx.hpack_index as usize];
            if log_request_header != 0 {
                log_error(
                    (*r).conf.errh,
                    b"/home/kkysen/work/rust/lighttpd/src/h2.c\0" as *const u8
                        as *const libc::c_char,
                    1264 as libc::c_int as libc::c_uint,
                    b"fd:%d id:%u rqst: %.*s: %.*s\0" as *const u8 as *const libc::c_char,
                    (*(*r).con).fd,
                    (*r).h2id,
                    hpctx.klen as libc::c_int,
                    hpctx.k,
                    hpctx.vlen as libc::c_int,
                    hpctx.v,
                );
            }
            let http_status_0: libc::c_int = http_request_parse_header(r, &mut hpctx);
            if !((0 as libc::c_int != http_status_0) as libc::c_int as libc::c_long != 0) {
                continue;
            }
            if (*r).http_status == 0 as libc::c_int {
                (*r).http_status = http_status_0;
            }
            break;
        } else {
            let mut err: request_h2error_t = H2_E_COMPRESSION_ERROR;
            if rc != -(1 as libc::c_int) {
                err = H2_E_PROTOCOL_ERROR;
                h2_send_rst_stream(r, (*r).con, err);
            }
            if (*h2c).sent_goaway == 0 && trailers == 0 {
                (*h2c).h2_cid = (*r).h2id;
            }
            h2_send_goaway_e((*r).con, err);
            if trailers == 0 {
                h2_retire_stream(r, (*r).con);
                return;
            } else {
                (*r).state = CON_STATE_ERROR;
                (*r).h2state = H2_STATE_CLOSED as libc::c_int as uint32_t;
            }
            break;
        }
    }
    hpctx.hlen = (hpctx.hlen as libc::c_uint).wrapping_add(2 as libc::c_int as libc::c_uint)
        as uint32_t as uint32_t;
    (*r).rqst_header_len =
        ((*r).rqst_header_len as libc::c_uint).wrapping_add(hpctx.hlen) as uint32_t as uint32_t;
    let rq: *mut chunkqueue = &mut (*r).read_queue;
    (*rq).bytes_in += hpctx.hlen as off_t;
    (*rq).bytes_out += hpctx.hlen as off_t;
    if 0 as libc::c_int == (*r).http_status && 0 as libc::c_int == rc && trailers == 0 {
        if hpctx.pseudo != 0 {
            (*r).http_status = http_request_validate_pseudohdrs(
                r,
                hpctx.scheme as libc::c_int,
                hpctx.http_parseopts,
            );
        }
        if 0 as libc::c_int == (*r).http_status {
            http_request_headers_process_h2(r, (*(*r).con).proto_default_port as libc::c_int);
        }
    }
}
unsafe extern "C" fn h2_recv_headers(
    con: *mut connection,
    s: *mut uint8_t,
    mut flen: uint32_t,
) -> libc::c_int {
    let mut r: *mut request_st = 0 as *mut request_st;
    let h2c: *mut h2con = (*con).h2;
    let id: uint32_t = h2_u31(s.offset(5 as libc::c_int as isize));
    if id & 1 as libc::c_int as libc::c_uint == 0 {
        h2_send_goaway_e(con, H2_E_PROTOCOL_ERROR);
        return 0 as libc::c_int;
    }
    let h2r: *mut request_st = &mut (*con).request;
    let mut trailers: libc::c_int = 0 as libc::c_int;
    if id > (*h2c).h2_cid {
        if (*h2c).rused as libc::c_ulong
            == (::core::mem::size_of::<[*mut request_st; 8]>() as libc::c_ulong)
                .wrapping_div(::core::mem::size_of::<*mut request_st>() as libc::c_ulong)
        {
            return h2_send_refused_stream(id, con);
        }
        r = h2_init_stream(h2r, con);
        (*r).h2id = id;
        (*r).h2state = (if *s.offset(4 as libc::c_int as isize) as libc::c_int
            & H2_FLAG_END_STREAM as libc::c_int
            != 0
        {
            H2_STATE_HALF_CLOSED_REMOTE as libc::c_int
        } else {
            H2_STATE_OPEN as libc::c_int
        }) as uint32_t;
        (*r).state = CON_STATE_REQUEST_END;
        (*r).start_hp.tv_sec = log_epoch_secs;
        if (*r).conf.high_precision_timestamps != 0 {
            clock_gettime(0 as libc::c_int, &mut (*r).start_hp);
        }
    } else {
        r = h2_recv_trailers_r(
            con,
            h2c,
            id,
            *s.offset(4 as libc::c_int as isize) as uint32_t,
        );
        if r.is_null() {
            return if (*h2c).sent_goaway > 0 as libc::c_int {
                0 as libc::c_int
            } else {
                1 as libc::c_int
            };
        }
        trailers = 1 as libc::c_int;
    }
    let mut psrc: *const libc::c_uchar = s.offset(9 as libc::c_int as isize);
    let mut alen: uint32_t = flen;
    if *s.offset(4 as libc::c_int as isize) as libc::c_int & H2_FLAG_PADDED as libc::c_int != 0 {
        psrc = psrc.offset(1);
        let pad: uint32_t = *s.offset(9 as libc::c_int as isize) as uint32_t;
        if flen
            < (1 as libc::c_int as libc::c_uint)
                .wrapping_add(pad)
                .wrapping_add(
                    (if *s.offset(4 as libc::c_int as isize) as libc::c_int
                        & H2_FLAG_PRIORITY as libc::c_int
                        != 0
                    {
                        5 as libc::c_int
                    } else {
                        0 as libc::c_int
                    }) as libc::c_uint,
                )
        {
            h2_send_goaway_e(con, H2_E_PROTOCOL_ERROR);
            if trailers == 0 {
                h2_retire_stream(r, con);
            } else {
                (*r).state = CON_STATE_ERROR;
                (*r).h2state = H2_STATE_CLOSED as libc::c_int as uint32_t;
            }
            return 0 as libc::c_int;
        }
        alen = (alen as libc::c_uint)
            .wrapping_sub((1 as libc::c_int as libc::c_uint).wrapping_add(pad))
            as uint32_t as uint32_t;
    }
    if *s.offset(4 as libc::c_int as isize) as libc::c_int & H2_FLAG_PRIORITY as libc::c_int != 0 {
        let prio: uint32_t = h2_u31(psrc);
        if prio == id {
            h2_send_rst_stream(r, con, H2_E_PROTOCOL_ERROR);
            if trailers == 0 {
                h2_retire_stream(r, con);
            }
            return 1 as libc::c_int;
        }
        psrc = psrc.offset(5 as libc::c_int as isize);
        alen = (alen as libc::c_uint).wrapping_sub(5 as libc::c_int as libc::c_uint) as uint32_t
            as uint32_t;
    }
    h2_parse_headers_frame(r, psrc, alen, trailers);
    if (*h2c).sent_goaway == 0 {
        (*h2c).h2_cid = id;
        if (*r).rqst_htags & (1 as libc::c_ulong) << HTTP_HEADER_CONTENT_LENGTH as libc::c_int == 0
        {
            (*r).reqbody_length = (if *s.offset(4 as libc::c_int as isize) as libc::c_int
                & H2_FLAG_END_STREAM as libc::c_int
                != 0
            {
                0 as libc::c_int
            } else {
                -(1 as libc::c_int)
            }) as off_t;
        }
    } else if (*h2c).h2_cid < id {
        (*r).http_status = 0 as libc::c_int;
        h2_retire_stream(r, con);
    }
    return 1 as libc::c_int;
}
#[no_mangle]
pub unsafe extern "C" fn h2_parse_frames(con: *mut connection) -> libc::c_int {
    let h2c: *mut h2con = (*con).h2;
    let cq: *mut chunkqueue = (*con).read_queue;
    let fsize: uint32_t = (*h2c).s_max_frame_size;
    let mut cqlen: off_t = chunkqueue_length(cq);
    while cqlen >= 9 as libc::c_int as libc::c_long {
        let mut c: *mut chunk = (*cq).first;
        let mut clen: uint32_t = (buffer_clen((*c).mem) as libc::c_long - (*c).offset) as uint32_t;
        if clen < 9 as libc::c_int as libc::c_uint {
            clen = h2_frame_cq_compact(cq, 9 as libc::c_int as uint32_t);
            c = (*cq).first;
        }
        let mut s: *mut uint8_t = ((*(*c).mem).ptr).offset((*c).offset as isize) as *mut uint8_t;
        let mut flen: uint32_t = h2_u24(s);
        if flen > fsize {
            h2_send_goaway_e(con, H2_E_FRAME_SIZE_ERROR);
            return 0 as libc::c_int;
        }
        if *s.offset(3 as libc::c_int as isize) as libc::c_int == H2_FTYPE_HEADERS as libc::c_int {
            if cqlen < (9 as libc::c_int as libc::c_uint).wrapping_add(flen) as libc::c_long {
                return 1 as libc::c_int;
            }
            if clen < (9 as libc::c_int as libc::c_uint).wrapping_add(flen) {
                clen =
                    h2_frame_cq_compact(cq, (9 as libc::c_int as libc::c_uint).wrapping_add(flen));
                c = (*cq).first;
                s = ((*(*c).mem).ptr).offset((*c).offset as isize) as *mut uint8_t;
            }
            if *s.offset(4 as libc::c_int as isize) as libc::c_int
                & H2_FLAG_END_HEADERS as libc::c_int
                == 0
            {
                clen = h2_recv_continuation(
                    (9 as libc::c_int as libc::c_uint).wrapping_add(flen),
                    clen,
                    cqlen,
                    cq,
                    con,
                );
                if 0 as libc::c_int as libc::c_uint == clen {
                    return 0 as libc::c_int;
                }
                if cqlen < clen as libc::c_long {
                    return 1 as libc::c_int;
                }
                c = (*cq).first;
                s = ((*(*c).mem).ptr).offset((*c).offset as isize) as *mut uint8_t;
                flen = h2_u24(s);
                cqlen = chunkqueue_length(cq);
            }
            let mut rc: libc::c_int = h2_recv_headers(con, s, flen);
            cqlen -= (9 as libc::c_int as libc::c_uint).wrapping_add(flen) as libc::c_long;
            if rc >= 0 as libc::c_int {
                chunkqueue_mark_written(
                    cq,
                    (9 as libc::c_int as libc::c_uint).wrapping_add(flen) as off_t,
                );
            }
            if rc <= 0 as libc::c_int {
                return 0 as libc::c_int;
            }
            (*con).read_idle_ts = log_monotonic_secs;
        } else if *s.offset(3 as libc::c_int as isize) as libc::c_int
            == H2_FTYPE_DATA as libc::c_int
        {
            if cqlen < (9 as libc::c_int as libc::c_uint).wrapping_add(flen) as libc::c_long {
                return 1 as libc::c_int;
            }
            (*con).read_idle_ts = log_monotonic_secs;
            if h2_recv_data(con, s, flen) == 0 {
                return 0 as libc::c_int;
            }
            cqlen -= (9 as libc::c_int as libc::c_uint).wrapping_add(flen) as libc::c_long;
        } else {
            if cqlen < (9 as libc::c_int as libc::c_uint).wrapping_add(flen) as libc::c_long {
                return 1 as libc::c_int;
            }
            if clen < (9 as libc::c_int as libc::c_uint).wrapping_add(flen) {
                clen =
                    h2_frame_cq_compact(cq, (9 as libc::c_int as libc::c_uint).wrapping_add(flen));
                c = (*cq).first;
                s = ((*(*c).mem).ptr).offset((*c).offset as isize) as *mut uint8_t;
            }
            match *s.offset(3 as libc::c_int as isize) as libc::c_int {
                8 => {
                    h2_recv_window_update(con, s, flen);
                }
                2 => {
                    h2_recv_priority(con, s, flen);
                }
                4 => {
                    h2_recv_settings(con, s, flen);
                }
                6 => {
                    h2_recv_ping(con, s, flen);
                }
                3 => {
                    h2_recv_rst_stream(con, s, flen);
                }
                7 => {
                    if h2_recv_goaway(con, s, flen) == 0 {
                        return 0 as libc::c_int;
                    }
                }
                5 | 9 => {
                    h2_send_goaway_e(con, H2_E_PROTOCOL_ERROR);
                    return 0 as libc::c_int;
                }
                _ => {}
            }
            cqlen -= (9 as libc::c_int as libc::c_uint).wrapping_add(flen) as libc::c_long;
            chunkqueue_mark_written(
                cq,
                (9 as libc::c_int as libc::c_uint).wrapping_add(flen) as off_t,
            );
        }
        if (*h2c).sent_goaway > 0 as libc::c_int {
            return 0 as libc::c_int;
        }
    }
    return 1 as libc::c_int;
}
#[no_mangle]
pub unsafe extern "C" fn h2_want_read(con: *mut connection) -> libc::c_int {
    let cq: *mut chunkqueue = (*con).read_queue;
    if chunkqueue_is_empty(cq) != 0 {
        return 1 as libc::c_int;
    }
    let cqlen: off_t = chunkqueue_length(cq);
    if cqlen < 9 as libc::c_int as libc::c_long {
        return 1 as libc::c_int;
    }
    let mut c: *mut chunk = (*cq).first;
    let mut clen: uint32_t = (buffer_clen((*c).mem) as libc::c_long - (*c).offset) as uint32_t;
    if clen < 9 as libc::c_int as libc::c_uint {
        clen = h2_frame_cq_compact(cq, 9 as libc::c_int as uint32_t);
        c = (*cq).first;
    }
    let mut s: *mut uint8_t = ((*(*c).mem).ptr).offset((*c).offset as isize) as *mut uint8_t;
    let mut flen: uint32_t = h2_u24(s);
    if clen < (9 as libc::c_int as libc::c_uint).wrapping_add(flen) {
        return 1 as libc::c_int;
    }
    if *s.offset(3 as libc::c_int as isize) as libc::c_int != H2_FTYPE_HEADERS as libc::c_int
        || *s.offset(4 as libc::c_int as isize) as libc::c_int & H2_FLAG_END_HEADERS as libc::c_int
            != 0
    {
        return 0 as libc::c_int;
    }
    let mut n: uint32_t = (9 as libc::c_int as libc::c_uint).wrapping_add(flen);
    while cqlen >= n.wrapping_add(9 as libc::c_int as libc::c_uint) as libc::c_long {
        if clen < n.wrapping_add(9 as libc::c_int as libc::c_uint) {
            clen = h2_frame_cq_compact(cq, n.wrapping_add(9 as libc::c_int as libc::c_uint));
            c = (*cq).first;
            s = ((*(*c).mem).ptr).offset((*c).offset as isize) as *mut uint8_t;
        }
        flen = h2_u24(s.offset(n as isize));
        if cqlen
            < n.wrapping_add(9 as libc::c_int as libc::c_uint)
                .wrapping_add(flen) as libc::c_long
        {
            return 1 as libc::c_int;
        }
        if *s.offset(4 as libc::c_int as isize) as libc::c_int & H2_FLAG_END_HEADERS as libc::c_int
            != 0
        {
            return 0 as libc::c_int;
        }
        n = (n as libc::c_uint).wrapping_add((9 as libc::c_int as libc::c_uint).wrapping_add(flen))
            as uint32_t as uint32_t;
    }
    return 1 as libc::c_int;
}
unsafe extern "C" fn h2_recv_client_connection_preface(con: *mut connection) -> libc::c_int {
    let cq: *mut chunkqueue = (*con).read_queue;
    if chunkqueue_length(cq) < 24 as libc::c_int as libc::c_long {
        let c: *mut chunk = (*cq).first;
        if !c.is_null()
            && buffer_clen((*c).mem) as libc::c_long - (*c).offset
                >= 4 as libc::c_int as libc::c_long
        {
            let s: *const libc::c_char = ((*(*c).mem).ptr).offset((*c).offset as isize);
            if *s.offset(0 as libc::c_int as isize) as libc::c_int != 'P' as i32
                || *s.offset(1 as libc::c_int as isize) as libc::c_int != 'R' as i32
                || *s.offset(2 as libc::c_int as isize) as libc::c_int != 'I' as i32
                || *s.offset(3 as libc::c_int as isize) as libc::c_int != ' ' as i32
            {
                h2_send_goaway_e(con, H2_E_PROTOCOL_ERROR);
                return 1 as libc::c_int;
            }
        }
        return 0 as libc::c_int;
    }
    static mut h2preface: [libc::c_char; 25] = unsafe {
        *::core::mem::transmute::<&[u8; 25], &[libc::c_char; 25]>(
            b"PRI * HTTP/2.0\r\n\r\nSM\r\n\r\n\0",
        )
    };
    let mut c_0: *mut chunk = (*cq).first;
    let clen: uint32_t = (buffer_clen((*c_0).mem) as libc::c_long - (*c_0).offset) as uint32_t;
    if clen < 24 as libc::c_int as libc::c_uint {
        h2_frame_cq_compact(cq, 24 as libc::c_int as uint32_t);
    }
    c_0 = (*cq).first;
    let s_0: *const uint8_t = ((*(*c_0).mem).ptr).offset((*c_0).offset as isize) as *mut uint8_t;
    if 0 as libc::c_int
        == memcmp(
            s_0 as *const libc::c_void,
            h2preface.as_ptr() as *const libc::c_void,
            24 as libc::c_int as libc::c_ulong,
        )
    {
        chunkqueue_mark_written(cq, 24 as libc::c_int as off_t);
    } else {
        h2_send_goaway_e(con, H2_E_PROTOCOL_ERROR);
    }
    return 1 as libc::c_int;
}
#[cold]
unsafe extern "C" fn h2_read_client_connection_preface(
    con: *mut connection,
    cq: *mut chunkqueue,
    mut max_bytes: off_t,
) -> libc::c_int {
    let hctx: *mut *mut libc::c_void = ((*con).plugin_ctx).offset(0 as libc::c_int as isize);
    let network_read: Option<
        unsafe extern "C" fn(*mut connection, *mut chunkqueue, off_t) -> libc::c_int,
    > = ::core::mem::transmute::<
        libc::intptr_t,
        Option<unsafe extern "C" fn(*mut connection, *mut chunkqueue, off_t) -> libc::c_int>,
    >(*hctx as uintptr_t as libc::intptr_t);
    if max_bytes < 24 as libc::c_int as libc::c_long {
        max_bytes = 24 as libc::c_int as off_t;
    }
    let mut rc: libc::c_int = network_read.expect("non-null function pointer")(con, cq, max_bytes);
    if ((*con).h2).is_null() {
        return rc;
    }
    if -(1 as libc::c_int) != rc && h2_recv_client_connection_preface(con) != 0 {
        (*con).network_read = network_read;
        *hctx = 0 as *mut libc::c_void;
        (*con).read_idle_ts = log_monotonic_secs;
    }
    return rc;
}
#[no_mangle]
pub unsafe extern "C" fn h2_init_con(
    h2r: *mut request_st,
    con: *mut connection,
    http2_settings: *const buffer,
) {
    let h2c: *mut h2con = calloc(
        1 as libc::c_int as libc::c_ulong,
        ::core::mem::size_of::<h2con>() as libc::c_ulong,
    ) as *mut h2con;
    if h2c.is_null() {
        ck_assert_failed(
            b"/home/kkysen/work/rust/lighttpd/src/h2.c\0" as *const u8 as *const libc::c_char,
            1740 as libc::c_int as libc::c_uint,
            b"h2c\0" as *const u8 as *const libc::c_char,
        );
    }
    (*con).h2 = h2c;
    (*con).read_idle_ts = log_monotonic_secs;
    (*con).keep_alive_idle = (*h2r).conf.max_keep_alive_idle as libc::c_int;
    (*h2r).h2_rwin = 65535 as libc::c_int;
    (*h2r).h2_swin = 65535 as libc::c_int;
    (*h2c).s_header_table_size = 4096 as libc::c_int as uint32_t;
    (*h2c).s_enable_push = 1 as libc::c_int as uint32_t;
    (*h2c).s_max_concurrent_streams = !(0 as libc::c_uint);
    (*h2c).s_initial_window_size = 65535 as libc::c_int;
    (*h2c).s_max_frame_size = 16384 as libc::c_int as uint32_t;
    (*h2c).s_max_header_list_size = !(0 as libc::c_uint);
    (*h2c).sent_settings = log_monotonic_secs;
    lshpack_dec_init(&mut (*h2c).decoder);
    lshpack_enc_init(&mut (*h2c).encoder);
    lshpack_enc_use_hist(&mut (*h2c).encoder, 1 as libc::c_int);
    if !http2_settings.is_null() {
        h2_parse_frame_settings(
            con,
            (*http2_settings).ptr as *mut uint8_t,
            buffer_clen(http2_settings),
        );
    }
    static mut h2settings: [uint8_t; 21] = [
        0 as libc::c_int as uint8_t,
        0 as libc::c_int as uint8_t,
        0xc as libc::c_int as uint8_t,
        H2_FTYPE_SETTINGS as libc::c_int as uint8_t,
        0 as libc::c_int as uint8_t,
        0 as libc::c_int as uint8_t,
        0 as libc::c_int as uint8_t,
        0 as libc::c_int as uint8_t,
        0 as libc::c_int as uint8_t,
        0 as libc::c_int as uint8_t,
        H2_SETTINGS_MAX_CONCURRENT_STREAMS as libc::c_int as uint8_t,
        0 as libc::c_int as uint8_t,
        0 as libc::c_int as uint8_t,
        0 as libc::c_int as uint8_t,
        0x8 as libc::c_int as uint8_t,
        0 as libc::c_int as uint8_t,
        H2_SETTINGS_MAX_HEADER_LIST_SIZE as libc::c_int as uint8_t,
        0 as libc::c_int as uint8_t,
        0 as libc::c_int as uint8_t,
        0xff as libc::c_int as uint8_t,
        0xff as libc::c_int as uint8_t,
    ];
    chunkqueue_append_mem(
        (*con).write_queue,
        h2settings.as_ptr() as *const libc::c_char,
        ::core::mem::size_of::<[uint8_t; 21]>() as libc::c_ulong,
    );
    if h2_recv_client_connection_preface(con) == 0 {
        let ref mut fresh13 = *((*con).plugin_ctx).offset(0 as libc::c_int as isize);
        *fresh13 = ::core::mem::transmute::<
            Option<unsafe extern "C" fn(*mut connection, *mut chunkqueue, off_t) -> libc::c_int>,
            uintptr_t,
        >((*con).network_read) as *mut libc::c_void;
        (*con).network_read = Some(
            h2_read_client_connection_preface
                as unsafe extern "C" fn(*mut connection, *mut chunkqueue, off_t) -> libc::c_int,
        );
    }
    buffer_string_prepare_copy((*h2r).tmp_buf, 65535 as libc::c_int as size_t);
}
unsafe extern "C" fn h2_send_hpack(
    r: *mut request_st,
    con: *mut connection,
    mut data: *const libc::c_char,
    mut dlen: uint32_t,
    flags: uint32_t,
) {
    let mut headers: C2RustUnnamed_18 = C2RustUnnamed_18 {
        c: [
            0 as libc::c_int as uint8_t,
            0 as libc::c_int as uint8_t,
            0 as libc::c_int as uint8_t,
            0 as libc::c_int as uint8_t,
            0 as libc::c_int as uint8_t,
            0 as libc::c_int as uint8_t,
            H2_FTYPE_HEADERS as libc::c_int as uint8_t,
            flags as uint8_t,
            0 as libc::c_int as uint8_t,
            0 as libc::c_int as uint8_t,
            0 as libc::c_int as uint8_t,
            0 as libc::c_int as uint8_t,
        ],
    };
    headers.u[2 as libc::c_int as usize] = htonl((*r).h2id);
    let b: *mut buffer = chunkqueue_append_buffer_open_sz(
        (*con).write_queue,
        dlen.wrapping_add(dlen >> 10 as libc::c_int)
            .wrapping_add(9 as libc::c_int as libc::c_uint) as size_t,
    );
    let mut ptr: *mut libc::c_char = (*b).ptr;
    let h2c: *mut h2con = (*con).h2;
    let fsize: uint32_t = (*h2c).s_max_frame_size;
    loop {
        let len: uint32_t = if dlen < fsize { dlen } else { fsize };
        headers.c[3 as libc::c_int as usize] =
            (len >> 16 as libc::c_int & 0xff as libc::c_int as libc::c_uint) as uint8_t;
        headers.c[4 as libc::c_int as usize] =
            (len >> 8 as libc::c_int & 0xff as libc::c_int as libc::c_uint) as uint8_t;
        headers.c[5 as libc::c_int as usize] =
            (len & 0xff as libc::c_int as libc::c_uint) as uint8_t;
        if len == dlen {
            headers.c[7 as libc::c_int as usize] =
                (headers.c[7 as libc::c_int as usize] as libc::c_int
                    | H2_FLAG_END_HEADERS as libc::c_int) as uint8_t;
        }
        memcpy(
            ptr as *mut libc::c_void,
            (headers.c).as_mut_ptr().offset(3 as libc::c_int as isize) as *const libc::c_void,
            (::core::mem::size_of::<C2RustUnnamed_18>() as libc::c_ulong)
                .wrapping_sub(3 as libc::c_int as libc::c_ulong),
        );
        memcpy(
            ptr.offset(::core::mem::size_of::<C2RustUnnamed_18>() as libc::c_ulong as isize)
                .offset(-(3 as libc::c_int as isize)) as *mut libc::c_void,
            data as *const libc::c_void,
            len as libc::c_ulong,
        );
        ptr = ptr.offset(
            (len as libc::c_ulong)
                .wrapping_add(::core::mem::size_of::<C2RustUnnamed_18>() as libc::c_ulong)
                .wrapping_sub(3 as libc::c_int as libc::c_ulong) as isize,
        );
        data = data.offset(len as isize);
        dlen = (dlen as libc::c_uint).wrapping_sub(len) as uint32_t as uint32_t;
        headers.c[6 as libc::c_int as usize] = H2_FTYPE_CONTINUATION as libc::c_int as uint8_t;
        headers.c[7 as libc::c_int as usize] = 0 as libc::c_int as uint8_t;
        if !(dlen != 0) {
            break;
        }
    }
    buffer_truncate(b, ptr.offset_from((*b).ptr) as libc::c_long as uint32_t);
    chunkqueue_append_buffer_commit((*con).write_queue);
}
#[cold]
unsafe extern "C" fn h2_log_response_header_lsx(r: *mut request_st, lsx: *const lsxpack_header_t) {
    log_error(
        (*r).conf.errh,
        b"/home/kkysen/work/rust/lighttpd/src/h2.c\0" as *const u8 as *const libc::c_char,
        1883 as libc::c_int as libc::c_uint,
        b"fd:%d id:%u resp: %.*s: %.*s\0" as *const u8 as *const libc::c_char,
        (*(*r).con).fd,
        (*r).h2id,
        (*lsx).name_len as libc::c_int,
        ((*lsx).buf).offset((*lsx).name_offset as libc::c_int as isize),
        (*lsx).val_len as libc::c_int,
        ((*lsx).buf).offset((*lsx).val_offset as libc::c_int as isize),
    );
}
#[cold]
unsafe extern "C" fn h2_log_response_header(
    r: *mut request_st,
    len: libc::c_int,
    hdr: *const libc::c_char,
) {
    log_error(
        (*r).conf.errh,
        b"/home/kkysen/work/rust/lighttpd/src/h2.c\0" as *const u8 as *const libc::c_char,
        1894 as libc::c_int as libc::c_uint,
        b"fd:%d id:%u resp: %.*s\0" as *const u8 as *const libc::c_char,
        (*(*r).con).fd,
        (*r).h2id,
        len,
        hdr,
    );
}
#[no_mangle]
pub unsafe extern "C" fn h2_send_cqdata(
    r: *mut request_st,
    con: *mut connection,
    cq: *mut chunkqueue,
    mut dlen: uint32_t,
) -> uint32_t {
    let mut dataframe: C2RustUnnamed_23 = C2RustUnnamed_23 {
        c: [
            0 as libc::c_int as uint8_t,
            0 as libc::c_int as uint8_t,
            0 as libc::c_int as uint8_t,
            0 as libc::c_int as uint8_t,
            0 as libc::c_int as uint8_t,
            0 as libc::c_int as uint8_t,
            H2_FTYPE_DATA as libc::c_int as uint8_t,
            0 as libc::c_int as uint8_t,
            0 as libc::c_int as uint8_t,
            0 as libc::c_int as uint8_t,
            0 as libc::c_int as uint8_t,
            0 as libc::c_int as uint8_t,
        ],
    };
    dataframe.u[2 as libc::c_int as usize] = htonl((*r).h2id);
    let h2r: *mut request_st = &mut (*con).request;
    if (*r).h2_swin < 0 as libc::c_int {
        return 0 as libc::c_int as uint32_t;
    }
    if (*h2r).h2_swin < 0 as libc::c_int {
        return 0 as libc::c_int as uint32_t;
    }
    if dlen as int32_t > (*r).h2_swin {
        dlen = (*r).h2_swin as uint32_t;
    }
    if dlen as int32_t > (*h2r).h2_swin {
        dlen = (*h2r).h2_swin as uint32_t;
    }
    let cqlen: uint32_t = chunkqueue_length(cq) as uint32_t;
    if dlen > cqlen {
        dlen = cqlen;
    }
    if 0 as libc::c_int as libc::c_uint == dlen {
        return 0 as libc::c_int as uint32_t;
    }
    let h2c: *mut h2con = (*con).h2;
    let fsize: uint32_t = (*h2c).s_max_frame_size;
    let mut sent: uint32_t = 0 as libc::c_int as uint32_t;
    let mut current_block_31: u64;
    loop {
        if (*(*cq).first).type_0 as libc::c_uint == FILE_CHUNK as libc::c_int as libc::c_uint {
            let len: uint32_t = if dlen < fsize {
                dlen
            } else {
                fsize.wrapping_sub(9 as libc::c_int as libc::c_uint)
            };
            let mut blen: uint32_t = len;
            let b: *mut buffer = chunkqueue_append_buffer_open_sz(
                (*con).write_queue,
                (9 as libc::c_int as libc::c_uint).wrapping_add(len) as size_t,
            );
            let mut data: *mut libc::c_char = ((*b).ptr).offset(9 as libc::c_int as isize);
            if 0 as libc::c_int == chunkqueue_peek_data(cq, &mut data, &mut blen, (*r).conf.errh)
                && blen == len
            {
                dlen = (dlen as libc::c_uint).wrapping_sub(len) as uint32_t as uint32_t;
                sent = (sent as libc::c_uint).wrapping_add(len) as uint32_t as uint32_t;
                dataframe.c[3 as libc::c_int as usize] =
                    (len >> 16 as libc::c_int & 0xff as libc::c_int as libc::c_uint) as uint8_t;
                dataframe.c[4 as libc::c_int as usize] =
                    (len >> 8 as libc::c_int & 0xff as libc::c_int as libc::c_uint) as uint8_t;
                dataframe.c[5 as libc::c_int as usize] =
                    (len & 0xff as libc::c_int as libc::c_uint) as uint8_t;
                memcpy(
                    (*b).ptr as *mut libc::c_void,
                    ((dataframe.c).as_mut_ptr() as *const libc::c_char)
                        .offset(3 as libc::c_int as isize)
                        as *const libc::c_void,
                    (::core::mem::size_of::<C2RustUnnamed_23>() as libc::c_ulong)
                        .wrapping_sub(3 as libc::c_int as libc::c_ulong),
                );
                if ((*b).ptr).offset(9 as libc::c_int as isize) != data {
                    memcpy(
                        ((*b).ptr).offset(9 as libc::c_int as isize) as *mut libc::c_void,
                        data as *const libc::c_void,
                        len as libc::c_ulong,
                    );
                }
                buffer_commit(
                    b,
                    (9 as libc::c_int as libc::c_uint).wrapping_add(len) as size_t,
                );
                chunkqueue_append_buffer_commit((*con).write_queue);
                chunkqueue_mark_written(cq, len as off_t);
                current_block_31 = 5399440093318478209;
            } else {
                chunkqueue_remove_empty_chunks(cq);
                current_block_31 = 17478428563724192186;
            }
        } else {
            current_block_31 = 17478428563724192186;
        }
        match current_block_31 {
            17478428563724192186 => {
                let len_0: uint32_t = if dlen < fsize { dlen } else { fsize };
                dlen = (dlen as libc::c_uint).wrapping_sub(len_0) as uint32_t as uint32_t;
                sent = (sent as libc::c_uint).wrapping_add(len_0) as uint32_t as uint32_t;
                dataframe.c[3 as libc::c_int as usize] =
                    (len_0 >> 16 as libc::c_int & 0xff as libc::c_int as libc::c_uint) as uint8_t;
                dataframe.c[4 as libc::c_int as usize] =
                    (len_0 >> 8 as libc::c_int & 0xff as libc::c_int as libc::c_uint) as uint8_t;
                dataframe.c[5 as libc::c_int as usize] =
                    (len_0 & 0xff as libc::c_int as libc::c_uint) as uint8_t;
                chunkqueue_append_mem(
                    (*con).write_queue,
                    ((dataframe.c).as_mut_ptr() as *const libc::c_char)
                        .offset(3 as libc::c_int as isize),
                    (::core::mem::size_of::<C2RustUnnamed_23>() as libc::c_ulong)
                        .wrapping_sub(3 as libc::c_int as libc::c_ulong),
                );
                chunkqueue_steal((*con).write_queue, cq, len_0 as off_t);
            }
            _ => {}
        }
        if !(dlen != 0) {
            break;
        }
    }
    (*r).h2_swin -= sent as int32_t;
    (*h2r).h2_swin -= sent as int32_t;
    return sent;
}
#[cold]
#[inline(never)]
unsafe extern "C" fn h2_send_end_stream_trailers(
    r: *mut request_st,
    con: *mut connection,
    trailers: *const buffer,
) {
    let mut hoff: [libc::c_ushort; 8192] = [0; 8192];
    hoff[0 as libc::c_int as usize] = 1 as libc::c_int as libc::c_ushort;
    hoff[1 as libc::c_int as usize] = 0 as libc::c_int as libc::c_ushort;
    let mut rc: uint32_t =
        http_header_parse_hoff((*trailers).ptr, buffer_clen(trailers), hoff.as_mut_ptr());
    if 0 as libc::c_int as libc::c_uint == rc
        || rc > (32767 as libc::c_int * 2 as libc::c_int + 1 as libc::c_int) as libc::c_uint
        || hoff[0 as libc::c_int as usize] as libc::c_ulong
            >= (::core::mem::size_of::<[libc::c_ushort; 8192]>() as libc::c_ulong)
                .wrapping_div(::core::mem::size_of::<libc::c_ushort>() as libc::c_ulong)
                .wrapping_sub(1 as libc::c_int as libc::c_ulong)
        || 1 as libc::c_int == hoff[0 as libc::c_int as usize] as libc::c_int
    {
        h2_send_end_stream_data(r, con);
        return;
    }
    let ptr: *mut libc::c_char = (*trailers).ptr;
    let mut i: libc::c_int = 1 as libc::c_int;
    while i < hoff[0 as libc::c_int as usize] as libc::c_int {
        let mut k: *mut libc::c_char = ptr.offset(
            (if i > 1 as libc::c_int {
                hoff[i as usize] as libc::c_int
            } else {
                0 as libc::c_int
            }) as isize,
        );
        if *k as libc::c_int == ':' as i32 {
            h2_send_end_stream_data(r, con);
            return;
        }
        let colon: *const libc::c_char = memchr(
            k as *const libc::c_void,
            ':' as i32,
            ptr.offset(hoff[(i + 1 as libc::c_int) as usize] as libc::c_int as isize)
                .offset_from(k) as libc::c_long as libc::c_ulong,
        ) as *const libc::c_char;
        if !colon.is_null() {
            loop {
                if (*k as uint32_t).wrapping_sub('A' as i32 as libc::c_uint)
                    <= ('Z' as i32 - 'A' as i32) as libc::c_uint
                {
                    *k = (*k as libc::c_int | 0x20 as libc::c_int) as libc::c_char;
                }
                k = k.offset(1);
                if !(k != colon as *mut libc::c_char) {
                    break;
                }
            }
        }
        i += 1;
    }
    h2_send_headers_block(
        r,
        con,
        (*trailers).ptr,
        buffer_clen(trailers),
        H2_FLAG_END_STREAM as libc::c_int as uint32_t,
    );
}
unsafe extern "C" fn h2_send_end_stream_data(r: *mut request_st, con: *mut connection) {
    let mut dataframe: C2RustUnnamed_22 = C2RustUnnamed_22 {
        c: [
            0 as libc::c_int as uint8_t,
            0 as libc::c_int as uint8_t,
            0 as libc::c_int as uint8_t,
            0 as libc::c_int as uint8_t,
            0 as libc::c_int as uint8_t,
            0 as libc::c_int as uint8_t,
            H2_FTYPE_DATA as libc::c_int as uint8_t,
            H2_FLAG_END_STREAM as libc::c_int as uint8_t,
            0 as libc::c_int as uint8_t,
            0 as libc::c_int as uint8_t,
            0 as libc::c_int as uint8_t,
            0 as libc::c_int as uint8_t,
        ],
    };
    dataframe.u[2 as libc::c_int as usize] = htonl((*r).h2id);
    chunkqueue_append_mem(
        (*con).write_queue,
        ((dataframe.c).as_mut_ptr() as *const libc::c_char).offset(3 as libc::c_int as isize),
        (::core::mem::size_of::<C2RustUnnamed_22>() as libc::c_ulong)
            .wrapping_sub(3 as libc::c_int as libc::c_ulong),
    );
    if (*r).h2state != H2_STATE_HALF_CLOSED_REMOTE as libc::c_int as libc::c_uint {
        let h2c: *mut h2con = (*con).h2;
        (*h2c).half_closed_ts = log_monotonic_secs;
        h2_send_rst_stream_id((*r).h2id, con, H2_E_NO_ERROR);
    }
    (*r).h2state = H2_STATE_CLOSED as libc::c_int as uint32_t;
}
#[no_mangle]
pub unsafe extern "C" fn h2_send_end_stream(r: *mut request_st, con: *mut connection) {
    if (*r).h2state == H2_STATE_CLOSED as libc::c_int as libc::c_uint {
        return;
    }
    if (*r).state as libc::c_uint != CON_STATE_ERROR as libc::c_int as libc::c_uint
        && (*r).resp_body_finished as libc::c_int != 0
    {
        if !((*r).gw_dechunk).is_null()
            && (*(*r).gw_dechunk).done != 0
            && buffer_is_unset(&mut (*(*r).gw_dechunk).b) == 0
        {
            h2_send_end_stream_trailers(r, con, &mut (*(*r).gw_dechunk).b);
        } else {
            h2_send_end_stream_data(r, con);
        }
    } else {
        h2_send_rst_stream(r, con, H2_E_INTERNAL_ERROR);
    };
}
#[no_mangle]
pub unsafe extern "C" fn h2_retire_stream(mut r: *mut request_st, con: *mut connection) {
    if r.is_null() {
        return;
    }
    let h2c: *mut h2con = (*con).h2;
    let ar: *mut *mut request_st = ((*h2c).r).as_mut_ptr();
    let mut i: uint32_t = 0 as libc::c_int as uint32_t;
    let mut rused: uint32_t = (*h2c).rused;
    while i < rused && *ar.offset(i as isize) != r {
        i = i.wrapping_add(1);
    }
    if i != rused {
        rused = rused.wrapping_sub(1);
        if i != rused {
            memmove(
                ar.offset(i as isize) as *mut libc::c_void,
                ar.offset(i as isize).offset(1 as libc::c_int as isize) as *const libc::c_void,
                (rused.wrapping_sub(i) as libc::c_ulong)
                    .wrapping_mul(::core::mem::size_of::<*mut request_st>() as libc::c_ulong),
            );
        }
        (*h2c).rused = rused;
        (*h2c).r[(*h2c).rused as usize] = 0 as *mut request_st;
        h2_release_stream(r, con);
    }
}
unsafe extern "C" fn h2_init_stream(h2r: *mut request_st, con: *mut connection) -> *mut request_st {
    let h2c: *mut h2con = (*con).h2;
    (*con).request_count = ((*con).request_count).wrapping_add(1);
    if !(((*h2c).rused as libc::c_ulong)
        < (::core::mem::size_of::<[*mut request_st; 8]>() as libc::c_ulong)
            .wrapping_div(::core::mem::size_of::<*mut request_st>() as libc::c_ulong))
    {
        ck_assert_failed(
            b"/home/kkysen/work/rust/lighttpd/src/h2.c\0" as *const u8 as *const libc::c_char,
            2558 as libc::c_int as libc::c_uint,
            b"h2c->rused < sizeof(h2c->r)/sizeof(*h2c->r)\0" as *const u8 as *const libc::c_char,
        );
    }
    let r: *mut request_st = request_acquire(con);
    let fresh14 = (*h2c).rused;
    (*h2c).rused = ((*h2c).rused).wrapping_add(1);
    (*h2c).r[fresh14 as usize] = r;
    (*r).h2_rwin = 65535 as libc::c_int;
    (*r).h2_swin = (*h2c).s_initial_window_size;
    (*r).http_version = HTTP_VERSION_2;
    let srv: *mut server = (*con).srv;
    let used: uint32_t = (*(*srv).config_context).used;
    (*r).conditional_is_valid = (*h2r).conditional_is_valid;
    memcpy(
        (*r).cond_cache as *mut libc::c_void,
        (*h2r).cond_cache as *const libc::c_void,
        (used as libc::c_ulong)
            .wrapping_mul(::core::mem::size_of::<cond_cache_t>() as libc::c_ulong),
    );
    if (*srv).config_captures != 0 {
        memcpy(
            (*r).cond_match as *mut libc::c_void,
            (*h2r).cond_match as *const libc::c_void,
            ((*srv).config_captures as libc::c_ulong)
                .wrapping_mul(::core::mem::size_of::<*mut cond_match_t>() as libc::c_ulong),
        );
    }
    (*r).server_name = (*h2r).server_name;
    memcpy(
        &mut (*r).conf as *mut request_config as *mut libc::c_void,
        &mut (*h2r).conf as *mut request_config as *const libc::c_void,
        ::core::mem::size_of::<request_config>() as libc::c_ulong,
    );
    return r;
}
#[no_mangle]
pub unsafe extern "C" fn h2_send_100_continue(r: *mut request_st, con: *mut connection) {
    h2_send_1xx_block(
        r,
        con,
        b":status: 100\r\n\r\n\0" as *const u8 as *const libc::c_char,
        (::core::mem::size_of::<[libc::c_char; 17]>() as libc::c_ulong as uint32_t)
            .wrapping_sub(1 as libc::c_int as libc::c_uint),
    );
}
unsafe extern "C" fn h2_send_1xx_block(
    r: *mut request_st,
    con: *mut connection,
    hdrs: *const libc::c_char,
    hlen: uint32_t,
) {
    h2_send_headers_block(r, con, hdrs, hlen, 0 as libc::c_int as uint32_t);
}
#[no_mangle]
#[cold]
#[inline(never)]
pub unsafe extern "C" fn h2_check_con_upgrade_h2c(r: *mut request_st) -> libc::c_int {
    let mut http_connection: *mut buffer = 0 as *mut buffer;
    let mut http2_settings: *mut buffer = 0 as *mut buffer;
    let mut upgrade: *mut buffer = http_header_request_get(
        r,
        HTTP_HEADER_UPGRADE,
        b"Upgrade\0" as *const u8 as *const libc::c_char,
        (::core::mem::size_of::<[libc::c_char; 8]>() as libc::c_ulong as uint32_t)
            .wrapping_sub(1 as libc::c_int as libc::c_uint),
    );
    if upgrade.is_null() {
        return 0 as libc::c_int;
    }
    http_connection = http_header_request_get(
        r,
        HTTP_HEADER_CONNECTION,
        b"Connection\0" as *const u8 as *const libc::c_char,
        (::core::mem::size_of::<[libc::c_char; 11]>() as libc::c_ulong as uint32_t)
            .wrapping_sub(1 as libc::c_int as libc::c_uint),
    );
    if http_connection.is_null() {
        http_header_request_unset(
            r,
            HTTP_HEADER_UPGRADE,
            b"Upgrade\0" as *const u8 as *const libc::c_char,
            (::core::mem::size_of::<[libc::c_char; 8]>() as libc::c_ulong as uint32_t)
                .wrapping_sub(1 as libc::c_int as libc::c_uint),
        );
        return 0 as libc::c_int;
    }
    if (*r).http_version as libc::c_int != HTTP_VERSION_1_1 as libc::c_int {
        http_header_request_unset(
            r,
            HTTP_HEADER_UPGRADE,
            b"Upgrade\0" as *const u8 as *const libc::c_char,
            (::core::mem::size_of::<[libc::c_char; 8]>() as libc::c_ulong as uint32_t)
                .wrapping_sub(1 as libc::c_int as libc::c_uint),
        );
        http_header_remove_token(
            http_connection,
            b"Upgrade\0" as *const u8 as *const libc::c_char,
            (::core::mem::size_of::<[libc::c_char; 8]>() as libc::c_ulong as uint32_t)
                .wrapping_sub(1 as libc::c_int as libc::c_uint),
        );
        return 0 as libc::c_int;
    }
    if http_header_str_contains_token(
        (*upgrade).ptr,
        buffer_clen(upgrade),
        b"h2c\0" as *const u8 as *const libc::c_char,
        (::core::mem::size_of::<[libc::c_char; 4]>() as libc::c_ulong as uint32_t)
            .wrapping_sub(1 as libc::c_int as libc::c_uint),
    ) == 0
    {
        return 0 as libc::c_int;
    }
    http2_settings = http_header_request_get(
        r,
        HTTP_HEADER_HTTP2_SETTINGS,
        b"HTTP2-Settings\0" as *const u8 as *const libc::c_char,
        (::core::mem::size_of::<[libc::c_char; 15]>() as libc::c_ulong as uint32_t)
            .wrapping_sub(1 as libc::c_int as libc::c_uint),
    );
    if !http2_settings.is_null() {
        if 0 as libc::c_int as libc::c_long == (*r).reqbody_length {
            let b: *mut buffer = (*r).tmp_buf;
            buffer_clear(b);
            if (*r).conf.h2proto as libc::c_int > 1 as libc::c_int
                && (*(*r).con).is_ssl_sock == 0
                && http_header_str_contains_token(
                    (*http_connection).ptr,
                    buffer_clen(http_connection),
                    b"HTTP2-Settings\0" as *const u8 as *const libc::c_char,
                    (::core::mem::size_of::<[libc::c_char; 15]>() as libc::c_ulong as uint32_t)
                        .wrapping_sub(1 as libc::c_int as libc::c_uint),
                ) != 0
                && !(buffer_append_base64_decode(
                    b,
                    (*http2_settings).ptr,
                    buffer_clen(http2_settings) as size_t,
                    BASE64_URL,
                ))
                .is_null()
            {
                h2_con_upgrade_h2c(r, b);
                (*r).http_version = HTTP_VERSION_2;
            }
        }
        http_header_request_unset(
            r,
            HTTP_HEADER_HTTP2_SETTINGS,
            b"HTTP2-Settings\0" as *const u8 as *const libc::c_char,
            (::core::mem::size_of::<[libc::c_char; 15]>() as libc::c_ulong as uint32_t)
                .wrapping_sub(1 as libc::c_int as libc::c_uint),
        );
        http_header_remove_token(
            http_connection,
            b"HTTP2-Settings\0" as *const u8 as *const libc::c_char,
            (::core::mem::size_of::<[libc::c_char; 15]>() as libc::c_ulong as uint32_t)
                .wrapping_sub(1 as libc::c_int as libc::c_uint),
        );
    }
    http_header_request_unset(
        r,
        HTTP_HEADER_UPGRADE,
        b"Upgrade\0" as *const u8 as *const libc::c_char,
        (::core::mem::size_of::<[libc::c_char; 8]>() as libc::c_ulong as uint32_t)
            .wrapping_sub(1 as libc::c_int as libc::c_uint),
    );
    http_header_remove_token(
        http_connection,
        b"Upgrade\0" as *const u8 as *const libc::c_char,
        (::core::mem::size_of::<[libc::c_char; 8]>() as libc::c_ulong as uint32_t)
            .wrapping_sub(1 as libc::c_int as libc::c_uint),
    );
    return ((*r).http_version as libc::c_int == HTTP_VERSION_2 as libc::c_int) as libc::c_int;
}
#[cold]
#[inline(never)]
unsafe extern "C" fn h2_send_headers_block(
    r: *mut request_st,
    con: *mut connection,
    hdrs: *const libc::c_char,
    hlen: uint32_t,
    mut flags: uint32_t,
) {
    let mut hoff: [libc::c_ushort; 8192] = [0; 8192];
    hoff[0 as libc::c_int as usize] = 1 as libc::c_int as libc::c_ushort;
    hoff[1 as libc::c_int as usize] = 0 as libc::c_int as libc::c_ushort;
    let mut rc: uint32_t = http_header_parse_hoff(hdrs, hlen, hoff.as_mut_ptr());
    if 0 as libc::c_int as libc::c_uint == rc
        || rc > (32767 as libc::c_int * 2 as libc::c_int + 1 as libc::c_int) as libc::c_uint
        || hoff[0 as libc::c_int as usize] as libc::c_ulong
            >= (::core::mem::size_of::<[libc::c_ushort; 8192]>() as libc::c_ulong)
                .wrapping_div(::core::mem::size_of::<libc::c_ushort>() as libc::c_ulong)
                .wrapping_sub(1 as libc::c_int as libc::c_ulong)
        || 1 as libc::c_int == hoff[0 as libc::c_int as usize] as libc::c_int
    {
        log_error(
            (*r).conf.errh,
            b"/home/kkysen/work/rust/lighttpd/src/h2.c\0" as *const u8 as *const libc::c_char,
            2133 as libc::c_int as libc::c_uint,
            b"oversized response-header\0" as *const u8 as *const libc::c_char,
        );
        hoff[0 as libc::c_int as usize] = 1 as libc::c_int as libc::c_ushort;
        hoff[1 as libc::c_int as usize] = 0 as libc::c_int as libc::c_ushort;
        http_header_parse_hoff(
            b":status: 500\r\n\r\n\0" as *const u8 as *const libc::c_char,
            (::core::mem::size_of::<[libc::c_char; 17]>() as libc::c_ulong as uint32_t)
                .wrapping_sub(1 as libc::c_int as libc::c_uint),
            hoff.as_mut_ptr(),
        ) != 0;
    }
    let tb: *mut buffer = (*r).tmp_buf;
    if !((*tb).size >= 65536 as libc::c_int as libc::c_uint) {
        ck_assert_failed(
            b"/home/kkysen/work/rust/lighttpd/src/h2.c\0" as *const u8 as *const libc::c_char,
            2144 as libc::c_int as libc::c_uint,
            b"tb->size >= 65536\0" as *const u8 as *const libc::c_char,
        );
    }
    let mut dst: *mut libc::c_uchar = (*tb).ptr as *mut libc::c_uchar;
    let dst_end: *mut libc::c_uchar = ((*tb).ptr as *mut libc::c_uchar).offset((*tb).size as isize);
    let h2c: *mut h2con = (*con).h2;
    let encoder: *mut lshpack_enc = &mut (*h2c).encoder;
    let mut lsx: lsxpack_header_t = lsxpack_header_t {
        buf: 0 as *mut libc::c_char,
        name_hash: 0,
        nameval_hash: 0,
        name_offset: 0,
        name_len: 0,
        val_offset: 0,
        val_len: 0,
        chain_next_idx: 0,
        hpack_index: 0,
        qpack_index: 0,
        app_index: 0,
        flags: [0; 1],
        indexed_type: 0,
        dec_overhead: 0,
    };
    let mut i: libc::c_int = 1 as libc::c_int;
    if *hdrs.offset(0 as libc::c_int as isize) as libc::c_int == ':' as i32 {
        i = 2 as libc::c_int;
        memset(
            &mut lsx as *mut lsxpack_header_t as *mut libc::c_void,
            0 as libc::c_int,
            ::core::mem::size_of::<lsxpack_header_t>() as libc::c_ulong,
        );
        let ref mut fresh15 = *(&mut lsx.buf as *mut *mut libc::c_char as *mut *const libc::c_char);
        *fresh15 = hdrs;
        lsx.name_offset = 0 as libc::c_int as lsxpack_strlen_t;
        lsx.name_len = (::core::mem::size_of::<[libc::c_char; 8]>() as libc::c_ulong)
            .wrapping_sub(1 as libc::c_int as libc::c_ulong)
            as lsxpack_strlen_t;
        lsx.val_offset = (lsx.name_len as libc::c_int + 2 as libc::c_int) as lsxpack_strlen_t;
        lsx.val_len = 3 as libc::c_int as lsxpack_strlen_t;
        dst = lshpack_enc_encode(encoder, dst, dst_end, &mut lsx);
        if dst == (*tb).ptr as *mut libc::c_uchar {
            h2_send_rst_stream(r, con, H2_E_INTERNAL_ERROR);
            return;
        }
    }
    while i < hoff[0 as libc::c_int as usize] as libc::c_int {
        let mut k: *const libc::c_char = hdrs.offset(
            (if i > 1 as libc::c_int {
                hoff[i as usize] as libc::c_int
            } else {
                0 as libc::c_int
            }) as isize,
        );
        let mut end: *const libc::c_char =
            hdrs.offset(hoff[(i + 1 as libc::c_int) as usize] as libc::c_int as isize);
        let mut v: *const libc::c_char = memchr(
            k as *const libc::c_void,
            ':' as i32,
            end.offset_from(k) as libc::c_long as libc::c_ulong,
        ) as *const libc::c_char;
        if !(v.is_null() || k == v) {
            let mut klen: uint32_t = v.offset_from(k) as libc::c_long as uint32_t;
            if !(0 as libc::c_int as libc::c_uint == klen) {
                loop {
                    v = v.offset(1);
                    if !(*v as libc::c_int == ' ' as i32 || *v as libc::c_int == '\t' as i32) {
                        break;
                    }
                }
                if !(*end.offset(-(2 as libc::c_int) as isize) as libc::c_int != '\r' as i32) {
                    end = end.offset(-(2 as libc::c_int as isize));
                    let mut vlen: uint32_t = end.offset_from(v) as libc::c_long as uint32_t;
                    if !(0 as libc::c_int as libc::c_uint == vlen) {
                        memset(
                            &mut lsx as *mut lsxpack_header_t as *mut libc::c_void,
                            0 as libc::c_int,
                            ::core::mem::size_of::<lsxpack_header_t>() as libc::c_ulong,
                        );
                        let ref mut fresh16 =
                            *(&mut lsx.buf as *mut *mut libc::c_char as *mut *const libc::c_char);
                        *fresh16 = hdrs;
                        lsx.name_offset = k.offset_from(hdrs) as libc::c_long as lsxpack_strlen_t;
                        lsx.name_len = klen as lsxpack_strlen_t;
                        lsx.val_offset = v.offset_from(hdrs) as libc::c_long as lsxpack_strlen_t;
                        lsx.val_len = vlen as lsxpack_strlen_t;
                        let dst_in: *mut libc::c_uchar = dst;
                        dst = lshpack_enc_encode(encoder, dst, dst_end, &mut lsx);
                        if dst == dst_in {
                            h2_send_rst_stream(r, con, H2_E_INTERNAL_ERROR);
                            return;
                        }
                    }
                }
            }
        }
        i += 1;
    }
    let mut dlen: uint32_t =
        (dst as *mut libc::c_char).offset_from((*tb).ptr) as libc::c_long as uint32_t;
    h2_send_hpack(r, con, (*tb).ptr, dlen, flags);
}
unsafe extern "C" fn h2_con_upgrade_h2c(h2r: *mut request_st, http2_settings: *const buffer) {
    static mut switch_proto: [libc::c_char; 72] = unsafe {
        *::core::mem::transmute::<&[u8; 72], &[libc::c_char; 72]>(
            b"HTTP/1.1 101 Switching Protocols\r\nConnection: Upgrade\r\nUpgrade: h2c\r\n\r\n\0",
        )
    };
    chunkqueue_append_mem(
        &mut (*h2r).write_queue,
        switch_proto.as_ptr(),
        (::core::mem::size_of::<[libc::c_char; 72]>() as libc::c_ulong as uint32_t)
            .wrapping_sub(1 as libc::c_int as libc::c_uint) as size_t,
    );
    (*h2r).resp_header_len = (::core::mem::size_of::<[libc::c_char; 72]>() as libc::c_ulong)
        .wrapping_sub(1 as libc::c_int as libc::c_ulong) as uint32_t;
    let con: *mut connection = (*h2r).con;
    h2_init_con(h2r, con, http2_settings);
    if (*(*con).h2).sent_goaway != 0 {
        return;
    }
    (*(*con).h2).h2_cid = 1 as libc::c_int as uint32_t;
    let r: *mut request_st = h2_init_stream(h2r, con);
    (*con).request_count = ((*con).request_count).wrapping_sub(1);
    (*r).state = CON_STATE_REQUEST_END;
    (*r).http_status = 0 as libc::c_int;
    (*r).http_method = (*h2r).http_method;
    (*r).h2state = H2_STATE_HALF_CLOSED_REMOTE as libc::c_int as uint32_t;
    (*r).h2id = 1 as libc::c_int as uint32_t;
    (*r).rqst_htags = (*h2r).rqst_htags;
    (*h2r).rqst_htags = 0 as libc::c_int as uint64_t;
    (*r).rqst_header_len = (*h2r).rqst_header_len;
    (*h2r).rqst_header_len = 0 as libc::c_int as uint32_t;
    (*r).rqst_headers = (*h2r).rqst_headers;
    memset(
        &mut (*h2r).rqst_headers as *mut array as *mut libc::c_void,
        0 as libc::c_int,
        ::core::mem::size_of::<array>() as libc::c_ulong,
    );
    (*r).uri = (*h2r).uri;
    memset(
        &mut (*h2r).rqst_headers as *mut array as *mut libc::c_void,
        0 as libc::c_int,
        ::core::mem::size_of::<array>() as libc::c_ulong,
    );
    memset(
        &mut (*h2r).uri as *mut request_uri as *mut libc::c_void,
        0 as libc::c_int,
        ::core::mem::size_of::<request_uri>() as libc::c_ulong,
    );
    (*r).http_host = (*h2r).http_host;
    (*h2r).http_host = 0 as *mut buffer;
    (*r).target = (*h2r).target;
    (*r).target_orig = (*h2r).target_orig;
    memset(
        &mut (*h2r).target as *mut buffer as *mut libc::c_void,
        0 as libc::c_int,
        ::core::mem::size_of::<buffer>() as libc::c_ulong,
    );
    memset(
        &mut (*h2r).target_orig as *mut buffer as *mut libc::c_void,
        0 as libc::c_int,
        ::core::mem::size_of::<buffer>() as libc::c_ulong,
    );
    (*r).keep_alive = (*h2r).keep_alive;
    (*r).tmp_buf = (*h2r).tmp_buf;
    (*r).start_hp = (*h2r).start_hp;
}
#[no_mangle]
pub unsafe extern "C" fn h2_retire_con(h2r: *mut request_st, con: *mut connection) {
    let h2c: *mut h2con = (*con).h2;
    if h2c.is_null() {
        return;
    }
    if (*h2r).state as libc::c_uint != CON_STATE_ERROR as libc::c_int as libc::c_uint {
        h2_send_goaway(con, H2_E_NO_ERROR);
        let mut i: uint32_t = 0 as libc::c_int as uint32_t;
        let mut rused: uint32_t = (*h2c).rused;
        while i < rused {
            let r: *mut request_st = (*h2c).r[i as usize];
            h2_send_rst_stream(r, con, H2_E_INTERNAL_ERROR);
            h2_release_stream(r, con);
            i = i.wrapping_add(1);
        }
        if chunkqueue_is_empty((*con).write_queue) == 0 {
            let cq: *mut chunkqueue = (*con).write_queue;
            let len: off_t = chunkqueue_length(cq);
            let mut written: off_t = (*cq).bytes_out;
            ((*con).network_write).expect("non-null function pointer")(con, cq, len);
            written = (*cq).bytes_out - written;
            (*con).bytes_written += written;
            (*con).bytes_written_cur_second += written;
            if !((*h2r).conf.global_bytes_per_second_cnt_ptr).is_null() {
                *(*h2r).conf.global_bytes_per_second_cnt_ptr += written;
            }
        }
    } else {
        let mut i_0: uint32_t = 0 as libc::c_int as uint32_t;
        let mut rused_0: uint32_t = (*h2c).rused;
        while i_0 < rused_0 {
            let r_0: *mut request_st = (*h2c).r[i_0 as usize];
            h2_release_stream(r_0, con);
            i_0 = i_0.wrapping_add(1);
        }
    }
    (*con).h2 = 0 as *mut h2con;
    lshpack_enc_cleanup(&mut (*h2c).encoder);
    lshpack_dec_cleanup(&mut (*h2c).decoder);
    free(h2c as *mut libc::c_void);
}
unsafe extern "C" fn h2_release_stream(r: *mut request_st, con: *mut connection) {
    if (*r).http_status != 0 {
        plugins_call_handle_request_done(r);
    }
    request_release(r);
}
#[no_mangle]
pub unsafe extern "C" fn h2_send_1xx(r: *mut request_st, con: *mut connection) -> libc::c_int {
    let b: *mut buffer = chunk_buffer_acquire();
    buffer_copy_string_len(
        b,
        b":status: \0" as *const u8 as *const libc::c_char,
        (::core::mem::size_of::<[libc::c_char; 10]>() as libc::c_ulong as uint32_t)
            .wrapping_sub(1 as libc::c_int as libc::c_uint) as size_t,
    );
    buffer_append_int(b, (*r).http_status as intmax_t);
    let mut i: uint32_t = 0 as libc::c_int as uint32_t;
    while i < (*r).resp_headers.used {
        let ds: *const data_string =
            *((*r).resp_headers.data).offset(i as isize) as *mut data_string;
        let klen: uint32_t = buffer_clen(&(*ds).key);
        let vlen: uint32_t = buffer_clen(&(*ds).value);
        if !(0 as libc::c_int as libc::c_uint == klen || 0 as libc::c_int as libc::c_uint == vlen) {
            buffer_append_str2(
                b,
                b"\r\n\0" as *const u8 as *const libc::c_char,
                (::core::mem::size_of::<[libc::c_char; 3]>() as libc::c_ulong as uint32_t)
                    .wrapping_sub(1 as libc::c_int as libc::c_uint) as size_t,
                (*ds).key.ptr,
                klen as size_t,
            );
            buffer_append_str2(
                b,
                b": \0" as *const u8 as *const libc::c_char,
                (::core::mem::size_of::<[libc::c_char; 3]>() as libc::c_ulong as uint32_t)
                    .wrapping_sub(1 as libc::c_int as libc::c_uint) as size_t,
                (*ds).value.ptr,
                vlen as size_t,
            );
        }
        i = i.wrapping_add(1);
    }
    buffer_append_string_len(
        b,
        b"\r\n\r\n\0" as *const u8 as *const libc::c_char,
        (::core::mem::size_of::<[libc::c_char; 5]>() as libc::c_ulong as uint32_t)
            .wrapping_sub(1 as libc::c_int as libc::c_uint) as size_t,
    );
    h2_send_1xx_block(r, con, (*b).ptr, buffer_clen(b));
    chunk_buffer_release(b);
    return 1 as libc::c_int;
}
#[no_mangle]
pub unsafe extern "C" fn h2_send_headers(r: *mut request_st, con: *mut connection) {
    (*con).keep_alive_idle = (*r).conf.max_keep_alive_idle as libc::c_int;
    if 304 as libc::c_int == (*r).http_status
        && (*r).resp_htags & (1 as libc::c_ulong) << HTTP_HEADER_CONTENT_ENCODING as libc::c_int
            != 0
    {
        http_header_response_unset(
            r,
            HTTP_HEADER_CONTENT_ENCODING,
            b"Content-Encoding\0" as *const u8 as *const libc::c_char,
            (::core::mem::size_of::<[libc::c_char; 17]>() as libc::c_ulong as uint32_t)
                .wrapping_sub(1 as libc::c_int as libc::c_uint),
        );
    }
    let tb: *mut buffer = (*r).tmp_buf;
    if !((*tb).size >= 65536 as libc::c_int as libc::c_uint) {
        ck_assert_failed(
            b"/home/kkysen/work/rust/lighttpd/src/h2.c\0" as *const u8 as *const libc::c_char,
            1916 as libc::c_int as libc::c_uint,
            b"tb->size >= 65536\0" as *const u8 as *const libc::c_char,
        );
    }
    let mut dst: *mut libc::c_uchar = (*tb).ptr as *mut libc::c_uchar;
    let dst_end: *mut libc::c_uchar = ((*tb).ptr as *mut libc::c_uchar).offset((*tb).size as isize);
    let h2c: *mut h2con = (*con).h2;
    let encoder: *mut lshpack_enc = &mut (*h2c).encoder;
    let mut lsx: lsxpack_header_t = lsxpack_header_t {
        buf: 0 as *mut libc::c_char,
        name_hash: 0,
        nameval_hash: 0,
        name_offset: 0,
        name_len: 0,
        val_offset: 0,
        val_len: 0,
        chain_next_idx: 0,
        hpack_index: 0,
        qpack_index: 0,
        app_index: 0,
        flags: [0; 1],
        indexed_type: 0,
        dec_overhead: 0,
    };
    let mut alen: uint32_t = (7 as libc::c_int + 3 as libc::c_int + 4 as libc::c_int) as uint32_t;
    let log_response_header: libc::c_int = (*r).conf.log_response_header as libc::c_int;
    let resp_header_repeated: libc::c_int = (*r).resp_header_repeated as libc::c_int;
    let mut status: [libc::c_char; 12] =
        *::core::mem::transmute::<&[u8; 12], &mut [libc::c_char; 12]>(b":status: 200");
    memset(
        &mut lsx as *mut lsxpack_header_t as *mut libc::c_void,
        0 as libc::c_int,
        ::core::mem::size_of::<lsxpack_header_t>() as libc::c_ulong,
    );
    lsx.buf = status.as_mut_ptr();
    lsx.name_offset = 0 as libc::c_int as lsxpack_strlen_t;
    lsx.name_len = 7 as libc::c_int as lsxpack_strlen_t;
    lsx.val_offset = 9 as libc::c_int as lsxpack_strlen_t;
    lsx.val_len = 3 as libc::c_int as lsxpack_strlen_t;
    if (200 as libc::c_int == (*r).http_status) as libc::c_int as libc::c_long != 0 {
        lsx.hpack_index = LSHPACK_HDR_STATUS_200 as libc::c_int as uint8_t;
    } else {
        let mut x: libc::c_int = (*r).http_status;
        match x {
            204 => {
                lsx.hpack_index = LSHPACK_HDR_STATUS_204 as libc::c_int as uint8_t;
            }
            206 => {
                lsx.hpack_index = LSHPACK_HDR_STATUS_206 as libc::c_int as uint8_t;
            }
            304 => {
                lsx.hpack_index = LSHPACK_HDR_STATUS_304 as libc::c_int as uint8_t;
            }
            400 => {
                lsx.hpack_index = LSHPACK_HDR_STATUS_400 as libc::c_int as uint8_t;
            }
            404 => {
                lsx.hpack_index = LSHPACK_HDR_STATUS_404 as libc::c_int as uint8_t;
            }
            500 => {
                lsx.hpack_index = LSHPACK_HDR_STATUS_500 as libc::c_int as uint8_t;
            }
            _ => {}
        }
        let mut nx: libc::c_int = 0;
        nx = x / 10 as libc::c_int;
        status[11 as libc::c_int as usize] = (status[11 as libc::c_int as usize] as libc::c_int
            + (x - nx * 10 as libc::c_int))
            as libc::c_char;
        x = nx;
        nx = x / 10 as libc::c_int;
        status[10 as libc::c_int as usize] = (status[10 as libc::c_int as usize] as libc::c_int
            + (x - nx * 10 as libc::c_int))
            as libc::c_char;
        status[9 as libc::c_int as usize] = ('0' as i32 + nx) as libc::c_char;
    }
    dst = lshpack_enc_encode(encoder, dst, dst_end, &mut lsx);
    if dst == (*tb).ptr as *mut libc::c_uchar {
        h2_send_rst_stream(r, con, H2_E_INTERNAL_ERROR);
        return;
    }
    if log_response_header != 0 {
        h2_log_response_header(r, 12 as libc::c_int, status.as_mut_ptr());
    }
    let hdata: *const *mut data_string = (*r).resp_headers.data as *const *mut data_string;
    let mut current_block_67: u64;
    let mut i: uint32_t = 0 as libc::c_int as uint32_t;
    let mut used: uint32_t = (*r).resp_headers.used;
    while i < used {
        let ds: *mut data_string = *hdata.offset(i as isize);
        let klen: uint32_t = buffer_clen(&mut (*ds).key);
        let vlen: uint32_t = buffer_clen(&mut (*ds).value);
        if !((0 as libc::c_int as libc::c_uint == klen) as libc::c_int as libc::c_long != 0) {
            if !((0 as libc::c_int as libc::c_uint == vlen) as libc::c_int as libc::c_long != 0) {
                alen = (alen as libc::c_uint).wrapping_add(
                    klen.wrapping_add(vlen)
                        .wrapping_add(4 as libc::c_int as libc::c_uint),
                ) as uint32_t as uint32_t;
                if alen > 65535 as libc::c_int as libc::c_uint {
                    h2_send_rst_stream(r, con, H2_E_INTERNAL_ERROR);
                    return;
                }
                let v: *mut libc::c_char = if (buffer_string_space(&mut (*ds).value) >= klen)
                    as libc::c_int as libc::c_long
                    != 0
                {
                    ((*ds).value.ptr)
                        .offset(vlen as isize)
                        .offset(1 as libc::c_int as isize)
                } else {
                    (buffer_string_prepare_append(&mut (*ds).value, klen as size_t))
                        .offset(1 as libc::c_int as isize)
                };
                if ((*ds).ext != HTTP_HEADER_OTHER as libc::c_int) as libc::c_int as libc::c_long
                    != 0
                {
                    memcpy(
                        v as *mut libc::c_void,
                        (http_header_lc[(*ds).ext as usize]).as_ptr() as *const libc::c_void,
                        klen as libc::c_ulong,
                    );
                    current_block_67 = 7990025728955927862;
                } else {
                    let k: *const libc::c_char = (*ds).key.ptr;
                    if *k.offset(0 as libc::c_int as isize) as libc::c_int & 0xdf as libc::c_int
                        == 'X' as i32
                        && http_response_omit_header(r, ds) != 0
                    {
                        alen = (alen as libc::c_uint).wrapping_sub(
                            klen.wrapping_add(vlen)
                                .wrapping_add(4 as libc::c_int as libc::c_uint),
                        ) as uint32_t as uint32_t;
                        current_block_67 = 17184638872671510253;
                    } else {
                        let mut j: uint32_t = 0 as libc::c_int as uint32_t;
                        while j < klen {
                            *v.offset(j as isize) = (if !((*k.offset(j as isize) as uint32_t)
                                .wrapping_sub('A' as i32 as libc::c_uint)
                                <= ('Z' as i32 - 'A' as i32) as libc::c_uint)
                            {
                                *k.offset(j as isize) as libc::c_int
                            } else {
                                *k.offset(j as isize) as libc::c_int | 0x20 as libc::c_int
                            }) as libc::c_char;
                            j = j.wrapping_add(1);
                        }
                        current_block_67 = 7990025728955927862;
                    }
                }
                match current_block_67 {
                    17184638872671510253 => {}
                    _ => {
                        let mut voff: uint32_t = 0 as libc::c_int as uint32_t;
                        let mut n: *const libc::c_char = 0 as *const libc::c_char;
                        lsx.buf = (*ds).value.ptr;
                        loop {
                            n = (if resp_header_repeated == 0 {
                                0 as *mut libc::c_void
                            } else {
                                memchr(
                                    (lsx.buf).offset(voff as isize) as *const libc::c_void,
                                    '\n' as i32,
                                    vlen.wrapping_sub(voff) as libc::c_ulong,
                                )
                            }) as *const libc::c_char;
                            memset(
                                &mut lsx as *mut lsxpack_header_t as *mut libc::c_void,
                                0 as libc::c_int,
                                ::core::mem::size_of::<lsxpack_header_t>() as libc::c_ulong,
                            );
                            lsx.hpack_index = http_header_lshpack_idx[(*ds).ext as usize];
                            lsx.buf = (*ds).value.ptr;
                            lsx.name_offset = vlen.wrapping_add(1 as libc::c_int as libc::c_uint)
                                as lsxpack_strlen_t;
                            lsx.name_len = klen as lsxpack_strlen_t;
                            lsx.val_offset = voff as lsxpack_strlen_t;
                            if n.is_null() {
                                lsx.val_len = vlen.wrapping_sub(voff) as lsxpack_strlen_t;
                            } else {
                                voff = n.offset(1 as libc::c_int as isize).offset_from(lsx.buf)
                                    as libc::c_long
                                    as uint32_t;
                                lsx.val_len = voff
                                    .wrapping_sub(2 as libc::c_int as libc::c_uint)
                                    .wrapping_sub(lsx.val_offset as libc::c_uint)
                                    as lsxpack_strlen_t;
                                voff = (voff as libc::c_uint).wrapping_add(
                                    klen.wrapping_add(2 as libc::c_int as libc::c_uint),
                                ) as uint32_t as uint32_t;
                            }
                            if log_response_header != 0 {
                                h2_log_response_header_lsx(r, &mut lsx);
                            }
                            let dst_in: *mut libc::c_uchar = dst;
                            dst = lshpack_enc_encode(encoder, dst, dst_end, &mut lsx);
                            if dst == dst_in {
                                h2_send_rst_stream(r, con, H2_E_INTERNAL_ERROR);
                                return;
                            }
                            if n.is_null() {
                                break;
                            }
                        }
                    }
                }
            }
        }
        i = i.wrapping_add(1);
    }
    if (*r).resp_htags & (1 as libc::c_ulong) << HTTP_HEADER_DATE as libc::c_int == 0 {
        static mut tlast: unix_time64_t = 0 as libc::c_int as unix_time64_t;
        static mut tstr: [libc::c_char; 36] = unsafe {
            *::core::mem::transmute::<&[u8; 36], &mut [libc::c_char; 36]>(
                b"date: \0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0",
            )
        };
        memset(
            &mut lsx as *mut lsxpack_header_t as *mut libc::c_void,
            0 as libc::c_int,
            ::core::mem::size_of::<lsxpack_header_t>() as libc::c_ulong,
        );
        lsx.buf = tstr.as_mut_ptr();
        lsx.name_offset = 0 as libc::c_int as lsxpack_strlen_t;
        lsx.name_len = 4 as libc::c_int as lsxpack_strlen_t;
        lsx.val_offset = 6 as libc::c_int as lsxpack_strlen_t;
        lsx.val_len = 29 as libc::c_int as lsxpack_strlen_t;
        lsx.hpack_index = LSHPACK_HDR_DATE as libc::c_int as uint8_t;
        let cur_ts: unix_time64_t = log_epoch_secs;
        if (tlast != cur_ts) as libc::c_int as libc::c_long != 0 {
            tlast = cur_ts;
            http_date_time_to_str(
                tstr.as_mut_ptr().offset(6 as libc::c_int as isize),
                (::core::mem::size_of::<[libc::c_char; 36]>() as libc::c_ulong)
                    .wrapping_sub(6 as libc::c_int as libc::c_ulong),
                tlast,
            );
        }
        alen = (alen as libc::c_uint)
            .wrapping_add((35 as libc::c_int + 2 as libc::c_int) as libc::c_uint)
            as uint32_t as uint32_t;
        if log_response_header != 0 {
            h2_log_response_header(r, 35 as libc::c_int, tstr.as_mut_ptr());
        }
        let dst_in_0: *mut libc::c_uchar = dst;
        dst = lshpack_enc_encode(encoder, dst, dst_end, &mut lsx);
        if dst == dst_in_0 {
            h2_send_rst_stream(r, con, H2_E_INTERNAL_ERROR);
            return;
        }
    }
    if (*r).resp_htags & (1 as libc::c_ulong) << HTTP_HEADER_SERVER as libc::c_int == 0
        && !((*r).conf.server_tag).is_null()
    {
        let b: *mut buffer = chunk_buffer_acquire();
        let vlen_0: uint32_t = buffer_clen((*r).conf.server_tag);
        buffer_append_str2(
            b,
            b"server: \0" as *const u8 as *const libc::c_char,
            (::core::mem::size_of::<[libc::c_char; 9]>() as libc::c_ulong as uint32_t)
                .wrapping_sub(1 as libc::c_int as libc::c_uint) as size_t,
            (*(*r).conf.server_tag).ptr,
            vlen_0 as size_t,
        );
        alen = (alen as libc::c_uint).wrapping_add(
            (6 as libc::c_int as libc::c_uint)
                .wrapping_add(vlen_0)
                .wrapping_add(4 as libc::c_int as libc::c_uint),
        ) as uint32_t as uint32_t;
        if log_response_header != 0 {
            h2_log_response_header(
                r,
                (6 as libc::c_int as libc::c_uint)
                    .wrapping_add(vlen_0)
                    .wrapping_add(2 as libc::c_int as libc::c_uint) as libc::c_int,
                (*b).ptr,
            );
        }
        memset(
            &mut lsx as *mut lsxpack_header_t as *mut libc::c_void,
            0 as libc::c_int,
            ::core::mem::size_of::<lsxpack_header_t>() as libc::c_ulong,
        );
        lsx.buf = (*b).ptr;
        lsx.name_offset = 0 as libc::c_int as lsxpack_strlen_t;
        lsx.name_len = 6 as libc::c_int as lsxpack_strlen_t;
        lsx.val_offset = 8 as libc::c_int as lsxpack_strlen_t;
        lsx.val_len = vlen_0 as lsxpack_strlen_t;
        lsx.hpack_index = LSHPACK_HDR_SERVER as libc::c_int as uint8_t;
        let dst_in_1: *mut libc::c_uchar = dst;
        dst = lshpack_enc_encode(encoder, dst, dst_end, &mut lsx);
        chunk_buffer_release(b);
        if dst == dst_in_1 {
            h2_send_rst_stream(r, con, H2_E_INTERNAL_ERROR);
            return;
        }
    }
    alen = (alen as libc::c_uint).wrapping_add(2 as libc::c_int as libc::c_uint) as uint32_t
        as uint32_t;
    (*r).resp_header_len = alen;
    let wq: *mut chunkqueue = &mut (*r).write_queue;
    (*wq).bytes_in += alen as off_t;
    (*wq).bytes_out += alen as off_t;
    let dlen: uint32_t =
        (dst as *mut libc::c_char).offset_from((*tb).ptr) as libc::c_long as uint32_t;
    let flags: uint32_t = (if (*r).resp_body_finished as libc::c_int != 0
        && chunkqueue_is_empty(&mut (*r).write_queue) != 0
    {
        H2_FLAG_END_STREAM as libc::c_int
    } else {
        0 as libc::c_int
    }) as uint32_t;
    h2_send_hpack(r, con, (*tb).ptr, dlen, flags);
}
#[no_mangle]
pub unsafe extern "C" fn request_reset_ex(r: *mut request_st) {
    (*r).server_name = &mut (*r).uri.authority;
    buffer_clear(&mut (*r).uri.authority);
    buffer_reset(&mut (*r).uri.path);
    buffer_reset(&mut (*r).uri.query);
    buffer_reset(&mut (*r).physical.path);
    buffer_reset(&mut (*r).physical.rel_path);
    buffer_reset(&mut (*r).target_orig);
    buffer_reset(&mut (*r).target);
    buffer_reset(&mut (*r).pathinfo);
}
#[no_mangle]
pub unsafe extern "C" fn request_reset(r: *mut request_st) {
    plugins_call_handle_request_reset(r);
    http_response_reset(r);
    (*r).loops_per_request = 0 as libc::c_int as libc::c_char;
    (*r).keep_alive = 0 as libc::c_int as int8_t;
    (*r).h2state = 0 as libc::c_int as uint32_t;
    (*r).h2id = 0 as libc::c_int as uint32_t;
    (*r).http_method = HTTP_METHOD_UNSET;
    (*r).http_version = HTTP_VERSION_UNSET;
    (*r).http_host = 0 as *mut buffer;
    (*r).reqbody_length = 0 as libc::c_int as off_t;
    (*r).te_chunked = 0 as libc::c_int as off_t;
    (*r).resp_body_scratchpad = -(1 as libc::c_int) as off_t;
    (*r).rqst_htags = 0 as libc::c_int as uint64_t;
    (*r).async_callback = 0 as libc::c_int as libc::c_char;
    (*r).error_handler_saved_status = 0 as libc::c_int;
    buffer_clear(&mut (*r).uri.scheme);
    if (*r).rqst_header_len <= 4096 as libc::c_int as libc::c_uint {
        (*r).rqst_headers.used = 0 as libc::c_int as uint32_t;
        buffer_clear(&mut (*r).target);
        buffer_clear(&mut (*r).pathinfo);
    } else {
        buffer_reset(&mut (*r).target);
        buffer_reset(&mut (*r).pathinfo);
        array_reset_data_strings(&mut (*r).rqst_headers);
    }
    (*r).rqst_header_len = 0 as libc::c_int as uint32_t;
    if 0 as libc::c_int as libc::c_uint != (*r).env.used {
        array_reset_data_strings(&mut (*r).env);
    }
    chunkqueue_reset(&mut (*r).reqbody_queue);
    request_config_reset(r);
}
#[no_mangle]
#[inline(never)]
pub unsafe extern "C" fn request_config_reset(r: *mut request_st) {
    memcpy(
        &mut (*r).conf as *mut request_config as *mut libc::c_void,
        request_config_defaults as *const libc::c_void,
        ::core::mem::size_of::<request_config>() as libc::c_ulong,
    );
}
static mut request_config_defaults: *const request_config = 0 as *const request_config;
#[no_mangle]
pub unsafe extern "C" fn request_init_data(
    r: *mut request_st,
    con: *mut connection,
    srv: *mut server,
) {
    chunkqueue_init(&mut (*r).write_queue);
    chunkqueue_init(&mut (*r).read_queue);
    chunkqueue_init(&mut (*r).reqbody_queue);
    (*r).http_method = HTTP_METHOD_UNSET;
    (*r).http_version = HTTP_VERSION_UNSET;
    (*r).resp_header_len = 0 as libc::c_int as uint32_t;
    (*r).loops_per_request = 0 as libc::c_int as libc::c_char;
    (*r).con = con;
    (*r).tmp_buf = (*srv).tmp_buf;
    (*r).resp_body_scratchpad = -(1 as libc::c_int) as off_t;
    (*r).server_name = &mut (*r).uri.authority;
    (*r).plugin_ctx = calloc(
        1 as libc::c_int as libc::c_ulong,
        (((*srv).plugins.used).wrapping_add(1 as libc::c_int as libc::c_uint) as libc::c_ulong)
            .wrapping_mul(::core::mem::size_of::<*mut libc::c_void>() as libc::c_ulong),
    ) as *mut *mut libc::c_void;
    if ((*r).plugin_ctx).is_null() {
        ck_assert_failed(
            b"/home/kkysen/work/rust/lighttpd/src/reqpool.c\0" as *const u8 as *const libc::c_char,
            63 as libc::c_int as libc::c_uint,
            b"((void*)0) != r->plugin_ctx\0" as *const u8 as *const libc::c_char,
        );
    }
    (*r).cond_cache = calloc(
        (*(*srv).config_context).used as libc::c_ulong,
        ::core::mem::size_of::<cond_cache_t>() as libc::c_ulong,
    ) as *mut cond_cache_t;
    if ((*r).cond_cache).is_null() {
        ck_assert_failed(
            b"/home/kkysen/work/rust/lighttpd/src/reqpool.c\0" as *const u8 as *const libc::c_char,
            66 as libc::c_int as libc::c_uint,
            b"((void*)0) != r->cond_cache\0" as *const u8 as *const libc::c_char,
        );
    }
    if (*srv).config_captures != 0 {
        (*r).cond_captures = (*srv).config_captures;
        (*r).cond_match = calloc(
            (*srv).config_captures as libc::c_ulong,
            ::core::mem::size_of::<*mut cond_match_t>() as libc::c_ulong,
        ) as *mut *mut cond_match_t;
        if ((*r).cond_match).is_null() {
            ck_assert_failed(
                b"/home/kkysen/work/rust/lighttpd/src/reqpool.c\0" as *const u8
                    as *const libc::c_char,
                72 as libc::c_int as libc::c_uint,
                b"((void*)0) != r->cond_match\0" as *const u8 as *const libc::c_char,
            );
        }
        (*r).cond_match_data = calloc(
            (*srv).config_captures as libc::c_ulong,
            ::core::mem::size_of::<cond_match_t>() as libc::c_ulong,
        ) as *mut cond_match_t;
        if ((*r).cond_match_data).is_null() {
            ck_assert_failed(
                b"/home/kkysen/work/rust/lighttpd/src/reqpool.c\0" as *const u8
                    as *const libc::c_char,
                74 as libc::c_int as libc::c_uint,
                b"((void*)0) != r->cond_match_data\0" as *const u8 as *const libc::c_char,
            );
        }
    }
    request_config_reset(r);
}
#[no_mangle]
pub unsafe extern "C" fn request_acquire(con: *mut connection) -> *mut request_st {
    let mut r: *mut request_st = reqpool;
    if !r.is_null() {
        reqpool = (*r).con as *mut request_st;
    } else {
        r = calloc(
            1 as libc::c_int as libc::c_ulong,
            ::core::mem::size_of::<request_st>() as libc::c_ulong,
        ) as *mut request_st;
        if r.is_null() {
            ck_assert_failed(
                b"/home/kkysen/work/rust/lighttpd/src/reqpool.c\0" as *const u8
                    as *const libc::c_char,
                300 as libc::c_int as libc::c_uint,
                b"r\0" as *const u8 as *const libc::c_char,
            );
        }
        request_init_data(r, con, (*con).srv);
    }
    (*r).con = con;
    (*r).tmp_buf = (*(*con).srv).tmp_buf;
    return r;
}
#[no_mangle]
pub unsafe extern "C" fn request_release(r: *mut request_st) {
    chunkqueue_reset(&mut (*r).read_queue);
    request_reset(r);
    request_reset_ex(r);
    (*r).state = CON_STATE_CONNECT;
    (*r).con = reqpool as *mut connection;
    reqpool = r;
}
#[no_mangle]
#[cold]
pub unsafe extern "C" fn request_pool_free() {
    while !reqpool.is_null() {
        let r: *mut request_st = reqpool;
        reqpool = (*r).con as *mut request_st;
        request_free_data(r);
        free(r as *mut libc::c_void);
    }
}
static mut reqpool: *mut request_st = 0 as *const request_st as *mut request_st;
#[no_mangle]
#[cold]
pub unsafe extern "C" fn request_config_set_defaults(mut config_defaults: *const request_config) {
    request_config_defaults = config_defaults;
}
#[no_mangle]
#[cold]
pub unsafe extern "C" fn request_free_data(r: *mut request_st) {
    chunkqueue_reset(&mut (*r).reqbody_queue);
    chunkqueue_reset(&mut (*r).write_queue);
    chunkqueue_reset(&mut (*r).read_queue);
    array_free_data(&mut (*r).rqst_headers);
    array_free_data(&mut (*r).resp_headers);
    array_free_data(&mut (*r).env);
    free((*r).target.ptr as *mut libc::c_void);
    free((*r).target_orig.ptr as *mut libc::c_void);
    free((*r).uri.scheme.ptr as *mut libc::c_void);
    free((*r).uri.authority.ptr as *mut libc::c_void);
    free((*r).uri.path.ptr as *mut libc::c_void);
    free((*r).uri.query.ptr as *mut libc::c_void);
    free((*r).physical.doc_root.ptr as *mut libc::c_void);
    free((*r).physical.path.ptr as *mut libc::c_void);
    free((*r).physical.basedir.ptr as *mut libc::c_void);
    free((*r).physical.rel_path.ptr as *mut libc::c_void);
    free((*r).pathinfo.ptr as *mut libc::c_void);
    free((*r).server_name_buf.ptr as *mut libc::c_void);
    free((*r).plugin_ctx as *mut libc::c_void);
    free((*r).cond_cache as *mut libc::c_void);
    if !((*r).cond_match_data).is_null() {
        let mut i: libc::c_int = 0 as libc::c_int;
        let mut used: libc::c_int = (*r).cond_captures;
        while i < used {
            if !((*((*r).cond_match_data).offset(i as isize)).match_data).is_null() {
                pcre2_match_data_free_8((*((*r).cond_match_data).offset(i as isize)).match_data);
            }
            i += 1;
        }
        free((*r).cond_match_data as *mut libc::c_void);
        free((*r).cond_match as *mut libc::c_void);
    }
}
#[no_mangle]
pub unsafe extern "C" fn sock_addr_cache_inet_ntop_copy_buffer(
    b: *mut buffer,
    saddr: *const sock_addr,
) -> libc::c_int {
    static mut ndx4: libc::c_int = 0;
    static mut ntop4_cache: [C2RustUnnamed_17; 4] = [C2RustUnnamed_17 {
        ipv4: in_addr { s_addr: 0 },
    }; 4];
    static mut ntop4_strs: [C2RustUnnamed_16; 4] = [C2RustUnnamed_16 { s: [0; 17] }; 4];
    static mut ndx6: libc::c_int = 0;
    static mut ntop6_cache: [C2RustUnnamed_15; 4] = [C2RustUnnamed_15 {
        ipv6: in6_addr {
            __in6_u: C2RustUnnamed_0 {
                __u6_addr8: [0; 16],
            },
        },
    }; 4];
    static mut ntop6_strs: [C2RustUnnamed_14; 4] = [C2RustUnnamed_14 { s: [0; 47] }; 4];
    match (*saddr).plain.sa_family as libc::c_int {
        2 => {
            let mut i: libc::c_int = 0 as libc::c_int;
            while i < 4 as libc::c_int {
                if ntop4_cache[i as usize].ipv4.s_addr == (*saddr).ipv4.sin_addr.s_addr {
                    buffer_copy_string(b, (ntop4_strs[i as usize].s).as_mut_ptr());
                    return 0 as libc::c_int;
                }
                i += 1;
            }
        }
        10 => {
            let mut i_0: libc::c_int = 0 as libc::c_int;
            while i_0 < 4 as libc::c_int {
                if 0 as libc::c_int
                    == memcmp(
                        (ntop6_cache[i_0 as usize].ipv6.__in6_u.__u6_addr8).as_mut_ptr()
                            as *const libc::c_void,
                        ((*saddr).ipv6.sin6_addr.__in6_u.__u6_addr8).as_ptr()
                            as *const libc::c_void,
                        16 as libc::c_int as libc::c_ulong,
                    )
                {
                    buffer_copy_string(b, (ntop6_strs[i_0 as usize].s).as_mut_ptr());
                    return 0 as libc::c_int;
                }
                i_0 += 1;
            }
        }
        _ => {}
    }
    if 0 as libc::c_int != sock_addr_inet_ntop_copy_buffer(b, saddr) {
        buffer_blank(b);
        return -(1 as libc::c_int);
    }
    match (*saddr).plain.sa_family as libc::c_int {
        2 => {
            ntop4_cache[ndx4 as usize].ipv4.s_addr = (*saddr).ipv4.sin_addr.s_addr;
            memcpy(
                ntop4_strs.as_mut_ptr().offset(ndx4 as isize) as *mut libc::c_void,
                (*b).ptr as *const libc::c_void,
                (buffer_clen(b)).wrapping_add(1 as libc::c_int as libc::c_uint) as libc::c_ulong,
            );
            ndx4 += 1;
            if ndx4 == 4 as libc::c_int {
                ndx4 = 0 as libc::c_int;
            }
        }
        10 => {
            memcpy(
                (ntop6_cache[ndx6 as usize].ipv6.__in6_u.__u6_addr8).as_mut_ptr()
                    as *mut libc::c_void,
                ((*saddr).ipv6.sin6_addr.__in6_u.__u6_addr8).as_ptr() as *const libc::c_void,
                16 as libc::c_int as libc::c_ulong,
            );
            memcpy(
                ntop6_strs.as_mut_ptr().offset(ndx6 as isize) as *mut libc::c_void,
                (*b).ptr as *const libc::c_void,
                (buffer_clen(b)).wrapping_add(1 as libc::c_int as libc::c_uint) as libc::c_ulong,
            );
            ndx6 += 1;
            if ndx6 == 4 as libc::c_int {
                ndx6 = 0 as libc::c_int;
            }
        }
        _ => {}
    }
    return 0 as libc::c_int;
}
static mut static_table: [C2RustUnnamed_20; 61] = [C2RustUnnamed_20 {
    name_len: 0,
    val_len: 0,
    name: 0 as *const libc::c_char,
    val: 0 as *const libc::c_char,
}; 61];
static mut static_table_name_hash: [uint32_t; 61] = [
    0x653a915b as libc::c_uint,
    0xc7742be4 as libc::c_uint,
    0xc7742be4 as libc::c_uint,
    0x3513518d as libc::c_uint,
    0x3513518d as libc::c_uint,
    0xf49f1451 as libc::c_uint,
    0xf49f1451 as libc::c_uint,
    0x672bda53 as libc::c_uint,
    0x672bda53 as libc::c_uint,
    0x672bda53 as libc::c_uint,
    0x672bda53 as libc::c_uint,
    0x672bda53 as libc::c_uint,
    0x672bda53 as libc::c_uint,
    0x672bda53 as libc::c_uint,
    0xcd2c0296 as libc::c_uint,
    0xf93ad8a9 as libc::c_uint,
    0x98bd32d3 as libc::c_uint,
    0x1dc691c8 as libc::c_uint,
    0x1ab214f8 as libc::c_uint,
    0x7d3b7a3b as libc::c_uint,
    0xbec8e440 as libc::c_uint,
    0xe9c1d9e1 as libc::c_uint,
    0x19d88141 as libc::c_uint,
    0xc25511f2 as libc::c_uint,
    0x16020a90 as libc::c_uint,
    0x48011191 as libc::c_uint,
    0x7d9aab7e as libc::c_uint,
    0x48f5cc19 as libc::c_uint,
    0x8847a08c as libc::c_uint,
    0xd19f766 as libc::c_uint,
    0x85ef7c5 as libc::c_uint,
    0xb486ed8 as libc::c_uint,
    0x1a7aa369 as libc::c_uint,
    0x6de855ba as libc::c_uint,
    0xa6006efd as libc::c_uint,
    0xa1bb4284 as libc::c_uint,
    0xae56e25f as libc::c_uint,
    0xb6787110 as libc::c_uint,
    0x791c6a0d as libc::c_uint,
    0xf2badabe as libc::c_uint,
    0xd8ca2594 as libc::c_uint,
    0xfba64c54 as libc::c_uint,
    0x4beb0951 as libc::c_uint,
    0x6b86c0b5 as libc::c_uint,
    0xc62fecd2 as libc::c_uint,
    0x8da64a26 as libc::c_uint,
    0x6ca35045 as libc::c_uint,
    0xf614d165 as libc::c_uint,
    0xe4d1df14 as libc::c_uint,
    0xb396750a as libc::c_uint,
    0x1f10233 as libc::c_uint,
    0x798bee18 as libc::c_uint,
    0x5239f142 as libc::c_uint,
    0x82e1b4e1 as libc::c_uint,
    0x8f7e493e as libc::c_uint,
    0x85e74c58 as libc::c_uint,
    0xbd17f160 as libc::c_uint,
    0x34c0456a as libc::c_uint,
    0x1a04df3d as libc::c_uint,
    0xb1b15ab2 as libc::c_uint,
    0xdddab6ff as libc::c_uint,
];
static mut static_table_nameval_hash: [uint32_t; 61] = [
    0xf8614896 as libc::c_uint,
    0x25d95a15 as libc::c_uint,
    0x33968bb7 as libc::c_uint,
    0xc8c267f6 as libc::c_uint,
    0x8351136f as libc::c_uint,
    0x98573f68 as libc::c_uint,
    0x16dde443 as libc::c_uint,
    0x352a6556 as libc::c_uint,
    0xd4f462d2 as libc::c_uint,
    0x125e66e0 as libc::c_uint,
    0xd7988bc9 as libc::c_uint,
    0x4c3c90de as libc::c_uint,
    0x65e6eca1 as libc::c_uint,
    0xb05b7b87 as libc::c_uint,
    0x96816317 as libc::c_uint,
    0x8bbf5398 as libc::c_uint,
    0x97e01849 as libc::c_uint,
    0xd7b48dd4 as libc::c_uint,
    0x9c180569 as libc::c_uint,
    0xc7c63b45 as libc::c_uint,
    0xf4223ee5 as libc::c_uint,
    0x12c8a744 as libc::c_uint,
    0xaa95a0bc as libc::c_uint,
    0x14f65730 as libc::c_uint,
    0x8410a906 as libc::c_uint,
    0x98f440dd as libc::c_uint,
    0x627e4803 as libc::c_uint,
    0x5a5cc325 as libc::c_uint,
    0x137fc223 as libc::c_uint,
    0x1529262f as libc::c_uint,
    0x7950b9bd as libc::c_uint,
    0x51d448a4 as libc::c_uint,
    0x52c167cf as libc::c_uint,
    0xfb22aa54 as libc::c_uint,
    0x540db9fe as libc::c_uint,
    0x75a6c685 as libc::c_uint,
    0xe1c54196 as libc::c_uint,
    0xdc0c3733 as libc::c_uint,
    0x6d78cb84 as libc::c_uint,
    0x4f5272cd as libc::c_uint,
    0x9d4170e4 as libc::c_uint,
    0xd4e28ba1 as libc::c_uint,
    0x28c7846 as libc::c_uint,
    0x4e8c1dc3 as libc::c_uint,
    0x684bddbc as libc::c_uint,
    0xe113a2b0 as libc::c_uint,
    0x55f7bbd1 as libc::c_uint,
    0x15bd3710 as libc::c_uint,
    0xe82b715d as libc::c_uint,
    0x3674bc1f as libc::c_uint,
    0x5010d24b as libc::c_uint,
    0x953de1cb as libc::c_uint,
    0x9f2c92d9 as libc::c_uint,
    0xb2de5570 as libc::c_uint,
    0xbca5998f as libc::c_uint,
    0xff5b88e as libc::c_uint,
    0x1fed156b as libc::c_uint,
    0xdc83e7ec as libc::c_uint,
    0x7b79e35 as libc::c_uint,
    0xa6d145a9 as libc::c_uint,
    0x43638cba as libc::c_uint,
];
unsafe extern "C" fn lshpack_arr_push(
    mut arr: *mut lshpack_arr,
    mut val: uintptr_t,
) -> libc::c_int {
    let mut new_els: *mut uintptr_t = 0 as *mut uintptr_t;
    let mut n: libc::c_uint = 0;
    if ((*arr).off).wrapping_add((*arr).nelem) < (*arr).nalloc {
        *((*arr).els).offset(((*arr).off).wrapping_add((*arr).nelem) as isize) = val;
        (*arr).nelem = ((*arr).nelem).wrapping_add(1);
        return 0 as libc::c_int;
    }
    if (*arr).off > ((*arr).nalloc).wrapping_div(2 as libc::c_int as libc::c_uint) {
        memmove(
            (*arr).els as *mut libc::c_void,
            ((*arr).els).offset((*arr).off as isize) as *const libc::c_void,
            (::core::mem::size_of::<uintptr_t>() as libc::c_ulong)
                .wrapping_mul((*arr).nelem as libc::c_ulong),
        );
        (*arr).off = 0 as libc::c_int as libc::c_uint;
        *((*arr).els).offset((*arr).nelem as isize) = val;
        (*arr).nelem = ((*arr).nelem).wrapping_add(1);
        return 0 as libc::c_int;
    }
    if (*arr).nalloc != 0 {
        n = ((*arr).nalloc).wrapping_mul(2 as libc::c_int as libc::c_uint);
    } else {
        n = 64 as libc::c_int as libc::c_uint;
    }
    new_els = malloc(
        (n as libc::c_ulong).wrapping_mul(::core::mem::size_of::<uintptr_t>() as libc::c_ulong),
    ) as *mut uintptr_t;
    if new_els.is_null() {
        return -(1 as libc::c_int);
    }
    memcpy(
        new_els as *mut libc::c_void,
        ((*arr).els).offset((*arr).off as isize) as *const libc::c_void,
        (::core::mem::size_of::<uintptr_t>() as libc::c_ulong)
            .wrapping_mul((*arr).nelem as libc::c_ulong),
    );
    free((*arr).els as *mut libc::c_void);
    (*arr).off = 0 as libc::c_int as libc::c_uint;
    (*arr).els = new_els;
    (*arr).nalloc = n;
    *((*arr).els).offset(((*arr).off).wrapping_add((*arr).nelem) as isize) = val;
    (*arr).nelem = ((*arr).nelem).wrapping_add(1);
    return 0 as libc::c_int;
}
unsafe extern "C" fn henc_hist_size(mut max_capacity: libc::c_uint) -> libc::c_uint {
    return max_capacity
        .wrapping_div(32 as libc::c_int as libc::c_uint)
        .wrapping_div(3 as libc::c_int as libc::c_uint);
}
#[no_mangle]
pub unsafe extern "C" fn lshpack_enc_init(mut enc: *mut lshpack_enc) -> libc::c_int {
    let mut buckets: *mut lshpack_double_enc_head = 0 as *mut lshpack_double_enc_head;
    let mut nbits: libc::c_uint = 2 as libc::c_int as libc::c_uint;
    let mut i: libc::c_uint = 0;
    buckets = malloc(
        (::core::mem::size_of::<lshpack_double_enc_head>() as libc::c_ulong)
            .wrapping_mul(((1 as libc::c_uint) << nbits) as libc::c_ulong),
    ) as *mut lshpack_double_enc_head;
    if buckets.is_null() {
        return -(1 as libc::c_int);
    }
    i = 0 as libc::c_int as libc::c_uint;
    while i < (1 as libc::c_uint) << nbits {
        let ref mut fresh17 = (*buckets.offset(i as isize)).by_name.stqh_first;
        *fresh17 = 0 as *mut lshpack_enc_table_entry;
        let ref mut fresh18 = (*buckets.offset(i as isize)).by_name.stqh_last;
        *fresh18 = &mut (*buckets.offset(i as isize)).by_name.stqh_first;
        let ref mut fresh19 = (*buckets.offset(i as isize)).by_nameval.stqh_first;
        *fresh19 = 0 as *mut lshpack_enc_table_entry;
        let ref mut fresh20 = (*buckets.offset(i as isize)).by_nameval.stqh_last;
        *fresh20 = &mut (*buckets.offset(i as isize)).by_nameval.stqh_first;
        i = i.wrapping_add(1);
    }
    memset(
        enc as *mut libc::c_void,
        0 as libc::c_int,
        ::core::mem::size_of::<lshpack_enc>() as libc::c_ulong,
    );
    (*enc).hpe_all_entries.stqh_first = 0 as *mut lshpack_enc_table_entry;
    (*enc).hpe_all_entries.stqh_last = &mut (*enc).hpe_all_entries.stqh_first;
    (*enc).hpe_max_capacity = 4096 as libc::c_int as libc::c_uint;
    (*enc).hpe_buckets = buckets;
    (*enc).hpe_next_id = (!(0 as libc::c_int) - 3 as libc::c_int) as libc::c_uint;
    (*enc).hpe_nbits = nbits;
    (*enc).hpe_nelem = 0 as libc::c_int as libc::c_uint;
    return 0 as libc::c_int;
}
#[no_mangle]
pub unsafe extern "C" fn lshpack_enc_cleanup(mut enc: *mut lshpack_enc) {
    let mut entry: *mut lshpack_enc_table_entry = 0 as *mut lshpack_enc_table_entry;
    let mut next: *mut lshpack_enc_table_entry = 0 as *mut lshpack_enc_table_entry;
    entry = (*enc).hpe_all_entries.stqh_first;
    while !entry.is_null() {
        next = (*entry).ete_next_all.stqe_next;
        free(entry as *mut libc::c_void);
        entry = next;
    }
    free((*enc).hpe_hist_buf as *mut libc::c_void);
    free((*enc).hpe_buckets as *mut libc::c_void);
}
unsafe extern "C" fn henc_use_hist(mut enc: *mut lshpack_enc) -> libc::c_int {
    let mut hist_size: libc::c_uint = 0;
    if !((*enc).hpe_hist_buf).is_null() {
        return 0 as libc::c_int;
    }
    hist_size = henc_hist_size(4096 as libc::c_int as libc::c_uint);
    if hist_size == 0 {
        return 0 as libc::c_int;
    }
    (*enc).hpe_hist_buf =
        malloc(
            (::core::mem::size_of::<uint32_t>() as libc::c_ulong).wrapping_mul(
                hist_size.wrapping_add(1 as libc::c_int as libc::c_uint) as libc::c_ulong,
            ),
        ) as *mut uint32_t;
    if ((*enc).hpe_hist_buf).is_null() {
        return -(1 as libc::c_int);
    }
    (*enc).hpe_hist_size = hist_size;
    (*enc).hpe_flags = ::core::mem::transmute::<libc::c_uint, C2RustUnnamed_5>(
        (*enc).hpe_flags as libc::c_uint | LSHPACK_ENC_USE_HIST as libc::c_int as libc::c_uint,
    );
    return 0 as libc::c_int;
}
#[no_mangle]
pub unsafe extern "C" fn lshpack_enc_use_hist(
    mut enc: *mut lshpack_enc,
    mut on: libc::c_int,
) -> libc::c_int {
    if on != 0 {
        return henc_use_hist(enc);
    } else {
        (*enc).hpe_flags = ::core::mem::transmute::<libc::c_uint, C2RustUnnamed_5>(
            (*enc).hpe_flags as libc::c_uint
                & !(LSHPACK_ENC_USE_HIST as libc::c_int) as libc::c_uint,
        );
        free((*enc).hpe_hist_buf as *mut libc::c_void);
        (*enc).hpe_hist_buf = 0 as *mut uint32_t;
        (*enc).hpe_hist_size = 0 as libc::c_int as libc::c_uint;
        (*enc).hpe_hist_idx = 0 as libc::c_int as libc::c_uint;
        (*enc).hpe_hist_wrapped = 0 as libc::c_int;
        return 0 as libc::c_int;
    };
}
#[no_mangle]
pub unsafe extern "C" fn lshpack_enc_hist_used(mut enc: *const lshpack_enc) -> libc::c_int {
    return ((*enc).hpe_flags as libc::c_uint & LSHPACK_ENC_USE_HIST as libc::c_int as libc::c_uint
        != 0 as libc::c_int as libc::c_uint) as libc::c_int;
}
static mut nameval2id: [libc::c_uchar; 512] = [
    0,
    0,
    0,
    27 as libc::c_int as libc::c_uchar,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    2 as libc::c_int as libc::c_uchar,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    50 as libc::c_int as libc::c_uchar,
    0,
    0,
    0,
    29 as libc::c_int as libc::c_uchar,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    30 as libc::c_int as libc::c_uchar,
    0,
    0,
    0,
    0,
    0,
    59 as libc::c_int as libc::c_uchar,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    7 as libc::c_int as libc::c_uchar,
    0,
    0,
    43 as libc::c_int as libc::c_uchar,
    0,
    0,
    17 as libc::c_int as libc::c_uchar,
    0,
    51 as libc::c_int as libc::c_uchar,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    34 as libc::c_int as libc::c_uchar,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    36 as libc::c_int as libc::c_uchar,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    56 as libc::c_int as libc::c_uchar,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    1 as libc::c_int as libc::c_uchar,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    13 as libc::c_int as libc::c_uchar,
    0,
    0,
    32 as libc::c_int as libc::c_uchar,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    46 as libc::c_int as libc::c_uchar,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    61 as libc::c_int as libc::c_uchar,
    0,
    23 as libc::c_int as libc::c_uchar,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    40 as libc::c_int as libc::c_uchar,
    0,
    0,
    0,
    0,
    9 as libc::c_int as libc::c_uchar,
    0,
    0,
    0,
    0,
    0,
    0,
    53 as libc::c_int as libc::c_uchar,
    0,
    0,
    0,
    26 as libc::c_int as libc::c_uchar,
    12 as libc::c_int as libc::c_uchar,
    0,
    10 as libc::c_int as libc::c_uchar,
    0,
    0,
    0,
    41 as libc::c_int as libc::c_uchar,
    21 as libc::c_int as libc::c_uchar,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    25 as libc::c_int as libc::c_uchar,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    48 as libc::c_int as libc::c_uchar,
    0,
    0,
    0,
    0,
    0,
    0,
    15 as libc::c_int as libc::c_uchar,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    28 as libc::c_int as libc::c_uchar,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    24 as libc::c_int as libc::c_uchar,
    0,
    0,
    38 as libc::c_int as libc::c_uchar,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    22 as libc::c_int as libc::c_uchar,
    20 as libc::c_int as libc::c_uchar,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    8 as libc::c_int as libc::c_uchar,
    0,
    0,
    0,
    0,
    0,
    0,
    49 as libc::c_int as libc::c_uchar,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    6 as libc::c_int as libc::c_uchar,
    19 as libc::c_int as libc::c_uchar,
    0,
    57 as libc::c_int as libc::c_uchar,
    0,
    0,
    0,
    5 as libc::c_int as libc::c_uchar,
    54 as libc::c_int as libc::c_uchar,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    39 as libc::c_int as libc::c_uchar,
    0,
    0,
    14 as libc::c_int as libc::c_uchar,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    55 as libc::c_int as libc::c_uchar,
    0,
    0,
    0,
    0,
    0,
    0,
    37 as libc::c_int as libc::c_uchar,
    0,
    16 as libc::c_int as libc::c_uchar,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    42 as libc::c_int as libc::c_uchar,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    60 as libc::c_int as libc::c_uchar,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    3 as libc::c_int as libc::c_uchar,
    0,
    0,
    0,
    0,
    45 as libc::c_int as libc::c_uchar,
    31 as libc::c_int as libc::c_uchar,
    0,
    0,
    0,
    0,
    0,
    44 as libc::c_int as libc::c_uchar,
    0,
    0,
    0,
    0,
    0,
    11 as libc::c_int as libc::c_uchar,
    0,
    52 as libc::c_int as libc::c_uchar,
    0,
    0,
    0,
    33 as libc::c_int as libc::c_uchar,
    0,
    47 as libc::c_int as libc::c_uchar,
    0,
    0,
    18 as libc::c_int as libc::c_uchar,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    58 as libc::c_int as libc::c_uchar,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    4 as libc::c_int as libc::c_uchar,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    35 as libc::c_int as libc::c_uchar,
    0,
];
static mut name2id: [libc::c_uchar; 512] = [
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    39 as libc::c_int as libc::c_uchar,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    52 as libc::c_int as libc::c_uchar,
    28 as libc::c_int as libc::c_uchar,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    46 as libc::c_int as libc::c_uchar,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    51 as libc::c_int as libc::c_uchar,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    20 as libc::c_int as libc::c_uchar,
    0,
    0,
    0,
    0,
    21 as libc::c_int as libc::c_uchar,
    0,
    0,
    0,
    0,
    47 as libc::c_int as libc::c_uchar,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    6 as libc::c_int as libc::c_uchar,
    0,
    8 as libc::c_int as libc::c_uchar,
    42 as libc::c_int as libc::c_uchar,
    0,
    0,
    0,
    56 as libc::c_int as libc::c_uchar,
    0,
    0,
    0,
    0,
    0,
    0,
    37 as libc::c_int as libc::c_uchar,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    36 as libc::c_int as libc::c_uchar,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    29 as libc::c_int as libc::c_uchar,
    0,
    0,
    0,
    25 as libc::c_int as libc::c_uchar,
    0,
    0,
    0,
    0,
    0,
    15 as libc::c_int as libc::c_uchar,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    16 as libc::c_int as libc::c_uchar,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    60 as libc::c_int as libc::c_uchar,
    0,
    0,
    44 as libc::c_int as libc::c_uchar,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    40 as libc::c_int as libc::c_uchar,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    45 as libc::c_int as libc::c_uchar,
    17 as libc::c_int as libc::c_uchar,
    0,
    0,
    0,
    0,
    32 as libc::c_int as libc::c_uchar,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    54 as libc::c_int as libc::c_uchar,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    19 as libc::c_int as libc::c_uchar,
    0,
    0,
    0,
    0,
    35 as libc::c_int as libc::c_uchar,
    0,
    61 as libc::c_int as libc::c_uchar,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    50 as libc::c_int as libc::c_uchar,
    0,
    0,
    0,
    0,
    0,
    38 as libc::c_int as libc::c_uchar,
    0,
    0,
    0,
    49 as libc::c_int as libc::c_uchar,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    59 as libc::c_int as libc::c_uchar,
    55 as libc::c_int as libc::c_uchar,
    0,
    0,
    23 as libc::c_int as libc::c_uchar,
    53 as libc::c_int as libc::c_uchar,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    43 as libc::c_int as libc::c_uchar,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    1 as libc::c_int as libc::c_uchar,
    0,
    0,
    0,
    0,
    57 as libc::c_int as libc::c_uchar,
    0,
    0,
    0,
    0,
    48 as libc::c_int as libc::c_uchar,
    30 as libc::c_int as libc::c_uchar,
    0,
    0,
    33 as libc::c_int as libc::c_uchar,
    58 as libc::c_int as libc::c_uchar,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    27 as libc::c_int as libc::c_uchar,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    4 as libc::c_int as libc::c_uchar,
    0,
    0,
    0,
    26 as libc::c_int as libc::c_uchar,
    0,
    0,
    41 as libc::c_int as libc::c_uchar,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    34 as libc::c_int as libc::c_uchar,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    31 as libc::c_int as libc::c_uchar,
    0,
    0,
    18 as libc::c_int as libc::c_uchar,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    22 as libc::c_int as libc::c_uchar,
    0,
    0,
    2 as libc::c_int as libc::c_uchar,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    24 as libc::c_int as libc::c_uchar,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
];
unsafe extern "C" fn lshpack_enc_get_static_nameval(
    mut input: *const lsxpack_header,
) -> libc::c_uint {
    let mut i: libc::c_uint = 0;
    i = (*input).nameval_hash >> 0 as libc::c_int
        & (((1 as libc::c_int) << 9 as libc::c_int) - 1 as libc::c_int) as libc::c_uint;
    if nameval2id[i as usize] != 0 {
        i = (nameval2id[i as usize] as libc::c_int - 1 as libc::c_int) as libc::c_uint;
        if static_table[i as usize].name_len == (*input).name_len as libc::c_uint
            && static_table[i as usize].val_len == (*input).val_len as libc::c_uint
            && memcmp(
                lsxpack_header_get_name(input) as *const libc::c_void,
                static_table[i as usize].name as *const libc::c_void,
                (*input).name_len as libc::c_ulong,
            ) == 0 as libc::c_int
            && memcmp(
                lsxpack_header_get_value(input) as *const libc::c_void,
                static_table[i as usize].val as *const libc::c_void,
                (*input).val_len as libc::c_ulong,
            ) == 0 as libc::c_int
        {
            return i.wrapping_add(1 as libc::c_int as libc::c_uint);
        }
    }
    return 0 as libc::c_int as libc::c_uint;
}
unsafe extern "C" fn lshpack_enc_get_static_name(mut input: *const lsxpack_header) -> libc::c_uint {
    let mut i: libc::c_uint = 0;
    i = (*input).name_hash >> 0 as libc::c_int
        & (((1 as libc::c_int) << 9 as libc::c_int) - 1 as libc::c_int) as libc::c_uint;
    if name2id[i as usize] != 0 {
        i = (name2id[i as usize] as libc::c_int - 1 as libc::c_int) as libc::c_uint;
        if static_table[i as usize].name_len == (*input).name_len as libc::c_uint
            && memcmp(
                lsxpack_header_get_name(input) as *const libc::c_void,
                static_table[i as usize].name as *const libc::c_void,
                (*input).name_len as libc::c_ulong,
            ) == 0 as libc::c_int
        {
            return i.wrapping_add(1 as libc::c_int as libc::c_uint);
        }
    }
    return 0 as libc::c_int as libc::c_uint;
}
unsafe extern "C" fn update_hash(mut input: *mut lsxpack_header) {
    if (*input).flags() as libc::c_int & LSXPACK_NAME_HASH as libc::c_int == 0 {
        (*input).name_hash = XXH32(
            lsxpack_header_get_name(input) as *const libc::c_void,
            (*input).name_len as size_t,
            39378473 as libc::c_int as XXH32_hash_t,
        );
    }
    if (*input).flags() as libc::c_int & LSXPACK_NAMEVAL_HASH as libc::c_int == 0 {
        (*input).nameval_hash = XXH32(
            ((*input).buf).offset((*input).val_offset as libc::c_int as isize)
                as *const libc::c_void,
            (*input).val_len as size_t,
            (*input).name_hash,
        );
    }
    (*input).set_flags(
        (*input).flags()
            | (LSXPACK_NAME_HASH as libc::c_int | LSXPACK_NAMEVAL_HASH as libc::c_int)
                as lsxpack_flag,
    );
}
#[no_mangle]
pub unsafe extern "C" fn lshpack_enc_get_stx_tab_id(
    mut input: *mut lsxpack_header,
) -> libc::c_uint {
    let mut i: libc::c_uint = 0;
    update_hash(input);
    i = (*input).nameval_hash >> 0 as libc::c_int
        & (((1 as libc::c_int) << 9 as libc::c_int) - 1 as libc::c_int) as libc::c_uint;
    if nameval2id[i as usize] != 0 {
        i = (nameval2id[i as usize] as libc::c_int - 1 as libc::c_int) as libc::c_uint;
        if static_table[i as usize].name_len == (*input).name_len as libc::c_uint
            && static_table[i as usize].val_len == (*input).val_len as libc::c_uint
            && memcmp(
                lsxpack_header_get_name(input) as *const libc::c_void,
                static_table[i as usize].name as *const libc::c_void,
                (*input).name_len as libc::c_ulong,
            ) == 0 as libc::c_int
            && memcmp(
                ((*input).buf).offset((*input).val_offset as libc::c_int as isize)
                    as *const libc::c_void,
                static_table[i as usize].val as *const libc::c_void,
                (*input).val_len as libc::c_ulong,
            ) == 0 as libc::c_int
        {
            return i.wrapping_add(1 as libc::c_int as libc::c_uint);
        }
    }
    i = (*input).name_hash >> 0 as libc::c_int
        & (((1 as libc::c_int) << 9 as libc::c_int) - 1 as libc::c_int) as libc::c_uint;
    if name2id[i as usize] != 0 {
        i = (name2id[i as usize] as libc::c_int - 1 as libc::c_int) as libc::c_uint;
        if static_table[i as usize].name_len == (*input).name_len as libc::c_uint
            && memcmp(
                lsxpack_header_get_name(input) as *const libc::c_void,
                static_table[i as usize].name as *const libc::c_void,
                (*input).name_len as libc::c_ulong,
            ) == 0 as libc::c_int
        {
            return i.wrapping_add(1 as libc::c_int as libc::c_uint);
        }
    }
    return 0 as libc::c_int as libc::c_uint;
}
unsafe extern "C" fn henc_calc_table_id(
    mut enc: *const lshpack_enc,
    mut entry: *const lshpack_enc_table_entry,
) -> libc::c_uint {
    return (61 as libc::c_int as libc::c_uint)
        .wrapping_add(((*enc).hpe_next_id).wrapping_sub((*entry).ete_id));
}
unsafe extern "C" fn henc_find_table_id(
    mut enc: *mut lshpack_enc,
    mut input: *mut lsxpack_header_t,
    mut val_matched: *mut libc::c_int,
) -> libc::c_uint {
    let mut entry: *mut lshpack_enc_table_entry = 0 as *mut lshpack_enc_table_entry;
    let mut buckno: libc::c_uint = 0;
    let mut id: libc::c_uint = 0;
    let mut val_ptr: *const libc::c_char =
        ((*input).buf).offset((*input).val_offset as libc::c_int as isize);
    let mut name: *const libc::c_char = 0 as *const libc::c_char;
    let mut name_len: libc::c_uint = 0;
    name_len = (*input).name_len as libc::c_uint;
    name = lsxpack_header_get_name(input);
    if (*input).hpack_index != 0 {
        id = ((*input).hpack_index as libc::c_int - 1 as libc::c_int) as libc::c_uint;
        if id <= LSHPACK_HDR_ACCEPT_ENCODING as libc::c_int as libc::c_uint
            || (*input).val_len as libc::c_int == 0 as libc::c_int
        {
            if static_table[id as usize].val_len == (*input).val_len as libc::c_uint
                && memcmp(
                    val_ptr as *const libc::c_void,
                    static_table[id as usize].val as *const libc::c_void,
                    (*input).val_len as libc::c_ulong,
                ) == 0 as libc::c_int
            {
                (*input).set_flags(
                    (*input).flags() | LSXPACK_HPACK_VAL_MATCHED as libc::c_int as lsxpack_flag,
                );
                *val_matched = 1 as libc::c_int;
                return (*input).hpack_index as libc::c_uint;
            }
        }
        if name_len == 0 {
            name = static_table[id as usize].name;
            name_len = static_table[id as usize].name_len;
        }
        if (*input).flags() as libc::c_int & LSXPACK_NAME_HASH as libc::c_int == 0 {
            (*input).name_hash = static_table_name_hash[id as usize];
        }
        if (*input).flags() as libc::c_int & LSXPACK_NAMEVAL_HASH as libc::c_int == 0 {
            (*input).nameval_hash = XXH32(
                val_ptr as *const libc::c_void,
                (*input).val_len as size_t,
                (*input).name_hash,
            );
        }
        (*input).set_flags(
            (*input).flags()
                | (LSXPACK_NAME_HASH as libc::c_int | LSXPACK_NAMEVAL_HASH as libc::c_int)
                    as lsxpack_flag,
        );
    } else {
        update_hash(input);
        (*input).hpack_index = lshpack_enc_get_static_nameval(input) as uint8_t;
        if (*input).hpack_index as libc::c_int != LSHPACK_HDR_UNKNOWN as libc::c_int {
            (*input).set_flags(
                (*input).flags() | LSXPACK_HPACK_VAL_MATCHED as libc::c_int as lsxpack_flag,
            );
            *val_matched = 1 as libc::c_int;
            return (*input).hpack_index as libc::c_uint;
        }
    }
    buckno = (*input).nameval_hash
        & ((1 as libc::c_uint) << (*enc).hpe_nbits).wrapping_sub(1 as libc::c_int as libc::c_uint);
    entry = (*((*enc).hpe_buckets).offset(buckno as isize))
        .by_nameval
        .stqh_first;
    while !entry.is_null() {
        if (*input).nameval_hash == (*entry).ete_nameval_hash
            && name_len == (*entry).ete_name_len
            && (*input).val_len as libc::c_uint == (*entry).ete_val_len
            && 0 as libc::c_int
                == memcmp(
                    name as *const libc::c_void,
                    ((*entry).ete_buf).as_mut_ptr() as *const libc::c_void,
                    name_len as libc::c_ulong,
                )
            && 0 as libc::c_int
                == memcmp(
                    val_ptr as *const libc::c_void,
                    &mut *((*entry).ete_buf)
                        .as_mut_ptr()
                        .offset((*entry).ete_name_len as isize)
                        as *mut libc::c_char as *const libc::c_void,
                    (*input).val_len as libc::c_ulong,
                )
        {
            *val_matched = 1 as libc::c_int;
            return henc_calc_table_id(enc, entry);
        }
        entry = (*entry).ete_next_nameval.stqe_next;
    }
    if (*input).hpack_index as libc::c_int == LSHPACK_HDR_UNKNOWN as libc::c_int {
        (*input).hpack_index = lshpack_enc_get_static_name(input) as uint8_t;
    }
    if (*input).hpack_index as libc::c_int != LSHPACK_HDR_UNKNOWN as libc::c_int {
        (*input).set_flags(
            (*input).flags() & !(LSXPACK_HPACK_VAL_MATCHED as libc::c_int) as lsxpack_flag,
        );
        return (*input).hpack_index as libc::c_uint;
    }
    buckno = (*input).name_hash
        & ((1 as libc::c_uint) << (*enc).hpe_nbits).wrapping_sub(1 as libc::c_int as libc::c_uint);
    entry = (*((*enc).hpe_buckets).offset(buckno as isize))
        .by_name
        .stqh_first;
    while !entry.is_null() {
        if (*input).name_hash == (*entry).ete_name_hash
            && (*input).name_len as libc::c_uint == (*entry).ete_name_len
            && 0 as libc::c_int
                == memcmp(
                    name as *const libc::c_void,
                    ((*entry).ete_buf).as_mut_ptr() as *const libc::c_void,
                    name_len as libc::c_ulong,
                )
        {
            (*input).set_flags(
                (*input).flags() & !(LSXPACK_HPACK_VAL_MATCHED as libc::c_int) as lsxpack_flag,
            );
            return henc_calc_table_id(enc, entry);
        }
        entry = (*entry).ete_next_name.stqe_next;
    }
    return 0 as libc::c_int as libc::c_uint;
}
unsafe extern "C" fn lshpack_enc_enc_int(
    mut dst: *mut libc::c_uchar,
    end: *mut libc::c_uchar,
    mut value: uint32_t,
    mut prefix_bits: uint8_t,
) -> *mut libc::c_uchar {
    let dst_orig: *mut libc::c_uchar = dst;
    if value
        < (((1 as libc::c_int) << prefix_bits as libc::c_int) as uint32_t)
            .wrapping_sub(1 as libc::c_int as libc::c_uint)
    {
        let fresh21 = dst;
        dst = dst.offset(1);
        *fresh21 = (*fresh21 as libc::c_uint | value) as libc::c_uchar;
    } else {
        let fresh22 = dst;
        dst = dst.offset(1);
        *fresh22 = (*fresh22 as libc::c_int
            | ((1 as libc::c_int) << prefix_bits as libc::c_int) - 1 as libc::c_int)
            as libc::c_uchar;
        value = (value as libc::c_uint).wrapping_sub(
            (((1 as libc::c_int) << prefix_bits as libc::c_int) - 1 as libc::c_int) as libc::c_uint,
        ) as uint32_t as uint32_t;
        while value >= 128 as libc::c_int as libc::c_uint {
            if dst < end {
                let fresh23 = dst;
                dst = dst.offset(1);
                *fresh23 = (0x80 as libc::c_int as libc::c_uint | value) as libc::c_uchar;
                value >>= 7 as libc::c_int;
            } else {
                return dst_orig;
            }
        }
        if dst < end {
            let fresh24 = dst;
            dst = dst.offset(1);
            *fresh24 = value as libc::c_uchar;
        } else {
            return dst_orig;
        }
    }
    return dst;
}
unsafe extern "C" fn lshpack_enc_huff_encode(
    mut src: *const libc::c_uchar,
    src_end: *const libc::c_uchar,
    dst: *mut libc::c_uchar,
    mut dst_len: libc::c_int,
) -> libc::c_int {
    let mut p_dst: *mut libc::c_uchar = dst;
    let mut dst_end: *mut libc::c_uchar = p_dst.offset(dst_len as isize);
    let mut bits: uintptr_t = 0;
    let mut bits_used: libc::c_uint = 0 as libc::c_int as libc::c_uint;
    let mut adj: libc::c_uint = 0;
    let mut cur_enc_code: encode_el = encode_el { code: 0, bits: 0 };
    while src != src_end {
        let fresh25 = src;
        src = src.offset(1);
        cur_enc_code = encode_table[*fresh25 as usize];
        if (bits_used.wrapping_add(cur_enc_code.bits as libc::c_uint) as libc::c_ulong)
            < (::core::mem::size_of::<uintptr_t>() as libc::c_ulong)
                .wrapping_mul(8 as libc::c_int as libc::c_ulong)
        {
            bits <<= cur_enc_code.bits;
            bits |= cur_enc_code.code as libc::c_ulong;
            bits_used = bits_used.wrapping_add(cur_enc_code.bits as libc::c_uint);
        } else if p_dst.offset(::core::mem::size_of::<uintptr_t>() as libc::c_ulong as isize)
            <= dst_end
        {
            bits <<= (::core::mem::size_of::<uintptr_t>() as libc::c_ulong)
                .wrapping_mul(8 as libc::c_int as libc::c_ulong)
                .wrapping_sub(bits_used as libc::c_ulong);
            bits_used = (cur_enc_code.bits as libc::c_ulong).wrapping_sub(
                (::core::mem::size_of::<uintptr_t>() as libc::c_ulong)
                    .wrapping_mul(8 as libc::c_int as libc::c_ulong)
                    .wrapping_sub(bits_used as libc::c_ulong),
            ) as libc::c_uint;
            bits |= (cur_enc_code.code >> bits_used) as libc::c_ulong;
            let fresh26 = p_dst;
            p_dst = p_dst.offset(1);
            *fresh26 = (bits >> 56 as libc::c_int) as libc::c_uchar;
            let fresh27 = p_dst;
            p_dst = p_dst.offset(1);
            *fresh27 = (bits >> 48 as libc::c_int) as libc::c_uchar;
            let fresh28 = p_dst;
            p_dst = p_dst.offset(1);
            *fresh28 = (bits >> 40 as libc::c_int) as libc::c_uchar;
            let fresh29 = p_dst;
            p_dst = p_dst.offset(1);
            *fresh29 = (bits >> 32 as libc::c_int) as libc::c_uchar;
            let fresh30 = p_dst;
            p_dst = p_dst.offset(1);
            *fresh30 = (bits >> 24 as libc::c_int) as libc::c_uchar;
            let fresh31 = p_dst;
            p_dst = p_dst.offset(1);
            *fresh31 = (bits >> 16 as libc::c_int) as libc::c_uchar;
            let fresh32 = p_dst;
            p_dst = p_dst.offset(1);
            *fresh32 = (bits >> 8 as libc::c_int) as libc::c_uchar;
            let fresh33 = p_dst;
            p_dst = p_dst.offset(1);
            *fresh33 = bits as libc::c_uchar;
            bits = cur_enc_code.code as uintptr_t;
        } else {
            return -(1 as libc::c_int);
        }
    }
    adj = bits_used.wrapping_add(bits_used.wrapping_neg() & 7 as libc::c_int as libc::c_uint);
    if bits_used != 0 && p_dst.offset((adj >> 3 as libc::c_int) as isize) <= dst_end {
        bits <<= bits_used.wrapping_neg() & 7 as libc::c_int as libc::c_uint;
        bits |= (((1 as libc::c_int)
            << (bits_used.wrapping_neg() & 7 as libc::c_int as libc::c_uint))
            - 1 as libc::c_int) as libc::c_ulong;
        let mut current_block_30: u64;
        match adj >> 3 as libc::c_int {
            8 => {
                let fresh34 = p_dst;
                p_dst = p_dst.offset(1);
                *fresh34 = (bits >> 56 as libc::c_int) as libc::c_uchar;
                current_block_30 = 6631634277023143147;
            }
            7 => {
                current_block_30 = 6631634277023143147;
            }
            6 => {
                current_block_30 = 8395417818682803232;
            }
            5 => {
                current_block_30 = 3688821302758866151;
            }
            4 => {
                current_block_30 = 1316748316239958175;
            }
            3 => {
                current_block_30 = 11265421515574763114;
            }
            2 => {
                current_block_30 = 2845109976931443964;
            }
            _ => {
                current_block_30 = 17864703914533948382;
            }
        }
        match current_block_30 {
            6631634277023143147 => {
                let fresh35 = p_dst;
                p_dst = p_dst.offset(1);
                *fresh35 = (bits >> 48 as libc::c_int) as libc::c_uchar;
                current_block_30 = 8395417818682803232;
            }
            _ => {}
        }
        match current_block_30 {
            8395417818682803232 => {
                let fresh36 = p_dst;
                p_dst = p_dst.offset(1);
                *fresh36 = (bits >> 40 as libc::c_int) as libc::c_uchar;
                current_block_30 = 3688821302758866151;
            }
            _ => {}
        }
        match current_block_30 {
            3688821302758866151 => {
                let fresh37 = p_dst;
                p_dst = p_dst.offset(1);
                *fresh37 = (bits >> 32 as libc::c_int) as libc::c_uchar;
                current_block_30 = 1316748316239958175;
            }
            _ => {}
        }
        match current_block_30 {
            1316748316239958175 => {
                let fresh38 = p_dst;
                p_dst = p_dst.offset(1);
                *fresh38 = (bits >> 24 as libc::c_int) as libc::c_uchar;
                current_block_30 = 11265421515574763114;
            }
            _ => {}
        }
        match current_block_30 {
            11265421515574763114 => {
                let fresh39 = p_dst;
                p_dst = p_dst.offset(1);
                *fresh39 = (bits >> 16 as libc::c_int) as libc::c_uchar;
                current_block_30 = 2845109976931443964;
            }
            _ => {}
        }
        match current_block_30 {
            2845109976931443964 => {
                let fresh40 = p_dst;
                p_dst = p_dst.offset(1);
                *fresh40 = (bits >> 8 as libc::c_int) as libc::c_uchar;
            }
            _ => {}
        }
        let fresh41 = p_dst;
        p_dst = p_dst.offset(1);
        *fresh41 = bits as libc::c_uchar;
        return p_dst.offset_from(dst) as libc::c_long as libc::c_int;
    } else if p_dst.offset((adj >> 3 as libc::c_int) as isize) <= dst_end {
        return p_dst.offset_from(dst) as libc::c_long as libc::c_int;
    } else {
        return -(1 as libc::c_int);
    };
}
unsafe extern "C" fn lshpack_enc_enc_str(
    dst: *mut libc::c_uchar,
    mut dst_len: size_t,
    mut str: *const libc::c_uchar,
    mut str_len: libc::c_uint,
) -> libc::c_int {
    let mut size_buf: [libc::c_uchar; 4] = [0; 4];
    let mut p: *mut libc::c_uchar = 0 as *mut libc::c_uchar;
    let mut size_len: libc::c_uint = 0;
    let mut rc: libc::c_int = 0;
    if dst_len > 1 as libc::c_int as libc::c_ulong {
        rc = lshpack_enc_huff_encode(
            str,
            str.offset(str_len as isize),
            dst.offset(1 as libc::c_int as isize),
            dst_len.wrapping_sub(1 as libc::c_int as libc::c_ulong) as libc::c_int,
        );
    } else if dst_len == 1 as libc::c_int as libc::c_ulong {
        rc = 0 as libc::c_int;
    } else {
        return -(1 as libc::c_int);
    }
    if rc > 0 as libc::c_int && rc as size_t <= str_len as libc::c_ulong {
        if rc < 127 as libc::c_int {
            *dst = (0x80 as libc::c_int | rc) as libc::c_uchar;
            return 1 as libc::c_int + rc;
        }
        size_buf[0 as libc::c_int as usize] = 0x80 as libc::c_int as libc::c_uchar;
        str_len = rc as libc::c_uint;
        str = dst.offset(1 as libc::c_int as isize);
    } else if str_len as libc::c_ulong <= dst_len.wrapping_sub(1 as libc::c_int as libc::c_ulong) {
        if str_len < 127 as libc::c_int as libc::c_uint {
            *dst = str_len as libc::c_uchar;
            memcpy(
                dst.offset(1 as libc::c_int as isize) as *mut libc::c_void,
                str as *const libc::c_void,
                str_len as libc::c_ulong,
            );
            return (1 as libc::c_int as libc::c_uint).wrapping_add(str_len) as libc::c_int;
        }
        size_buf[0 as libc::c_int as usize] = 0 as libc::c_int as libc::c_uchar;
    } else {
        return -(1 as libc::c_int);
    }
    p = lshpack_enc_enc_int(
        size_buf.as_mut_ptr(),
        size_buf
            .as_mut_ptr()
            .offset(::core::mem::size_of::<[libc::c_uchar; 4]>() as libc::c_ulong as isize),
        str_len,
        7 as libc::c_int as uint8_t,
    );
    if p == size_buf.as_mut_ptr() {
        return -(1 as libc::c_int);
    }
    size_len = p.offset_from(size_buf.as_mut_ptr()) as libc::c_long as libc::c_uint;
    if size_len.wrapping_add(str_len) as libc::c_ulong > dst_len {
        return -(1 as libc::c_int);
    }
    memmove(
        dst.offset(size_len as isize) as *mut libc::c_void,
        str as *const libc::c_void,
        str_len as libc::c_ulong,
    );
    memcpy(
        dst as *mut libc::c_void,
        size_buf.as_mut_ptr() as *const libc::c_void,
        size_len as libc::c_ulong,
    );
    return size_len.wrapping_add(str_len) as libc::c_int;
}
unsafe extern "C" fn lshpack_dec_dec_int(
    mut src_p: *mut *const libc::c_uchar,
    mut src_end: *const libc::c_uchar,
    mut prefix_bits: libc::c_uint,
    mut value_p: *mut uint32_t,
) -> libc::c_int {
    let orig_src: *const libc::c_uchar = *src_p;
    let mut src: *const libc::c_uchar = 0 as *const libc::c_uchar;
    let mut prefix_max: libc::c_uint = 0;
    let mut M: libc::c_uint = 0;
    let mut val: uint32_t = 0;
    let mut B: uint32_t = 0;
    src = *src_p;
    prefix_max = (((1 as libc::c_int) << prefix_bits) - 1 as libc::c_int) as libc::c_uint;
    let fresh42 = src;
    src = src.offset(1);
    val = *fresh42 as uint32_t;
    val &= prefix_max;
    if val < prefix_max {
        *src_p = src;
        *value_p = val;
        return 0 as libc::c_int;
    }
    M = 0 as libc::c_int as libc::c_uint;
    loop {
        if src < src_end {
            let fresh43 = src;
            src = src.offset(1);
            B = *fresh43 as uint32_t;
            val = val.wrapping_add((B & 0x7f as libc::c_int as libc::c_uint) << M);
            M = M.wrapping_add(7 as libc::c_int as libc::c_uint);
        } else if (src.offset_from(orig_src) as libc::c_long) < 6 as libc::c_int as libc::c_long {
            return -(1 as libc::c_int);
        } else {
            return -(2 as libc::c_int);
        }
        if !(B & 0x80 as libc::c_int as libc::c_uint != 0) {
            break;
        }
    }
    if M <= 28 as libc::c_int as libc::c_uint
        || M == 35 as libc::c_int as libc::c_uint
            && *src.offset(-(1 as libc::c_int) as isize) as libc::c_int <= 0xf as libc::c_int
            && val.wrapping_sub(
                ((*src.offset(-(1 as libc::c_int) as isize) as libc::c_int) << 28 as libc::c_int)
                    as libc::c_uint,
            ) < val
    {
        *src_p = src;
        *value_p = val;
        return 0 as libc::c_int;
    } else {
        return -(2 as libc::c_int);
    };
}
unsafe extern "C" fn hdec_dec_str(
    mut dst: *mut libc::c_uchar,
    mut dst_len: size_t,
    mut src: *mut *const libc::c_uchar,
    mut src_end: *const libc::c_uchar,
) -> libc::c_int {
    if *src == src_end {
        return 0 as libc::c_int;
    }
    let mut is_huffman: libc::c_int = **src as libc::c_int & 0x80 as libc::c_int;
    let mut len: uint32_t = 0;
    if 0 as libc::c_int
        != lshpack_dec_dec_int(src, src_end, 7 as libc::c_int as libc::c_uint, &mut len)
    {
        return -(1 as libc::c_int);
    }
    let mut ret: libc::c_int = 0 as libc::c_int;
    if (src_end.offset_from(*src) as libc::c_long as uint32_t) < len {
        return -(1 as libc::c_int);
    }
    if is_huffman != 0 {
        ret = lshpack_dec_huff_decode(*src, len as libc::c_int, dst, dst_len as libc::c_int);
        if ret < 0 as libc::c_int {
            return ret;
        }
        *src = (*src).offset(len as isize);
    } else if dst_len < len as libc::c_ulong {
        ret = dst_len.wrapping_sub(len as libc::c_ulong) as libc::c_int;
        if ret > -(3 as libc::c_int) {
            ret = -(3 as libc::c_int);
        }
    } else {
        memcpy(
            dst as *mut libc::c_void,
            *src as *const libc::c_void,
            len as libc::c_ulong,
        );
        *src = (*src).offset(len as isize);
        ret = len as libc::c_int;
    }
    return ret;
}
unsafe extern "C" fn lshpack_dec_huff_decode(
    mut src: *const libc::c_uchar,
    mut src_len: libc::c_int,
    mut dst: *mut libc::c_uchar,
    mut dst_len: libc::c_int,
) -> libc::c_int {
    let mut p_src: *const libc::c_uchar = src;
    let src_end: *const libc::c_uchar = src.offset(src_len as isize);
    let mut p_dst: *mut libc::c_uchar = dst;
    let mut dst_end: *mut libc::c_uchar = dst.offset(dst_len as isize);
    let mut status: decode_status = {
        let mut init = decode_status {
            state: 0 as libc::c_int as uint8_t,
            eos: 1 as libc::c_int as uint8_t,
        };
        init
    };
    while p_src != src_end {
        if p_dst == dst_end {
            return -(3 as libc::c_int);
        }
        p_dst = hdec_huff_dec4bits(
            (*p_src as libc::c_int >> 4 as libc::c_int) as uint8_t,
            p_dst,
            &mut status,
        );
        if p_dst.is_null() {
            return -(1 as libc::c_int);
        }
        if p_dst == dst_end {
            return -(3 as libc::c_int);
        }
        p_dst = hdec_huff_dec4bits(
            (*p_src as libc::c_int & 0xf as libc::c_int) as uint8_t,
            p_dst,
            &mut status,
        );
        if p_dst.is_null() {
            return -(1 as libc::c_int);
        }
        p_src = p_src.offset(1);
    }
    if status.eos == 0 {
        return -(1 as libc::c_int);
    }
    return p_dst.offset_from(dst) as libc::c_long as libc::c_int;
}
unsafe extern "C" fn hdec_huff_dec4bits(
    mut src_4bits: uint8_t,
    mut dst: *mut libc::c_uchar,
    mut status: *mut decode_status,
) -> *mut libc::c_uchar {
    let cur_dec_code: decode_el = decode_tables[(*status).state as usize][src_4bits as usize];
    if cur_dec_code.flags as libc::c_int & HPACK_HUFFMAN_FLAG_FAIL as libc::c_int != 0 {
        return 0 as *mut libc::c_uchar;
    }
    if cur_dec_code.flags as libc::c_int & HPACK_HUFFMAN_FLAG_SYM as libc::c_int != 0 {
        *dst = cur_dec_code.sym;
        dst = dst.offset(1);
    }
    (*status).state = cur_dec_code.state;
    (*status).eos = (cur_dec_code.flags as libc::c_int & HPACK_HUFFMAN_FLAG_ACCEPTED as libc::c_int
        != 0 as libc::c_int) as libc::c_int as uint8_t;
    return dst;
}
#[no_mangle]
pub unsafe extern "C" fn lshpack_enc_encode(
    mut enc: *mut lshpack_enc,
    mut dst: *mut libc::c_uchar,
    mut dst_end: *mut libc::c_uchar,
    mut input: *mut lsxpack_header_t,
) -> *mut libc::c_uchar {
    static mut indexed_prefix_number: [libc::c_char; 3] = [
        0x40 as libc::c_int as libc::c_char,
        0 as libc::c_int as libc::c_char,
        0x10 as libc::c_int as libc::c_char,
    ];
    let dst_org: *mut libc::c_uchar = dst;
    let mut rc: libc::c_int = 0;
    let mut val_matched: libc::c_int = 0 as libc::c_int;
    let mut table_id: libc::c_uint = 0;
    if dst_end <= dst {
        return dst_org;
    }
    if (*input).flags() as libc::c_int & LSXPACK_HPACK_VAL_MATCHED as libc::c_int != 0 {
        table_id = (*input).hpack_index as libc::c_uint;
        val_matched = 1 as libc::c_int;
    } else {
        if (*input).flags() as libc::c_int & LSXPACK_NEVER_INDEX as libc::c_int != 0 {
            (*input).indexed_type = 2 as libc::c_int as uint8_t;
        }
        table_id = henc_find_table_id(enc, input, &mut val_matched);
        if !((*enc).hpe_hist_buf).is_null() {
            rc = henc_hist_add(enc, (*input).nameval_hash);
            if rc == 0
                && (*enc).hpe_hist_wrapped != 0
                && (*input).indexed_type as libc::c_int == 0 as libc::c_int
            {
                (*input).indexed_type = 1 as libc::c_int as uint8_t;
            }
        }
    }
    if table_id > 0 as libc::c_int as libc::c_uint {
        if val_matched != 0 {
            table_id > 61 as libc::c_int as libc::c_uint;
            *dst = 0x80 as libc::c_int as libc::c_uchar;
            dst = lshpack_enc_enc_int(dst, dst_end, table_id, 7 as libc::c_int as uint8_t);
            return dst;
        } else {
            *dst = indexed_prefix_number[(*input).indexed_type as usize] as libc::c_uchar;
            dst = lshpack_enc_enc_int(
                dst,
                dst_end,
                table_id,
                (if (*input).indexed_type as libc::c_int == 0 as libc::c_int {
                    6 as libc::c_int
                } else {
                    4 as libc::c_int
                }) as uint8_t,
            );
            if dst == dst_org {
                return dst_org;
            }
        }
    } else {
        let fresh44 = dst;
        dst = dst.offset(1);
        *fresh44 = indexed_prefix_number[(*input).indexed_type as usize] as libc::c_uchar;
        rc = lshpack_enc_enc_str(
            dst,
            dst_end.offset_from(dst) as libc::c_long as size_t,
            lsxpack_header_get_name(input) as *mut libc::c_uchar,
            (*input).name_len as libc::c_uint,
        );
        if rc < 0 as libc::c_int {
            return dst_org;
        }
        dst = dst.offset(rc as isize);
    }
    rc = lshpack_enc_enc_str(
        dst,
        dst_end.offset_from(dst) as libc::c_long as size_t,
        ((*input).buf as *const libc::c_uchar).offset((*input).val_offset as libc::c_int as isize),
        (*input).val_len as libc::c_uint,
    );
    if rc < 0 as libc::c_int {
        return dst_org;
    }
    dst = dst.offset(rc as isize);
    if (*input).indexed_type as libc::c_int == 0 as libc::c_int {
        rc = lshpack_enc_push_entry(enc, input);
        if rc != 0 as libc::c_int {
            return dst_org;
        }
    }
    return dst;
}
unsafe extern "C" fn lshpack_dec_copy_value(
    mut output: *mut lsxpack_header_t,
    mut dest: *mut libc::c_char,
    mut val: *const libc::c_char,
    mut val_len: libc::c_uint,
) -> libc::c_int {
    if val_len.wrapping_add(0 as libc::c_int as libc::c_uint) > (*output).val_len as libc::c_uint {
        return -(3 as libc::c_int);
    }
    (*output).val_offset = ((*output).name_offset as libc::c_int
        + (*output).name_len as libc::c_int
        + 0 as libc::c_int) as lsxpack_strlen_t;
    (*output).val_len = val_len as lsxpack_strlen_t;
    memcpy(
        dest as *mut libc::c_void,
        val as *const libc::c_void,
        (*output).val_len as libc::c_ulong,
    );
    dest = dest.offset((*output).val_len as libc::c_int as isize);
    return 0 as libc::c_int;
}
#[no_mangle]
pub unsafe extern "C" fn lshpack_dec_set_max_capacity(
    mut dec: *mut lshpack_dec,
    mut max_capacity: libc::c_uint,
) {
    (*dec).hpd_max_capacity = max_capacity;
    hdec_update_max_capacity(dec, max_capacity);
}
unsafe extern "C" fn lshpack_enc_push_entry(
    mut enc: *mut lshpack_enc,
    mut input: *const lsxpack_header,
) -> libc::c_int {
    let mut buckno: libc::c_uint = 0;
    let mut entry: *mut lshpack_enc_table_entry = 0 as *mut lshpack_enc_table_entry;
    let mut size: size_t = 0;
    let mut name: *const libc::c_char = 0 as *const libc::c_char;
    let mut name_len: libc::c_uint = 0;
    if (*enc).hpe_nelem
        >= ((1 as libc::c_uint) << (*enc).hpe_nbits).wrapping_div(2 as libc::c_int as libc::c_uint)
        && 0 as libc::c_int != henc_grow_tables(enc)
    {
        return -(1 as libc::c_int);
    }
    name_len = (*input).name_len as libc::c_uint;
    if name_len == 0 as libc::c_int as libc::c_uint {
        name = static_table[((*input).hpack_index as libc::c_int - 1 as libc::c_int) as usize].name;
        name_len = static_table[((*input).hpack_index as libc::c_int - 1 as libc::c_int) as usize]
            .name_len;
    } else {
        name = lsxpack_header_get_name(input);
    }
    size = (::core::mem::size_of::<lshpack_enc_table_entry>() as libc::c_ulong)
        .wrapping_add(name_len as libc::c_ulong)
        .wrapping_add((*input).val_len as libc::c_ulong);
    entry = malloc(size) as *mut lshpack_enc_table_entry;
    if entry.is_null() {
        return -(1 as libc::c_int);
    }
    (*entry).ete_name_hash = (*input).name_hash;
    (*entry).ete_nameval_hash = (*input).nameval_hash;
    (*entry).ete_name_len = name_len;
    (*entry).ete_val_len = (*input).val_len as libc::c_uint;
    let fresh45 = (*enc).hpe_next_id;
    (*enc).hpe_next_id = ((*enc).hpe_next_id).wrapping_add(1);
    (*entry).ete_id = fresh45;
    memcpy(
        ((*entry).ete_buf).as_mut_ptr() as *mut libc::c_void,
        name as *const libc::c_void,
        name_len as libc::c_ulong,
    );
    memcpy(
        &mut *((*entry).ete_buf)
            .as_mut_ptr()
            .offset((*entry).ete_name_len as isize) as *mut libc::c_char
            as *mut libc::c_void,
        ((*input).buf).offset((*input).val_offset as libc::c_int as isize) as *const libc::c_void,
        (*input).val_len as libc::c_ulong,
    );
    (*entry).ete_next_all.stqe_next = 0 as *mut lshpack_enc_table_entry;
    *(*enc).hpe_all_entries.stqh_last = entry;
    (*enc).hpe_all_entries.stqh_last = &mut (*entry).ete_next_all.stqe_next;
    buckno = (*input).nameval_hash
        & ((1 as libc::c_uint) << (*enc).hpe_nbits).wrapping_sub(1 as libc::c_int as libc::c_uint);
    (*entry).ete_next_nameval.stqe_next = 0 as *mut lshpack_enc_table_entry;
    let ref mut fresh46 = *(*((*enc).hpe_buckets).offset(buckno as isize))
        .by_nameval
        .stqh_last;
    *fresh46 = entry;
    let ref mut fresh47 = (*((*enc).hpe_buckets).offset(buckno as isize))
        .by_nameval
        .stqh_last;
    *fresh47 = &mut (*entry).ete_next_nameval.stqe_next;
    if (*input).hpack_index as libc::c_int == LSHPACK_HDR_UNKNOWN as libc::c_int {
        buckno = (*input).name_hash
            & ((1 as libc::c_uint) << (*enc).hpe_nbits)
                .wrapping_sub(1 as libc::c_int as libc::c_uint);
        (*entry).ete_next_name.stqe_next = 0 as *mut lshpack_enc_table_entry;
        let ref mut fresh48 = *(*((*enc).hpe_buckets).offset(buckno as isize))
            .by_name
            .stqh_last;
        *fresh48 = entry;
        let ref mut fresh49 = (*((*enc).hpe_buckets).offset(buckno as isize))
            .by_name
            .stqh_last;
        *fresh49 = &mut (*entry).ete_next_name.stqe_next;
    }
    (*enc).hpe_cur_capacity = ((*enc).hpe_cur_capacity).wrapping_add(
        (32 as libc::c_int as libc::c_uint)
            .wrapping_add(name_len)
            .wrapping_add((*input).val_len as libc::c_uint),
    );
    (*enc).hpe_nelem = ((*enc).hpe_nelem).wrapping_add(1);
    henc_remove_overflow_entries(enc);
    return 0 as libc::c_int;
}
unsafe extern "C" fn henc_remove_overflow_entries(mut enc: *mut lshpack_enc) {
    while (*enc).hpe_cur_capacity > (*enc).hpe_max_capacity {
        henc_drop_oldest_entry(enc);
    }
}
unsafe extern "C" fn henc_drop_oldest_entry(mut enc: *mut lshpack_enc) {
    let mut entry: *mut lshpack_enc_table_entry = 0 as *mut lshpack_enc_table_entry;
    let mut buckno: libc::c_uint = 0;
    entry = (*enc).hpe_all_entries.stqh_first;
    (*enc).hpe_all_entries.stqh_first = (*(*enc).hpe_all_entries.stqh_first).ete_next_all.stqe_next;
    if ((*enc).hpe_all_entries.stqh_first).is_null() {
        (*enc).hpe_all_entries.stqh_last = &mut (*enc).hpe_all_entries.stqh_first;
    }
    buckno = (*entry).ete_nameval_hash
        & ((1 as libc::c_uint) << (*enc).hpe_nbits).wrapping_sub(1 as libc::c_int as libc::c_uint);
    let ref mut fresh50 = (*((*enc).hpe_buckets).offset(buckno as isize))
        .by_nameval
        .stqh_first;
    *fresh50 = (*(*((*enc).hpe_buckets).offset(buckno as isize))
        .by_nameval
        .stqh_first)
        .ete_next_nameval
        .stqe_next;
    if (*fresh50).is_null() {
        let ref mut fresh51 = (*((*enc).hpe_buckets).offset(buckno as isize))
            .by_nameval
            .stqh_last;
        *fresh51 = &mut (*((*enc).hpe_buckets).offset(buckno as isize))
            .by_nameval
            .stqh_first;
    }
    buckno = (*entry).ete_name_hash
        & ((1 as libc::c_uint) << (*enc).hpe_nbits).wrapping_sub(1 as libc::c_int as libc::c_uint);
    if entry
        == (*((*enc).hpe_buckets).offset(buckno as isize))
            .by_name
            .stqh_first
    {
        let ref mut fresh52 = (*((*enc).hpe_buckets).offset(buckno as isize))
            .by_name
            .stqh_first;
        *fresh52 = (*(*((*enc).hpe_buckets).offset(buckno as isize))
            .by_name
            .stqh_first)
            .ete_next_name
            .stqe_next;
        if (*fresh52).is_null() {
            let ref mut fresh53 = (*((*enc).hpe_buckets).offset(buckno as isize))
                .by_name
                .stqh_last;
            *fresh53 = &mut (*((*enc).hpe_buckets).offset(buckno as isize))
                .by_name
                .stqh_first;
        }
    }
    (*enc).hpe_cur_capacity = ((*enc).hpe_cur_capacity).wrapping_sub(
        (32 as libc::c_int as libc::c_uint)
            .wrapping_add((*entry).ete_name_len)
            .wrapping_add((*entry).ete_val_len),
    );
    (*enc).hpe_nelem = ((*enc).hpe_nelem).wrapping_sub(1);
    free(entry as *mut libc::c_void);
}
unsafe extern "C" fn henc_grow_tables(mut enc: *mut lshpack_enc) -> libc::c_int {
    let mut new_buckets: *mut lshpack_double_enc_head = 0 as *mut lshpack_double_enc_head;
    let mut new: [*mut lshpack_double_enc_head; 2] = [0 as *mut lshpack_double_enc_head; 2];
    let mut entry: *mut lshpack_enc_table_entry = 0 as *mut lshpack_enc_table_entry;
    let mut n: libc::c_uint = 0;
    let mut old_nbits: libc::c_uint = 0;
    let mut idx: libc::c_int = 0;
    old_nbits = (*enc).hpe_nbits;
    new_buckets = malloc(
        (::core::mem::size_of::<lshpack_double_enc_head>() as libc::c_ulong).wrapping_mul(
            ((1 as libc::c_uint) << old_nbits.wrapping_add(1 as libc::c_int as libc::c_uint))
                as libc::c_ulong,
        ),
    ) as *mut lshpack_double_enc_head;
    if new_buckets.is_null() {
        return -(1 as libc::c_int);
    }
    n = 0 as libc::c_int as libc::c_uint;
    while n < (1 as libc::c_uint) << old_nbits {
        new[0 as libc::c_int as usize] =
            &mut *new_buckets.offset(n as isize) as *mut lshpack_double_enc_head;
        new[1 as libc::c_int as usize] = &mut *new_buckets
            .offset(n.wrapping_add((1 as libc::c_uint) << old_nbits) as isize)
            as *mut lshpack_double_enc_head;
        (*new[0 as libc::c_int as usize]).by_name.stqh_first = 0 as *mut lshpack_enc_table_entry;
        (*new[0 as libc::c_int as usize]).by_name.stqh_last =
            &mut (**new.as_mut_ptr().offset(0 as libc::c_int as isize))
                .by_name
                .stqh_first;
        (*new[1 as libc::c_int as usize]).by_name.stqh_first = 0 as *mut lshpack_enc_table_entry;
        (*new[1 as libc::c_int as usize]).by_name.stqh_last =
            &mut (**new.as_mut_ptr().offset(1 as libc::c_int as isize))
                .by_name
                .stqh_first;
        (*new[0 as libc::c_int as usize]).by_nameval.stqh_first = 0 as *mut lshpack_enc_table_entry;
        (*new[0 as libc::c_int as usize]).by_nameval.stqh_last =
            &mut (**new.as_mut_ptr().offset(0 as libc::c_int as isize))
                .by_nameval
                .stqh_first;
        (*new[1 as libc::c_int as usize]).by_nameval.stqh_first = 0 as *mut lshpack_enc_table_entry;
        (*new[1 as libc::c_int as usize]).by_nameval.stqh_last =
            &mut (**new.as_mut_ptr().offset(1 as libc::c_int as isize))
                .by_nameval
                .stqh_first;
        loop {
            entry = (*((*enc).hpe_buckets).offset(n as isize))
                .by_name
                .stqh_first;
            if entry.is_null() {
                break;
            }
            let ref mut fresh54 = (*((*enc).hpe_buckets).offset(n as isize))
                .by_name
                .stqh_first;
            *fresh54 = (*(*((*enc).hpe_buckets).offset(n as isize))
                .by_name
                .stqh_first)
                .ete_next_name
                .stqe_next;
            if (*fresh54).is_null() {
                let ref mut fresh55 = (*((*enc).hpe_buckets).offset(n as isize)).by_name.stqh_last;
                *fresh55 = &mut (*((*enc).hpe_buckets).offset(n as isize))
                    .by_name
                    .stqh_first;
            }
            idx = (((*entry).ete_name_hash
                & ((1 as libc::c_uint)
                    << old_nbits.wrapping_add(1 as libc::c_int as libc::c_uint))
                .wrapping_sub(1 as libc::c_int as libc::c_uint))
                >> old_nbits
                & 1 as libc::c_int as libc::c_uint) as libc::c_int;
            (*entry).ete_next_name.stqe_next = 0 as *mut lshpack_enc_table_entry;
            *(*new[idx as usize]).by_name.stqh_last = entry;
            (*new[idx as usize]).by_name.stqh_last = &mut (*entry).ete_next_name.stqe_next;
        }
        loop {
            entry = (*((*enc).hpe_buckets).offset(n as isize))
                .by_nameval
                .stqh_first;
            if entry.is_null() {
                break;
            }
            let ref mut fresh56 = (*((*enc).hpe_buckets).offset(n as isize))
                .by_nameval
                .stqh_first;
            *fresh56 = (*(*((*enc).hpe_buckets).offset(n as isize))
                .by_nameval
                .stqh_first)
                .ete_next_nameval
                .stqe_next;
            if (*fresh56).is_null() {
                let ref mut fresh57 = (*((*enc).hpe_buckets).offset(n as isize))
                    .by_nameval
                    .stqh_last;
                *fresh57 = &mut (*((*enc).hpe_buckets).offset(n as isize))
                    .by_nameval
                    .stqh_first;
            }
            idx = (((*entry).ete_nameval_hash
                & ((1 as libc::c_uint)
                    << old_nbits.wrapping_add(1 as libc::c_int as libc::c_uint))
                .wrapping_sub(1 as libc::c_int as libc::c_uint))
                >> old_nbits
                & 1 as libc::c_int as libc::c_uint) as libc::c_int;
            (*entry).ete_next_nameval.stqe_next = 0 as *mut lshpack_enc_table_entry;
            *(*new[idx as usize]).by_nameval.stqh_last = entry;
            (*new[idx as usize]).by_nameval.stqh_last = &mut (*entry).ete_next_nameval.stqe_next;
        }
        n = n.wrapping_add(1);
    }
    free((*enc).hpe_buckets as *mut libc::c_void);
    (*enc).hpe_nbits = old_nbits.wrapping_add(1 as libc::c_int as libc::c_uint);
    (*enc).hpe_buckets = new_buckets;
    return 0 as libc::c_int;
}
static mut encode_table: [encode_el; 257] = [
    {
        let mut init = encode_el {
            code: 0x1ff8 as libc::c_int as uint32_t,
            bits: 13 as libc::c_int,
        };
        init
    },
    {
        let mut init = encode_el {
            code: 0x7fffd8 as libc::c_int as uint32_t,
            bits: 23 as libc::c_int,
        };
        init
    },
    {
        let mut init = encode_el {
            code: 0xfffffe2 as libc::c_int as uint32_t,
            bits: 28 as libc::c_int,
        };
        init
    },
    {
        let mut init = encode_el {
            code: 0xfffffe3 as libc::c_int as uint32_t,
            bits: 28 as libc::c_int,
        };
        init
    },
    {
        let mut init = encode_el {
            code: 0xfffffe4 as libc::c_int as uint32_t,
            bits: 28 as libc::c_int,
        };
        init
    },
    {
        let mut init = encode_el {
            code: 0xfffffe5 as libc::c_int as uint32_t,
            bits: 28 as libc::c_int,
        };
        init
    },
    {
        let mut init = encode_el {
            code: 0xfffffe6 as libc::c_int as uint32_t,
            bits: 28 as libc::c_int,
        };
        init
    },
    {
        let mut init = encode_el {
            code: 0xfffffe7 as libc::c_int as uint32_t,
            bits: 28 as libc::c_int,
        };
        init
    },
    {
        let mut init = encode_el {
            code: 0xfffffe8 as libc::c_int as uint32_t,
            bits: 28 as libc::c_int,
        };
        init
    },
    {
        let mut init = encode_el {
            code: 0xffffea as libc::c_int as uint32_t,
            bits: 24 as libc::c_int,
        };
        init
    },
    {
        let mut init = encode_el {
            code: 0x3ffffffc as libc::c_int as uint32_t,
            bits: 30 as libc::c_int,
        };
        init
    },
    {
        let mut init = encode_el {
            code: 0xfffffe9 as libc::c_int as uint32_t,
            bits: 28 as libc::c_int,
        };
        init
    },
    {
        let mut init = encode_el {
            code: 0xfffffea as libc::c_int as uint32_t,
            bits: 28 as libc::c_int,
        };
        init
    },
    {
        let mut init = encode_el {
            code: 0x3ffffffd as libc::c_int as uint32_t,
            bits: 30 as libc::c_int,
        };
        init
    },
    {
        let mut init = encode_el {
            code: 0xfffffeb as libc::c_int as uint32_t,
            bits: 28 as libc::c_int,
        };
        init
    },
    {
        let mut init = encode_el {
            code: 0xfffffec as libc::c_int as uint32_t,
            bits: 28 as libc::c_int,
        };
        init
    },
    {
        let mut init = encode_el {
            code: 0xfffffed as libc::c_int as uint32_t,
            bits: 28 as libc::c_int,
        };
        init
    },
    {
        let mut init = encode_el {
            code: 0xfffffee as libc::c_int as uint32_t,
            bits: 28 as libc::c_int,
        };
        init
    },
    {
        let mut init = encode_el {
            code: 0xfffffef as libc::c_int as uint32_t,
            bits: 28 as libc::c_int,
        };
        init
    },
    {
        let mut init = encode_el {
            code: 0xffffff0 as libc::c_int as uint32_t,
            bits: 28 as libc::c_int,
        };
        init
    },
    {
        let mut init = encode_el {
            code: 0xffffff1 as libc::c_int as uint32_t,
            bits: 28 as libc::c_int,
        };
        init
    },
    {
        let mut init = encode_el {
            code: 0xffffff2 as libc::c_int as uint32_t,
            bits: 28 as libc::c_int,
        };
        init
    },
    {
        let mut init = encode_el {
            code: 0x3ffffffe as libc::c_int as uint32_t,
            bits: 30 as libc::c_int,
        };
        init
    },
    {
        let mut init = encode_el {
            code: 0xffffff3 as libc::c_int as uint32_t,
            bits: 28 as libc::c_int,
        };
        init
    },
    {
        let mut init = encode_el {
            code: 0xffffff4 as libc::c_int as uint32_t,
            bits: 28 as libc::c_int,
        };
        init
    },
    {
        let mut init = encode_el {
            code: 0xffffff5 as libc::c_int as uint32_t,
            bits: 28 as libc::c_int,
        };
        init
    },
    {
        let mut init = encode_el {
            code: 0xffffff6 as libc::c_int as uint32_t,
            bits: 28 as libc::c_int,
        };
        init
    },
    {
        let mut init = encode_el {
            code: 0xffffff7 as libc::c_int as uint32_t,
            bits: 28 as libc::c_int,
        };
        init
    },
    {
        let mut init = encode_el {
            code: 0xffffff8 as libc::c_int as uint32_t,
            bits: 28 as libc::c_int,
        };
        init
    },
    {
        let mut init = encode_el {
            code: 0xffffff9 as libc::c_int as uint32_t,
            bits: 28 as libc::c_int,
        };
        init
    },
    {
        let mut init = encode_el {
            code: 0xffffffa as libc::c_int as uint32_t,
            bits: 28 as libc::c_int,
        };
        init
    },
    {
        let mut init = encode_el {
            code: 0xffffffb as libc::c_int as uint32_t,
            bits: 28 as libc::c_int,
        };
        init
    },
    {
        let mut init = encode_el {
            code: 0x14 as libc::c_int as uint32_t,
            bits: 6 as libc::c_int,
        };
        init
    },
    {
        let mut init = encode_el {
            code: 0x3f8 as libc::c_int as uint32_t,
            bits: 10 as libc::c_int,
        };
        init
    },
    {
        let mut init = encode_el {
            code: 0x3f9 as libc::c_int as uint32_t,
            bits: 10 as libc::c_int,
        };
        init
    },
    {
        let mut init = encode_el {
            code: 0xffa as libc::c_int as uint32_t,
            bits: 12 as libc::c_int,
        };
        init
    },
    {
        let mut init = encode_el {
            code: 0x1ff9 as libc::c_int as uint32_t,
            bits: 13 as libc::c_int,
        };
        init
    },
    {
        let mut init = encode_el {
            code: 0x15 as libc::c_int as uint32_t,
            bits: 6 as libc::c_int,
        };
        init
    },
    {
        let mut init = encode_el {
            code: 0xf8 as libc::c_int as uint32_t,
            bits: 8 as libc::c_int,
        };
        init
    },
    {
        let mut init = encode_el {
            code: 0x7fa as libc::c_int as uint32_t,
            bits: 11 as libc::c_int,
        };
        init
    },
    {
        let mut init = encode_el {
            code: 0x3fa as libc::c_int as uint32_t,
            bits: 10 as libc::c_int,
        };
        init
    },
    {
        let mut init = encode_el {
            code: 0x3fb as libc::c_int as uint32_t,
            bits: 10 as libc::c_int,
        };
        init
    },
    {
        let mut init = encode_el {
            code: 0xf9 as libc::c_int as uint32_t,
            bits: 8 as libc::c_int,
        };
        init
    },
    {
        let mut init = encode_el {
            code: 0x7fb as libc::c_int as uint32_t,
            bits: 11 as libc::c_int,
        };
        init
    },
    {
        let mut init = encode_el {
            code: 0xfa as libc::c_int as uint32_t,
            bits: 8 as libc::c_int,
        };
        init
    },
    {
        let mut init = encode_el {
            code: 0x16 as libc::c_int as uint32_t,
            bits: 6 as libc::c_int,
        };
        init
    },
    {
        let mut init = encode_el {
            code: 0x17 as libc::c_int as uint32_t,
            bits: 6 as libc::c_int,
        };
        init
    },
    {
        let mut init = encode_el {
            code: 0x18 as libc::c_int as uint32_t,
            bits: 6 as libc::c_int,
        };
        init
    },
    {
        let mut init = encode_el {
            code: 0 as libc::c_int as uint32_t,
            bits: 5 as libc::c_int,
        };
        init
    },
    {
        let mut init = encode_el {
            code: 0x1 as libc::c_int as uint32_t,
            bits: 5 as libc::c_int,
        };
        init
    },
    {
        let mut init = encode_el {
            code: 0x2 as libc::c_int as uint32_t,
            bits: 5 as libc::c_int,
        };
        init
    },
    {
        let mut init = encode_el {
            code: 0x19 as libc::c_int as uint32_t,
            bits: 6 as libc::c_int,
        };
        init
    },
    {
        let mut init = encode_el {
            code: 0x1a as libc::c_int as uint32_t,
            bits: 6 as libc::c_int,
        };
        init
    },
    {
        let mut init = encode_el {
            code: 0x1b as libc::c_int as uint32_t,
            bits: 6 as libc::c_int,
        };
        init
    },
    {
        let mut init = encode_el {
            code: 0x1c as libc::c_int as uint32_t,
            bits: 6 as libc::c_int,
        };
        init
    },
    {
        let mut init = encode_el {
            code: 0x1d as libc::c_int as uint32_t,
            bits: 6 as libc::c_int,
        };
        init
    },
    {
        let mut init = encode_el {
            code: 0x1e as libc::c_int as uint32_t,
            bits: 6 as libc::c_int,
        };
        init
    },
    {
        let mut init = encode_el {
            code: 0x1f as libc::c_int as uint32_t,
            bits: 6 as libc::c_int,
        };
        init
    },
    {
        let mut init = encode_el {
            code: 0x5c as libc::c_int as uint32_t,
            bits: 7 as libc::c_int,
        };
        init
    },
    {
        let mut init = encode_el {
            code: 0xfb as libc::c_int as uint32_t,
            bits: 8 as libc::c_int,
        };
        init
    },
    {
        let mut init = encode_el {
            code: 0x7ffc as libc::c_int as uint32_t,
            bits: 15 as libc::c_int,
        };
        init
    },
    {
        let mut init = encode_el {
            code: 0x20 as libc::c_int as uint32_t,
            bits: 6 as libc::c_int,
        };
        init
    },
    {
        let mut init = encode_el {
            code: 0xffb as libc::c_int as uint32_t,
            bits: 12 as libc::c_int,
        };
        init
    },
    {
        let mut init = encode_el {
            code: 0x3fc as libc::c_int as uint32_t,
            bits: 10 as libc::c_int,
        };
        init
    },
    {
        let mut init = encode_el {
            code: 0x1ffa as libc::c_int as uint32_t,
            bits: 13 as libc::c_int,
        };
        init
    },
    {
        let mut init = encode_el {
            code: 0x21 as libc::c_int as uint32_t,
            bits: 6 as libc::c_int,
        };
        init
    },
    {
        let mut init = encode_el {
            code: 0x5d as libc::c_int as uint32_t,
            bits: 7 as libc::c_int,
        };
        init
    },
    {
        let mut init = encode_el {
            code: 0x5e as libc::c_int as uint32_t,
            bits: 7 as libc::c_int,
        };
        init
    },
    {
        let mut init = encode_el {
            code: 0x5f as libc::c_int as uint32_t,
            bits: 7 as libc::c_int,
        };
        init
    },
    {
        let mut init = encode_el {
            code: 0x60 as libc::c_int as uint32_t,
            bits: 7 as libc::c_int,
        };
        init
    },
    {
        let mut init = encode_el {
            code: 0x61 as libc::c_int as uint32_t,
            bits: 7 as libc::c_int,
        };
        init
    },
    {
        let mut init = encode_el {
            code: 0x62 as libc::c_int as uint32_t,
            bits: 7 as libc::c_int,
        };
        init
    },
    {
        let mut init = encode_el {
            code: 0x63 as libc::c_int as uint32_t,
            bits: 7 as libc::c_int,
        };
        init
    },
    {
        let mut init = encode_el {
            code: 0x64 as libc::c_int as uint32_t,
            bits: 7 as libc::c_int,
        };
        init
    },
    {
        let mut init = encode_el {
            code: 0x65 as libc::c_int as uint32_t,
            bits: 7 as libc::c_int,
        };
        init
    },
    {
        let mut init = encode_el {
            code: 0x66 as libc::c_int as uint32_t,
            bits: 7 as libc::c_int,
        };
        init
    },
    {
        let mut init = encode_el {
            code: 0x67 as libc::c_int as uint32_t,
            bits: 7 as libc::c_int,
        };
        init
    },
    {
        let mut init = encode_el {
            code: 0x68 as libc::c_int as uint32_t,
            bits: 7 as libc::c_int,
        };
        init
    },
    {
        let mut init = encode_el {
            code: 0x69 as libc::c_int as uint32_t,
            bits: 7 as libc::c_int,
        };
        init
    },
    {
        let mut init = encode_el {
            code: 0x6a as libc::c_int as uint32_t,
            bits: 7 as libc::c_int,
        };
        init
    },
    {
        let mut init = encode_el {
            code: 0x6b as libc::c_int as uint32_t,
            bits: 7 as libc::c_int,
        };
        init
    },
    {
        let mut init = encode_el {
            code: 0x6c as libc::c_int as uint32_t,
            bits: 7 as libc::c_int,
        };
        init
    },
    {
        let mut init = encode_el {
            code: 0x6d as libc::c_int as uint32_t,
            bits: 7 as libc::c_int,
        };
        init
    },
    {
        let mut init = encode_el {
            code: 0x6e as libc::c_int as uint32_t,
            bits: 7 as libc::c_int,
        };
        init
    },
    {
        let mut init = encode_el {
            code: 0x6f as libc::c_int as uint32_t,
            bits: 7 as libc::c_int,
        };
        init
    },
    {
        let mut init = encode_el {
            code: 0x70 as libc::c_int as uint32_t,
            bits: 7 as libc::c_int,
        };
        init
    },
    {
        let mut init = encode_el {
            code: 0x71 as libc::c_int as uint32_t,
            bits: 7 as libc::c_int,
        };
        init
    },
    {
        let mut init = encode_el {
            code: 0x72 as libc::c_int as uint32_t,
            bits: 7 as libc::c_int,
        };
        init
    },
    {
        let mut init = encode_el {
            code: 0xfc as libc::c_int as uint32_t,
            bits: 8 as libc::c_int,
        };
        init
    },
    {
        let mut init = encode_el {
            code: 0x73 as libc::c_int as uint32_t,
            bits: 7 as libc::c_int,
        };
        init
    },
    {
        let mut init = encode_el {
            code: 0xfd as libc::c_int as uint32_t,
            bits: 8 as libc::c_int,
        };
        init
    },
    {
        let mut init = encode_el {
            code: 0x1ffb as libc::c_int as uint32_t,
            bits: 13 as libc::c_int,
        };
        init
    },
    {
        let mut init = encode_el {
            code: 0x7fff0 as libc::c_int as uint32_t,
            bits: 19 as libc::c_int,
        };
        init
    },
    {
        let mut init = encode_el {
            code: 0x1ffc as libc::c_int as uint32_t,
            bits: 13 as libc::c_int,
        };
        init
    },
    {
        let mut init = encode_el {
            code: 0x3ffc as libc::c_int as uint32_t,
            bits: 14 as libc::c_int,
        };
        init
    },
    {
        let mut init = encode_el {
            code: 0x22 as libc::c_int as uint32_t,
            bits: 6 as libc::c_int,
        };
        init
    },
    {
        let mut init = encode_el {
            code: 0x7ffd as libc::c_int as uint32_t,
            bits: 15 as libc::c_int,
        };
        init
    },
    {
        let mut init = encode_el {
            code: 0x3 as libc::c_int as uint32_t,
            bits: 5 as libc::c_int,
        };
        init
    },
    {
        let mut init = encode_el {
            code: 0x23 as libc::c_int as uint32_t,
            bits: 6 as libc::c_int,
        };
        init
    },
    {
        let mut init = encode_el {
            code: 0x4 as libc::c_int as uint32_t,
            bits: 5 as libc::c_int,
        };
        init
    },
    {
        let mut init = encode_el {
            code: 0x24 as libc::c_int as uint32_t,
            bits: 6 as libc::c_int,
        };
        init
    },
    {
        let mut init = encode_el {
            code: 0x5 as libc::c_int as uint32_t,
            bits: 5 as libc::c_int,
        };
        init
    },
    {
        let mut init = encode_el {
            code: 0x25 as libc::c_int as uint32_t,
            bits: 6 as libc::c_int,
        };
        init
    },
    {
        let mut init = encode_el {
            code: 0x26 as libc::c_int as uint32_t,
            bits: 6 as libc::c_int,
        };
        init
    },
    {
        let mut init = encode_el {
            code: 0x27 as libc::c_int as uint32_t,
            bits: 6 as libc::c_int,
        };
        init
    },
    {
        let mut init = encode_el {
            code: 0x6 as libc::c_int as uint32_t,
            bits: 5 as libc::c_int,
        };
        init
    },
    {
        let mut init = encode_el {
            code: 0x74 as libc::c_int as uint32_t,
            bits: 7 as libc::c_int,
        };
        init
    },
    {
        let mut init = encode_el {
            code: 0x75 as libc::c_int as uint32_t,
            bits: 7 as libc::c_int,
        };
        init
    },
    {
        let mut init = encode_el {
            code: 0x28 as libc::c_int as uint32_t,
            bits: 6 as libc::c_int,
        };
        init
    },
    {
        let mut init = encode_el {
            code: 0x29 as libc::c_int as uint32_t,
            bits: 6 as libc::c_int,
        };
        init
    },
    {
        let mut init = encode_el {
            code: 0x2a as libc::c_int as uint32_t,
            bits: 6 as libc::c_int,
        };
        init
    },
    {
        let mut init = encode_el {
            code: 0x7 as libc::c_int as uint32_t,
            bits: 5 as libc::c_int,
        };
        init
    },
    {
        let mut init = encode_el {
            code: 0x2b as libc::c_int as uint32_t,
            bits: 6 as libc::c_int,
        };
        init
    },
    {
        let mut init = encode_el {
            code: 0x76 as libc::c_int as uint32_t,
            bits: 7 as libc::c_int,
        };
        init
    },
    {
        let mut init = encode_el {
            code: 0x2c as libc::c_int as uint32_t,
            bits: 6 as libc::c_int,
        };
        init
    },
    {
        let mut init = encode_el {
            code: 0x8 as libc::c_int as uint32_t,
            bits: 5 as libc::c_int,
        };
        init
    },
    {
        let mut init = encode_el {
            code: 0x9 as libc::c_int as uint32_t,
            bits: 5 as libc::c_int,
        };
        init
    },
    {
        let mut init = encode_el {
            code: 0x2d as libc::c_int as uint32_t,
            bits: 6 as libc::c_int,
        };
        init
    },
    {
        let mut init = encode_el {
            code: 0x77 as libc::c_int as uint32_t,
            bits: 7 as libc::c_int,
        };
        init
    },
    {
        let mut init = encode_el {
            code: 0x78 as libc::c_int as uint32_t,
            bits: 7 as libc::c_int,
        };
        init
    },
    {
        let mut init = encode_el {
            code: 0x79 as libc::c_int as uint32_t,
            bits: 7 as libc::c_int,
        };
        init
    },
    {
        let mut init = encode_el {
            code: 0x7a as libc::c_int as uint32_t,
            bits: 7 as libc::c_int,
        };
        init
    },
    {
        let mut init = encode_el {
            code: 0x7b as libc::c_int as uint32_t,
            bits: 7 as libc::c_int,
        };
        init
    },
    {
        let mut init = encode_el {
            code: 0x7ffe as libc::c_int as uint32_t,
            bits: 15 as libc::c_int,
        };
        init
    },
    {
        let mut init = encode_el {
            code: 0x7fc as libc::c_int as uint32_t,
            bits: 11 as libc::c_int,
        };
        init
    },
    {
        let mut init = encode_el {
            code: 0x3ffd as libc::c_int as uint32_t,
            bits: 14 as libc::c_int,
        };
        init
    },
    {
        let mut init = encode_el {
            code: 0x1ffd as libc::c_int as uint32_t,
            bits: 13 as libc::c_int,
        };
        init
    },
    {
        let mut init = encode_el {
            code: 0xffffffc as libc::c_int as uint32_t,
            bits: 28 as libc::c_int,
        };
        init
    },
    {
        let mut init = encode_el {
            code: 0xfffe6 as libc::c_int as uint32_t,
            bits: 20 as libc::c_int,
        };
        init
    },
    {
        let mut init = encode_el {
            code: 0x3fffd2 as libc::c_int as uint32_t,
            bits: 22 as libc::c_int,
        };
        init
    },
    {
        let mut init = encode_el {
            code: 0xfffe7 as libc::c_int as uint32_t,
            bits: 20 as libc::c_int,
        };
        init
    },
    {
        let mut init = encode_el {
            code: 0xfffe8 as libc::c_int as uint32_t,
            bits: 20 as libc::c_int,
        };
        init
    },
    {
        let mut init = encode_el {
            code: 0x3fffd3 as libc::c_int as uint32_t,
            bits: 22 as libc::c_int,
        };
        init
    },
    {
        let mut init = encode_el {
            code: 0x3fffd4 as libc::c_int as uint32_t,
            bits: 22 as libc::c_int,
        };
        init
    },
    {
        let mut init = encode_el {
            code: 0x3fffd5 as libc::c_int as uint32_t,
            bits: 22 as libc::c_int,
        };
        init
    },
    {
        let mut init = encode_el {
            code: 0x7fffd9 as libc::c_int as uint32_t,
            bits: 23 as libc::c_int,
        };
        init
    },
    {
        let mut init = encode_el {
            code: 0x3fffd6 as libc::c_int as uint32_t,
            bits: 22 as libc::c_int,
        };
        init
    },
    {
        let mut init = encode_el {
            code: 0x7fffda as libc::c_int as uint32_t,
            bits: 23 as libc::c_int,
        };
        init
    },
    {
        let mut init = encode_el {
            code: 0x7fffdb as libc::c_int as uint32_t,
            bits: 23 as libc::c_int,
        };
        init
    },
    {
        let mut init = encode_el {
            code: 0x7fffdc as libc::c_int as uint32_t,
            bits: 23 as libc::c_int,
        };
        init
    },
    {
        let mut init = encode_el {
            code: 0x7fffdd as libc::c_int as uint32_t,
            bits: 23 as libc::c_int,
        };
        init
    },
    {
        let mut init = encode_el {
            code: 0x7fffde as libc::c_int as uint32_t,
            bits: 23 as libc::c_int,
        };
        init
    },
    {
        let mut init = encode_el {
            code: 0xffffeb as libc::c_int as uint32_t,
            bits: 24 as libc::c_int,
        };
        init
    },
    {
        let mut init = encode_el {
            code: 0x7fffdf as libc::c_int as uint32_t,
            bits: 23 as libc::c_int,
        };
        init
    },
    {
        let mut init = encode_el {
            code: 0xffffec as libc::c_int as uint32_t,
            bits: 24 as libc::c_int,
        };
        init
    },
    {
        let mut init = encode_el {
            code: 0xffffed as libc::c_int as uint32_t,
            bits: 24 as libc::c_int,
        };
        init
    },
    {
        let mut init = encode_el {
            code: 0x3fffd7 as libc::c_int as uint32_t,
            bits: 22 as libc::c_int,
        };
        init
    },
    {
        let mut init = encode_el {
            code: 0x7fffe0 as libc::c_int as uint32_t,
            bits: 23 as libc::c_int,
        };
        init
    },
    {
        let mut init = encode_el {
            code: 0xffffee as libc::c_int as uint32_t,
            bits: 24 as libc::c_int,
        };
        init
    },
    {
        let mut init = encode_el {
            code: 0x7fffe1 as libc::c_int as uint32_t,
            bits: 23 as libc::c_int,
        };
        init
    },
    {
        let mut init = encode_el {
            code: 0x7fffe2 as libc::c_int as uint32_t,
            bits: 23 as libc::c_int,
        };
        init
    },
    {
        let mut init = encode_el {
            code: 0x7fffe3 as libc::c_int as uint32_t,
            bits: 23 as libc::c_int,
        };
        init
    },
    {
        let mut init = encode_el {
            code: 0x7fffe4 as libc::c_int as uint32_t,
            bits: 23 as libc::c_int,
        };
        init
    },
    {
        let mut init = encode_el {
            code: 0x1fffdc as libc::c_int as uint32_t,
            bits: 21 as libc::c_int,
        };
        init
    },
    {
        let mut init = encode_el {
            code: 0x3fffd8 as libc::c_int as uint32_t,
            bits: 22 as libc::c_int,
        };
        init
    },
    {
        let mut init = encode_el {
            code: 0x7fffe5 as libc::c_int as uint32_t,
            bits: 23 as libc::c_int,
        };
        init
    },
    {
        let mut init = encode_el {
            code: 0x3fffd9 as libc::c_int as uint32_t,
            bits: 22 as libc::c_int,
        };
        init
    },
    {
        let mut init = encode_el {
            code: 0x7fffe6 as libc::c_int as uint32_t,
            bits: 23 as libc::c_int,
        };
        init
    },
    {
        let mut init = encode_el {
            code: 0x7fffe7 as libc::c_int as uint32_t,
            bits: 23 as libc::c_int,
        };
        init
    },
    {
        let mut init = encode_el {
            code: 0xffffef as libc::c_int as uint32_t,
            bits: 24 as libc::c_int,
        };
        init
    },
    {
        let mut init = encode_el {
            code: 0x3fffda as libc::c_int as uint32_t,
            bits: 22 as libc::c_int,
        };
        init
    },
    {
        let mut init = encode_el {
            code: 0x1fffdd as libc::c_int as uint32_t,
            bits: 21 as libc::c_int,
        };
        init
    },
    {
        let mut init = encode_el {
            code: 0xfffe9 as libc::c_int as uint32_t,
            bits: 20 as libc::c_int,
        };
        init
    },
    {
        let mut init = encode_el {
            code: 0x3fffdb as libc::c_int as uint32_t,
            bits: 22 as libc::c_int,
        };
        init
    },
    {
        let mut init = encode_el {
            code: 0x3fffdc as libc::c_int as uint32_t,
            bits: 22 as libc::c_int,
        };
        init
    },
    {
        let mut init = encode_el {
            code: 0x7fffe8 as libc::c_int as uint32_t,
            bits: 23 as libc::c_int,
        };
        init
    },
    {
        let mut init = encode_el {
            code: 0x7fffe9 as libc::c_int as uint32_t,
            bits: 23 as libc::c_int,
        };
        init
    },
    {
        let mut init = encode_el {
            code: 0x1fffde as libc::c_int as uint32_t,
            bits: 21 as libc::c_int,
        };
        init
    },
    {
        let mut init = encode_el {
            code: 0x7fffea as libc::c_int as uint32_t,
            bits: 23 as libc::c_int,
        };
        init
    },
    {
        let mut init = encode_el {
            code: 0x3fffdd as libc::c_int as uint32_t,
            bits: 22 as libc::c_int,
        };
        init
    },
    {
        let mut init = encode_el {
            code: 0x3fffde as libc::c_int as uint32_t,
            bits: 22 as libc::c_int,
        };
        init
    },
    {
        let mut init = encode_el {
            code: 0xfffff0 as libc::c_int as uint32_t,
            bits: 24 as libc::c_int,
        };
        init
    },
    {
        let mut init = encode_el {
            code: 0x1fffdf as libc::c_int as uint32_t,
            bits: 21 as libc::c_int,
        };
        init
    },
    {
        let mut init = encode_el {
            code: 0x3fffdf as libc::c_int as uint32_t,
            bits: 22 as libc::c_int,
        };
        init
    },
    {
        let mut init = encode_el {
            code: 0x7fffeb as libc::c_int as uint32_t,
            bits: 23 as libc::c_int,
        };
        init
    },
    {
        let mut init = encode_el {
            code: 0x7fffec as libc::c_int as uint32_t,
            bits: 23 as libc::c_int,
        };
        init
    },
    {
        let mut init = encode_el {
            code: 0x1fffe0 as libc::c_int as uint32_t,
            bits: 21 as libc::c_int,
        };
        init
    },
    {
        let mut init = encode_el {
            code: 0x1fffe1 as libc::c_int as uint32_t,
            bits: 21 as libc::c_int,
        };
        init
    },
    {
        let mut init = encode_el {
            code: 0x3fffe0 as libc::c_int as uint32_t,
            bits: 22 as libc::c_int,
        };
        init
    },
    {
        let mut init = encode_el {
            code: 0x1fffe2 as libc::c_int as uint32_t,
            bits: 21 as libc::c_int,
        };
        init
    },
    {
        let mut init = encode_el {
            code: 0x7fffed as libc::c_int as uint32_t,
            bits: 23 as libc::c_int,
        };
        init
    },
    {
        let mut init = encode_el {
            code: 0x3fffe1 as libc::c_int as uint32_t,
            bits: 22 as libc::c_int,
        };
        init
    },
    {
        let mut init = encode_el {
            code: 0x7fffee as libc::c_int as uint32_t,
            bits: 23 as libc::c_int,
        };
        init
    },
    {
        let mut init = encode_el {
            code: 0x7fffef as libc::c_int as uint32_t,
            bits: 23 as libc::c_int,
        };
        init
    },
    {
        let mut init = encode_el {
            code: 0xfffea as libc::c_int as uint32_t,
            bits: 20 as libc::c_int,
        };
        init
    },
    {
        let mut init = encode_el {
            code: 0x3fffe2 as libc::c_int as uint32_t,
            bits: 22 as libc::c_int,
        };
        init
    },
    {
        let mut init = encode_el {
            code: 0x3fffe3 as libc::c_int as uint32_t,
            bits: 22 as libc::c_int,
        };
        init
    },
    {
        let mut init = encode_el {
            code: 0x3fffe4 as libc::c_int as uint32_t,
            bits: 22 as libc::c_int,
        };
        init
    },
    {
        let mut init = encode_el {
            code: 0x7ffff0 as libc::c_int as uint32_t,
            bits: 23 as libc::c_int,
        };
        init
    },
    {
        let mut init = encode_el {
            code: 0x3fffe5 as libc::c_int as uint32_t,
            bits: 22 as libc::c_int,
        };
        init
    },
    {
        let mut init = encode_el {
            code: 0x3fffe6 as libc::c_int as uint32_t,
            bits: 22 as libc::c_int,
        };
        init
    },
    {
        let mut init = encode_el {
            code: 0x7ffff1 as libc::c_int as uint32_t,
            bits: 23 as libc::c_int,
        };
        init
    },
    {
        let mut init = encode_el {
            code: 0x3ffffe0 as libc::c_int as uint32_t,
            bits: 26 as libc::c_int,
        };
        init
    },
    {
        let mut init = encode_el {
            code: 0x3ffffe1 as libc::c_int as uint32_t,
            bits: 26 as libc::c_int,
        };
        init
    },
    {
        let mut init = encode_el {
            code: 0xfffeb as libc::c_int as uint32_t,
            bits: 20 as libc::c_int,
        };
        init
    },
    {
        let mut init = encode_el {
            code: 0x7fff1 as libc::c_int as uint32_t,
            bits: 19 as libc::c_int,
        };
        init
    },
    {
        let mut init = encode_el {
            code: 0x3fffe7 as libc::c_int as uint32_t,
            bits: 22 as libc::c_int,
        };
        init
    },
    {
        let mut init = encode_el {
            code: 0x7ffff2 as libc::c_int as uint32_t,
            bits: 23 as libc::c_int,
        };
        init
    },
    {
        let mut init = encode_el {
            code: 0x3fffe8 as libc::c_int as uint32_t,
            bits: 22 as libc::c_int,
        };
        init
    },
    {
        let mut init = encode_el {
            code: 0x1ffffec as libc::c_int as uint32_t,
            bits: 25 as libc::c_int,
        };
        init
    },
    {
        let mut init = encode_el {
            code: 0x3ffffe2 as libc::c_int as uint32_t,
            bits: 26 as libc::c_int,
        };
        init
    },
    {
        let mut init = encode_el {
            code: 0x3ffffe3 as libc::c_int as uint32_t,
            bits: 26 as libc::c_int,
        };
        init
    },
    {
        let mut init = encode_el {
            code: 0x3ffffe4 as libc::c_int as uint32_t,
            bits: 26 as libc::c_int,
        };
        init
    },
    {
        let mut init = encode_el {
            code: 0x7ffffde as libc::c_int as uint32_t,
            bits: 27 as libc::c_int,
        };
        init
    },
    {
        let mut init = encode_el {
            code: 0x7ffffdf as libc::c_int as uint32_t,
            bits: 27 as libc::c_int,
        };
        init
    },
    {
        let mut init = encode_el {
            code: 0x3ffffe5 as libc::c_int as uint32_t,
            bits: 26 as libc::c_int,
        };
        init
    },
    {
        let mut init = encode_el {
            code: 0xfffff1 as libc::c_int as uint32_t,
            bits: 24 as libc::c_int,
        };
        init
    },
    {
        let mut init = encode_el {
            code: 0x1ffffed as libc::c_int as uint32_t,
            bits: 25 as libc::c_int,
        };
        init
    },
    {
        let mut init = encode_el {
            code: 0x7fff2 as libc::c_int as uint32_t,
            bits: 19 as libc::c_int,
        };
        init
    },
    {
        let mut init = encode_el {
            code: 0x1fffe3 as libc::c_int as uint32_t,
            bits: 21 as libc::c_int,
        };
        init
    },
    {
        let mut init = encode_el {
            code: 0x3ffffe6 as libc::c_int as uint32_t,
            bits: 26 as libc::c_int,
        };
        init
    },
    {
        let mut init = encode_el {
            code: 0x7ffffe0 as libc::c_int as uint32_t,
            bits: 27 as libc::c_int,
        };
        init
    },
    {
        let mut init = encode_el {
            code: 0x7ffffe1 as libc::c_int as uint32_t,
            bits: 27 as libc::c_int,
        };
        init
    },
    {
        let mut init = encode_el {
            code: 0x3ffffe7 as libc::c_int as uint32_t,
            bits: 26 as libc::c_int,
        };
        init
    },
    {
        let mut init = encode_el {
            code: 0x7ffffe2 as libc::c_int as uint32_t,
            bits: 27 as libc::c_int,
        };
        init
    },
    {
        let mut init = encode_el {
            code: 0xfffff2 as libc::c_int as uint32_t,
            bits: 24 as libc::c_int,
        };
        init
    },
    {
        let mut init = encode_el {
            code: 0x1fffe4 as libc::c_int as uint32_t,
            bits: 21 as libc::c_int,
        };
        init
    },
    {
        let mut init = encode_el {
            code: 0x1fffe5 as libc::c_int as uint32_t,
            bits: 21 as libc::c_int,
        };
        init
    },
    {
        let mut init = encode_el {
            code: 0x3ffffe8 as libc::c_int as uint32_t,
            bits: 26 as libc::c_int,
        };
        init
    },
    {
        let mut init = encode_el {
            code: 0x3ffffe9 as libc::c_int as uint32_t,
            bits: 26 as libc::c_int,
        };
        init
    },
    {
        let mut init = encode_el {
            code: 0xffffffd as libc::c_int as uint32_t,
            bits: 28 as libc::c_int,
        };
        init
    },
    {
        let mut init = encode_el {
            code: 0x7ffffe3 as libc::c_int as uint32_t,
            bits: 27 as libc::c_int,
        };
        init
    },
    {
        let mut init = encode_el {
            code: 0x7ffffe4 as libc::c_int as uint32_t,
            bits: 27 as libc::c_int,
        };
        init
    },
    {
        let mut init = encode_el {
            code: 0x7ffffe5 as libc::c_int as uint32_t,
            bits: 27 as libc::c_int,
        };
        init
    },
    {
        let mut init = encode_el {
            code: 0xfffec as libc::c_int as uint32_t,
            bits: 20 as libc::c_int,
        };
        init
    },
    {
        let mut init = encode_el {
            code: 0xfffff3 as libc::c_int as uint32_t,
            bits: 24 as libc::c_int,
        };
        init
    },
    {
        let mut init = encode_el {
            code: 0xfffed as libc::c_int as uint32_t,
            bits: 20 as libc::c_int,
        };
        init
    },
    {
        let mut init = encode_el {
            code: 0x1fffe6 as libc::c_int as uint32_t,
            bits: 21 as libc::c_int,
        };
        init
    },
    {
        let mut init = encode_el {
            code: 0x3fffe9 as libc::c_int as uint32_t,
            bits: 22 as libc::c_int,
        };
        init
    },
    {
        let mut init = encode_el {
            code: 0x1fffe7 as libc::c_int as uint32_t,
            bits: 21 as libc::c_int,
        };
        init
    },
    {
        let mut init = encode_el {
            code: 0x1fffe8 as libc::c_int as uint32_t,
            bits: 21 as libc::c_int,
        };
        init
    },
    {
        let mut init = encode_el {
            code: 0x7ffff3 as libc::c_int as uint32_t,
            bits: 23 as libc::c_int,
        };
        init
    },
    {
        let mut init = encode_el {
            code: 0x3fffea as libc::c_int as uint32_t,
            bits: 22 as libc::c_int,
        };
        init
    },
    {
        let mut init = encode_el {
            code: 0x3fffeb as libc::c_int as uint32_t,
            bits: 22 as libc::c_int,
        };
        init
    },
    {
        let mut init = encode_el {
            code: 0x1ffffee as libc::c_int as uint32_t,
            bits: 25 as libc::c_int,
        };
        init
    },
    {
        let mut init = encode_el {
            code: 0x1ffffef as libc::c_int as uint32_t,
            bits: 25 as libc::c_int,
        };
        init
    },
    {
        let mut init = encode_el {
            code: 0xfffff4 as libc::c_int as uint32_t,
            bits: 24 as libc::c_int,
        };
        init
    },
    {
        let mut init = encode_el {
            code: 0xfffff5 as libc::c_int as uint32_t,
            bits: 24 as libc::c_int,
        };
        init
    },
    {
        let mut init = encode_el {
            code: 0x3ffffea as libc::c_int as uint32_t,
            bits: 26 as libc::c_int,
        };
        init
    },
    {
        let mut init = encode_el {
            code: 0x7ffff4 as libc::c_int as uint32_t,
            bits: 23 as libc::c_int,
        };
        init
    },
    {
        let mut init = encode_el {
            code: 0x3ffffeb as libc::c_int as uint32_t,
            bits: 26 as libc::c_int,
        };
        init
    },
    {
        let mut init = encode_el {
            code: 0x7ffffe6 as libc::c_int as uint32_t,
            bits: 27 as libc::c_int,
        };
        init
    },
    {
        let mut init = encode_el {
            code: 0x3ffffec as libc::c_int as uint32_t,
            bits: 26 as libc::c_int,
        };
        init
    },
    {
        let mut init = encode_el {
            code: 0x3ffffed as libc::c_int as uint32_t,
            bits: 26 as libc::c_int,
        };
        init
    },
    {
        let mut init = encode_el {
            code: 0x7ffffe7 as libc::c_int as uint32_t,
            bits: 27 as libc::c_int,
        };
        init
    },
    {
        let mut init = encode_el {
            code: 0x7ffffe8 as libc::c_int as uint32_t,
            bits: 27 as libc::c_int,
        };
        init
    },
    {
        let mut init = encode_el {
            code: 0x7ffffe9 as libc::c_int as uint32_t,
            bits: 27 as libc::c_int,
        };
        init
    },
    {
        let mut init = encode_el {
            code: 0x7ffffea as libc::c_int as uint32_t,
            bits: 27 as libc::c_int,
        };
        init
    },
    {
        let mut init = encode_el {
            code: 0x7ffffeb as libc::c_int as uint32_t,
            bits: 27 as libc::c_int,
        };
        init
    },
    {
        let mut init = encode_el {
            code: 0xffffffe as libc::c_int as uint32_t,
            bits: 28 as libc::c_int,
        };
        init
    },
    {
        let mut init = encode_el {
            code: 0x7ffffec as libc::c_int as uint32_t,
            bits: 27 as libc::c_int,
        };
        init
    },
    {
        let mut init = encode_el {
            code: 0x7ffffed as libc::c_int as uint32_t,
            bits: 27 as libc::c_int,
        };
        init
    },
    {
        let mut init = encode_el {
            code: 0x7ffffee as libc::c_int as uint32_t,
            bits: 27 as libc::c_int,
        };
        init
    },
    {
        let mut init = encode_el {
            code: 0x7ffffef as libc::c_int as uint32_t,
            bits: 27 as libc::c_int,
        };
        init
    },
    {
        let mut init = encode_el {
            code: 0x7fffff0 as libc::c_int as uint32_t,
            bits: 27 as libc::c_int,
        };
        init
    },
    {
        let mut init = encode_el {
            code: 0x3ffffee as libc::c_int as uint32_t,
            bits: 26 as libc::c_int,
        };
        init
    },
    {
        let mut init = encode_el {
            code: 0x3fffffff as libc::c_int as uint32_t,
            bits: 30 as libc::c_int,
        };
        init
    },
];
#[no_mangle]
pub unsafe extern "C" fn lshpack_dec_init(mut dec: *mut lshpack_dec) {
    memset(
        dec as *mut libc::c_void,
        0 as libc::c_int,
        ::core::mem::size_of::<lshpack_dec>() as libc::c_ulong,
    );
    (*dec).hpd_max_capacity = 4096 as libc::c_int as libc::c_uint;
    (*dec).hpd_cur_max_capacity = 4096 as libc::c_int as libc::c_uint;
    memset(
        &mut (*dec).hpd_dyn_table as *mut lshpack_arr as *mut libc::c_void,
        0 as libc::c_int,
        ::core::mem::size_of::<lshpack_arr>() as libc::c_ulong,
    );
}
unsafe extern "C" fn henc_hist_add(
    mut enc: *mut lshpack_enc,
    mut nameval_hash: uint32_t,
) -> libc::c_int {
    let mut last: libc::c_uint = 0;
    let mut p: *mut uint32_t = 0 as *mut uint32_t;
    if (*enc).hpe_hist_wrapped != 0 {
        last = (*enc).hpe_hist_size;
    } else {
        last = (*enc).hpe_hist_idx;
    }
    *((*enc).hpe_hist_buf).offset(last as isize) = nameval_hash;
    p = (*enc).hpe_hist_buf;
    while *p != nameval_hash {
        p = p.offset(1);
    }
    *((*enc).hpe_hist_buf).offset((*enc).hpe_hist_idx as isize) = nameval_hash;
    (*enc).hpe_hist_idx = ((*enc).hpe_hist_idx)
        .wrapping_add(1 as libc::c_int as libc::c_uint)
        .wrapping_rem((*enc).hpe_hist_size);
    (*enc).hpe_hist_wrapped |=
        ((*enc).hpe_hist_idx == 0 as libc::c_int as libc::c_uint) as libc::c_int;
    return (p < ((*enc).hpe_hist_buf).offset(last as isize)) as libc::c_int;
}
unsafe extern "C" fn hdec_drop_oldest_entry(mut dec: *mut lshpack_dec) {
    let mut entry: *mut dec_table_entry = 0 as *mut dec_table_entry;
    (*dec).hpd_dyn_table.nelem =
        ((*dec).hpd_dyn_table.nelem).wrapping_sub(1 as libc::c_int as libc::c_uint);
    let fresh58 = (*dec).hpd_dyn_table.off;
    (*dec).hpd_dyn_table.off = ((*dec).hpd_dyn_table.off).wrapping_add(1);
    entry = *((*dec).hpd_dyn_table.els).offset(fresh58 as isize) as *mut libc::c_void
        as *mut dec_table_entry;
    (*dec).hpd_cur_capacity = ((*dec).hpd_cur_capacity).wrapping_sub(
        (32 as libc::c_int as libc::c_uint)
            .wrapping_add((*entry).dte_name_len)
            .wrapping_add((*entry).dte_val_len),
    );
    (*dec).hpd_state = ((*dec).hpd_state).wrapping_add(1);
    free(entry as *mut libc::c_void);
}
unsafe extern "C" fn hdec_remove_overflow_entries(mut dec: *mut lshpack_dec) {
    while (*dec).hpd_cur_capacity > (*dec).hpd_cur_max_capacity {
        hdec_drop_oldest_entry(dec);
    }
}
unsafe extern "C" fn lshpack_dec_push_entry(
    mut dec: *mut lshpack_dec,
    mut xhdr: *const lsxpack_header,
) -> libc::c_int {
    let mut entry: *mut dec_table_entry = 0 as *mut dec_table_entry;
    let mut name_len: libc::c_uint = 0;
    let mut val_len: libc::c_uint = 0;
    let mut size: size_t = 0;
    name_len = (*xhdr).name_len as libc::c_uint;
    val_len = (*xhdr).val_len as libc::c_uint;
    size = (::core::mem::size_of::<dec_table_entry>() as libc::c_ulong)
        .wrapping_add(name_len as libc::c_ulong)
        .wrapping_add(val_len as libc::c_ulong);
    entry = malloc(size) as *mut dec_table_entry;
    if entry.is_null() {
        return -(1 as libc::c_int);
    }
    if 0 as libc::c_int != lshpack_arr_push(&mut (*dec).hpd_dyn_table, entry as uintptr_t) {
        free(entry as *mut libc::c_void);
        return -(1 as libc::c_int);
    }
    (*dec).hpd_state = ((*dec).hpd_state).wrapping_add(1);
    (*dec).hpd_cur_capacity = ((*dec).hpd_cur_capacity).wrapping_add(
        (32 as libc::c_int as libc::c_uint)
            .wrapping_add(name_len)
            .wrapping_add(val_len),
    );
    (*entry).dte_name_len = name_len;
    (*entry).dte_val_len = val_len;
    (*entry).dte_name_idx = (*xhdr).hpack_index;
    memcpy(
        ((*entry).dte_buf).as_mut_ptr() as *mut libc::c_void,
        lsxpack_header_get_name(xhdr) as *const libc::c_void,
        name_len as libc::c_ulong,
    );
    memcpy(
        &mut *((*entry).dte_buf)
            .as_mut_ptr()
            .offset((*entry).dte_name_len as isize) as *mut libc::c_char
            as *mut libc::c_void,
        lsxpack_header_get_value(xhdr) as *const libc::c_void,
        val_len as libc::c_ulong,
    );
    hdec_remove_overflow_entries(dec);
    return 0 as libc::c_int;
}
#[no_mangle]
pub unsafe extern "C" fn lshpack_dec_decode(
    mut dec: *mut lshpack_dec,
    mut src: *mut *const libc::c_uchar,
    mut src_end: *const libc::c_uchar,
    mut output: *mut lsxpack_header,
) -> libc::c_int {
    let mut current_block: u64;
    let mut entry: *mut dec_table_entry = 0 as *mut dec_table_entry;
    let mut index: uint32_t = 0;
    let mut new_capacity: uint32_t = 0;
    let mut indexed_type: libc::c_int = 0;
    let mut len: libc::c_int = 0;
    let mut s: *const libc::c_uchar = 0 as *const libc::c_uchar;
    let mut buf_len: size_t = (*output).val_len as size_t;
    let mut extra_buf: size_t = 0 as libc::c_int as size_t;
    if *src == src_end {
        return -(1 as libc::c_int);
    }
    buf_len = (*output).val_len as size_t;
    extra_buf = 0 as libc::c_int as size_t;
    s = *src;
    while *s as libc::c_int & 0xe0 as libc::c_int == 0x20 as libc::c_int {
        if 0 as libc::c_int
            != lshpack_dec_dec_int(
                &mut s,
                src_end,
                5 as libc::c_int as libc::c_uint,
                &mut new_capacity,
            )
        {
            return -(1 as libc::c_int);
        }
        if new_capacity > (*dec).hpd_max_capacity {
            return -(1 as libc::c_int);
        }
        hdec_update_max_capacity(dec, new_capacity);
        if s == src_end {
            return -(1 as libc::c_int);
        }
    }
    if *s as libc::c_int & 0x80 as libc::c_int != 0 {
        if 0 as libc::c_int
            != lshpack_dec_dec_int(
                &mut s,
                src_end,
                7 as libc::c_int as libc::c_uint,
                &mut index,
            )
        {
            return -(1 as libc::c_int);
        }
        if index == 0 as libc::c_int as libc::c_uint {
            return -(1 as libc::c_int);
        }
        indexed_type = LSHPACK_VAL_INDEX as libc::c_int;
    } else if *s as libc::c_int > 0x40 as libc::c_int {
        if 0 as libc::c_int
            != lshpack_dec_dec_int(
                &mut s,
                src_end,
                6 as libc::c_int as libc::c_uint,
                &mut index,
            )
        {
            return -(1 as libc::c_int);
        }
        indexed_type = LSHPACK_ADD_INDEX as libc::c_int;
    } else if *s as libc::c_int == 0x40 as libc::c_int {
        indexed_type = LSHPACK_ADD_INDEX as libc::c_int;
        index = LSHPACK_HDR_UNKNOWN as libc::c_int as uint32_t;
        s = s.offset(1);
    } else if *s as libc::c_int == 0x10 as libc::c_int {
        indexed_type = LSHPACK_NEVER_INDEX as libc::c_int;
        (*output).set_flags((*output).flags() | LSXPACK_NEVER_INDEX as libc::c_int as lsxpack_flag);
        index = LSHPACK_HDR_UNKNOWN as libc::c_int as uint32_t;
        s = s.offset(1);
    } else if *s as libc::c_int & 0xf0 as libc::c_int == 0x10 as libc::c_int {
        if 0 as libc::c_int
            != lshpack_dec_dec_int(
                &mut s,
                src_end,
                4 as libc::c_int as libc::c_uint,
                &mut index,
            )
        {
            return -(1 as libc::c_int);
        }
        indexed_type = LSHPACK_NEVER_INDEX as libc::c_int;
        (*output).set_flags((*output).flags() | LSXPACK_NEVER_INDEX as libc::c_int as lsxpack_flag);
    } else if *s as libc::c_int == 0 as libc::c_int {
        indexed_type = LSHPACK_NO_INDEX as libc::c_int;
        index = LSHPACK_HDR_UNKNOWN as libc::c_int as uint32_t;
        s = s.offset(1);
    } else {
        if 0 as libc::c_int
            != lshpack_dec_dec_int(
                &mut s,
                src_end,
                4 as libc::c_int as libc::c_uint,
                &mut index,
            )
        {
            return -(1 as libc::c_int);
        }
        indexed_type = LSHPACK_NO_INDEX as libc::c_int;
    }
    if index != LSHPACK_HDR_UNKNOWN as libc::c_int as libc::c_uint
        && index <= LSHPACK_HDR_WWW_AUTHENTICATE as libc::c_int as libc::c_uint
    {
        (*output).hpack_index = index as uint8_t;
    }
    let mut name: *mut libc::c_char =
        ((*output).buf).offset((*output).name_offset as libc::c_int as isize);
    if index > 0 as libc::c_int as libc::c_uint {
        if index <= 61 as libc::c_int as libc::c_uint {
            if lshpack_dec_copy_name(
                output,
                &mut name,
                static_table[index.wrapping_sub(1 as libc::c_int as libc::c_uint) as usize].name,
                static_table[index.wrapping_sub(1 as libc::c_int as libc::c_uint) as usize]
                    .name_len,
            ) == -(3 as libc::c_int)
            {
                extra_buf = (static_table
                    [index.wrapping_sub(1 as libc::c_int as libc::c_uint) as usize]
                    .name_len)
                    .wrapping_add(0 as libc::c_int as libc::c_uint)
                    as size_t;
                current_block = 10322097796516096563;
            } else {
                (*output).set_flags(
                    (*output).flags() | LSXPACK_NAME_HASH as libc::c_int as lsxpack_flag,
                );
                (*output).name_hash = static_table_name_hash
                    [index.wrapping_sub(1 as libc::c_int as libc::c_uint) as usize];
                if indexed_type == LSHPACK_VAL_INDEX as libc::c_int {
                    if lshpack_dec_copy_value(
                        output,
                        name,
                        static_table[index.wrapping_sub(1 as libc::c_int as libc::c_uint) as usize]
                            .val,
                        static_table[index.wrapping_sub(1 as libc::c_int as libc::c_uint) as usize]
                            .val_len,
                    ) == 0 as libc::c_int
                    {
                        (*output).set_flags(
                            (*output).flags() | LSXPACK_NAMEVAL_HASH as libc::c_int as lsxpack_flag,
                        );
                        (*output).nameval_hash = static_table_nameval_hash
                            [index.wrapping_sub(1 as libc::c_int as libc::c_uint) as usize];
                        current_block = 12203005246480679048;
                    } else {
                        extra_buf = (static_table
                            [index.wrapping_sub(1 as libc::c_int as libc::c_uint) as usize]
                            .val_len)
                            .wrapping_add(0 as libc::c_int as libc::c_uint)
                            as size_t;
                        current_block = 10322097796516096563;
                    }
                } else {
                    current_block = 8834769789432328951;
                }
            }
        } else {
            entry = hdec_get_table_entry(dec, index);
            if entry.is_null() {
                return -(1 as libc::c_int);
            }
            if lshpack_dec_copy_name(
                output,
                &mut name,
                ((*entry).dte_buf).as_mut_ptr(),
                (*entry).dte_name_len,
            ) == -(3 as libc::c_int)
            {
                extra_buf = ((*entry).dte_name_len).wrapping_add(0 as libc::c_int as libc::c_uint)
                    as size_t;
                current_block = 10322097796516096563;
            } else {
                if (*entry).dte_name_idx != 0 {
                    (*output).hpack_index = (*entry).dte_name_idx;
                } else {
                    (*output).hpack_index = LSHPACK_HDR_UNKNOWN as libc::c_int as uint8_t;
                }
                if indexed_type == LSHPACK_VAL_INDEX as libc::c_int {
                    if lshpack_dec_copy_value(
                        output,
                        name,
                        &mut *((*entry).dte_buf)
                            .as_mut_ptr()
                            .offset((*entry).dte_name_len as isize),
                        (*entry).dte_val_len,
                    ) == 0 as libc::c_int
                    {
                        current_block = 12203005246480679048;
                    } else {
                        extra_buf = ((*entry).dte_val_len)
                            .wrapping_add(0 as libc::c_int as libc::c_uint)
                            as size_t;
                        current_block = 10322097796516096563;
                    }
                } else {
                    current_block = 8834769789432328951;
                }
            }
        }
    } else {
        len = hdec_dec_str(
            name as *mut libc::c_uchar,
            (*output).val_len as size_t,
            &mut s,
            src_end,
        );
        if len < 0 as libc::c_int {
            if len <= -(3 as libc::c_int) {
                extra_buf = -len as size_t;
            } else {
                return len;
            }
            current_block = 10322097796516096563;
        } else {
            if len > 65535 as libc::c_int {
                return -(2 as libc::c_int);
            }
            (*output).name_len = len as lsxpack_strlen_t;
            name = name.offset((*output).name_len as libc::c_int as isize);
            (*output).val_len =
                ((*output).val_len as libc::c_int - (len + 0 as libc::c_int)) as lsxpack_strlen_t;
            current_block = 8834769789432328951;
        }
    }
    match current_block {
        8834769789432328951 => {
            len = hdec_dec_str(
                name as *mut libc::c_uchar,
                (*output).val_len as size_t,
                &mut s,
                src_end,
            );
            if len < 0 as libc::c_int {
                if len <= -(3 as libc::c_int) {
                    extra_buf = -len as size_t;
                } else {
                    return len;
                }
                current_block = 10322097796516096563;
            } else {
                if len > 65535 as libc::c_int {
                    return -(2 as libc::c_int);
                }
                (*output).val_offset = ((*output).name_offset as libc::c_int
                    + (*output).name_len as libc::c_int
                    + 0 as libc::c_int) as lsxpack_strlen_t;
                (*output).val_len = len as lsxpack_strlen_t;
                if indexed_type == LSHPACK_ADD_INDEX as libc::c_int
                    && 0 as libc::c_int != lshpack_dec_push_entry(dec, output)
                {
                    return -(1 as libc::c_int);
                }
                current_block = 12203005246480679048;
            }
        }
        _ => {}
    }
    match current_block {
        10322097796516096563 => {
            buf_len = (buf_len as libc::c_ulong).wrapping_add(extra_buf) as size_t as size_t;
            (*output).val_len = buf_len as lsxpack_strlen_t;
            return -(3 as libc::c_int);
        }
        _ => {
            *src = s;
            return 0 as libc::c_int;
        }
    };
}
unsafe extern "C" fn henc_resize_history(mut enc: *mut lshpack_enc) {
    let mut hist_buf: *mut uint32_t = 0 as *mut uint32_t;
    let mut hist_size: libc::c_uint = 0;
    let mut first: libc::c_uint = 0;
    let mut count: libc::c_uint = 0;
    let mut i: libc::c_uint = 0;
    let mut j: libc::c_uint = 0;
    hist_size = henc_hist_size((*enc).hpe_max_capacity);
    if hist_size == (*enc).hpe_hist_size {
        return;
    }
    if hist_size == 0 as libc::c_int as libc::c_uint {
        free((*enc).hpe_hist_buf as *mut libc::c_void);
        (*enc).hpe_hist_buf = 0 as *mut uint32_t;
        (*enc).hpe_hist_size = 0 as libc::c_int as libc::c_uint;
        (*enc).hpe_hist_idx = 0 as libc::c_int as libc::c_uint;
        (*enc).hpe_hist_wrapped = 0 as libc::c_int;
        return;
    }
    hist_buf =
        malloc(
            (::core::mem::size_of::<uint32_t>() as libc::c_ulong).wrapping_mul(
                hist_size.wrapping_add(1 as libc::c_int as libc::c_uint) as libc::c_ulong,
            ),
        ) as *mut uint32_t;
    if hist_buf.is_null() {
        return;
    }
    if (*enc).hpe_hist_wrapped != 0 {
        first = ((*enc).hpe_hist_idx)
            .wrapping_add(1 as libc::c_int as libc::c_uint)
            .wrapping_rem((*enc).hpe_hist_size);
        count = (*enc).hpe_hist_size;
    } else {
        first = 0 as libc::c_int as libc::c_uint;
        count = (*enc).hpe_hist_idx;
    }
    i = 0 as libc::c_int as libc::c_uint;
    j = 0 as libc::c_int as libc::c_uint;
    while count > 0 as libc::c_int as libc::c_uint && j < hist_size {
        *hist_buf.offset(j as isize) = *((*enc).hpe_hist_buf)
            .offset(first.wrapping_add(i).wrapping_rem((*enc).hpe_hist_size) as isize);
        i = i.wrapping_add(1);
        j = j.wrapping_add(1);
        count = count.wrapping_sub(1);
    }
    (*enc).hpe_hist_size = hist_size;
    (*enc).hpe_hist_idx = j.wrapping_rem(hist_size);
    (*enc).hpe_hist_wrapped =
        ((*enc).hpe_hist_idx == 0 as libc::c_int as libc::c_uint) as libc::c_int;
    free((*enc).hpe_hist_buf as *mut libc::c_void);
    (*enc).hpe_hist_buf = hist_buf;
}
#[no_mangle]
pub unsafe extern "C" fn lshpack_enc_set_max_capacity(
    mut enc: *mut lshpack_enc,
    mut max_capacity: libc::c_uint,
) {
    (*enc).hpe_max_capacity = max_capacity;
    henc_remove_overflow_entries(enc);
    if lshpack_enc_hist_used(enc) != 0 {
        henc_resize_history(enc);
    }
}
unsafe extern "C" fn lshpack_dec_copy_name(
    mut output: *mut lsxpack_header_t,
    mut dest: *mut *mut libc::c_char,
    mut name: *const libc::c_char,
    mut name_len: libc::c_uint,
) -> libc::c_int {
    if name_len.wrapping_add(0 as libc::c_int as libc::c_uint) > (*output).val_len as libc::c_uint {
        return -(3 as libc::c_int);
    }
    (*output).val_len = ((*output).val_len as libc::c_uint)
        .wrapping_sub(name_len.wrapping_add(0 as libc::c_int as libc::c_uint))
        as lsxpack_strlen_t as lsxpack_strlen_t;
    (*output).name_len = name_len as lsxpack_strlen_t;
    memcpy(
        *dest as *mut libc::c_void,
        name as *const libc::c_void,
        name_len as libc::c_ulong,
    );
    *dest = (*dest).offset(name_len as isize);
    return 0 as libc::c_int;
}
unsafe extern "C" fn hdec_get_table_entry(
    mut dec: *mut lshpack_dec,
    mut index: uint32_t,
) -> *mut dec_table_entry {
    let mut val: uintptr_t = 0;
    index = (index as libc::c_uint).wrapping_sub(61 as libc::c_int as libc::c_uint) as uint32_t
        as uint32_t;
    if index == 0 as libc::c_int as libc::c_uint || index > (*dec).hpd_dyn_table.nelem {
        return 0 as *mut dec_table_entry;
    }
    index = ((*dec).hpd_dyn_table.nelem).wrapping_sub(index);
    val =
        *((*dec).hpd_dyn_table.els).offset(((*dec).hpd_dyn_table.off).wrapping_add(index) as isize);
    return val as *mut dec_table_entry;
}
unsafe extern "C" fn hdec_update_max_capacity(
    mut dec: *mut lshpack_dec,
    mut new_capacity: uint32_t,
) {
    (*dec).hpd_cur_max_capacity = new_capacity;
    hdec_remove_overflow_entries(dec);
}
#[no_mangle]
pub unsafe extern "C" fn lshpack_dec_cleanup(mut dec: *mut lshpack_dec) {
    let mut val: uintptr_t = 0;
    while (*dec).hpd_dyn_table.nelem > 0 as libc::c_int as libc::c_uint {
        (*dec).hpd_dyn_table.nelem =
            ((*dec).hpd_dyn_table.nelem).wrapping_sub(1 as libc::c_int as libc::c_uint);
        val = *((*dec).hpd_dyn_table.els)
            .offset(((*dec).hpd_dyn_table.off).wrapping_add((*dec).hpd_dyn_table.nelem) as isize);
        free(val as *mut dec_table_entry as *mut libc::c_void);
    }
    free((*dec).hpd_dyn_table.els as *mut libc::c_void);
    memset(
        &mut (*dec).hpd_dyn_table as *mut lshpack_arr as *mut libc::c_void,
        0 as libc::c_int,
        ::core::mem::size_of::<lshpack_arr>() as libc::c_ulong,
    );
}
static mut decode_tables: [[decode_el; 16]; 256] = [
    [
        {
            let mut init = decode_el {
                state: 4 as libc::c_int as uint8_t,
                flags: 0 as libc::c_int as uint8_t,
                sym: 0 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 5 as libc::c_int as uint8_t,
                flags: 0 as libc::c_int as uint8_t,
                sym: 0 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 7 as libc::c_int as uint8_t,
                flags: 0 as libc::c_int as uint8_t,
                sym: 0 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 8 as libc::c_int as uint8_t,
                flags: 0 as libc::c_int as uint8_t,
                sym: 0 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 11 as libc::c_int as uint8_t,
                flags: 0 as libc::c_int as uint8_t,
                sym: 0 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 12 as libc::c_int as uint8_t,
                flags: 0 as libc::c_int as uint8_t,
                sym: 0 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 16 as libc::c_int as uint8_t,
                flags: 0 as libc::c_int as uint8_t,
                sym: 0 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 19 as libc::c_int as uint8_t,
                flags: 0 as libc::c_int as uint8_t,
                sym: 0 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 25 as libc::c_int as uint8_t,
                flags: 0 as libc::c_int as uint8_t,
                sym: 0 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 28 as libc::c_int as uint8_t,
                flags: 0 as libc::c_int as uint8_t,
                sym: 0 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 32 as libc::c_int as uint8_t,
                flags: 0 as libc::c_int as uint8_t,
                sym: 0 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 35 as libc::c_int as uint8_t,
                flags: 0 as libc::c_int as uint8_t,
                sym: 0 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 42 as libc::c_int as uint8_t,
                flags: 0 as libc::c_int as uint8_t,
                sym: 0 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 49 as libc::c_int as uint8_t,
                flags: 0 as libc::c_int as uint8_t,
                sym: 0 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 57 as libc::c_int as uint8_t,
                flags: 0 as libc::c_int as uint8_t,
                sym: 0 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 64 as libc::c_int as uint8_t,
                flags: 0x1 as libc::c_int as uint8_t,
                sym: 0 as libc::c_int as uint8_t,
            };
            init
        },
    ],
    [
        {
            let mut init = decode_el {
                state: 0 as libc::c_int as uint8_t,
                flags: 0x3 as libc::c_int as uint8_t,
                sym: 48 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 0 as libc::c_int as uint8_t,
                flags: 0x3 as libc::c_int as uint8_t,
                sym: 49 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 0 as libc::c_int as uint8_t,
                flags: 0x3 as libc::c_int as uint8_t,
                sym: 50 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 0 as libc::c_int as uint8_t,
                flags: 0x3 as libc::c_int as uint8_t,
                sym: 97 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 0 as libc::c_int as uint8_t,
                flags: 0x3 as libc::c_int as uint8_t,
                sym: 99 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 0 as libc::c_int as uint8_t,
                flags: 0x3 as libc::c_int as uint8_t,
                sym: 101 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 0 as libc::c_int as uint8_t,
                flags: 0x3 as libc::c_int as uint8_t,
                sym: 105 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 0 as libc::c_int as uint8_t,
                flags: 0x3 as libc::c_int as uint8_t,
                sym: 111 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 0 as libc::c_int as uint8_t,
                flags: 0x3 as libc::c_int as uint8_t,
                sym: 115 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 0 as libc::c_int as uint8_t,
                flags: 0x3 as libc::c_int as uint8_t,
                sym: 116 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 13 as libc::c_int as uint8_t,
                flags: 0 as libc::c_int as uint8_t,
                sym: 0 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 14 as libc::c_int as uint8_t,
                flags: 0 as libc::c_int as uint8_t,
                sym: 0 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 17 as libc::c_int as uint8_t,
                flags: 0 as libc::c_int as uint8_t,
                sym: 0 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 18 as libc::c_int as uint8_t,
                flags: 0 as libc::c_int as uint8_t,
                sym: 0 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 20 as libc::c_int as uint8_t,
                flags: 0 as libc::c_int as uint8_t,
                sym: 0 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 21 as libc::c_int as uint8_t,
                flags: 0 as libc::c_int as uint8_t,
                sym: 0 as libc::c_int as uint8_t,
            };
            init
        },
    ],
    [
        {
            let mut init = decode_el {
                state: 1 as libc::c_int as uint8_t,
                flags: 0x2 as libc::c_int as uint8_t,
                sym: 48 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 22 as libc::c_int as uint8_t,
                flags: 0x3 as libc::c_int as uint8_t,
                sym: 48 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 1 as libc::c_int as uint8_t,
                flags: 0x2 as libc::c_int as uint8_t,
                sym: 49 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 22 as libc::c_int as uint8_t,
                flags: 0x3 as libc::c_int as uint8_t,
                sym: 49 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 1 as libc::c_int as uint8_t,
                flags: 0x2 as libc::c_int as uint8_t,
                sym: 50 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 22 as libc::c_int as uint8_t,
                flags: 0x3 as libc::c_int as uint8_t,
                sym: 50 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 1 as libc::c_int as uint8_t,
                flags: 0x2 as libc::c_int as uint8_t,
                sym: 97 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 22 as libc::c_int as uint8_t,
                flags: 0x3 as libc::c_int as uint8_t,
                sym: 97 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 1 as libc::c_int as uint8_t,
                flags: 0x2 as libc::c_int as uint8_t,
                sym: 99 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 22 as libc::c_int as uint8_t,
                flags: 0x3 as libc::c_int as uint8_t,
                sym: 99 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 1 as libc::c_int as uint8_t,
                flags: 0x2 as libc::c_int as uint8_t,
                sym: 101 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 22 as libc::c_int as uint8_t,
                flags: 0x3 as libc::c_int as uint8_t,
                sym: 101 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 1 as libc::c_int as uint8_t,
                flags: 0x2 as libc::c_int as uint8_t,
                sym: 105 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 22 as libc::c_int as uint8_t,
                flags: 0x3 as libc::c_int as uint8_t,
                sym: 105 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 1 as libc::c_int as uint8_t,
                flags: 0x2 as libc::c_int as uint8_t,
                sym: 111 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 22 as libc::c_int as uint8_t,
                flags: 0x3 as libc::c_int as uint8_t,
                sym: 111 as libc::c_int as uint8_t,
            };
            init
        },
    ],
    [
        {
            let mut init = decode_el {
                state: 2 as libc::c_int as uint8_t,
                flags: 0x2 as libc::c_int as uint8_t,
                sym: 48 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 9 as libc::c_int as uint8_t,
                flags: 0x2 as libc::c_int as uint8_t,
                sym: 48 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 23 as libc::c_int as uint8_t,
                flags: 0x2 as libc::c_int as uint8_t,
                sym: 48 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 40 as libc::c_int as uint8_t,
                flags: 0x3 as libc::c_int as uint8_t,
                sym: 48 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 2 as libc::c_int as uint8_t,
                flags: 0x2 as libc::c_int as uint8_t,
                sym: 49 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 9 as libc::c_int as uint8_t,
                flags: 0x2 as libc::c_int as uint8_t,
                sym: 49 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 23 as libc::c_int as uint8_t,
                flags: 0x2 as libc::c_int as uint8_t,
                sym: 49 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 40 as libc::c_int as uint8_t,
                flags: 0x3 as libc::c_int as uint8_t,
                sym: 49 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 2 as libc::c_int as uint8_t,
                flags: 0x2 as libc::c_int as uint8_t,
                sym: 50 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 9 as libc::c_int as uint8_t,
                flags: 0x2 as libc::c_int as uint8_t,
                sym: 50 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 23 as libc::c_int as uint8_t,
                flags: 0x2 as libc::c_int as uint8_t,
                sym: 50 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 40 as libc::c_int as uint8_t,
                flags: 0x3 as libc::c_int as uint8_t,
                sym: 50 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 2 as libc::c_int as uint8_t,
                flags: 0x2 as libc::c_int as uint8_t,
                sym: 97 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 9 as libc::c_int as uint8_t,
                flags: 0x2 as libc::c_int as uint8_t,
                sym: 97 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 23 as libc::c_int as uint8_t,
                flags: 0x2 as libc::c_int as uint8_t,
                sym: 97 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 40 as libc::c_int as uint8_t,
                flags: 0x3 as libc::c_int as uint8_t,
                sym: 97 as libc::c_int as uint8_t,
            };
            init
        },
    ],
    [
        {
            let mut init = decode_el {
                state: 3 as libc::c_int as uint8_t,
                flags: 0x2 as libc::c_int as uint8_t,
                sym: 48 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 6 as libc::c_int as uint8_t,
                flags: 0x2 as libc::c_int as uint8_t,
                sym: 48 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 10 as libc::c_int as uint8_t,
                flags: 0x2 as libc::c_int as uint8_t,
                sym: 48 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 15 as libc::c_int as uint8_t,
                flags: 0x2 as libc::c_int as uint8_t,
                sym: 48 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 24 as libc::c_int as uint8_t,
                flags: 0x2 as libc::c_int as uint8_t,
                sym: 48 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 31 as libc::c_int as uint8_t,
                flags: 0x2 as libc::c_int as uint8_t,
                sym: 48 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 41 as libc::c_int as uint8_t,
                flags: 0x2 as libc::c_int as uint8_t,
                sym: 48 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 56 as libc::c_int as uint8_t,
                flags: 0x3 as libc::c_int as uint8_t,
                sym: 48 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 3 as libc::c_int as uint8_t,
                flags: 0x2 as libc::c_int as uint8_t,
                sym: 49 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 6 as libc::c_int as uint8_t,
                flags: 0x2 as libc::c_int as uint8_t,
                sym: 49 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 10 as libc::c_int as uint8_t,
                flags: 0x2 as libc::c_int as uint8_t,
                sym: 49 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 15 as libc::c_int as uint8_t,
                flags: 0x2 as libc::c_int as uint8_t,
                sym: 49 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 24 as libc::c_int as uint8_t,
                flags: 0x2 as libc::c_int as uint8_t,
                sym: 49 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 31 as libc::c_int as uint8_t,
                flags: 0x2 as libc::c_int as uint8_t,
                sym: 49 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 41 as libc::c_int as uint8_t,
                flags: 0x2 as libc::c_int as uint8_t,
                sym: 49 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 56 as libc::c_int as uint8_t,
                flags: 0x3 as libc::c_int as uint8_t,
                sym: 49 as libc::c_int as uint8_t,
            };
            init
        },
    ],
    [
        {
            let mut init = decode_el {
                state: 3 as libc::c_int as uint8_t,
                flags: 0x2 as libc::c_int as uint8_t,
                sym: 50 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 6 as libc::c_int as uint8_t,
                flags: 0x2 as libc::c_int as uint8_t,
                sym: 50 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 10 as libc::c_int as uint8_t,
                flags: 0x2 as libc::c_int as uint8_t,
                sym: 50 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 15 as libc::c_int as uint8_t,
                flags: 0x2 as libc::c_int as uint8_t,
                sym: 50 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 24 as libc::c_int as uint8_t,
                flags: 0x2 as libc::c_int as uint8_t,
                sym: 50 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 31 as libc::c_int as uint8_t,
                flags: 0x2 as libc::c_int as uint8_t,
                sym: 50 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 41 as libc::c_int as uint8_t,
                flags: 0x2 as libc::c_int as uint8_t,
                sym: 50 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 56 as libc::c_int as uint8_t,
                flags: 0x3 as libc::c_int as uint8_t,
                sym: 50 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 3 as libc::c_int as uint8_t,
                flags: 0x2 as libc::c_int as uint8_t,
                sym: 97 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 6 as libc::c_int as uint8_t,
                flags: 0x2 as libc::c_int as uint8_t,
                sym: 97 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 10 as libc::c_int as uint8_t,
                flags: 0x2 as libc::c_int as uint8_t,
                sym: 97 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 15 as libc::c_int as uint8_t,
                flags: 0x2 as libc::c_int as uint8_t,
                sym: 97 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 24 as libc::c_int as uint8_t,
                flags: 0x2 as libc::c_int as uint8_t,
                sym: 97 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 31 as libc::c_int as uint8_t,
                flags: 0x2 as libc::c_int as uint8_t,
                sym: 97 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 41 as libc::c_int as uint8_t,
                flags: 0x2 as libc::c_int as uint8_t,
                sym: 97 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 56 as libc::c_int as uint8_t,
                flags: 0x3 as libc::c_int as uint8_t,
                sym: 97 as libc::c_int as uint8_t,
            };
            init
        },
    ],
    [
        {
            let mut init = decode_el {
                state: 2 as libc::c_int as uint8_t,
                flags: 0x2 as libc::c_int as uint8_t,
                sym: 99 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 9 as libc::c_int as uint8_t,
                flags: 0x2 as libc::c_int as uint8_t,
                sym: 99 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 23 as libc::c_int as uint8_t,
                flags: 0x2 as libc::c_int as uint8_t,
                sym: 99 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 40 as libc::c_int as uint8_t,
                flags: 0x3 as libc::c_int as uint8_t,
                sym: 99 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 2 as libc::c_int as uint8_t,
                flags: 0x2 as libc::c_int as uint8_t,
                sym: 101 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 9 as libc::c_int as uint8_t,
                flags: 0x2 as libc::c_int as uint8_t,
                sym: 101 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 23 as libc::c_int as uint8_t,
                flags: 0x2 as libc::c_int as uint8_t,
                sym: 101 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 40 as libc::c_int as uint8_t,
                flags: 0x3 as libc::c_int as uint8_t,
                sym: 101 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 2 as libc::c_int as uint8_t,
                flags: 0x2 as libc::c_int as uint8_t,
                sym: 105 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 9 as libc::c_int as uint8_t,
                flags: 0x2 as libc::c_int as uint8_t,
                sym: 105 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 23 as libc::c_int as uint8_t,
                flags: 0x2 as libc::c_int as uint8_t,
                sym: 105 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 40 as libc::c_int as uint8_t,
                flags: 0x3 as libc::c_int as uint8_t,
                sym: 105 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 2 as libc::c_int as uint8_t,
                flags: 0x2 as libc::c_int as uint8_t,
                sym: 111 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 9 as libc::c_int as uint8_t,
                flags: 0x2 as libc::c_int as uint8_t,
                sym: 111 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 23 as libc::c_int as uint8_t,
                flags: 0x2 as libc::c_int as uint8_t,
                sym: 111 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 40 as libc::c_int as uint8_t,
                flags: 0x3 as libc::c_int as uint8_t,
                sym: 111 as libc::c_int as uint8_t,
            };
            init
        },
    ],
    [
        {
            let mut init = decode_el {
                state: 3 as libc::c_int as uint8_t,
                flags: 0x2 as libc::c_int as uint8_t,
                sym: 99 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 6 as libc::c_int as uint8_t,
                flags: 0x2 as libc::c_int as uint8_t,
                sym: 99 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 10 as libc::c_int as uint8_t,
                flags: 0x2 as libc::c_int as uint8_t,
                sym: 99 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 15 as libc::c_int as uint8_t,
                flags: 0x2 as libc::c_int as uint8_t,
                sym: 99 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 24 as libc::c_int as uint8_t,
                flags: 0x2 as libc::c_int as uint8_t,
                sym: 99 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 31 as libc::c_int as uint8_t,
                flags: 0x2 as libc::c_int as uint8_t,
                sym: 99 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 41 as libc::c_int as uint8_t,
                flags: 0x2 as libc::c_int as uint8_t,
                sym: 99 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 56 as libc::c_int as uint8_t,
                flags: 0x3 as libc::c_int as uint8_t,
                sym: 99 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 3 as libc::c_int as uint8_t,
                flags: 0x2 as libc::c_int as uint8_t,
                sym: 101 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 6 as libc::c_int as uint8_t,
                flags: 0x2 as libc::c_int as uint8_t,
                sym: 101 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 10 as libc::c_int as uint8_t,
                flags: 0x2 as libc::c_int as uint8_t,
                sym: 101 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 15 as libc::c_int as uint8_t,
                flags: 0x2 as libc::c_int as uint8_t,
                sym: 101 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 24 as libc::c_int as uint8_t,
                flags: 0x2 as libc::c_int as uint8_t,
                sym: 101 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 31 as libc::c_int as uint8_t,
                flags: 0x2 as libc::c_int as uint8_t,
                sym: 101 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 41 as libc::c_int as uint8_t,
                flags: 0x2 as libc::c_int as uint8_t,
                sym: 101 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 56 as libc::c_int as uint8_t,
                flags: 0x3 as libc::c_int as uint8_t,
                sym: 101 as libc::c_int as uint8_t,
            };
            init
        },
    ],
    [
        {
            let mut init = decode_el {
                state: 3 as libc::c_int as uint8_t,
                flags: 0x2 as libc::c_int as uint8_t,
                sym: 105 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 6 as libc::c_int as uint8_t,
                flags: 0x2 as libc::c_int as uint8_t,
                sym: 105 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 10 as libc::c_int as uint8_t,
                flags: 0x2 as libc::c_int as uint8_t,
                sym: 105 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 15 as libc::c_int as uint8_t,
                flags: 0x2 as libc::c_int as uint8_t,
                sym: 105 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 24 as libc::c_int as uint8_t,
                flags: 0x2 as libc::c_int as uint8_t,
                sym: 105 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 31 as libc::c_int as uint8_t,
                flags: 0x2 as libc::c_int as uint8_t,
                sym: 105 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 41 as libc::c_int as uint8_t,
                flags: 0x2 as libc::c_int as uint8_t,
                sym: 105 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 56 as libc::c_int as uint8_t,
                flags: 0x3 as libc::c_int as uint8_t,
                sym: 105 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 3 as libc::c_int as uint8_t,
                flags: 0x2 as libc::c_int as uint8_t,
                sym: 111 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 6 as libc::c_int as uint8_t,
                flags: 0x2 as libc::c_int as uint8_t,
                sym: 111 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 10 as libc::c_int as uint8_t,
                flags: 0x2 as libc::c_int as uint8_t,
                sym: 111 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 15 as libc::c_int as uint8_t,
                flags: 0x2 as libc::c_int as uint8_t,
                sym: 111 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 24 as libc::c_int as uint8_t,
                flags: 0x2 as libc::c_int as uint8_t,
                sym: 111 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 31 as libc::c_int as uint8_t,
                flags: 0x2 as libc::c_int as uint8_t,
                sym: 111 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 41 as libc::c_int as uint8_t,
                flags: 0x2 as libc::c_int as uint8_t,
                sym: 111 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 56 as libc::c_int as uint8_t,
                flags: 0x3 as libc::c_int as uint8_t,
                sym: 111 as libc::c_int as uint8_t,
            };
            init
        },
    ],
    [
        {
            let mut init = decode_el {
                state: 1 as libc::c_int as uint8_t,
                flags: 0x2 as libc::c_int as uint8_t,
                sym: 115 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 22 as libc::c_int as uint8_t,
                flags: 0x3 as libc::c_int as uint8_t,
                sym: 115 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 1 as libc::c_int as uint8_t,
                flags: 0x2 as libc::c_int as uint8_t,
                sym: 116 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 22 as libc::c_int as uint8_t,
                flags: 0x3 as libc::c_int as uint8_t,
                sym: 116 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 0 as libc::c_int as uint8_t,
                flags: 0x3 as libc::c_int as uint8_t,
                sym: 32 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 0 as libc::c_int as uint8_t,
                flags: 0x3 as libc::c_int as uint8_t,
                sym: 37 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 0 as libc::c_int as uint8_t,
                flags: 0x3 as libc::c_int as uint8_t,
                sym: 45 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 0 as libc::c_int as uint8_t,
                flags: 0x3 as libc::c_int as uint8_t,
                sym: 46 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 0 as libc::c_int as uint8_t,
                flags: 0x3 as libc::c_int as uint8_t,
                sym: 47 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 0 as libc::c_int as uint8_t,
                flags: 0x3 as libc::c_int as uint8_t,
                sym: 51 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 0 as libc::c_int as uint8_t,
                flags: 0x3 as libc::c_int as uint8_t,
                sym: 52 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 0 as libc::c_int as uint8_t,
                flags: 0x3 as libc::c_int as uint8_t,
                sym: 53 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 0 as libc::c_int as uint8_t,
                flags: 0x3 as libc::c_int as uint8_t,
                sym: 54 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 0 as libc::c_int as uint8_t,
                flags: 0x3 as libc::c_int as uint8_t,
                sym: 55 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 0 as libc::c_int as uint8_t,
                flags: 0x3 as libc::c_int as uint8_t,
                sym: 56 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 0 as libc::c_int as uint8_t,
                flags: 0x3 as libc::c_int as uint8_t,
                sym: 57 as libc::c_int as uint8_t,
            };
            init
        },
    ],
    [
        {
            let mut init = decode_el {
                state: 2 as libc::c_int as uint8_t,
                flags: 0x2 as libc::c_int as uint8_t,
                sym: 115 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 9 as libc::c_int as uint8_t,
                flags: 0x2 as libc::c_int as uint8_t,
                sym: 115 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 23 as libc::c_int as uint8_t,
                flags: 0x2 as libc::c_int as uint8_t,
                sym: 115 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 40 as libc::c_int as uint8_t,
                flags: 0x3 as libc::c_int as uint8_t,
                sym: 115 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 2 as libc::c_int as uint8_t,
                flags: 0x2 as libc::c_int as uint8_t,
                sym: 116 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 9 as libc::c_int as uint8_t,
                flags: 0x2 as libc::c_int as uint8_t,
                sym: 116 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 23 as libc::c_int as uint8_t,
                flags: 0x2 as libc::c_int as uint8_t,
                sym: 116 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 40 as libc::c_int as uint8_t,
                flags: 0x3 as libc::c_int as uint8_t,
                sym: 116 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 1 as libc::c_int as uint8_t,
                flags: 0x2 as libc::c_int as uint8_t,
                sym: 32 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 22 as libc::c_int as uint8_t,
                flags: 0x3 as libc::c_int as uint8_t,
                sym: 32 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 1 as libc::c_int as uint8_t,
                flags: 0x2 as libc::c_int as uint8_t,
                sym: 37 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 22 as libc::c_int as uint8_t,
                flags: 0x3 as libc::c_int as uint8_t,
                sym: 37 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 1 as libc::c_int as uint8_t,
                flags: 0x2 as libc::c_int as uint8_t,
                sym: 45 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 22 as libc::c_int as uint8_t,
                flags: 0x3 as libc::c_int as uint8_t,
                sym: 45 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 1 as libc::c_int as uint8_t,
                flags: 0x2 as libc::c_int as uint8_t,
                sym: 46 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 22 as libc::c_int as uint8_t,
                flags: 0x3 as libc::c_int as uint8_t,
                sym: 46 as libc::c_int as uint8_t,
            };
            init
        },
    ],
    [
        {
            let mut init = decode_el {
                state: 3 as libc::c_int as uint8_t,
                flags: 0x2 as libc::c_int as uint8_t,
                sym: 115 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 6 as libc::c_int as uint8_t,
                flags: 0x2 as libc::c_int as uint8_t,
                sym: 115 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 10 as libc::c_int as uint8_t,
                flags: 0x2 as libc::c_int as uint8_t,
                sym: 115 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 15 as libc::c_int as uint8_t,
                flags: 0x2 as libc::c_int as uint8_t,
                sym: 115 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 24 as libc::c_int as uint8_t,
                flags: 0x2 as libc::c_int as uint8_t,
                sym: 115 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 31 as libc::c_int as uint8_t,
                flags: 0x2 as libc::c_int as uint8_t,
                sym: 115 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 41 as libc::c_int as uint8_t,
                flags: 0x2 as libc::c_int as uint8_t,
                sym: 115 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 56 as libc::c_int as uint8_t,
                flags: 0x3 as libc::c_int as uint8_t,
                sym: 115 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 3 as libc::c_int as uint8_t,
                flags: 0x2 as libc::c_int as uint8_t,
                sym: 116 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 6 as libc::c_int as uint8_t,
                flags: 0x2 as libc::c_int as uint8_t,
                sym: 116 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 10 as libc::c_int as uint8_t,
                flags: 0x2 as libc::c_int as uint8_t,
                sym: 116 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 15 as libc::c_int as uint8_t,
                flags: 0x2 as libc::c_int as uint8_t,
                sym: 116 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 24 as libc::c_int as uint8_t,
                flags: 0x2 as libc::c_int as uint8_t,
                sym: 116 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 31 as libc::c_int as uint8_t,
                flags: 0x2 as libc::c_int as uint8_t,
                sym: 116 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 41 as libc::c_int as uint8_t,
                flags: 0x2 as libc::c_int as uint8_t,
                sym: 116 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 56 as libc::c_int as uint8_t,
                flags: 0x3 as libc::c_int as uint8_t,
                sym: 116 as libc::c_int as uint8_t,
            };
            init
        },
    ],
    [
        {
            let mut init = decode_el {
                state: 2 as libc::c_int as uint8_t,
                flags: 0x2 as libc::c_int as uint8_t,
                sym: 32 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 9 as libc::c_int as uint8_t,
                flags: 0x2 as libc::c_int as uint8_t,
                sym: 32 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 23 as libc::c_int as uint8_t,
                flags: 0x2 as libc::c_int as uint8_t,
                sym: 32 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 40 as libc::c_int as uint8_t,
                flags: 0x3 as libc::c_int as uint8_t,
                sym: 32 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 2 as libc::c_int as uint8_t,
                flags: 0x2 as libc::c_int as uint8_t,
                sym: 37 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 9 as libc::c_int as uint8_t,
                flags: 0x2 as libc::c_int as uint8_t,
                sym: 37 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 23 as libc::c_int as uint8_t,
                flags: 0x2 as libc::c_int as uint8_t,
                sym: 37 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 40 as libc::c_int as uint8_t,
                flags: 0x3 as libc::c_int as uint8_t,
                sym: 37 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 2 as libc::c_int as uint8_t,
                flags: 0x2 as libc::c_int as uint8_t,
                sym: 45 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 9 as libc::c_int as uint8_t,
                flags: 0x2 as libc::c_int as uint8_t,
                sym: 45 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 23 as libc::c_int as uint8_t,
                flags: 0x2 as libc::c_int as uint8_t,
                sym: 45 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 40 as libc::c_int as uint8_t,
                flags: 0x3 as libc::c_int as uint8_t,
                sym: 45 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 2 as libc::c_int as uint8_t,
                flags: 0x2 as libc::c_int as uint8_t,
                sym: 46 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 9 as libc::c_int as uint8_t,
                flags: 0x2 as libc::c_int as uint8_t,
                sym: 46 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 23 as libc::c_int as uint8_t,
                flags: 0x2 as libc::c_int as uint8_t,
                sym: 46 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 40 as libc::c_int as uint8_t,
                flags: 0x3 as libc::c_int as uint8_t,
                sym: 46 as libc::c_int as uint8_t,
            };
            init
        },
    ],
    [
        {
            let mut init = decode_el {
                state: 3 as libc::c_int as uint8_t,
                flags: 0x2 as libc::c_int as uint8_t,
                sym: 32 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 6 as libc::c_int as uint8_t,
                flags: 0x2 as libc::c_int as uint8_t,
                sym: 32 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 10 as libc::c_int as uint8_t,
                flags: 0x2 as libc::c_int as uint8_t,
                sym: 32 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 15 as libc::c_int as uint8_t,
                flags: 0x2 as libc::c_int as uint8_t,
                sym: 32 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 24 as libc::c_int as uint8_t,
                flags: 0x2 as libc::c_int as uint8_t,
                sym: 32 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 31 as libc::c_int as uint8_t,
                flags: 0x2 as libc::c_int as uint8_t,
                sym: 32 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 41 as libc::c_int as uint8_t,
                flags: 0x2 as libc::c_int as uint8_t,
                sym: 32 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 56 as libc::c_int as uint8_t,
                flags: 0x3 as libc::c_int as uint8_t,
                sym: 32 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 3 as libc::c_int as uint8_t,
                flags: 0x2 as libc::c_int as uint8_t,
                sym: 37 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 6 as libc::c_int as uint8_t,
                flags: 0x2 as libc::c_int as uint8_t,
                sym: 37 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 10 as libc::c_int as uint8_t,
                flags: 0x2 as libc::c_int as uint8_t,
                sym: 37 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 15 as libc::c_int as uint8_t,
                flags: 0x2 as libc::c_int as uint8_t,
                sym: 37 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 24 as libc::c_int as uint8_t,
                flags: 0x2 as libc::c_int as uint8_t,
                sym: 37 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 31 as libc::c_int as uint8_t,
                flags: 0x2 as libc::c_int as uint8_t,
                sym: 37 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 41 as libc::c_int as uint8_t,
                flags: 0x2 as libc::c_int as uint8_t,
                sym: 37 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 56 as libc::c_int as uint8_t,
                flags: 0x3 as libc::c_int as uint8_t,
                sym: 37 as libc::c_int as uint8_t,
            };
            init
        },
    ],
    [
        {
            let mut init = decode_el {
                state: 3 as libc::c_int as uint8_t,
                flags: 0x2 as libc::c_int as uint8_t,
                sym: 45 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 6 as libc::c_int as uint8_t,
                flags: 0x2 as libc::c_int as uint8_t,
                sym: 45 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 10 as libc::c_int as uint8_t,
                flags: 0x2 as libc::c_int as uint8_t,
                sym: 45 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 15 as libc::c_int as uint8_t,
                flags: 0x2 as libc::c_int as uint8_t,
                sym: 45 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 24 as libc::c_int as uint8_t,
                flags: 0x2 as libc::c_int as uint8_t,
                sym: 45 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 31 as libc::c_int as uint8_t,
                flags: 0x2 as libc::c_int as uint8_t,
                sym: 45 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 41 as libc::c_int as uint8_t,
                flags: 0x2 as libc::c_int as uint8_t,
                sym: 45 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 56 as libc::c_int as uint8_t,
                flags: 0x3 as libc::c_int as uint8_t,
                sym: 45 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 3 as libc::c_int as uint8_t,
                flags: 0x2 as libc::c_int as uint8_t,
                sym: 46 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 6 as libc::c_int as uint8_t,
                flags: 0x2 as libc::c_int as uint8_t,
                sym: 46 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 10 as libc::c_int as uint8_t,
                flags: 0x2 as libc::c_int as uint8_t,
                sym: 46 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 15 as libc::c_int as uint8_t,
                flags: 0x2 as libc::c_int as uint8_t,
                sym: 46 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 24 as libc::c_int as uint8_t,
                flags: 0x2 as libc::c_int as uint8_t,
                sym: 46 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 31 as libc::c_int as uint8_t,
                flags: 0x2 as libc::c_int as uint8_t,
                sym: 46 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 41 as libc::c_int as uint8_t,
                flags: 0x2 as libc::c_int as uint8_t,
                sym: 46 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 56 as libc::c_int as uint8_t,
                flags: 0x3 as libc::c_int as uint8_t,
                sym: 46 as libc::c_int as uint8_t,
            };
            init
        },
    ],
    [
        {
            let mut init = decode_el {
                state: 1 as libc::c_int as uint8_t,
                flags: 0x2 as libc::c_int as uint8_t,
                sym: 47 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 22 as libc::c_int as uint8_t,
                flags: 0x3 as libc::c_int as uint8_t,
                sym: 47 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 1 as libc::c_int as uint8_t,
                flags: 0x2 as libc::c_int as uint8_t,
                sym: 51 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 22 as libc::c_int as uint8_t,
                flags: 0x3 as libc::c_int as uint8_t,
                sym: 51 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 1 as libc::c_int as uint8_t,
                flags: 0x2 as libc::c_int as uint8_t,
                sym: 52 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 22 as libc::c_int as uint8_t,
                flags: 0x3 as libc::c_int as uint8_t,
                sym: 52 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 1 as libc::c_int as uint8_t,
                flags: 0x2 as libc::c_int as uint8_t,
                sym: 53 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 22 as libc::c_int as uint8_t,
                flags: 0x3 as libc::c_int as uint8_t,
                sym: 53 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 1 as libc::c_int as uint8_t,
                flags: 0x2 as libc::c_int as uint8_t,
                sym: 54 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 22 as libc::c_int as uint8_t,
                flags: 0x3 as libc::c_int as uint8_t,
                sym: 54 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 1 as libc::c_int as uint8_t,
                flags: 0x2 as libc::c_int as uint8_t,
                sym: 55 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 22 as libc::c_int as uint8_t,
                flags: 0x3 as libc::c_int as uint8_t,
                sym: 55 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 1 as libc::c_int as uint8_t,
                flags: 0x2 as libc::c_int as uint8_t,
                sym: 56 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 22 as libc::c_int as uint8_t,
                flags: 0x3 as libc::c_int as uint8_t,
                sym: 56 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 1 as libc::c_int as uint8_t,
                flags: 0x2 as libc::c_int as uint8_t,
                sym: 57 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 22 as libc::c_int as uint8_t,
                flags: 0x3 as libc::c_int as uint8_t,
                sym: 57 as libc::c_int as uint8_t,
            };
            init
        },
    ],
    [
        {
            let mut init = decode_el {
                state: 2 as libc::c_int as uint8_t,
                flags: 0x2 as libc::c_int as uint8_t,
                sym: 47 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 9 as libc::c_int as uint8_t,
                flags: 0x2 as libc::c_int as uint8_t,
                sym: 47 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 23 as libc::c_int as uint8_t,
                flags: 0x2 as libc::c_int as uint8_t,
                sym: 47 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 40 as libc::c_int as uint8_t,
                flags: 0x3 as libc::c_int as uint8_t,
                sym: 47 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 2 as libc::c_int as uint8_t,
                flags: 0x2 as libc::c_int as uint8_t,
                sym: 51 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 9 as libc::c_int as uint8_t,
                flags: 0x2 as libc::c_int as uint8_t,
                sym: 51 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 23 as libc::c_int as uint8_t,
                flags: 0x2 as libc::c_int as uint8_t,
                sym: 51 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 40 as libc::c_int as uint8_t,
                flags: 0x3 as libc::c_int as uint8_t,
                sym: 51 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 2 as libc::c_int as uint8_t,
                flags: 0x2 as libc::c_int as uint8_t,
                sym: 52 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 9 as libc::c_int as uint8_t,
                flags: 0x2 as libc::c_int as uint8_t,
                sym: 52 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 23 as libc::c_int as uint8_t,
                flags: 0x2 as libc::c_int as uint8_t,
                sym: 52 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 40 as libc::c_int as uint8_t,
                flags: 0x3 as libc::c_int as uint8_t,
                sym: 52 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 2 as libc::c_int as uint8_t,
                flags: 0x2 as libc::c_int as uint8_t,
                sym: 53 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 9 as libc::c_int as uint8_t,
                flags: 0x2 as libc::c_int as uint8_t,
                sym: 53 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 23 as libc::c_int as uint8_t,
                flags: 0x2 as libc::c_int as uint8_t,
                sym: 53 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 40 as libc::c_int as uint8_t,
                flags: 0x3 as libc::c_int as uint8_t,
                sym: 53 as libc::c_int as uint8_t,
            };
            init
        },
    ],
    [
        {
            let mut init = decode_el {
                state: 3 as libc::c_int as uint8_t,
                flags: 0x2 as libc::c_int as uint8_t,
                sym: 47 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 6 as libc::c_int as uint8_t,
                flags: 0x2 as libc::c_int as uint8_t,
                sym: 47 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 10 as libc::c_int as uint8_t,
                flags: 0x2 as libc::c_int as uint8_t,
                sym: 47 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 15 as libc::c_int as uint8_t,
                flags: 0x2 as libc::c_int as uint8_t,
                sym: 47 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 24 as libc::c_int as uint8_t,
                flags: 0x2 as libc::c_int as uint8_t,
                sym: 47 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 31 as libc::c_int as uint8_t,
                flags: 0x2 as libc::c_int as uint8_t,
                sym: 47 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 41 as libc::c_int as uint8_t,
                flags: 0x2 as libc::c_int as uint8_t,
                sym: 47 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 56 as libc::c_int as uint8_t,
                flags: 0x3 as libc::c_int as uint8_t,
                sym: 47 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 3 as libc::c_int as uint8_t,
                flags: 0x2 as libc::c_int as uint8_t,
                sym: 51 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 6 as libc::c_int as uint8_t,
                flags: 0x2 as libc::c_int as uint8_t,
                sym: 51 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 10 as libc::c_int as uint8_t,
                flags: 0x2 as libc::c_int as uint8_t,
                sym: 51 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 15 as libc::c_int as uint8_t,
                flags: 0x2 as libc::c_int as uint8_t,
                sym: 51 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 24 as libc::c_int as uint8_t,
                flags: 0x2 as libc::c_int as uint8_t,
                sym: 51 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 31 as libc::c_int as uint8_t,
                flags: 0x2 as libc::c_int as uint8_t,
                sym: 51 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 41 as libc::c_int as uint8_t,
                flags: 0x2 as libc::c_int as uint8_t,
                sym: 51 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 56 as libc::c_int as uint8_t,
                flags: 0x3 as libc::c_int as uint8_t,
                sym: 51 as libc::c_int as uint8_t,
            };
            init
        },
    ],
    [
        {
            let mut init = decode_el {
                state: 3 as libc::c_int as uint8_t,
                flags: 0x2 as libc::c_int as uint8_t,
                sym: 52 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 6 as libc::c_int as uint8_t,
                flags: 0x2 as libc::c_int as uint8_t,
                sym: 52 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 10 as libc::c_int as uint8_t,
                flags: 0x2 as libc::c_int as uint8_t,
                sym: 52 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 15 as libc::c_int as uint8_t,
                flags: 0x2 as libc::c_int as uint8_t,
                sym: 52 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 24 as libc::c_int as uint8_t,
                flags: 0x2 as libc::c_int as uint8_t,
                sym: 52 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 31 as libc::c_int as uint8_t,
                flags: 0x2 as libc::c_int as uint8_t,
                sym: 52 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 41 as libc::c_int as uint8_t,
                flags: 0x2 as libc::c_int as uint8_t,
                sym: 52 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 56 as libc::c_int as uint8_t,
                flags: 0x3 as libc::c_int as uint8_t,
                sym: 52 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 3 as libc::c_int as uint8_t,
                flags: 0x2 as libc::c_int as uint8_t,
                sym: 53 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 6 as libc::c_int as uint8_t,
                flags: 0x2 as libc::c_int as uint8_t,
                sym: 53 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 10 as libc::c_int as uint8_t,
                flags: 0x2 as libc::c_int as uint8_t,
                sym: 53 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 15 as libc::c_int as uint8_t,
                flags: 0x2 as libc::c_int as uint8_t,
                sym: 53 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 24 as libc::c_int as uint8_t,
                flags: 0x2 as libc::c_int as uint8_t,
                sym: 53 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 31 as libc::c_int as uint8_t,
                flags: 0x2 as libc::c_int as uint8_t,
                sym: 53 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 41 as libc::c_int as uint8_t,
                flags: 0x2 as libc::c_int as uint8_t,
                sym: 53 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 56 as libc::c_int as uint8_t,
                flags: 0x3 as libc::c_int as uint8_t,
                sym: 53 as libc::c_int as uint8_t,
            };
            init
        },
    ],
    [
        {
            let mut init = decode_el {
                state: 2 as libc::c_int as uint8_t,
                flags: 0x2 as libc::c_int as uint8_t,
                sym: 54 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 9 as libc::c_int as uint8_t,
                flags: 0x2 as libc::c_int as uint8_t,
                sym: 54 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 23 as libc::c_int as uint8_t,
                flags: 0x2 as libc::c_int as uint8_t,
                sym: 54 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 40 as libc::c_int as uint8_t,
                flags: 0x3 as libc::c_int as uint8_t,
                sym: 54 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 2 as libc::c_int as uint8_t,
                flags: 0x2 as libc::c_int as uint8_t,
                sym: 55 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 9 as libc::c_int as uint8_t,
                flags: 0x2 as libc::c_int as uint8_t,
                sym: 55 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 23 as libc::c_int as uint8_t,
                flags: 0x2 as libc::c_int as uint8_t,
                sym: 55 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 40 as libc::c_int as uint8_t,
                flags: 0x3 as libc::c_int as uint8_t,
                sym: 55 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 2 as libc::c_int as uint8_t,
                flags: 0x2 as libc::c_int as uint8_t,
                sym: 56 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 9 as libc::c_int as uint8_t,
                flags: 0x2 as libc::c_int as uint8_t,
                sym: 56 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 23 as libc::c_int as uint8_t,
                flags: 0x2 as libc::c_int as uint8_t,
                sym: 56 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 40 as libc::c_int as uint8_t,
                flags: 0x3 as libc::c_int as uint8_t,
                sym: 56 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 2 as libc::c_int as uint8_t,
                flags: 0x2 as libc::c_int as uint8_t,
                sym: 57 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 9 as libc::c_int as uint8_t,
                flags: 0x2 as libc::c_int as uint8_t,
                sym: 57 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 23 as libc::c_int as uint8_t,
                flags: 0x2 as libc::c_int as uint8_t,
                sym: 57 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 40 as libc::c_int as uint8_t,
                flags: 0x3 as libc::c_int as uint8_t,
                sym: 57 as libc::c_int as uint8_t,
            };
            init
        },
    ],
    [
        {
            let mut init = decode_el {
                state: 3 as libc::c_int as uint8_t,
                flags: 0x2 as libc::c_int as uint8_t,
                sym: 54 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 6 as libc::c_int as uint8_t,
                flags: 0x2 as libc::c_int as uint8_t,
                sym: 54 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 10 as libc::c_int as uint8_t,
                flags: 0x2 as libc::c_int as uint8_t,
                sym: 54 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 15 as libc::c_int as uint8_t,
                flags: 0x2 as libc::c_int as uint8_t,
                sym: 54 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 24 as libc::c_int as uint8_t,
                flags: 0x2 as libc::c_int as uint8_t,
                sym: 54 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 31 as libc::c_int as uint8_t,
                flags: 0x2 as libc::c_int as uint8_t,
                sym: 54 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 41 as libc::c_int as uint8_t,
                flags: 0x2 as libc::c_int as uint8_t,
                sym: 54 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 56 as libc::c_int as uint8_t,
                flags: 0x3 as libc::c_int as uint8_t,
                sym: 54 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 3 as libc::c_int as uint8_t,
                flags: 0x2 as libc::c_int as uint8_t,
                sym: 55 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 6 as libc::c_int as uint8_t,
                flags: 0x2 as libc::c_int as uint8_t,
                sym: 55 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 10 as libc::c_int as uint8_t,
                flags: 0x2 as libc::c_int as uint8_t,
                sym: 55 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 15 as libc::c_int as uint8_t,
                flags: 0x2 as libc::c_int as uint8_t,
                sym: 55 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 24 as libc::c_int as uint8_t,
                flags: 0x2 as libc::c_int as uint8_t,
                sym: 55 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 31 as libc::c_int as uint8_t,
                flags: 0x2 as libc::c_int as uint8_t,
                sym: 55 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 41 as libc::c_int as uint8_t,
                flags: 0x2 as libc::c_int as uint8_t,
                sym: 55 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 56 as libc::c_int as uint8_t,
                flags: 0x3 as libc::c_int as uint8_t,
                sym: 55 as libc::c_int as uint8_t,
            };
            init
        },
    ],
    [
        {
            let mut init = decode_el {
                state: 3 as libc::c_int as uint8_t,
                flags: 0x2 as libc::c_int as uint8_t,
                sym: 56 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 6 as libc::c_int as uint8_t,
                flags: 0x2 as libc::c_int as uint8_t,
                sym: 56 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 10 as libc::c_int as uint8_t,
                flags: 0x2 as libc::c_int as uint8_t,
                sym: 56 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 15 as libc::c_int as uint8_t,
                flags: 0x2 as libc::c_int as uint8_t,
                sym: 56 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 24 as libc::c_int as uint8_t,
                flags: 0x2 as libc::c_int as uint8_t,
                sym: 56 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 31 as libc::c_int as uint8_t,
                flags: 0x2 as libc::c_int as uint8_t,
                sym: 56 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 41 as libc::c_int as uint8_t,
                flags: 0x2 as libc::c_int as uint8_t,
                sym: 56 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 56 as libc::c_int as uint8_t,
                flags: 0x3 as libc::c_int as uint8_t,
                sym: 56 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 3 as libc::c_int as uint8_t,
                flags: 0x2 as libc::c_int as uint8_t,
                sym: 57 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 6 as libc::c_int as uint8_t,
                flags: 0x2 as libc::c_int as uint8_t,
                sym: 57 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 10 as libc::c_int as uint8_t,
                flags: 0x2 as libc::c_int as uint8_t,
                sym: 57 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 15 as libc::c_int as uint8_t,
                flags: 0x2 as libc::c_int as uint8_t,
                sym: 57 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 24 as libc::c_int as uint8_t,
                flags: 0x2 as libc::c_int as uint8_t,
                sym: 57 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 31 as libc::c_int as uint8_t,
                flags: 0x2 as libc::c_int as uint8_t,
                sym: 57 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 41 as libc::c_int as uint8_t,
                flags: 0x2 as libc::c_int as uint8_t,
                sym: 57 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 56 as libc::c_int as uint8_t,
                flags: 0x3 as libc::c_int as uint8_t,
                sym: 57 as libc::c_int as uint8_t,
            };
            init
        },
    ],
    [
        {
            let mut init = decode_el {
                state: 26 as libc::c_int as uint8_t,
                flags: 0 as libc::c_int as uint8_t,
                sym: 0 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 27 as libc::c_int as uint8_t,
                flags: 0 as libc::c_int as uint8_t,
                sym: 0 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 29 as libc::c_int as uint8_t,
                flags: 0 as libc::c_int as uint8_t,
                sym: 0 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 30 as libc::c_int as uint8_t,
                flags: 0 as libc::c_int as uint8_t,
                sym: 0 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 33 as libc::c_int as uint8_t,
                flags: 0 as libc::c_int as uint8_t,
                sym: 0 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 34 as libc::c_int as uint8_t,
                flags: 0 as libc::c_int as uint8_t,
                sym: 0 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 36 as libc::c_int as uint8_t,
                flags: 0 as libc::c_int as uint8_t,
                sym: 0 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 37 as libc::c_int as uint8_t,
                flags: 0 as libc::c_int as uint8_t,
                sym: 0 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 43 as libc::c_int as uint8_t,
                flags: 0 as libc::c_int as uint8_t,
                sym: 0 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 46 as libc::c_int as uint8_t,
                flags: 0 as libc::c_int as uint8_t,
                sym: 0 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 50 as libc::c_int as uint8_t,
                flags: 0 as libc::c_int as uint8_t,
                sym: 0 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 53 as libc::c_int as uint8_t,
                flags: 0 as libc::c_int as uint8_t,
                sym: 0 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 58 as libc::c_int as uint8_t,
                flags: 0 as libc::c_int as uint8_t,
                sym: 0 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 61 as libc::c_int as uint8_t,
                flags: 0 as libc::c_int as uint8_t,
                sym: 0 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 65 as libc::c_int as uint8_t,
                flags: 0 as libc::c_int as uint8_t,
                sym: 0 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 68 as libc::c_int as uint8_t,
                flags: 0x1 as libc::c_int as uint8_t,
                sym: 0 as libc::c_int as uint8_t,
            };
            init
        },
    ],
    [
        {
            let mut init = decode_el {
                state: 0 as libc::c_int as uint8_t,
                flags: 0x3 as libc::c_int as uint8_t,
                sym: 61 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 0 as libc::c_int as uint8_t,
                flags: 0x3 as libc::c_int as uint8_t,
                sym: 65 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 0 as libc::c_int as uint8_t,
                flags: 0x3 as libc::c_int as uint8_t,
                sym: 95 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 0 as libc::c_int as uint8_t,
                flags: 0x3 as libc::c_int as uint8_t,
                sym: 98 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 0 as libc::c_int as uint8_t,
                flags: 0x3 as libc::c_int as uint8_t,
                sym: 100 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 0 as libc::c_int as uint8_t,
                flags: 0x3 as libc::c_int as uint8_t,
                sym: 102 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 0 as libc::c_int as uint8_t,
                flags: 0x3 as libc::c_int as uint8_t,
                sym: 103 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 0 as libc::c_int as uint8_t,
                flags: 0x3 as libc::c_int as uint8_t,
                sym: 104 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 0 as libc::c_int as uint8_t,
                flags: 0x3 as libc::c_int as uint8_t,
                sym: 108 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 0 as libc::c_int as uint8_t,
                flags: 0x3 as libc::c_int as uint8_t,
                sym: 109 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 0 as libc::c_int as uint8_t,
                flags: 0x3 as libc::c_int as uint8_t,
                sym: 110 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 0 as libc::c_int as uint8_t,
                flags: 0x3 as libc::c_int as uint8_t,
                sym: 112 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 0 as libc::c_int as uint8_t,
                flags: 0x3 as libc::c_int as uint8_t,
                sym: 114 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 0 as libc::c_int as uint8_t,
                flags: 0x3 as libc::c_int as uint8_t,
                sym: 117 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 38 as libc::c_int as uint8_t,
                flags: 0 as libc::c_int as uint8_t,
                sym: 0 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 39 as libc::c_int as uint8_t,
                flags: 0 as libc::c_int as uint8_t,
                sym: 0 as libc::c_int as uint8_t,
            };
            init
        },
    ],
    [
        {
            let mut init = decode_el {
                state: 1 as libc::c_int as uint8_t,
                flags: 0x2 as libc::c_int as uint8_t,
                sym: 61 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 22 as libc::c_int as uint8_t,
                flags: 0x3 as libc::c_int as uint8_t,
                sym: 61 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 1 as libc::c_int as uint8_t,
                flags: 0x2 as libc::c_int as uint8_t,
                sym: 65 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 22 as libc::c_int as uint8_t,
                flags: 0x3 as libc::c_int as uint8_t,
                sym: 65 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 1 as libc::c_int as uint8_t,
                flags: 0x2 as libc::c_int as uint8_t,
                sym: 95 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 22 as libc::c_int as uint8_t,
                flags: 0x3 as libc::c_int as uint8_t,
                sym: 95 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 1 as libc::c_int as uint8_t,
                flags: 0x2 as libc::c_int as uint8_t,
                sym: 98 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 22 as libc::c_int as uint8_t,
                flags: 0x3 as libc::c_int as uint8_t,
                sym: 98 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 1 as libc::c_int as uint8_t,
                flags: 0x2 as libc::c_int as uint8_t,
                sym: 100 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 22 as libc::c_int as uint8_t,
                flags: 0x3 as libc::c_int as uint8_t,
                sym: 100 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 1 as libc::c_int as uint8_t,
                flags: 0x2 as libc::c_int as uint8_t,
                sym: 102 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 22 as libc::c_int as uint8_t,
                flags: 0x3 as libc::c_int as uint8_t,
                sym: 102 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 1 as libc::c_int as uint8_t,
                flags: 0x2 as libc::c_int as uint8_t,
                sym: 103 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 22 as libc::c_int as uint8_t,
                flags: 0x3 as libc::c_int as uint8_t,
                sym: 103 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 1 as libc::c_int as uint8_t,
                flags: 0x2 as libc::c_int as uint8_t,
                sym: 104 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 22 as libc::c_int as uint8_t,
                flags: 0x3 as libc::c_int as uint8_t,
                sym: 104 as libc::c_int as uint8_t,
            };
            init
        },
    ],
    [
        {
            let mut init = decode_el {
                state: 2 as libc::c_int as uint8_t,
                flags: 0x2 as libc::c_int as uint8_t,
                sym: 61 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 9 as libc::c_int as uint8_t,
                flags: 0x2 as libc::c_int as uint8_t,
                sym: 61 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 23 as libc::c_int as uint8_t,
                flags: 0x2 as libc::c_int as uint8_t,
                sym: 61 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 40 as libc::c_int as uint8_t,
                flags: 0x3 as libc::c_int as uint8_t,
                sym: 61 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 2 as libc::c_int as uint8_t,
                flags: 0x2 as libc::c_int as uint8_t,
                sym: 65 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 9 as libc::c_int as uint8_t,
                flags: 0x2 as libc::c_int as uint8_t,
                sym: 65 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 23 as libc::c_int as uint8_t,
                flags: 0x2 as libc::c_int as uint8_t,
                sym: 65 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 40 as libc::c_int as uint8_t,
                flags: 0x3 as libc::c_int as uint8_t,
                sym: 65 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 2 as libc::c_int as uint8_t,
                flags: 0x2 as libc::c_int as uint8_t,
                sym: 95 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 9 as libc::c_int as uint8_t,
                flags: 0x2 as libc::c_int as uint8_t,
                sym: 95 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 23 as libc::c_int as uint8_t,
                flags: 0x2 as libc::c_int as uint8_t,
                sym: 95 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 40 as libc::c_int as uint8_t,
                flags: 0x3 as libc::c_int as uint8_t,
                sym: 95 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 2 as libc::c_int as uint8_t,
                flags: 0x2 as libc::c_int as uint8_t,
                sym: 98 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 9 as libc::c_int as uint8_t,
                flags: 0x2 as libc::c_int as uint8_t,
                sym: 98 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 23 as libc::c_int as uint8_t,
                flags: 0x2 as libc::c_int as uint8_t,
                sym: 98 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 40 as libc::c_int as uint8_t,
                flags: 0x3 as libc::c_int as uint8_t,
                sym: 98 as libc::c_int as uint8_t,
            };
            init
        },
    ],
    [
        {
            let mut init = decode_el {
                state: 3 as libc::c_int as uint8_t,
                flags: 0x2 as libc::c_int as uint8_t,
                sym: 61 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 6 as libc::c_int as uint8_t,
                flags: 0x2 as libc::c_int as uint8_t,
                sym: 61 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 10 as libc::c_int as uint8_t,
                flags: 0x2 as libc::c_int as uint8_t,
                sym: 61 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 15 as libc::c_int as uint8_t,
                flags: 0x2 as libc::c_int as uint8_t,
                sym: 61 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 24 as libc::c_int as uint8_t,
                flags: 0x2 as libc::c_int as uint8_t,
                sym: 61 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 31 as libc::c_int as uint8_t,
                flags: 0x2 as libc::c_int as uint8_t,
                sym: 61 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 41 as libc::c_int as uint8_t,
                flags: 0x2 as libc::c_int as uint8_t,
                sym: 61 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 56 as libc::c_int as uint8_t,
                flags: 0x3 as libc::c_int as uint8_t,
                sym: 61 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 3 as libc::c_int as uint8_t,
                flags: 0x2 as libc::c_int as uint8_t,
                sym: 65 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 6 as libc::c_int as uint8_t,
                flags: 0x2 as libc::c_int as uint8_t,
                sym: 65 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 10 as libc::c_int as uint8_t,
                flags: 0x2 as libc::c_int as uint8_t,
                sym: 65 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 15 as libc::c_int as uint8_t,
                flags: 0x2 as libc::c_int as uint8_t,
                sym: 65 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 24 as libc::c_int as uint8_t,
                flags: 0x2 as libc::c_int as uint8_t,
                sym: 65 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 31 as libc::c_int as uint8_t,
                flags: 0x2 as libc::c_int as uint8_t,
                sym: 65 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 41 as libc::c_int as uint8_t,
                flags: 0x2 as libc::c_int as uint8_t,
                sym: 65 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 56 as libc::c_int as uint8_t,
                flags: 0x3 as libc::c_int as uint8_t,
                sym: 65 as libc::c_int as uint8_t,
            };
            init
        },
    ],
    [
        {
            let mut init = decode_el {
                state: 3 as libc::c_int as uint8_t,
                flags: 0x2 as libc::c_int as uint8_t,
                sym: 95 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 6 as libc::c_int as uint8_t,
                flags: 0x2 as libc::c_int as uint8_t,
                sym: 95 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 10 as libc::c_int as uint8_t,
                flags: 0x2 as libc::c_int as uint8_t,
                sym: 95 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 15 as libc::c_int as uint8_t,
                flags: 0x2 as libc::c_int as uint8_t,
                sym: 95 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 24 as libc::c_int as uint8_t,
                flags: 0x2 as libc::c_int as uint8_t,
                sym: 95 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 31 as libc::c_int as uint8_t,
                flags: 0x2 as libc::c_int as uint8_t,
                sym: 95 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 41 as libc::c_int as uint8_t,
                flags: 0x2 as libc::c_int as uint8_t,
                sym: 95 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 56 as libc::c_int as uint8_t,
                flags: 0x3 as libc::c_int as uint8_t,
                sym: 95 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 3 as libc::c_int as uint8_t,
                flags: 0x2 as libc::c_int as uint8_t,
                sym: 98 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 6 as libc::c_int as uint8_t,
                flags: 0x2 as libc::c_int as uint8_t,
                sym: 98 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 10 as libc::c_int as uint8_t,
                flags: 0x2 as libc::c_int as uint8_t,
                sym: 98 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 15 as libc::c_int as uint8_t,
                flags: 0x2 as libc::c_int as uint8_t,
                sym: 98 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 24 as libc::c_int as uint8_t,
                flags: 0x2 as libc::c_int as uint8_t,
                sym: 98 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 31 as libc::c_int as uint8_t,
                flags: 0x2 as libc::c_int as uint8_t,
                sym: 98 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 41 as libc::c_int as uint8_t,
                flags: 0x2 as libc::c_int as uint8_t,
                sym: 98 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 56 as libc::c_int as uint8_t,
                flags: 0x3 as libc::c_int as uint8_t,
                sym: 98 as libc::c_int as uint8_t,
            };
            init
        },
    ],
    [
        {
            let mut init = decode_el {
                state: 2 as libc::c_int as uint8_t,
                flags: 0x2 as libc::c_int as uint8_t,
                sym: 100 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 9 as libc::c_int as uint8_t,
                flags: 0x2 as libc::c_int as uint8_t,
                sym: 100 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 23 as libc::c_int as uint8_t,
                flags: 0x2 as libc::c_int as uint8_t,
                sym: 100 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 40 as libc::c_int as uint8_t,
                flags: 0x3 as libc::c_int as uint8_t,
                sym: 100 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 2 as libc::c_int as uint8_t,
                flags: 0x2 as libc::c_int as uint8_t,
                sym: 102 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 9 as libc::c_int as uint8_t,
                flags: 0x2 as libc::c_int as uint8_t,
                sym: 102 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 23 as libc::c_int as uint8_t,
                flags: 0x2 as libc::c_int as uint8_t,
                sym: 102 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 40 as libc::c_int as uint8_t,
                flags: 0x3 as libc::c_int as uint8_t,
                sym: 102 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 2 as libc::c_int as uint8_t,
                flags: 0x2 as libc::c_int as uint8_t,
                sym: 103 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 9 as libc::c_int as uint8_t,
                flags: 0x2 as libc::c_int as uint8_t,
                sym: 103 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 23 as libc::c_int as uint8_t,
                flags: 0x2 as libc::c_int as uint8_t,
                sym: 103 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 40 as libc::c_int as uint8_t,
                flags: 0x3 as libc::c_int as uint8_t,
                sym: 103 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 2 as libc::c_int as uint8_t,
                flags: 0x2 as libc::c_int as uint8_t,
                sym: 104 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 9 as libc::c_int as uint8_t,
                flags: 0x2 as libc::c_int as uint8_t,
                sym: 104 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 23 as libc::c_int as uint8_t,
                flags: 0x2 as libc::c_int as uint8_t,
                sym: 104 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 40 as libc::c_int as uint8_t,
                flags: 0x3 as libc::c_int as uint8_t,
                sym: 104 as libc::c_int as uint8_t,
            };
            init
        },
    ],
    [
        {
            let mut init = decode_el {
                state: 3 as libc::c_int as uint8_t,
                flags: 0x2 as libc::c_int as uint8_t,
                sym: 100 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 6 as libc::c_int as uint8_t,
                flags: 0x2 as libc::c_int as uint8_t,
                sym: 100 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 10 as libc::c_int as uint8_t,
                flags: 0x2 as libc::c_int as uint8_t,
                sym: 100 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 15 as libc::c_int as uint8_t,
                flags: 0x2 as libc::c_int as uint8_t,
                sym: 100 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 24 as libc::c_int as uint8_t,
                flags: 0x2 as libc::c_int as uint8_t,
                sym: 100 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 31 as libc::c_int as uint8_t,
                flags: 0x2 as libc::c_int as uint8_t,
                sym: 100 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 41 as libc::c_int as uint8_t,
                flags: 0x2 as libc::c_int as uint8_t,
                sym: 100 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 56 as libc::c_int as uint8_t,
                flags: 0x3 as libc::c_int as uint8_t,
                sym: 100 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 3 as libc::c_int as uint8_t,
                flags: 0x2 as libc::c_int as uint8_t,
                sym: 102 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 6 as libc::c_int as uint8_t,
                flags: 0x2 as libc::c_int as uint8_t,
                sym: 102 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 10 as libc::c_int as uint8_t,
                flags: 0x2 as libc::c_int as uint8_t,
                sym: 102 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 15 as libc::c_int as uint8_t,
                flags: 0x2 as libc::c_int as uint8_t,
                sym: 102 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 24 as libc::c_int as uint8_t,
                flags: 0x2 as libc::c_int as uint8_t,
                sym: 102 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 31 as libc::c_int as uint8_t,
                flags: 0x2 as libc::c_int as uint8_t,
                sym: 102 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 41 as libc::c_int as uint8_t,
                flags: 0x2 as libc::c_int as uint8_t,
                sym: 102 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 56 as libc::c_int as uint8_t,
                flags: 0x3 as libc::c_int as uint8_t,
                sym: 102 as libc::c_int as uint8_t,
            };
            init
        },
    ],
    [
        {
            let mut init = decode_el {
                state: 3 as libc::c_int as uint8_t,
                flags: 0x2 as libc::c_int as uint8_t,
                sym: 103 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 6 as libc::c_int as uint8_t,
                flags: 0x2 as libc::c_int as uint8_t,
                sym: 103 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 10 as libc::c_int as uint8_t,
                flags: 0x2 as libc::c_int as uint8_t,
                sym: 103 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 15 as libc::c_int as uint8_t,
                flags: 0x2 as libc::c_int as uint8_t,
                sym: 103 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 24 as libc::c_int as uint8_t,
                flags: 0x2 as libc::c_int as uint8_t,
                sym: 103 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 31 as libc::c_int as uint8_t,
                flags: 0x2 as libc::c_int as uint8_t,
                sym: 103 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 41 as libc::c_int as uint8_t,
                flags: 0x2 as libc::c_int as uint8_t,
                sym: 103 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 56 as libc::c_int as uint8_t,
                flags: 0x3 as libc::c_int as uint8_t,
                sym: 103 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 3 as libc::c_int as uint8_t,
                flags: 0x2 as libc::c_int as uint8_t,
                sym: 104 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 6 as libc::c_int as uint8_t,
                flags: 0x2 as libc::c_int as uint8_t,
                sym: 104 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 10 as libc::c_int as uint8_t,
                flags: 0x2 as libc::c_int as uint8_t,
                sym: 104 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 15 as libc::c_int as uint8_t,
                flags: 0x2 as libc::c_int as uint8_t,
                sym: 104 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 24 as libc::c_int as uint8_t,
                flags: 0x2 as libc::c_int as uint8_t,
                sym: 104 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 31 as libc::c_int as uint8_t,
                flags: 0x2 as libc::c_int as uint8_t,
                sym: 104 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 41 as libc::c_int as uint8_t,
                flags: 0x2 as libc::c_int as uint8_t,
                sym: 104 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 56 as libc::c_int as uint8_t,
                flags: 0x3 as libc::c_int as uint8_t,
                sym: 104 as libc::c_int as uint8_t,
            };
            init
        },
    ],
    [
        {
            let mut init = decode_el {
                state: 1 as libc::c_int as uint8_t,
                flags: 0x2 as libc::c_int as uint8_t,
                sym: 108 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 22 as libc::c_int as uint8_t,
                flags: 0x3 as libc::c_int as uint8_t,
                sym: 108 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 1 as libc::c_int as uint8_t,
                flags: 0x2 as libc::c_int as uint8_t,
                sym: 109 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 22 as libc::c_int as uint8_t,
                flags: 0x3 as libc::c_int as uint8_t,
                sym: 109 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 1 as libc::c_int as uint8_t,
                flags: 0x2 as libc::c_int as uint8_t,
                sym: 110 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 22 as libc::c_int as uint8_t,
                flags: 0x3 as libc::c_int as uint8_t,
                sym: 110 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 1 as libc::c_int as uint8_t,
                flags: 0x2 as libc::c_int as uint8_t,
                sym: 112 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 22 as libc::c_int as uint8_t,
                flags: 0x3 as libc::c_int as uint8_t,
                sym: 112 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 1 as libc::c_int as uint8_t,
                flags: 0x2 as libc::c_int as uint8_t,
                sym: 114 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 22 as libc::c_int as uint8_t,
                flags: 0x3 as libc::c_int as uint8_t,
                sym: 114 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 1 as libc::c_int as uint8_t,
                flags: 0x2 as libc::c_int as uint8_t,
                sym: 117 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 22 as libc::c_int as uint8_t,
                flags: 0x3 as libc::c_int as uint8_t,
                sym: 117 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 0 as libc::c_int as uint8_t,
                flags: 0x3 as libc::c_int as uint8_t,
                sym: 58 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 0 as libc::c_int as uint8_t,
                flags: 0x3 as libc::c_int as uint8_t,
                sym: 66 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 0 as libc::c_int as uint8_t,
                flags: 0x3 as libc::c_int as uint8_t,
                sym: 67 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 0 as libc::c_int as uint8_t,
                flags: 0x3 as libc::c_int as uint8_t,
                sym: 68 as libc::c_int as uint8_t,
            };
            init
        },
    ],
    [
        {
            let mut init = decode_el {
                state: 2 as libc::c_int as uint8_t,
                flags: 0x2 as libc::c_int as uint8_t,
                sym: 108 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 9 as libc::c_int as uint8_t,
                flags: 0x2 as libc::c_int as uint8_t,
                sym: 108 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 23 as libc::c_int as uint8_t,
                flags: 0x2 as libc::c_int as uint8_t,
                sym: 108 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 40 as libc::c_int as uint8_t,
                flags: 0x3 as libc::c_int as uint8_t,
                sym: 108 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 2 as libc::c_int as uint8_t,
                flags: 0x2 as libc::c_int as uint8_t,
                sym: 109 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 9 as libc::c_int as uint8_t,
                flags: 0x2 as libc::c_int as uint8_t,
                sym: 109 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 23 as libc::c_int as uint8_t,
                flags: 0x2 as libc::c_int as uint8_t,
                sym: 109 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 40 as libc::c_int as uint8_t,
                flags: 0x3 as libc::c_int as uint8_t,
                sym: 109 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 2 as libc::c_int as uint8_t,
                flags: 0x2 as libc::c_int as uint8_t,
                sym: 110 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 9 as libc::c_int as uint8_t,
                flags: 0x2 as libc::c_int as uint8_t,
                sym: 110 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 23 as libc::c_int as uint8_t,
                flags: 0x2 as libc::c_int as uint8_t,
                sym: 110 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 40 as libc::c_int as uint8_t,
                flags: 0x3 as libc::c_int as uint8_t,
                sym: 110 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 2 as libc::c_int as uint8_t,
                flags: 0x2 as libc::c_int as uint8_t,
                sym: 112 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 9 as libc::c_int as uint8_t,
                flags: 0x2 as libc::c_int as uint8_t,
                sym: 112 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 23 as libc::c_int as uint8_t,
                flags: 0x2 as libc::c_int as uint8_t,
                sym: 112 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 40 as libc::c_int as uint8_t,
                flags: 0x3 as libc::c_int as uint8_t,
                sym: 112 as libc::c_int as uint8_t,
            };
            init
        },
    ],
    [
        {
            let mut init = decode_el {
                state: 3 as libc::c_int as uint8_t,
                flags: 0x2 as libc::c_int as uint8_t,
                sym: 108 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 6 as libc::c_int as uint8_t,
                flags: 0x2 as libc::c_int as uint8_t,
                sym: 108 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 10 as libc::c_int as uint8_t,
                flags: 0x2 as libc::c_int as uint8_t,
                sym: 108 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 15 as libc::c_int as uint8_t,
                flags: 0x2 as libc::c_int as uint8_t,
                sym: 108 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 24 as libc::c_int as uint8_t,
                flags: 0x2 as libc::c_int as uint8_t,
                sym: 108 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 31 as libc::c_int as uint8_t,
                flags: 0x2 as libc::c_int as uint8_t,
                sym: 108 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 41 as libc::c_int as uint8_t,
                flags: 0x2 as libc::c_int as uint8_t,
                sym: 108 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 56 as libc::c_int as uint8_t,
                flags: 0x3 as libc::c_int as uint8_t,
                sym: 108 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 3 as libc::c_int as uint8_t,
                flags: 0x2 as libc::c_int as uint8_t,
                sym: 109 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 6 as libc::c_int as uint8_t,
                flags: 0x2 as libc::c_int as uint8_t,
                sym: 109 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 10 as libc::c_int as uint8_t,
                flags: 0x2 as libc::c_int as uint8_t,
                sym: 109 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 15 as libc::c_int as uint8_t,
                flags: 0x2 as libc::c_int as uint8_t,
                sym: 109 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 24 as libc::c_int as uint8_t,
                flags: 0x2 as libc::c_int as uint8_t,
                sym: 109 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 31 as libc::c_int as uint8_t,
                flags: 0x2 as libc::c_int as uint8_t,
                sym: 109 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 41 as libc::c_int as uint8_t,
                flags: 0x2 as libc::c_int as uint8_t,
                sym: 109 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 56 as libc::c_int as uint8_t,
                flags: 0x3 as libc::c_int as uint8_t,
                sym: 109 as libc::c_int as uint8_t,
            };
            init
        },
    ],
    [
        {
            let mut init = decode_el {
                state: 3 as libc::c_int as uint8_t,
                flags: 0x2 as libc::c_int as uint8_t,
                sym: 110 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 6 as libc::c_int as uint8_t,
                flags: 0x2 as libc::c_int as uint8_t,
                sym: 110 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 10 as libc::c_int as uint8_t,
                flags: 0x2 as libc::c_int as uint8_t,
                sym: 110 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 15 as libc::c_int as uint8_t,
                flags: 0x2 as libc::c_int as uint8_t,
                sym: 110 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 24 as libc::c_int as uint8_t,
                flags: 0x2 as libc::c_int as uint8_t,
                sym: 110 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 31 as libc::c_int as uint8_t,
                flags: 0x2 as libc::c_int as uint8_t,
                sym: 110 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 41 as libc::c_int as uint8_t,
                flags: 0x2 as libc::c_int as uint8_t,
                sym: 110 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 56 as libc::c_int as uint8_t,
                flags: 0x3 as libc::c_int as uint8_t,
                sym: 110 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 3 as libc::c_int as uint8_t,
                flags: 0x2 as libc::c_int as uint8_t,
                sym: 112 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 6 as libc::c_int as uint8_t,
                flags: 0x2 as libc::c_int as uint8_t,
                sym: 112 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 10 as libc::c_int as uint8_t,
                flags: 0x2 as libc::c_int as uint8_t,
                sym: 112 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 15 as libc::c_int as uint8_t,
                flags: 0x2 as libc::c_int as uint8_t,
                sym: 112 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 24 as libc::c_int as uint8_t,
                flags: 0x2 as libc::c_int as uint8_t,
                sym: 112 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 31 as libc::c_int as uint8_t,
                flags: 0x2 as libc::c_int as uint8_t,
                sym: 112 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 41 as libc::c_int as uint8_t,
                flags: 0x2 as libc::c_int as uint8_t,
                sym: 112 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 56 as libc::c_int as uint8_t,
                flags: 0x3 as libc::c_int as uint8_t,
                sym: 112 as libc::c_int as uint8_t,
            };
            init
        },
    ],
    [
        {
            let mut init = decode_el {
                state: 2 as libc::c_int as uint8_t,
                flags: 0x2 as libc::c_int as uint8_t,
                sym: 114 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 9 as libc::c_int as uint8_t,
                flags: 0x2 as libc::c_int as uint8_t,
                sym: 114 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 23 as libc::c_int as uint8_t,
                flags: 0x2 as libc::c_int as uint8_t,
                sym: 114 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 40 as libc::c_int as uint8_t,
                flags: 0x3 as libc::c_int as uint8_t,
                sym: 114 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 2 as libc::c_int as uint8_t,
                flags: 0x2 as libc::c_int as uint8_t,
                sym: 117 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 9 as libc::c_int as uint8_t,
                flags: 0x2 as libc::c_int as uint8_t,
                sym: 117 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 23 as libc::c_int as uint8_t,
                flags: 0x2 as libc::c_int as uint8_t,
                sym: 117 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 40 as libc::c_int as uint8_t,
                flags: 0x3 as libc::c_int as uint8_t,
                sym: 117 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 1 as libc::c_int as uint8_t,
                flags: 0x2 as libc::c_int as uint8_t,
                sym: 58 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 22 as libc::c_int as uint8_t,
                flags: 0x3 as libc::c_int as uint8_t,
                sym: 58 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 1 as libc::c_int as uint8_t,
                flags: 0x2 as libc::c_int as uint8_t,
                sym: 66 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 22 as libc::c_int as uint8_t,
                flags: 0x3 as libc::c_int as uint8_t,
                sym: 66 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 1 as libc::c_int as uint8_t,
                flags: 0x2 as libc::c_int as uint8_t,
                sym: 67 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 22 as libc::c_int as uint8_t,
                flags: 0x3 as libc::c_int as uint8_t,
                sym: 67 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 1 as libc::c_int as uint8_t,
                flags: 0x2 as libc::c_int as uint8_t,
                sym: 68 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 22 as libc::c_int as uint8_t,
                flags: 0x3 as libc::c_int as uint8_t,
                sym: 68 as libc::c_int as uint8_t,
            };
            init
        },
    ],
    [
        {
            let mut init = decode_el {
                state: 3 as libc::c_int as uint8_t,
                flags: 0x2 as libc::c_int as uint8_t,
                sym: 114 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 6 as libc::c_int as uint8_t,
                flags: 0x2 as libc::c_int as uint8_t,
                sym: 114 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 10 as libc::c_int as uint8_t,
                flags: 0x2 as libc::c_int as uint8_t,
                sym: 114 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 15 as libc::c_int as uint8_t,
                flags: 0x2 as libc::c_int as uint8_t,
                sym: 114 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 24 as libc::c_int as uint8_t,
                flags: 0x2 as libc::c_int as uint8_t,
                sym: 114 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 31 as libc::c_int as uint8_t,
                flags: 0x2 as libc::c_int as uint8_t,
                sym: 114 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 41 as libc::c_int as uint8_t,
                flags: 0x2 as libc::c_int as uint8_t,
                sym: 114 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 56 as libc::c_int as uint8_t,
                flags: 0x3 as libc::c_int as uint8_t,
                sym: 114 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 3 as libc::c_int as uint8_t,
                flags: 0x2 as libc::c_int as uint8_t,
                sym: 117 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 6 as libc::c_int as uint8_t,
                flags: 0x2 as libc::c_int as uint8_t,
                sym: 117 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 10 as libc::c_int as uint8_t,
                flags: 0x2 as libc::c_int as uint8_t,
                sym: 117 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 15 as libc::c_int as uint8_t,
                flags: 0x2 as libc::c_int as uint8_t,
                sym: 117 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 24 as libc::c_int as uint8_t,
                flags: 0x2 as libc::c_int as uint8_t,
                sym: 117 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 31 as libc::c_int as uint8_t,
                flags: 0x2 as libc::c_int as uint8_t,
                sym: 117 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 41 as libc::c_int as uint8_t,
                flags: 0x2 as libc::c_int as uint8_t,
                sym: 117 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 56 as libc::c_int as uint8_t,
                flags: 0x3 as libc::c_int as uint8_t,
                sym: 117 as libc::c_int as uint8_t,
            };
            init
        },
    ],
    [
        {
            let mut init = decode_el {
                state: 2 as libc::c_int as uint8_t,
                flags: 0x2 as libc::c_int as uint8_t,
                sym: 58 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 9 as libc::c_int as uint8_t,
                flags: 0x2 as libc::c_int as uint8_t,
                sym: 58 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 23 as libc::c_int as uint8_t,
                flags: 0x2 as libc::c_int as uint8_t,
                sym: 58 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 40 as libc::c_int as uint8_t,
                flags: 0x3 as libc::c_int as uint8_t,
                sym: 58 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 2 as libc::c_int as uint8_t,
                flags: 0x2 as libc::c_int as uint8_t,
                sym: 66 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 9 as libc::c_int as uint8_t,
                flags: 0x2 as libc::c_int as uint8_t,
                sym: 66 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 23 as libc::c_int as uint8_t,
                flags: 0x2 as libc::c_int as uint8_t,
                sym: 66 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 40 as libc::c_int as uint8_t,
                flags: 0x3 as libc::c_int as uint8_t,
                sym: 66 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 2 as libc::c_int as uint8_t,
                flags: 0x2 as libc::c_int as uint8_t,
                sym: 67 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 9 as libc::c_int as uint8_t,
                flags: 0x2 as libc::c_int as uint8_t,
                sym: 67 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 23 as libc::c_int as uint8_t,
                flags: 0x2 as libc::c_int as uint8_t,
                sym: 67 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 40 as libc::c_int as uint8_t,
                flags: 0x3 as libc::c_int as uint8_t,
                sym: 67 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 2 as libc::c_int as uint8_t,
                flags: 0x2 as libc::c_int as uint8_t,
                sym: 68 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 9 as libc::c_int as uint8_t,
                flags: 0x2 as libc::c_int as uint8_t,
                sym: 68 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 23 as libc::c_int as uint8_t,
                flags: 0x2 as libc::c_int as uint8_t,
                sym: 68 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 40 as libc::c_int as uint8_t,
                flags: 0x3 as libc::c_int as uint8_t,
                sym: 68 as libc::c_int as uint8_t,
            };
            init
        },
    ],
    [
        {
            let mut init = decode_el {
                state: 3 as libc::c_int as uint8_t,
                flags: 0x2 as libc::c_int as uint8_t,
                sym: 58 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 6 as libc::c_int as uint8_t,
                flags: 0x2 as libc::c_int as uint8_t,
                sym: 58 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 10 as libc::c_int as uint8_t,
                flags: 0x2 as libc::c_int as uint8_t,
                sym: 58 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 15 as libc::c_int as uint8_t,
                flags: 0x2 as libc::c_int as uint8_t,
                sym: 58 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 24 as libc::c_int as uint8_t,
                flags: 0x2 as libc::c_int as uint8_t,
                sym: 58 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 31 as libc::c_int as uint8_t,
                flags: 0x2 as libc::c_int as uint8_t,
                sym: 58 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 41 as libc::c_int as uint8_t,
                flags: 0x2 as libc::c_int as uint8_t,
                sym: 58 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 56 as libc::c_int as uint8_t,
                flags: 0x3 as libc::c_int as uint8_t,
                sym: 58 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 3 as libc::c_int as uint8_t,
                flags: 0x2 as libc::c_int as uint8_t,
                sym: 66 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 6 as libc::c_int as uint8_t,
                flags: 0x2 as libc::c_int as uint8_t,
                sym: 66 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 10 as libc::c_int as uint8_t,
                flags: 0x2 as libc::c_int as uint8_t,
                sym: 66 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 15 as libc::c_int as uint8_t,
                flags: 0x2 as libc::c_int as uint8_t,
                sym: 66 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 24 as libc::c_int as uint8_t,
                flags: 0x2 as libc::c_int as uint8_t,
                sym: 66 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 31 as libc::c_int as uint8_t,
                flags: 0x2 as libc::c_int as uint8_t,
                sym: 66 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 41 as libc::c_int as uint8_t,
                flags: 0x2 as libc::c_int as uint8_t,
                sym: 66 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 56 as libc::c_int as uint8_t,
                flags: 0x3 as libc::c_int as uint8_t,
                sym: 66 as libc::c_int as uint8_t,
            };
            init
        },
    ],
    [
        {
            let mut init = decode_el {
                state: 3 as libc::c_int as uint8_t,
                flags: 0x2 as libc::c_int as uint8_t,
                sym: 67 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 6 as libc::c_int as uint8_t,
                flags: 0x2 as libc::c_int as uint8_t,
                sym: 67 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 10 as libc::c_int as uint8_t,
                flags: 0x2 as libc::c_int as uint8_t,
                sym: 67 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 15 as libc::c_int as uint8_t,
                flags: 0x2 as libc::c_int as uint8_t,
                sym: 67 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 24 as libc::c_int as uint8_t,
                flags: 0x2 as libc::c_int as uint8_t,
                sym: 67 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 31 as libc::c_int as uint8_t,
                flags: 0x2 as libc::c_int as uint8_t,
                sym: 67 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 41 as libc::c_int as uint8_t,
                flags: 0x2 as libc::c_int as uint8_t,
                sym: 67 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 56 as libc::c_int as uint8_t,
                flags: 0x3 as libc::c_int as uint8_t,
                sym: 67 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 3 as libc::c_int as uint8_t,
                flags: 0x2 as libc::c_int as uint8_t,
                sym: 68 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 6 as libc::c_int as uint8_t,
                flags: 0x2 as libc::c_int as uint8_t,
                sym: 68 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 10 as libc::c_int as uint8_t,
                flags: 0x2 as libc::c_int as uint8_t,
                sym: 68 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 15 as libc::c_int as uint8_t,
                flags: 0x2 as libc::c_int as uint8_t,
                sym: 68 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 24 as libc::c_int as uint8_t,
                flags: 0x2 as libc::c_int as uint8_t,
                sym: 68 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 31 as libc::c_int as uint8_t,
                flags: 0x2 as libc::c_int as uint8_t,
                sym: 68 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 41 as libc::c_int as uint8_t,
                flags: 0x2 as libc::c_int as uint8_t,
                sym: 68 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 56 as libc::c_int as uint8_t,
                flags: 0x3 as libc::c_int as uint8_t,
                sym: 68 as libc::c_int as uint8_t,
            };
            init
        },
    ],
    [
        {
            let mut init = decode_el {
                state: 44 as libc::c_int as uint8_t,
                flags: 0 as libc::c_int as uint8_t,
                sym: 0 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 45 as libc::c_int as uint8_t,
                flags: 0 as libc::c_int as uint8_t,
                sym: 0 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 47 as libc::c_int as uint8_t,
                flags: 0 as libc::c_int as uint8_t,
                sym: 0 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 48 as libc::c_int as uint8_t,
                flags: 0 as libc::c_int as uint8_t,
                sym: 0 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 51 as libc::c_int as uint8_t,
                flags: 0 as libc::c_int as uint8_t,
                sym: 0 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 52 as libc::c_int as uint8_t,
                flags: 0 as libc::c_int as uint8_t,
                sym: 0 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 54 as libc::c_int as uint8_t,
                flags: 0 as libc::c_int as uint8_t,
                sym: 0 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 55 as libc::c_int as uint8_t,
                flags: 0 as libc::c_int as uint8_t,
                sym: 0 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 59 as libc::c_int as uint8_t,
                flags: 0 as libc::c_int as uint8_t,
                sym: 0 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 60 as libc::c_int as uint8_t,
                flags: 0 as libc::c_int as uint8_t,
                sym: 0 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 62 as libc::c_int as uint8_t,
                flags: 0 as libc::c_int as uint8_t,
                sym: 0 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 63 as libc::c_int as uint8_t,
                flags: 0 as libc::c_int as uint8_t,
                sym: 0 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 66 as libc::c_int as uint8_t,
                flags: 0 as libc::c_int as uint8_t,
                sym: 0 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 67 as libc::c_int as uint8_t,
                flags: 0 as libc::c_int as uint8_t,
                sym: 0 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 69 as libc::c_int as uint8_t,
                flags: 0 as libc::c_int as uint8_t,
                sym: 0 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 72 as libc::c_int as uint8_t,
                flags: 0x1 as libc::c_int as uint8_t,
                sym: 0 as libc::c_int as uint8_t,
            };
            init
        },
    ],
    [
        {
            let mut init = decode_el {
                state: 0 as libc::c_int as uint8_t,
                flags: 0x3 as libc::c_int as uint8_t,
                sym: 69 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 0 as libc::c_int as uint8_t,
                flags: 0x3 as libc::c_int as uint8_t,
                sym: 70 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 0 as libc::c_int as uint8_t,
                flags: 0x3 as libc::c_int as uint8_t,
                sym: 71 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 0 as libc::c_int as uint8_t,
                flags: 0x3 as libc::c_int as uint8_t,
                sym: 72 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 0 as libc::c_int as uint8_t,
                flags: 0x3 as libc::c_int as uint8_t,
                sym: 73 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 0 as libc::c_int as uint8_t,
                flags: 0x3 as libc::c_int as uint8_t,
                sym: 74 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 0 as libc::c_int as uint8_t,
                flags: 0x3 as libc::c_int as uint8_t,
                sym: 75 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 0 as libc::c_int as uint8_t,
                flags: 0x3 as libc::c_int as uint8_t,
                sym: 76 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 0 as libc::c_int as uint8_t,
                flags: 0x3 as libc::c_int as uint8_t,
                sym: 77 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 0 as libc::c_int as uint8_t,
                flags: 0x3 as libc::c_int as uint8_t,
                sym: 78 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 0 as libc::c_int as uint8_t,
                flags: 0x3 as libc::c_int as uint8_t,
                sym: 79 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 0 as libc::c_int as uint8_t,
                flags: 0x3 as libc::c_int as uint8_t,
                sym: 80 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 0 as libc::c_int as uint8_t,
                flags: 0x3 as libc::c_int as uint8_t,
                sym: 81 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 0 as libc::c_int as uint8_t,
                flags: 0x3 as libc::c_int as uint8_t,
                sym: 82 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 0 as libc::c_int as uint8_t,
                flags: 0x3 as libc::c_int as uint8_t,
                sym: 83 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 0 as libc::c_int as uint8_t,
                flags: 0x3 as libc::c_int as uint8_t,
                sym: 84 as libc::c_int as uint8_t,
            };
            init
        },
    ],
    [
        {
            let mut init = decode_el {
                state: 1 as libc::c_int as uint8_t,
                flags: 0x2 as libc::c_int as uint8_t,
                sym: 69 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 22 as libc::c_int as uint8_t,
                flags: 0x3 as libc::c_int as uint8_t,
                sym: 69 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 1 as libc::c_int as uint8_t,
                flags: 0x2 as libc::c_int as uint8_t,
                sym: 70 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 22 as libc::c_int as uint8_t,
                flags: 0x3 as libc::c_int as uint8_t,
                sym: 70 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 1 as libc::c_int as uint8_t,
                flags: 0x2 as libc::c_int as uint8_t,
                sym: 71 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 22 as libc::c_int as uint8_t,
                flags: 0x3 as libc::c_int as uint8_t,
                sym: 71 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 1 as libc::c_int as uint8_t,
                flags: 0x2 as libc::c_int as uint8_t,
                sym: 72 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 22 as libc::c_int as uint8_t,
                flags: 0x3 as libc::c_int as uint8_t,
                sym: 72 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 1 as libc::c_int as uint8_t,
                flags: 0x2 as libc::c_int as uint8_t,
                sym: 73 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 22 as libc::c_int as uint8_t,
                flags: 0x3 as libc::c_int as uint8_t,
                sym: 73 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 1 as libc::c_int as uint8_t,
                flags: 0x2 as libc::c_int as uint8_t,
                sym: 74 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 22 as libc::c_int as uint8_t,
                flags: 0x3 as libc::c_int as uint8_t,
                sym: 74 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 1 as libc::c_int as uint8_t,
                flags: 0x2 as libc::c_int as uint8_t,
                sym: 75 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 22 as libc::c_int as uint8_t,
                flags: 0x3 as libc::c_int as uint8_t,
                sym: 75 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 1 as libc::c_int as uint8_t,
                flags: 0x2 as libc::c_int as uint8_t,
                sym: 76 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 22 as libc::c_int as uint8_t,
                flags: 0x3 as libc::c_int as uint8_t,
                sym: 76 as libc::c_int as uint8_t,
            };
            init
        },
    ],
    [
        {
            let mut init = decode_el {
                state: 2 as libc::c_int as uint8_t,
                flags: 0x2 as libc::c_int as uint8_t,
                sym: 69 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 9 as libc::c_int as uint8_t,
                flags: 0x2 as libc::c_int as uint8_t,
                sym: 69 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 23 as libc::c_int as uint8_t,
                flags: 0x2 as libc::c_int as uint8_t,
                sym: 69 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 40 as libc::c_int as uint8_t,
                flags: 0x3 as libc::c_int as uint8_t,
                sym: 69 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 2 as libc::c_int as uint8_t,
                flags: 0x2 as libc::c_int as uint8_t,
                sym: 70 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 9 as libc::c_int as uint8_t,
                flags: 0x2 as libc::c_int as uint8_t,
                sym: 70 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 23 as libc::c_int as uint8_t,
                flags: 0x2 as libc::c_int as uint8_t,
                sym: 70 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 40 as libc::c_int as uint8_t,
                flags: 0x3 as libc::c_int as uint8_t,
                sym: 70 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 2 as libc::c_int as uint8_t,
                flags: 0x2 as libc::c_int as uint8_t,
                sym: 71 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 9 as libc::c_int as uint8_t,
                flags: 0x2 as libc::c_int as uint8_t,
                sym: 71 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 23 as libc::c_int as uint8_t,
                flags: 0x2 as libc::c_int as uint8_t,
                sym: 71 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 40 as libc::c_int as uint8_t,
                flags: 0x3 as libc::c_int as uint8_t,
                sym: 71 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 2 as libc::c_int as uint8_t,
                flags: 0x2 as libc::c_int as uint8_t,
                sym: 72 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 9 as libc::c_int as uint8_t,
                flags: 0x2 as libc::c_int as uint8_t,
                sym: 72 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 23 as libc::c_int as uint8_t,
                flags: 0x2 as libc::c_int as uint8_t,
                sym: 72 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 40 as libc::c_int as uint8_t,
                flags: 0x3 as libc::c_int as uint8_t,
                sym: 72 as libc::c_int as uint8_t,
            };
            init
        },
    ],
    [
        {
            let mut init = decode_el {
                state: 3 as libc::c_int as uint8_t,
                flags: 0x2 as libc::c_int as uint8_t,
                sym: 69 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 6 as libc::c_int as uint8_t,
                flags: 0x2 as libc::c_int as uint8_t,
                sym: 69 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 10 as libc::c_int as uint8_t,
                flags: 0x2 as libc::c_int as uint8_t,
                sym: 69 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 15 as libc::c_int as uint8_t,
                flags: 0x2 as libc::c_int as uint8_t,
                sym: 69 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 24 as libc::c_int as uint8_t,
                flags: 0x2 as libc::c_int as uint8_t,
                sym: 69 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 31 as libc::c_int as uint8_t,
                flags: 0x2 as libc::c_int as uint8_t,
                sym: 69 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 41 as libc::c_int as uint8_t,
                flags: 0x2 as libc::c_int as uint8_t,
                sym: 69 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 56 as libc::c_int as uint8_t,
                flags: 0x3 as libc::c_int as uint8_t,
                sym: 69 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 3 as libc::c_int as uint8_t,
                flags: 0x2 as libc::c_int as uint8_t,
                sym: 70 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 6 as libc::c_int as uint8_t,
                flags: 0x2 as libc::c_int as uint8_t,
                sym: 70 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 10 as libc::c_int as uint8_t,
                flags: 0x2 as libc::c_int as uint8_t,
                sym: 70 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 15 as libc::c_int as uint8_t,
                flags: 0x2 as libc::c_int as uint8_t,
                sym: 70 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 24 as libc::c_int as uint8_t,
                flags: 0x2 as libc::c_int as uint8_t,
                sym: 70 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 31 as libc::c_int as uint8_t,
                flags: 0x2 as libc::c_int as uint8_t,
                sym: 70 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 41 as libc::c_int as uint8_t,
                flags: 0x2 as libc::c_int as uint8_t,
                sym: 70 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 56 as libc::c_int as uint8_t,
                flags: 0x3 as libc::c_int as uint8_t,
                sym: 70 as libc::c_int as uint8_t,
            };
            init
        },
    ],
    [
        {
            let mut init = decode_el {
                state: 3 as libc::c_int as uint8_t,
                flags: 0x2 as libc::c_int as uint8_t,
                sym: 71 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 6 as libc::c_int as uint8_t,
                flags: 0x2 as libc::c_int as uint8_t,
                sym: 71 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 10 as libc::c_int as uint8_t,
                flags: 0x2 as libc::c_int as uint8_t,
                sym: 71 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 15 as libc::c_int as uint8_t,
                flags: 0x2 as libc::c_int as uint8_t,
                sym: 71 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 24 as libc::c_int as uint8_t,
                flags: 0x2 as libc::c_int as uint8_t,
                sym: 71 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 31 as libc::c_int as uint8_t,
                flags: 0x2 as libc::c_int as uint8_t,
                sym: 71 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 41 as libc::c_int as uint8_t,
                flags: 0x2 as libc::c_int as uint8_t,
                sym: 71 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 56 as libc::c_int as uint8_t,
                flags: 0x3 as libc::c_int as uint8_t,
                sym: 71 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 3 as libc::c_int as uint8_t,
                flags: 0x2 as libc::c_int as uint8_t,
                sym: 72 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 6 as libc::c_int as uint8_t,
                flags: 0x2 as libc::c_int as uint8_t,
                sym: 72 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 10 as libc::c_int as uint8_t,
                flags: 0x2 as libc::c_int as uint8_t,
                sym: 72 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 15 as libc::c_int as uint8_t,
                flags: 0x2 as libc::c_int as uint8_t,
                sym: 72 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 24 as libc::c_int as uint8_t,
                flags: 0x2 as libc::c_int as uint8_t,
                sym: 72 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 31 as libc::c_int as uint8_t,
                flags: 0x2 as libc::c_int as uint8_t,
                sym: 72 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 41 as libc::c_int as uint8_t,
                flags: 0x2 as libc::c_int as uint8_t,
                sym: 72 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 56 as libc::c_int as uint8_t,
                flags: 0x3 as libc::c_int as uint8_t,
                sym: 72 as libc::c_int as uint8_t,
            };
            init
        },
    ],
    [
        {
            let mut init = decode_el {
                state: 2 as libc::c_int as uint8_t,
                flags: 0x2 as libc::c_int as uint8_t,
                sym: 73 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 9 as libc::c_int as uint8_t,
                flags: 0x2 as libc::c_int as uint8_t,
                sym: 73 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 23 as libc::c_int as uint8_t,
                flags: 0x2 as libc::c_int as uint8_t,
                sym: 73 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 40 as libc::c_int as uint8_t,
                flags: 0x3 as libc::c_int as uint8_t,
                sym: 73 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 2 as libc::c_int as uint8_t,
                flags: 0x2 as libc::c_int as uint8_t,
                sym: 74 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 9 as libc::c_int as uint8_t,
                flags: 0x2 as libc::c_int as uint8_t,
                sym: 74 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 23 as libc::c_int as uint8_t,
                flags: 0x2 as libc::c_int as uint8_t,
                sym: 74 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 40 as libc::c_int as uint8_t,
                flags: 0x3 as libc::c_int as uint8_t,
                sym: 74 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 2 as libc::c_int as uint8_t,
                flags: 0x2 as libc::c_int as uint8_t,
                sym: 75 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 9 as libc::c_int as uint8_t,
                flags: 0x2 as libc::c_int as uint8_t,
                sym: 75 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 23 as libc::c_int as uint8_t,
                flags: 0x2 as libc::c_int as uint8_t,
                sym: 75 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 40 as libc::c_int as uint8_t,
                flags: 0x3 as libc::c_int as uint8_t,
                sym: 75 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 2 as libc::c_int as uint8_t,
                flags: 0x2 as libc::c_int as uint8_t,
                sym: 76 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 9 as libc::c_int as uint8_t,
                flags: 0x2 as libc::c_int as uint8_t,
                sym: 76 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 23 as libc::c_int as uint8_t,
                flags: 0x2 as libc::c_int as uint8_t,
                sym: 76 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 40 as libc::c_int as uint8_t,
                flags: 0x3 as libc::c_int as uint8_t,
                sym: 76 as libc::c_int as uint8_t,
            };
            init
        },
    ],
    [
        {
            let mut init = decode_el {
                state: 3 as libc::c_int as uint8_t,
                flags: 0x2 as libc::c_int as uint8_t,
                sym: 73 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 6 as libc::c_int as uint8_t,
                flags: 0x2 as libc::c_int as uint8_t,
                sym: 73 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 10 as libc::c_int as uint8_t,
                flags: 0x2 as libc::c_int as uint8_t,
                sym: 73 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 15 as libc::c_int as uint8_t,
                flags: 0x2 as libc::c_int as uint8_t,
                sym: 73 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 24 as libc::c_int as uint8_t,
                flags: 0x2 as libc::c_int as uint8_t,
                sym: 73 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 31 as libc::c_int as uint8_t,
                flags: 0x2 as libc::c_int as uint8_t,
                sym: 73 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 41 as libc::c_int as uint8_t,
                flags: 0x2 as libc::c_int as uint8_t,
                sym: 73 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 56 as libc::c_int as uint8_t,
                flags: 0x3 as libc::c_int as uint8_t,
                sym: 73 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 3 as libc::c_int as uint8_t,
                flags: 0x2 as libc::c_int as uint8_t,
                sym: 74 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 6 as libc::c_int as uint8_t,
                flags: 0x2 as libc::c_int as uint8_t,
                sym: 74 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 10 as libc::c_int as uint8_t,
                flags: 0x2 as libc::c_int as uint8_t,
                sym: 74 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 15 as libc::c_int as uint8_t,
                flags: 0x2 as libc::c_int as uint8_t,
                sym: 74 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 24 as libc::c_int as uint8_t,
                flags: 0x2 as libc::c_int as uint8_t,
                sym: 74 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 31 as libc::c_int as uint8_t,
                flags: 0x2 as libc::c_int as uint8_t,
                sym: 74 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 41 as libc::c_int as uint8_t,
                flags: 0x2 as libc::c_int as uint8_t,
                sym: 74 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 56 as libc::c_int as uint8_t,
                flags: 0x3 as libc::c_int as uint8_t,
                sym: 74 as libc::c_int as uint8_t,
            };
            init
        },
    ],
    [
        {
            let mut init = decode_el {
                state: 3 as libc::c_int as uint8_t,
                flags: 0x2 as libc::c_int as uint8_t,
                sym: 75 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 6 as libc::c_int as uint8_t,
                flags: 0x2 as libc::c_int as uint8_t,
                sym: 75 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 10 as libc::c_int as uint8_t,
                flags: 0x2 as libc::c_int as uint8_t,
                sym: 75 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 15 as libc::c_int as uint8_t,
                flags: 0x2 as libc::c_int as uint8_t,
                sym: 75 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 24 as libc::c_int as uint8_t,
                flags: 0x2 as libc::c_int as uint8_t,
                sym: 75 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 31 as libc::c_int as uint8_t,
                flags: 0x2 as libc::c_int as uint8_t,
                sym: 75 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 41 as libc::c_int as uint8_t,
                flags: 0x2 as libc::c_int as uint8_t,
                sym: 75 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 56 as libc::c_int as uint8_t,
                flags: 0x3 as libc::c_int as uint8_t,
                sym: 75 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 3 as libc::c_int as uint8_t,
                flags: 0x2 as libc::c_int as uint8_t,
                sym: 76 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 6 as libc::c_int as uint8_t,
                flags: 0x2 as libc::c_int as uint8_t,
                sym: 76 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 10 as libc::c_int as uint8_t,
                flags: 0x2 as libc::c_int as uint8_t,
                sym: 76 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 15 as libc::c_int as uint8_t,
                flags: 0x2 as libc::c_int as uint8_t,
                sym: 76 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 24 as libc::c_int as uint8_t,
                flags: 0x2 as libc::c_int as uint8_t,
                sym: 76 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 31 as libc::c_int as uint8_t,
                flags: 0x2 as libc::c_int as uint8_t,
                sym: 76 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 41 as libc::c_int as uint8_t,
                flags: 0x2 as libc::c_int as uint8_t,
                sym: 76 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 56 as libc::c_int as uint8_t,
                flags: 0x3 as libc::c_int as uint8_t,
                sym: 76 as libc::c_int as uint8_t,
            };
            init
        },
    ],
    [
        {
            let mut init = decode_el {
                state: 1 as libc::c_int as uint8_t,
                flags: 0x2 as libc::c_int as uint8_t,
                sym: 77 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 22 as libc::c_int as uint8_t,
                flags: 0x3 as libc::c_int as uint8_t,
                sym: 77 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 1 as libc::c_int as uint8_t,
                flags: 0x2 as libc::c_int as uint8_t,
                sym: 78 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 22 as libc::c_int as uint8_t,
                flags: 0x3 as libc::c_int as uint8_t,
                sym: 78 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 1 as libc::c_int as uint8_t,
                flags: 0x2 as libc::c_int as uint8_t,
                sym: 79 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 22 as libc::c_int as uint8_t,
                flags: 0x3 as libc::c_int as uint8_t,
                sym: 79 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 1 as libc::c_int as uint8_t,
                flags: 0x2 as libc::c_int as uint8_t,
                sym: 80 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 22 as libc::c_int as uint8_t,
                flags: 0x3 as libc::c_int as uint8_t,
                sym: 80 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 1 as libc::c_int as uint8_t,
                flags: 0x2 as libc::c_int as uint8_t,
                sym: 81 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 22 as libc::c_int as uint8_t,
                flags: 0x3 as libc::c_int as uint8_t,
                sym: 81 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 1 as libc::c_int as uint8_t,
                flags: 0x2 as libc::c_int as uint8_t,
                sym: 82 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 22 as libc::c_int as uint8_t,
                flags: 0x3 as libc::c_int as uint8_t,
                sym: 82 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 1 as libc::c_int as uint8_t,
                flags: 0x2 as libc::c_int as uint8_t,
                sym: 83 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 22 as libc::c_int as uint8_t,
                flags: 0x3 as libc::c_int as uint8_t,
                sym: 83 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 1 as libc::c_int as uint8_t,
                flags: 0x2 as libc::c_int as uint8_t,
                sym: 84 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 22 as libc::c_int as uint8_t,
                flags: 0x3 as libc::c_int as uint8_t,
                sym: 84 as libc::c_int as uint8_t,
            };
            init
        },
    ],
    [
        {
            let mut init = decode_el {
                state: 2 as libc::c_int as uint8_t,
                flags: 0x2 as libc::c_int as uint8_t,
                sym: 77 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 9 as libc::c_int as uint8_t,
                flags: 0x2 as libc::c_int as uint8_t,
                sym: 77 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 23 as libc::c_int as uint8_t,
                flags: 0x2 as libc::c_int as uint8_t,
                sym: 77 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 40 as libc::c_int as uint8_t,
                flags: 0x3 as libc::c_int as uint8_t,
                sym: 77 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 2 as libc::c_int as uint8_t,
                flags: 0x2 as libc::c_int as uint8_t,
                sym: 78 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 9 as libc::c_int as uint8_t,
                flags: 0x2 as libc::c_int as uint8_t,
                sym: 78 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 23 as libc::c_int as uint8_t,
                flags: 0x2 as libc::c_int as uint8_t,
                sym: 78 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 40 as libc::c_int as uint8_t,
                flags: 0x3 as libc::c_int as uint8_t,
                sym: 78 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 2 as libc::c_int as uint8_t,
                flags: 0x2 as libc::c_int as uint8_t,
                sym: 79 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 9 as libc::c_int as uint8_t,
                flags: 0x2 as libc::c_int as uint8_t,
                sym: 79 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 23 as libc::c_int as uint8_t,
                flags: 0x2 as libc::c_int as uint8_t,
                sym: 79 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 40 as libc::c_int as uint8_t,
                flags: 0x3 as libc::c_int as uint8_t,
                sym: 79 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 2 as libc::c_int as uint8_t,
                flags: 0x2 as libc::c_int as uint8_t,
                sym: 80 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 9 as libc::c_int as uint8_t,
                flags: 0x2 as libc::c_int as uint8_t,
                sym: 80 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 23 as libc::c_int as uint8_t,
                flags: 0x2 as libc::c_int as uint8_t,
                sym: 80 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 40 as libc::c_int as uint8_t,
                flags: 0x3 as libc::c_int as uint8_t,
                sym: 80 as libc::c_int as uint8_t,
            };
            init
        },
    ],
    [
        {
            let mut init = decode_el {
                state: 3 as libc::c_int as uint8_t,
                flags: 0x2 as libc::c_int as uint8_t,
                sym: 77 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 6 as libc::c_int as uint8_t,
                flags: 0x2 as libc::c_int as uint8_t,
                sym: 77 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 10 as libc::c_int as uint8_t,
                flags: 0x2 as libc::c_int as uint8_t,
                sym: 77 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 15 as libc::c_int as uint8_t,
                flags: 0x2 as libc::c_int as uint8_t,
                sym: 77 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 24 as libc::c_int as uint8_t,
                flags: 0x2 as libc::c_int as uint8_t,
                sym: 77 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 31 as libc::c_int as uint8_t,
                flags: 0x2 as libc::c_int as uint8_t,
                sym: 77 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 41 as libc::c_int as uint8_t,
                flags: 0x2 as libc::c_int as uint8_t,
                sym: 77 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 56 as libc::c_int as uint8_t,
                flags: 0x3 as libc::c_int as uint8_t,
                sym: 77 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 3 as libc::c_int as uint8_t,
                flags: 0x2 as libc::c_int as uint8_t,
                sym: 78 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 6 as libc::c_int as uint8_t,
                flags: 0x2 as libc::c_int as uint8_t,
                sym: 78 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 10 as libc::c_int as uint8_t,
                flags: 0x2 as libc::c_int as uint8_t,
                sym: 78 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 15 as libc::c_int as uint8_t,
                flags: 0x2 as libc::c_int as uint8_t,
                sym: 78 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 24 as libc::c_int as uint8_t,
                flags: 0x2 as libc::c_int as uint8_t,
                sym: 78 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 31 as libc::c_int as uint8_t,
                flags: 0x2 as libc::c_int as uint8_t,
                sym: 78 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 41 as libc::c_int as uint8_t,
                flags: 0x2 as libc::c_int as uint8_t,
                sym: 78 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 56 as libc::c_int as uint8_t,
                flags: 0x3 as libc::c_int as uint8_t,
                sym: 78 as libc::c_int as uint8_t,
            };
            init
        },
    ],
    [
        {
            let mut init = decode_el {
                state: 3 as libc::c_int as uint8_t,
                flags: 0x2 as libc::c_int as uint8_t,
                sym: 79 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 6 as libc::c_int as uint8_t,
                flags: 0x2 as libc::c_int as uint8_t,
                sym: 79 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 10 as libc::c_int as uint8_t,
                flags: 0x2 as libc::c_int as uint8_t,
                sym: 79 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 15 as libc::c_int as uint8_t,
                flags: 0x2 as libc::c_int as uint8_t,
                sym: 79 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 24 as libc::c_int as uint8_t,
                flags: 0x2 as libc::c_int as uint8_t,
                sym: 79 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 31 as libc::c_int as uint8_t,
                flags: 0x2 as libc::c_int as uint8_t,
                sym: 79 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 41 as libc::c_int as uint8_t,
                flags: 0x2 as libc::c_int as uint8_t,
                sym: 79 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 56 as libc::c_int as uint8_t,
                flags: 0x3 as libc::c_int as uint8_t,
                sym: 79 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 3 as libc::c_int as uint8_t,
                flags: 0x2 as libc::c_int as uint8_t,
                sym: 80 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 6 as libc::c_int as uint8_t,
                flags: 0x2 as libc::c_int as uint8_t,
                sym: 80 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 10 as libc::c_int as uint8_t,
                flags: 0x2 as libc::c_int as uint8_t,
                sym: 80 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 15 as libc::c_int as uint8_t,
                flags: 0x2 as libc::c_int as uint8_t,
                sym: 80 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 24 as libc::c_int as uint8_t,
                flags: 0x2 as libc::c_int as uint8_t,
                sym: 80 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 31 as libc::c_int as uint8_t,
                flags: 0x2 as libc::c_int as uint8_t,
                sym: 80 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 41 as libc::c_int as uint8_t,
                flags: 0x2 as libc::c_int as uint8_t,
                sym: 80 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 56 as libc::c_int as uint8_t,
                flags: 0x3 as libc::c_int as uint8_t,
                sym: 80 as libc::c_int as uint8_t,
            };
            init
        },
    ],
    [
        {
            let mut init = decode_el {
                state: 2 as libc::c_int as uint8_t,
                flags: 0x2 as libc::c_int as uint8_t,
                sym: 81 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 9 as libc::c_int as uint8_t,
                flags: 0x2 as libc::c_int as uint8_t,
                sym: 81 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 23 as libc::c_int as uint8_t,
                flags: 0x2 as libc::c_int as uint8_t,
                sym: 81 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 40 as libc::c_int as uint8_t,
                flags: 0x3 as libc::c_int as uint8_t,
                sym: 81 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 2 as libc::c_int as uint8_t,
                flags: 0x2 as libc::c_int as uint8_t,
                sym: 82 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 9 as libc::c_int as uint8_t,
                flags: 0x2 as libc::c_int as uint8_t,
                sym: 82 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 23 as libc::c_int as uint8_t,
                flags: 0x2 as libc::c_int as uint8_t,
                sym: 82 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 40 as libc::c_int as uint8_t,
                flags: 0x3 as libc::c_int as uint8_t,
                sym: 82 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 2 as libc::c_int as uint8_t,
                flags: 0x2 as libc::c_int as uint8_t,
                sym: 83 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 9 as libc::c_int as uint8_t,
                flags: 0x2 as libc::c_int as uint8_t,
                sym: 83 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 23 as libc::c_int as uint8_t,
                flags: 0x2 as libc::c_int as uint8_t,
                sym: 83 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 40 as libc::c_int as uint8_t,
                flags: 0x3 as libc::c_int as uint8_t,
                sym: 83 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 2 as libc::c_int as uint8_t,
                flags: 0x2 as libc::c_int as uint8_t,
                sym: 84 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 9 as libc::c_int as uint8_t,
                flags: 0x2 as libc::c_int as uint8_t,
                sym: 84 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 23 as libc::c_int as uint8_t,
                flags: 0x2 as libc::c_int as uint8_t,
                sym: 84 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 40 as libc::c_int as uint8_t,
                flags: 0x3 as libc::c_int as uint8_t,
                sym: 84 as libc::c_int as uint8_t,
            };
            init
        },
    ],
    [
        {
            let mut init = decode_el {
                state: 3 as libc::c_int as uint8_t,
                flags: 0x2 as libc::c_int as uint8_t,
                sym: 81 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 6 as libc::c_int as uint8_t,
                flags: 0x2 as libc::c_int as uint8_t,
                sym: 81 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 10 as libc::c_int as uint8_t,
                flags: 0x2 as libc::c_int as uint8_t,
                sym: 81 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 15 as libc::c_int as uint8_t,
                flags: 0x2 as libc::c_int as uint8_t,
                sym: 81 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 24 as libc::c_int as uint8_t,
                flags: 0x2 as libc::c_int as uint8_t,
                sym: 81 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 31 as libc::c_int as uint8_t,
                flags: 0x2 as libc::c_int as uint8_t,
                sym: 81 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 41 as libc::c_int as uint8_t,
                flags: 0x2 as libc::c_int as uint8_t,
                sym: 81 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 56 as libc::c_int as uint8_t,
                flags: 0x3 as libc::c_int as uint8_t,
                sym: 81 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 3 as libc::c_int as uint8_t,
                flags: 0x2 as libc::c_int as uint8_t,
                sym: 82 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 6 as libc::c_int as uint8_t,
                flags: 0x2 as libc::c_int as uint8_t,
                sym: 82 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 10 as libc::c_int as uint8_t,
                flags: 0x2 as libc::c_int as uint8_t,
                sym: 82 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 15 as libc::c_int as uint8_t,
                flags: 0x2 as libc::c_int as uint8_t,
                sym: 82 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 24 as libc::c_int as uint8_t,
                flags: 0x2 as libc::c_int as uint8_t,
                sym: 82 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 31 as libc::c_int as uint8_t,
                flags: 0x2 as libc::c_int as uint8_t,
                sym: 82 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 41 as libc::c_int as uint8_t,
                flags: 0x2 as libc::c_int as uint8_t,
                sym: 82 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 56 as libc::c_int as uint8_t,
                flags: 0x3 as libc::c_int as uint8_t,
                sym: 82 as libc::c_int as uint8_t,
            };
            init
        },
    ],
    [
        {
            let mut init = decode_el {
                state: 3 as libc::c_int as uint8_t,
                flags: 0x2 as libc::c_int as uint8_t,
                sym: 83 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 6 as libc::c_int as uint8_t,
                flags: 0x2 as libc::c_int as uint8_t,
                sym: 83 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 10 as libc::c_int as uint8_t,
                flags: 0x2 as libc::c_int as uint8_t,
                sym: 83 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 15 as libc::c_int as uint8_t,
                flags: 0x2 as libc::c_int as uint8_t,
                sym: 83 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 24 as libc::c_int as uint8_t,
                flags: 0x2 as libc::c_int as uint8_t,
                sym: 83 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 31 as libc::c_int as uint8_t,
                flags: 0x2 as libc::c_int as uint8_t,
                sym: 83 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 41 as libc::c_int as uint8_t,
                flags: 0x2 as libc::c_int as uint8_t,
                sym: 83 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 56 as libc::c_int as uint8_t,
                flags: 0x3 as libc::c_int as uint8_t,
                sym: 83 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 3 as libc::c_int as uint8_t,
                flags: 0x2 as libc::c_int as uint8_t,
                sym: 84 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 6 as libc::c_int as uint8_t,
                flags: 0x2 as libc::c_int as uint8_t,
                sym: 84 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 10 as libc::c_int as uint8_t,
                flags: 0x2 as libc::c_int as uint8_t,
                sym: 84 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 15 as libc::c_int as uint8_t,
                flags: 0x2 as libc::c_int as uint8_t,
                sym: 84 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 24 as libc::c_int as uint8_t,
                flags: 0x2 as libc::c_int as uint8_t,
                sym: 84 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 31 as libc::c_int as uint8_t,
                flags: 0x2 as libc::c_int as uint8_t,
                sym: 84 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 41 as libc::c_int as uint8_t,
                flags: 0x2 as libc::c_int as uint8_t,
                sym: 84 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 56 as libc::c_int as uint8_t,
                flags: 0x3 as libc::c_int as uint8_t,
                sym: 84 as libc::c_int as uint8_t,
            };
            init
        },
    ],
    [
        {
            let mut init = decode_el {
                state: 0 as libc::c_int as uint8_t,
                flags: 0x3 as libc::c_int as uint8_t,
                sym: 85 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 0 as libc::c_int as uint8_t,
                flags: 0x3 as libc::c_int as uint8_t,
                sym: 86 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 0 as libc::c_int as uint8_t,
                flags: 0x3 as libc::c_int as uint8_t,
                sym: 87 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 0 as libc::c_int as uint8_t,
                flags: 0x3 as libc::c_int as uint8_t,
                sym: 89 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 0 as libc::c_int as uint8_t,
                flags: 0x3 as libc::c_int as uint8_t,
                sym: 106 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 0 as libc::c_int as uint8_t,
                flags: 0x3 as libc::c_int as uint8_t,
                sym: 107 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 0 as libc::c_int as uint8_t,
                flags: 0x3 as libc::c_int as uint8_t,
                sym: 113 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 0 as libc::c_int as uint8_t,
                flags: 0x3 as libc::c_int as uint8_t,
                sym: 118 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 0 as libc::c_int as uint8_t,
                flags: 0x3 as libc::c_int as uint8_t,
                sym: 119 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 0 as libc::c_int as uint8_t,
                flags: 0x3 as libc::c_int as uint8_t,
                sym: 120 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 0 as libc::c_int as uint8_t,
                flags: 0x3 as libc::c_int as uint8_t,
                sym: 121 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 0 as libc::c_int as uint8_t,
                flags: 0x3 as libc::c_int as uint8_t,
                sym: 122 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 70 as libc::c_int as uint8_t,
                flags: 0 as libc::c_int as uint8_t,
                sym: 0 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 71 as libc::c_int as uint8_t,
                flags: 0 as libc::c_int as uint8_t,
                sym: 0 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 73 as libc::c_int as uint8_t,
                flags: 0 as libc::c_int as uint8_t,
                sym: 0 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 74 as libc::c_int as uint8_t,
                flags: 0x1 as libc::c_int as uint8_t,
                sym: 0 as libc::c_int as uint8_t,
            };
            init
        },
    ],
    [
        {
            let mut init = decode_el {
                state: 1 as libc::c_int as uint8_t,
                flags: 0x2 as libc::c_int as uint8_t,
                sym: 85 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 22 as libc::c_int as uint8_t,
                flags: 0x3 as libc::c_int as uint8_t,
                sym: 85 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 1 as libc::c_int as uint8_t,
                flags: 0x2 as libc::c_int as uint8_t,
                sym: 86 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 22 as libc::c_int as uint8_t,
                flags: 0x3 as libc::c_int as uint8_t,
                sym: 86 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 1 as libc::c_int as uint8_t,
                flags: 0x2 as libc::c_int as uint8_t,
                sym: 87 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 22 as libc::c_int as uint8_t,
                flags: 0x3 as libc::c_int as uint8_t,
                sym: 87 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 1 as libc::c_int as uint8_t,
                flags: 0x2 as libc::c_int as uint8_t,
                sym: 89 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 22 as libc::c_int as uint8_t,
                flags: 0x3 as libc::c_int as uint8_t,
                sym: 89 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 1 as libc::c_int as uint8_t,
                flags: 0x2 as libc::c_int as uint8_t,
                sym: 106 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 22 as libc::c_int as uint8_t,
                flags: 0x3 as libc::c_int as uint8_t,
                sym: 106 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 1 as libc::c_int as uint8_t,
                flags: 0x2 as libc::c_int as uint8_t,
                sym: 107 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 22 as libc::c_int as uint8_t,
                flags: 0x3 as libc::c_int as uint8_t,
                sym: 107 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 1 as libc::c_int as uint8_t,
                flags: 0x2 as libc::c_int as uint8_t,
                sym: 113 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 22 as libc::c_int as uint8_t,
                flags: 0x3 as libc::c_int as uint8_t,
                sym: 113 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 1 as libc::c_int as uint8_t,
                flags: 0x2 as libc::c_int as uint8_t,
                sym: 118 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 22 as libc::c_int as uint8_t,
                flags: 0x3 as libc::c_int as uint8_t,
                sym: 118 as libc::c_int as uint8_t,
            };
            init
        },
    ],
    [
        {
            let mut init = decode_el {
                state: 2 as libc::c_int as uint8_t,
                flags: 0x2 as libc::c_int as uint8_t,
                sym: 85 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 9 as libc::c_int as uint8_t,
                flags: 0x2 as libc::c_int as uint8_t,
                sym: 85 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 23 as libc::c_int as uint8_t,
                flags: 0x2 as libc::c_int as uint8_t,
                sym: 85 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 40 as libc::c_int as uint8_t,
                flags: 0x3 as libc::c_int as uint8_t,
                sym: 85 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 2 as libc::c_int as uint8_t,
                flags: 0x2 as libc::c_int as uint8_t,
                sym: 86 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 9 as libc::c_int as uint8_t,
                flags: 0x2 as libc::c_int as uint8_t,
                sym: 86 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 23 as libc::c_int as uint8_t,
                flags: 0x2 as libc::c_int as uint8_t,
                sym: 86 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 40 as libc::c_int as uint8_t,
                flags: 0x3 as libc::c_int as uint8_t,
                sym: 86 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 2 as libc::c_int as uint8_t,
                flags: 0x2 as libc::c_int as uint8_t,
                sym: 87 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 9 as libc::c_int as uint8_t,
                flags: 0x2 as libc::c_int as uint8_t,
                sym: 87 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 23 as libc::c_int as uint8_t,
                flags: 0x2 as libc::c_int as uint8_t,
                sym: 87 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 40 as libc::c_int as uint8_t,
                flags: 0x3 as libc::c_int as uint8_t,
                sym: 87 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 2 as libc::c_int as uint8_t,
                flags: 0x2 as libc::c_int as uint8_t,
                sym: 89 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 9 as libc::c_int as uint8_t,
                flags: 0x2 as libc::c_int as uint8_t,
                sym: 89 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 23 as libc::c_int as uint8_t,
                flags: 0x2 as libc::c_int as uint8_t,
                sym: 89 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 40 as libc::c_int as uint8_t,
                flags: 0x3 as libc::c_int as uint8_t,
                sym: 89 as libc::c_int as uint8_t,
            };
            init
        },
    ],
    [
        {
            let mut init = decode_el {
                state: 3 as libc::c_int as uint8_t,
                flags: 0x2 as libc::c_int as uint8_t,
                sym: 85 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 6 as libc::c_int as uint8_t,
                flags: 0x2 as libc::c_int as uint8_t,
                sym: 85 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 10 as libc::c_int as uint8_t,
                flags: 0x2 as libc::c_int as uint8_t,
                sym: 85 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 15 as libc::c_int as uint8_t,
                flags: 0x2 as libc::c_int as uint8_t,
                sym: 85 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 24 as libc::c_int as uint8_t,
                flags: 0x2 as libc::c_int as uint8_t,
                sym: 85 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 31 as libc::c_int as uint8_t,
                flags: 0x2 as libc::c_int as uint8_t,
                sym: 85 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 41 as libc::c_int as uint8_t,
                flags: 0x2 as libc::c_int as uint8_t,
                sym: 85 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 56 as libc::c_int as uint8_t,
                flags: 0x3 as libc::c_int as uint8_t,
                sym: 85 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 3 as libc::c_int as uint8_t,
                flags: 0x2 as libc::c_int as uint8_t,
                sym: 86 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 6 as libc::c_int as uint8_t,
                flags: 0x2 as libc::c_int as uint8_t,
                sym: 86 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 10 as libc::c_int as uint8_t,
                flags: 0x2 as libc::c_int as uint8_t,
                sym: 86 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 15 as libc::c_int as uint8_t,
                flags: 0x2 as libc::c_int as uint8_t,
                sym: 86 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 24 as libc::c_int as uint8_t,
                flags: 0x2 as libc::c_int as uint8_t,
                sym: 86 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 31 as libc::c_int as uint8_t,
                flags: 0x2 as libc::c_int as uint8_t,
                sym: 86 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 41 as libc::c_int as uint8_t,
                flags: 0x2 as libc::c_int as uint8_t,
                sym: 86 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 56 as libc::c_int as uint8_t,
                flags: 0x3 as libc::c_int as uint8_t,
                sym: 86 as libc::c_int as uint8_t,
            };
            init
        },
    ],
    [
        {
            let mut init = decode_el {
                state: 3 as libc::c_int as uint8_t,
                flags: 0x2 as libc::c_int as uint8_t,
                sym: 87 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 6 as libc::c_int as uint8_t,
                flags: 0x2 as libc::c_int as uint8_t,
                sym: 87 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 10 as libc::c_int as uint8_t,
                flags: 0x2 as libc::c_int as uint8_t,
                sym: 87 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 15 as libc::c_int as uint8_t,
                flags: 0x2 as libc::c_int as uint8_t,
                sym: 87 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 24 as libc::c_int as uint8_t,
                flags: 0x2 as libc::c_int as uint8_t,
                sym: 87 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 31 as libc::c_int as uint8_t,
                flags: 0x2 as libc::c_int as uint8_t,
                sym: 87 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 41 as libc::c_int as uint8_t,
                flags: 0x2 as libc::c_int as uint8_t,
                sym: 87 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 56 as libc::c_int as uint8_t,
                flags: 0x3 as libc::c_int as uint8_t,
                sym: 87 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 3 as libc::c_int as uint8_t,
                flags: 0x2 as libc::c_int as uint8_t,
                sym: 89 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 6 as libc::c_int as uint8_t,
                flags: 0x2 as libc::c_int as uint8_t,
                sym: 89 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 10 as libc::c_int as uint8_t,
                flags: 0x2 as libc::c_int as uint8_t,
                sym: 89 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 15 as libc::c_int as uint8_t,
                flags: 0x2 as libc::c_int as uint8_t,
                sym: 89 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 24 as libc::c_int as uint8_t,
                flags: 0x2 as libc::c_int as uint8_t,
                sym: 89 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 31 as libc::c_int as uint8_t,
                flags: 0x2 as libc::c_int as uint8_t,
                sym: 89 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 41 as libc::c_int as uint8_t,
                flags: 0x2 as libc::c_int as uint8_t,
                sym: 89 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 56 as libc::c_int as uint8_t,
                flags: 0x3 as libc::c_int as uint8_t,
                sym: 89 as libc::c_int as uint8_t,
            };
            init
        },
    ],
    [
        {
            let mut init = decode_el {
                state: 2 as libc::c_int as uint8_t,
                flags: 0x2 as libc::c_int as uint8_t,
                sym: 106 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 9 as libc::c_int as uint8_t,
                flags: 0x2 as libc::c_int as uint8_t,
                sym: 106 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 23 as libc::c_int as uint8_t,
                flags: 0x2 as libc::c_int as uint8_t,
                sym: 106 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 40 as libc::c_int as uint8_t,
                flags: 0x3 as libc::c_int as uint8_t,
                sym: 106 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 2 as libc::c_int as uint8_t,
                flags: 0x2 as libc::c_int as uint8_t,
                sym: 107 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 9 as libc::c_int as uint8_t,
                flags: 0x2 as libc::c_int as uint8_t,
                sym: 107 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 23 as libc::c_int as uint8_t,
                flags: 0x2 as libc::c_int as uint8_t,
                sym: 107 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 40 as libc::c_int as uint8_t,
                flags: 0x3 as libc::c_int as uint8_t,
                sym: 107 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 2 as libc::c_int as uint8_t,
                flags: 0x2 as libc::c_int as uint8_t,
                sym: 113 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 9 as libc::c_int as uint8_t,
                flags: 0x2 as libc::c_int as uint8_t,
                sym: 113 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 23 as libc::c_int as uint8_t,
                flags: 0x2 as libc::c_int as uint8_t,
                sym: 113 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 40 as libc::c_int as uint8_t,
                flags: 0x3 as libc::c_int as uint8_t,
                sym: 113 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 2 as libc::c_int as uint8_t,
                flags: 0x2 as libc::c_int as uint8_t,
                sym: 118 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 9 as libc::c_int as uint8_t,
                flags: 0x2 as libc::c_int as uint8_t,
                sym: 118 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 23 as libc::c_int as uint8_t,
                flags: 0x2 as libc::c_int as uint8_t,
                sym: 118 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 40 as libc::c_int as uint8_t,
                flags: 0x3 as libc::c_int as uint8_t,
                sym: 118 as libc::c_int as uint8_t,
            };
            init
        },
    ],
    [
        {
            let mut init = decode_el {
                state: 3 as libc::c_int as uint8_t,
                flags: 0x2 as libc::c_int as uint8_t,
                sym: 106 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 6 as libc::c_int as uint8_t,
                flags: 0x2 as libc::c_int as uint8_t,
                sym: 106 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 10 as libc::c_int as uint8_t,
                flags: 0x2 as libc::c_int as uint8_t,
                sym: 106 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 15 as libc::c_int as uint8_t,
                flags: 0x2 as libc::c_int as uint8_t,
                sym: 106 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 24 as libc::c_int as uint8_t,
                flags: 0x2 as libc::c_int as uint8_t,
                sym: 106 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 31 as libc::c_int as uint8_t,
                flags: 0x2 as libc::c_int as uint8_t,
                sym: 106 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 41 as libc::c_int as uint8_t,
                flags: 0x2 as libc::c_int as uint8_t,
                sym: 106 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 56 as libc::c_int as uint8_t,
                flags: 0x3 as libc::c_int as uint8_t,
                sym: 106 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 3 as libc::c_int as uint8_t,
                flags: 0x2 as libc::c_int as uint8_t,
                sym: 107 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 6 as libc::c_int as uint8_t,
                flags: 0x2 as libc::c_int as uint8_t,
                sym: 107 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 10 as libc::c_int as uint8_t,
                flags: 0x2 as libc::c_int as uint8_t,
                sym: 107 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 15 as libc::c_int as uint8_t,
                flags: 0x2 as libc::c_int as uint8_t,
                sym: 107 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 24 as libc::c_int as uint8_t,
                flags: 0x2 as libc::c_int as uint8_t,
                sym: 107 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 31 as libc::c_int as uint8_t,
                flags: 0x2 as libc::c_int as uint8_t,
                sym: 107 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 41 as libc::c_int as uint8_t,
                flags: 0x2 as libc::c_int as uint8_t,
                sym: 107 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 56 as libc::c_int as uint8_t,
                flags: 0x3 as libc::c_int as uint8_t,
                sym: 107 as libc::c_int as uint8_t,
            };
            init
        },
    ],
    [
        {
            let mut init = decode_el {
                state: 3 as libc::c_int as uint8_t,
                flags: 0x2 as libc::c_int as uint8_t,
                sym: 113 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 6 as libc::c_int as uint8_t,
                flags: 0x2 as libc::c_int as uint8_t,
                sym: 113 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 10 as libc::c_int as uint8_t,
                flags: 0x2 as libc::c_int as uint8_t,
                sym: 113 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 15 as libc::c_int as uint8_t,
                flags: 0x2 as libc::c_int as uint8_t,
                sym: 113 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 24 as libc::c_int as uint8_t,
                flags: 0x2 as libc::c_int as uint8_t,
                sym: 113 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 31 as libc::c_int as uint8_t,
                flags: 0x2 as libc::c_int as uint8_t,
                sym: 113 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 41 as libc::c_int as uint8_t,
                flags: 0x2 as libc::c_int as uint8_t,
                sym: 113 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 56 as libc::c_int as uint8_t,
                flags: 0x3 as libc::c_int as uint8_t,
                sym: 113 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 3 as libc::c_int as uint8_t,
                flags: 0x2 as libc::c_int as uint8_t,
                sym: 118 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 6 as libc::c_int as uint8_t,
                flags: 0x2 as libc::c_int as uint8_t,
                sym: 118 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 10 as libc::c_int as uint8_t,
                flags: 0x2 as libc::c_int as uint8_t,
                sym: 118 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 15 as libc::c_int as uint8_t,
                flags: 0x2 as libc::c_int as uint8_t,
                sym: 118 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 24 as libc::c_int as uint8_t,
                flags: 0x2 as libc::c_int as uint8_t,
                sym: 118 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 31 as libc::c_int as uint8_t,
                flags: 0x2 as libc::c_int as uint8_t,
                sym: 118 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 41 as libc::c_int as uint8_t,
                flags: 0x2 as libc::c_int as uint8_t,
                sym: 118 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 56 as libc::c_int as uint8_t,
                flags: 0x3 as libc::c_int as uint8_t,
                sym: 118 as libc::c_int as uint8_t,
            };
            init
        },
    ],
    [
        {
            let mut init = decode_el {
                state: 1 as libc::c_int as uint8_t,
                flags: 0x2 as libc::c_int as uint8_t,
                sym: 119 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 22 as libc::c_int as uint8_t,
                flags: 0x3 as libc::c_int as uint8_t,
                sym: 119 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 1 as libc::c_int as uint8_t,
                flags: 0x2 as libc::c_int as uint8_t,
                sym: 120 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 22 as libc::c_int as uint8_t,
                flags: 0x3 as libc::c_int as uint8_t,
                sym: 120 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 1 as libc::c_int as uint8_t,
                flags: 0x2 as libc::c_int as uint8_t,
                sym: 121 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 22 as libc::c_int as uint8_t,
                flags: 0x3 as libc::c_int as uint8_t,
                sym: 121 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 1 as libc::c_int as uint8_t,
                flags: 0x2 as libc::c_int as uint8_t,
                sym: 122 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 22 as libc::c_int as uint8_t,
                flags: 0x3 as libc::c_int as uint8_t,
                sym: 122 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 0 as libc::c_int as uint8_t,
                flags: 0x3 as libc::c_int as uint8_t,
                sym: 38 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 0 as libc::c_int as uint8_t,
                flags: 0x3 as libc::c_int as uint8_t,
                sym: 42 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 0 as libc::c_int as uint8_t,
                flags: 0x3 as libc::c_int as uint8_t,
                sym: 44 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 0 as libc::c_int as uint8_t,
                flags: 0x3 as libc::c_int as uint8_t,
                sym: 59 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 0 as libc::c_int as uint8_t,
                flags: 0x3 as libc::c_int as uint8_t,
                sym: 88 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 0 as libc::c_int as uint8_t,
                flags: 0x3 as libc::c_int as uint8_t,
                sym: 90 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 75 as libc::c_int as uint8_t,
                flags: 0 as libc::c_int as uint8_t,
                sym: 0 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 78 as libc::c_int as uint8_t,
                flags: 0 as libc::c_int as uint8_t,
                sym: 0 as libc::c_int as uint8_t,
            };
            init
        },
    ],
    [
        {
            let mut init = decode_el {
                state: 2 as libc::c_int as uint8_t,
                flags: 0x2 as libc::c_int as uint8_t,
                sym: 119 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 9 as libc::c_int as uint8_t,
                flags: 0x2 as libc::c_int as uint8_t,
                sym: 119 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 23 as libc::c_int as uint8_t,
                flags: 0x2 as libc::c_int as uint8_t,
                sym: 119 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 40 as libc::c_int as uint8_t,
                flags: 0x3 as libc::c_int as uint8_t,
                sym: 119 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 2 as libc::c_int as uint8_t,
                flags: 0x2 as libc::c_int as uint8_t,
                sym: 120 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 9 as libc::c_int as uint8_t,
                flags: 0x2 as libc::c_int as uint8_t,
                sym: 120 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 23 as libc::c_int as uint8_t,
                flags: 0x2 as libc::c_int as uint8_t,
                sym: 120 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 40 as libc::c_int as uint8_t,
                flags: 0x3 as libc::c_int as uint8_t,
                sym: 120 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 2 as libc::c_int as uint8_t,
                flags: 0x2 as libc::c_int as uint8_t,
                sym: 121 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 9 as libc::c_int as uint8_t,
                flags: 0x2 as libc::c_int as uint8_t,
                sym: 121 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 23 as libc::c_int as uint8_t,
                flags: 0x2 as libc::c_int as uint8_t,
                sym: 121 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 40 as libc::c_int as uint8_t,
                flags: 0x3 as libc::c_int as uint8_t,
                sym: 121 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 2 as libc::c_int as uint8_t,
                flags: 0x2 as libc::c_int as uint8_t,
                sym: 122 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 9 as libc::c_int as uint8_t,
                flags: 0x2 as libc::c_int as uint8_t,
                sym: 122 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 23 as libc::c_int as uint8_t,
                flags: 0x2 as libc::c_int as uint8_t,
                sym: 122 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 40 as libc::c_int as uint8_t,
                flags: 0x3 as libc::c_int as uint8_t,
                sym: 122 as libc::c_int as uint8_t,
            };
            init
        },
    ],
    [
        {
            let mut init = decode_el {
                state: 3 as libc::c_int as uint8_t,
                flags: 0x2 as libc::c_int as uint8_t,
                sym: 119 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 6 as libc::c_int as uint8_t,
                flags: 0x2 as libc::c_int as uint8_t,
                sym: 119 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 10 as libc::c_int as uint8_t,
                flags: 0x2 as libc::c_int as uint8_t,
                sym: 119 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 15 as libc::c_int as uint8_t,
                flags: 0x2 as libc::c_int as uint8_t,
                sym: 119 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 24 as libc::c_int as uint8_t,
                flags: 0x2 as libc::c_int as uint8_t,
                sym: 119 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 31 as libc::c_int as uint8_t,
                flags: 0x2 as libc::c_int as uint8_t,
                sym: 119 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 41 as libc::c_int as uint8_t,
                flags: 0x2 as libc::c_int as uint8_t,
                sym: 119 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 56 as libc::c_int as uint8_t,
                flags: 0x3 as libc::c_int as uint8_t,
                sym: 119 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 3 as libc::c_int as uint8_t,
                flags: 0x2 as libc::c_int as uint8_t,
                sym: 120 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 6 as libc::c_int as uint8_t,
                flags: 0x2 as libc::c_int as uint8_t,
                sym: 120 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 10 as libc::c_int as uint8_t,
                flags: 0x2 as libc::c_int as uint8_t,
                sym: 120 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 15 as libc::c_int as uint8_t,
                flags: 0x2 as libc::c_int as uint8_t,
                sym: 120 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 24 as libc::c_int as uint8_t,
                flags: 0x2 as libc::c_int as uint8_t,
                sym: 120 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 31 as libc::c_int as uint8_t,
                flags: 0x2 as libc::c_int as uint8_t,
                sym: 120 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 41 as libc::c_int as uint8_t,
                flags: 0x2 as libc::c_int as uint8_t,
                sym: 120 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 56 as libc::c_int as uint8_t,
                flags: 0x3 as libc::c_int as uint8_t,
                sym: 120 as libc::c_int as uint8_t,
            };
            init
        },
    ],
    [
        {
            let mut init = decode_el {
                state: 3 as libc::c_int as uint8_t,
                flags: 0x2 as libc::c_int as uint8_t,
                sym: 121 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 6 as libc::c_int as uint8_t,
                flags: 0x2 as libc::c_int as uint8_t,
                sym: 121 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 10 as libc::c_int as uint8_t,
                flags: 0x2 as libc::c_int as uint8_t,
                sym: 121 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 15 as libc::c_int as uint8_t,
                flags: 0x2 as libc::c_int as uint8_t,
                sym: 121 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 24 as libc::c_int as uint8_t,
                flags: 0x2 as libc::c_int as uint8_t,
                sym: 121 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 31 as libc::c_int as uint8_t,
                flags: 0x2 as libc::c_int as uint8_t,
                sym: 121 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 41 as libc::c_int as uint8_t,
                flags: 0x2 as libc::c_int as uint8_t,
                sym: 121 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 56 as libc::c_int as uint8_t,
                flags: 0x3 as libc::c_int as uint8_t,
                sym: 121 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 3 as libc::c_int as uint8_t,
                flags: 0x2 as libc::c_int as uint8_t,
                sym: 122 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 6 as libc::c_int as uint8_t,
                flags: 0x2 as libc::c_int as uint8_t,
                sym: 122 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 10 as libc::c_int as uint8_t,
                flags: 0x2 as libc::c_int as uint8_t,
                sym: 122 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 15 as libc::c_int as uint8_t,
                flags: 0x2 as libc::c_int as uint8_t,
                sym: 122 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 24 as libc::c_int as uint8_t,
                flags: 0x2 as libc::c_int as uint8_t,
                sym: 122 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 31 as libc::c_int as uint8_t,
                flags: 0x2 as libc::c_int as uint8_t,
                sym: 122 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 41 as libc::c_int as uint8_t,
                flags: 0x2 as libc::c_int as uint8_t,
                sym: 122 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 56 as libc::c_int as uint8_t,
                flags: 0x3 as libc::c_int as uint8_t,
                sym: 122 as libc::c_int as uint8_t,
            };
            init
        },
    ],
    [
        {
            let mut init = decode_el {
                state: 1 as libc::c_int as uint8_t,
                flags: 0x2 as libc::c_int as uint8_t,
                sym: 38 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 22 as libc::c_int as uint8_t,
                flags: 0x3 as libc::c_int as uint8_t,
                sym: 38 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 1 as libc::c_int as uint8_t,
                flags: 0x2 as libc::c_int as uint8_t,
                sym: 42 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 22 as libc::c_int as uint8_t,
                flags: 0x3 as libc::c_int as uint8_t,
                sym: 42 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 1 as libc::c_int as uint8_t,
                flags: 0x2 as libc::c_int as uint8_t,
                sym: 44 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 22 as libc::c_int as uint8_t,
                flags: 0x3 as libc::c_int as uint8_t,
                sym: 44 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 1 as libc::c_int as uint8_t,
                flags: 0x2 as libc::c_int as uint8_t,
                sym: 59 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 22 as libc::c_int as uint8_t,
                flags: 0x3 as libc::c_int as uint8_t,
                sym: 59 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 1 as libc::c_int as uint8_t,
                flags: 0x2 as libc::c_int as uint8_t,
                sym: 88 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 22 as libc::c_int as uint8_t,
                flags: 0x3 as libc::c_int as uint8_t,
                sym: 88 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 1 as libc::c_int as uint8_t,
                flags: 0x2 as libc::c_int as uint8_t,
                sym: 90 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 22 as libc::c_int as uint8_t,
                flags: 0x3 as libc::c_int as uint8_t,
                sym: 90 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 76 as libc::c_int as uint8_t,
                flags: 0 as libc::c_int as uint8_t,
                sym: 0 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 77 as libc::c_int as uint8_t,
                flags: 0 as libc::c_int as uint8_t,
                sym: 0 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 79 as libc::c_int as uint8_t,
                flags: 0 as libc::c_int as uint8_t,
                sym: 0 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 81 as libc::c_int as uint8_t,
                flags: 0 as libc::c_int as uint8_t,
                sym: 0 as libc::c_int as uint8_t,
            };
            init
        },
    ],
    [
        {
            let mut init = decode_el {
                state: 2 as libc::c_int as uint8_t,
                flags: 0x2 as libc::c_int as uint8_t,
                sym: 38 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 9 as libc::c_int as uint8_t,
                flags: 0x2 as libc::c_int as uint8_t,
                sym: 38 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 23 as libc::c_int as uint8_t,
                flags: 0x2 as libc::c_int as uint8_t,
                sym: 38 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 40 as libc::c_int as uint8_t,
                flags: 0x3 as libc::c_int as uint8_t,
                sym: 38 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 2 as libc::c_int as uint8_t,
                flags: 0x2 as libc::c_int as uint8_t,
                sym: 42 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 9 as libc::c_int as uint8_t,
                flags: 0x2 as libc::c_int as uint8_t,
                sym: 42 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 23 as libc::c_int as uint8_t,
                flags: 0x2 as libc::c_int as uint8_t,
                sym: 42 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 40 as libc::c_int as uint8_t,
                flags: 0x3 as libc::c_int as uint8_t,
                sym: 42 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 2 as libc::c_int as uint8_t,
                flags: 0x2 as libc::c_int as uint8_t,
                sym: 44 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 9 as libc::c_int as uint8_t,
                flags: 0x2 as libc::c_int as uint8_t,
                sym: 44 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 23 as libc::c_int as uint8_t,
                flags: 0x2 as libc::c_int as uint8_t,
                sym: 44 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 40 as libc::c_int as uint8_t,
                flags: 0x3 as libc::c_int as uint8_t,
                sym: 44 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 2 as libc::c_int as uint8_t,
                flags: 0x2 as libc::c_int as uint8_t,
                sym: 59 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 9 as libc::c_int as uint8_t,
                flags: 0x2 as libc::c_int as uint8_t,
                sym: 59 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 23 as libc::c_int as uint8_t,
                flags: 0x2 as libc::c_int as uint8_t,
                sym: 59 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 40 as libc::c_int as uint8_t,
                flags: 0x3 as libc::c_int as uint8_t,
                sym: 59 as libc::c_int as uint8_t,
            };
            init
        },
    ],
    [
        {
            let mut init = decode_el {
                state: 3 as libc::c_int as uint8_t,
                flags: 0x2 as libc::c_int as uint8_t,
                sym: 38 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 6 as libc::c_int as uint8_t,
                flags: 0x2 as libc::c_int as uint8_t,
                sym: 38 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 10 as libc::c_int as uint8_t,
                flags: 0x2 as libc::c_int as uint8_t,
                sym: 38 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 15 as libc::c_int as uint8_t,
                flags: 0x2 as libc::c_int as uint8_t,
                sym: 38 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 24 as libc::c_int as uint8_t,
                flags: 0x2 as libc::c_int as uint8_t,
                sym: 38 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 31 as libc::c_int as uint8_t,
                flags: 0x2 as libc::c_int as uint8_t,
                sym: 38 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 41 as libc::c_int as uint8_t,
                flags: 0x2 as libc::c_int as uint8_t,
                sym: 38 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 56 as libc::c_int as uint8_t,
                flags: 0x3 as libc::c_int as uint8_t,
                sym: 38 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 3 as libc::c_int as uint8_t,
                flags: 0x2 as libc::c_int as uint8_t,
                sym: 42 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 6 as libc::c_int as uint8_t,
                flags: 0x2 as libc::c_int as uint8_t,
                sym: 42 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 10 as libc::c_int as uint8_t,
                flags: 0x2 as libc::c_int as uint8_t,
                sym: 42 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 15 as libc::c_int as uint8_t,
                flags: 0x2 as libc::c_int as uint8_t,
                sym: 42 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 24 as libc::c_int as uint8_t,
                flags: 0x2 as libc::c_int as uint8_t,
                sym: 42 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 31 as libc::c_int as uint8_t,
                flags: 0x2 as libc::c_int as uint8_t,
                sym: 42 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 41 as libc::c_int as uint8_t,
                flags: 0x2 as libc::c_int as uint8_t,
                sym: 42 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 56 as libc::c_int as uint8_t,
                flags: 0x3 as libc::c_int as uint8_t,
                sym: 42 as libc::c_int as uint8_t,
            };
            init
        },
    ],
    [
        {
            let mut init = decode_el {
                state: 3 as libc::c_int as uint8_t,
                flags: 0x2 as libc::c_int as uint8_t,
                sym: 44 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 6 as libc::c_int as uint8_t,
                flags: 0x2 as libc::c_int as uint8_t,
                sym: 44 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 10 as libc::c_int as uint8_t,
                flags: 0x2 as libc::c_int as uint8_t,
                sym: 44 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 15 as libc::c_int as uint8_t,
                flags: 0x2 as libc::c_int as uint8_t,
                sym: 44 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 24 as libc::c_int as uint8_t,
                flags: 0x2 as libc::c_int as uint8_t,
                sym: 44 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 31 as libc::c_int as uint8_t,
                flags: 0x2 as libc::c_int as uint8_t,
                sym: 44 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 41 as libc::c_int as uint8_t,
                flags: 0x2 as libc::c_int as uint8_t,
                sym: 44 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 56 as libc::c_int as uint8_t,
                flags: 0x3 as libc::c_int as uint8_t,
                sym: 44 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 3 as libc::c_int as uint8_t,
                flags: 0x2 as libc::c_int as uint8_t,
                sym: 59 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 6 as libc::c_int as uint8_t,
                flags: 0x2 as libc::c_int as uint8_t,
                sym: 59 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 10 as libc::c_int as uint8_t,
                flags: 0x2 as libc::c_int as uint8_t,
                sym: 59 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 15 as libc::c_int as uint8_t,
                flags: 0x2 as libc::c_int as uint8_t,
                sym: 59 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 24 as libc::c_int as uint8_t,
                flags: 0x2 as libc::c_int as uint8_t,
                sym: 59 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 31 as libc::c_int as uint8_t,
                flags: 0x2 as libc::c_int as uint8_t,
                sym: 59 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 41 as libc::c_int as uint8_t,
                flags: 0x2 as libc::c_int as uint8_t,
                sym: 59 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 56 as libc::c_int as uint8_t,
                flags: 0x3 as libc::c_int as uint8_t,
                sym: 59 as libc::c_int as uint8_t,
            };
            init
        },
    ],
    [
        {
            let mut init = decode_el {
                state: 2 as libc::c_int as uint8_t,
                flags: 0x2 as libc::c_int as uint8_t,
                sym: 88 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 9 as libc::c_int as uint8_t,
                flags: 0x2 as libc::c_int as uint8_t,
                sym: 88 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 23 as libc::c_int as uint8_t,
                flags: 0x2 as libc::c_int as uint8_t,
                sym: 88 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 40 as libc::c_int as uint8_t,
                flags: 0x3 as libc::c_int as uint8_t,
                sym: 88 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 2 as libc::c_int as uint8_t,
                flags: 0x2 as libc::c_int as uint8_t,
                sym: 90 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 9 as libc::c_int as uint8_t,
                flags: 0x2 as libc::c_int as uint8_t,
                sym: 90 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 23 as libc::c_int as uint8_t,
                flags: 0x2 as libc::c_int as uint8_t,
                sym: 90 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 40 as libc::c_int as uint8_t,
                flags: 0x3 as libc::c_int as uint8_t,
                sym: 90 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 0 as libc::c_int as uint8_t,
                flags: 0x3 as libc::c_int as uint8_t,
                sym: 33 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 0 as libc::c_int as uint8_t,
                flags: 0x3 as libc::c_int as uint8_t,
                sym: 34 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 0 as libc::c_int as uint8_t,
                flags: 0x3 as libc::c_int as uint8_t,
                sym: 40 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 0 as libc::c_int as uint8_t,
                flags: 0x3 as libc::c_int as uint8_t,
                sym: 41 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 0 as libc::c_int as uint8_t,
                flags: 0x3 as libc::c_int as uint8_t,
                sym: 63 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 80 as libc::c_int as uint8_t,
                flags: 0 as libc::c_int as uint8_t,
                sym: 0 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 82 as libc::c_int as uint8_t,
                flags: 0 as libc::c_int as uint8_t,
                sym: 0 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 84 as libc::c_int as uint8_t,
                flags: 0 as libc::c_int as uint8_t,
                sym: 0 as libc::c_int as uint8_t,
            };
            init
        },
    ],
    [
        {
            let mut init = decode_el {
                state: 3 as libc::c_int as uint8_t,
                flags: 0x2 as libc::c_int as uint8_t,
                sym: 88 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 6 as libc::c_int as uint8_t,
                flags: 0x2 as libc::c_int as uint8_t,
                sym: 88 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 10 as libc::c_int as uint8_t,
                flags: 0x2 as libc::c_int as uint8_t,
                sym: 88 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 15 as libc::c_int as uint8_t,
                flags: 0x2 as libc::c_int as uint8_t,
                sym: 88 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 24 as libc::c_int as uint8_t,
                flags: 0x2 as libc::c_int as uint8_t,
                sym: 88 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 31 as libc::c_int as uint8_t,
                flags: 0x2 as libc::c_int as uint8_t,
                sym: 88 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 41 as libc::c_int as uint8_t,
                flags: 0x2 as libc::c_int as uint8_t,
                sym: 88 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 56 as libc::c_int as uint8_t,
                flags: 0x3 as libc::c_int as uint8_t,
                sym: 88 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 3 as libc::c_int as uint8_t,
                flags: 0x2 as libc::c_int as uint8_t,
                sym: 90 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 6 as libc::c_int as uint8_t,
                flags: 0x2 as libc::c_int as uint8_t,
                sym: 90 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 10 as libc::c_int as uint8_t,
                flags: 0x2 as libc::c_int as uint8_t,
                sym: 90 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 15 as libc::c_int as uint8_t,
                flags: 0x2 as libc::c_int as uint8_t,
                sym: 90 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 24 as libc::c_int as uint8_t,
                flags: 0x2 as libc::c_int as uint8_t,
                sym: 90 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 31 as libc::c_int as uint8_t,
                flags: 0x2 as libc::c_int as uint8_t,
                sym: 90 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 41 as libc::c_int as uint8_t,
                flags: 0x2 as libc::c_int as uint8_t,
                sym: 90 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 56 as libc::c_int as uint8_t,
                flags: 0x3 as libc::c_int as uint8_t,
                sym: 90 as libc::c_int as uint8_t,
            };
            init
        },
    ],
    [
        {
            let mut init = decode_el {
                state: 1 as libc::c_int as uint8_t,
                flags: 0x2 as libc::c_int as uint8_t,
                sym: 33 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 22 as libc::c_int as uint8_t,
                flags: 0x3 as libc::c_int as uint8_t,
                sym: 33 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 1 as libc::c_int as uint8_t,
                flags: 0x2 as libc::c_int as uint8_t,
                sym: 34 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 22 as libc::c_int as uint8_t,
                flags: 0x3 as libc::c_int as uint8_t,
                sym: 34 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 1 as libc::c_int as uint8_t,
                flags: 0x2 as libc::c_int as uint8_t,
                sym: 40 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 22 as libc::c_int as uint8_t,
                flags: 0x3 as libc::c_int as uint8_t,
                sym: 40 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 1 as libc::c_int as uint8_t,
                flags: 0x2 as libc::c_int as uint8_t,
                sym: 41 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 22 as libc::c_int as uint8_t,
                flags: 0x3 as libc::c_int as uint8_t,
                sym: 41 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 1 as libc::c_int as uint8_t,
                flags: 0x2 as libc::c_int as uint8_t,
                sym: 63 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 22 as libc::c_int as uint8_t,
                flags: 0x3 as libc::c_int as uint8_t,
                sym: 63 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 0 as libc::c_int as uint8_t,
                flags: 0x3 as libc::c_int as uint8_t,
                sym: 39 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 0 as libc::c_int as uint8_t,
                flags: 0x3 as libc::c_int as uint8_t,
                sym: 43 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 0 as libc::c_int as uint8_t,
                flags: 0x3 as libc::c_int as uint8_t,
                sym: 124 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 83 as libc::c_int as uint8_t,
                flags: 0 as libc::c_int as uint8_t,
                sym: 0 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 85 as libc::c_int as uint8_t,
                flags: 0 as libc::c_int as uint8_t,
                sym: 0 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 88 as libc::c_int as uint8_t,
                flags: 0 as libc::c_int as uint8_t,
                sym: 0 as libc::c_int as uint8_t,
            };
            init
        },
    ],
    [
        {
            let mut init = decode_el {
                state: 2 as libc::c_int as uint8_t,
                flags: 0x2 as libc::c_int as uint8_t,
                sym: 33 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 9 as libc::c_int as uint8_t,
                flags: 0x2 as libc::c_int as uint8_t,
                sym: 33 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 23 as libc::c_int as uint8_t,
                flags: 0x2 as libc::c_int as uint8_t,
                sym: 33 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 40 as libc::c_int as uint8_t,
                flags: 0x3 as libc::c_int as uint8_t,
                sym: 33 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 2 as libc::c_int as uint8_t,
                flags: 0x2 as libc::c_int as uint8_t,
                sym: 34 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 9 as libc::c_int as uint8_t,
                flags: 0x2 as libc::c_int as uint8_t,
                sym: 34 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 23 as libc::c_int as uint8_t,
                flags: 0x2 as libc::c_int as uint8_t,
                sym: 34 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 40 as libc::c_int as uint8_t,
                flags: 0x3 as libc::c_int as uint8_t,
                sym: 34 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 2 as libc::c_int as uint8_t,
                flags: 0x2 as libc::c_int as uint8_t,
                sym: 40 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 9 as libc::c_int as uint8_t,
                flags: 0x2 as libc::c_int as uint8_t,
                sym: 40 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 23 as libc::c_int as uint8_t,
                flags: 0x2 as libc::c_int as uint8_t,
                sym: 40 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 40 as libc::c_int as uint8_t,
                flags: 0x3 as libc::c_int as uint8_t,
                sym: 40 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 2 as libc::c_int as uint8_t,
                flags: 0x2 as libc::c_int as uint8_t,
                sym: 41 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 9 as libc::c_int as uint8_t,
                flags: 0x2 as libc::c_int as uint8_t,
                sym: 41 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 23 as libc::c_int as uint8_t,
                flags: 0x2 as libc::c_int as uint8_t,
                sym: 41 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 40 as libc::c_int as uint8_t,
                flags: 0x3 as libc::c_int as uint8_t,
                sym: 41 as libc::c_int as uint8_t,
            };
            init
        },
    ],
    [
        {
            let mut init = decode_el {
                state: 3 as libc::c_int as uint8_t,
                flags: 0x2 as libc::c_int as uint8_t,
                sym: 33 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 6 as libc::c_int as uint8_t,
                flags: 0x2 as libc::c_int as uint8_t,
                sym: 33 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 10 as libc::c_int as uint8_t,
                flags: 0x2 as libc::c_int as uint8_t,
                sym: 33 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 15 as libc::c_int as uint8_t,
                flags: 0x2 as libc::c_int as uint8_t,
                sym: 33 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 24 as libc::c_int as uint8_t,
                flags: 0x2 as libc::c_int as uint8_t,
                sym: 33 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 31 as libc::c_int as uint8_t,
                flags: 0x2 as libc::c_int as uint8_t,
                sym: 33 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 41 as libc::c_int as uint8_t,
                flags: 0x2 as libc::c_int as uint8_t,
                sym: 33 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 56 as libc::c_int as uint8_t,
                flags: 0x3 as libc::c_int as uint8_t,
                sym: 33 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 3 as libc::c_int as uint8_t,
                flags: 0x2 as libc::c_int as uint8_t,
                sym: 34 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 6 as libc::c_int as uint8_t,
                flags: 0x2 as libc::c_int as uint8_t,
                sym: 34 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 10 as libc::c_int as uint8_t,
                flags: 0x2 as libc::c_int as uint8_t,
                sym: 34 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 15 as libc::c_int as uint8_t,
                flags: 0x2 as libc::c_int as uint8_t,
                sym: 34 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 24 as libc::c_int as uint8_t,
                flags: 0x2 as libc::c_int as uint8_t,
                sym: 34 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 31 as libc::c_int as uint8_t,
                flags: 0x2 as libc::c_int as uint8_t,
                sym: 34 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 41 as libc::c_int as uint8_t,
                flags: 0x2 as libc::c_int as uint8_t,
                sym: 34 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 56 as libc::c_int as uint8_t,
                flags: 0x3 as libc::c_int as uint8_t,
                sym: 34 as libc::c_int as uint8_t,
            };
            init
        },
    ],
    [
        {
            let mut init = decode_el {
                state: 3 as libc::c_int as uint8_t,
                flags: 0x2 as libc::c_int as uint8_t,
                sym: 40 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 6 as libc::c_int as uint8_t,
                flags: 0x2 as libc::c_int as uint8_t,
                sym: 40 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 10 as libc::c_int as uint8_t,
                flags: 0x2 as libc::c_int as uint8_t,
                sym: 40 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 15 as libc::c_int as uint8_t,
                flags: 0x2 as libc::c_int as uint8_t,
                sym: 40 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 24 as libc::c_int as uint8_t,
                flags: 0x2 as libc::c_int as uint8_t,
                sym: 40 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 31 as libc::c_int as uint8_t,
                flags: 0x2 as libc::c_int as uint8_t,
                sym: 40 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 41 as libc::c_int as uint8_t,
                flags: 0x2 as libc::c_int as uint8_t,
                sym: 40 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 56 as libc::c_int as uint8_t,
                flags: 0x3 as libc::c_int as uint8_t,
                sym: 40 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 3 as libc::c_int as uint8_t,
                flags: 0x2 as libc::c_int as uint8_t,
                sym: 41 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 6 as libc::c_int as uint8_t,
                flags: 0x2 as libc::c_int as uint8_t,
                sym: 41 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 10 as libc::c_int as uint8_t,
                flags: 0x2 as libc::c_int as uint8_t,
                sym: 41 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 15 as libc::c_int as uint8_t,
                flags: 0x2 as libc::c_int as uint8_t,
                sym: 41 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 24 as libc::c_int as uint8_t,
                flags: 0x2 as libc::c_int as uint8_t,
                sym: 41 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 31 as libc::c_int as uint8_t,
                flags: 0x2 as libc::c_int as uint8_t,
                sym: 41 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 41 as libc::c_int as uint8_t,
                flags: 0x2 as libc::c_int as uint8_t,
                sym: 41 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 56 as libc::c_int as uint8_t,
                flags: 0x3 as libc::c_int as uint8_t,
                sym: 41 as libc::c_int as uint8_t,
            };
            init
        },
    ],
    [
        {
            let mut init = decode_el {
                state: 2 as libc::c_int as uint8_t,
                flags: 0x2 as libc::c_int as uint8_t,
                sym: 63 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 9 as libc::c_int as uint8_t,
                flags: 0x2 as libc::c_int as uint8_t,
                sym: 63 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 23 as libc::c_int as uint8_t,
                flags: 0x2 as libc::c_int as uint8_t,
                sym: 63 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 40 as libc::c_int as uint8_t,
                flags: 0x3 as libc::c_int as uint8_t,
                sym: 63 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 1 as libc::c_int as uint8_t,
                flags: 0x2 as libc::c_int as uint8_t,
                sym: 39 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 22 as libc::c_int as uint8_t,
                flags: 0x3 as libc::c_int as uint8_t,
                sym: 39 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 1 as libc::c_int as uint8_t,
                flags: 0x2 as libc::c_int as uint8_t,
                sym: 43 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 22 as libc::c_int as uint8_t,
                flags: 0x3 as libc::c_int as uint8_t,
                sym: 43 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 1 as libc::c_int as uint8_t,
                flags: 0x2 as libc::c_int as uint8_t,
                sym: 124 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 22 as libc::c_int as uint8_t,
                flags: 0x3 as libc::c_int as uint8_t,
                sym: 124 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 0 as libc::c_int as uint8_t,
                flags: 0x3 as libc::c_int as uint8_t,
                sym: 35 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 0 as libc::c_int as uint8_t,
                flags: 0x3 as libc::c_int as uint8_t,
                sym: 62 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 86 as libc::c_int as uint8_t,
                flags: 0 as libc::c_int as uint8_t,
                sym: 0 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 87 as libc::c_int as uint8_t,
                flags: 0 as libc::c_int as uint8_t,
                sym: 0 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 89 as libc::c_int as uint8_t,
                flags: 0 as libc::c_int as uint8_t,
                sym: 0 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 90 as libc::c_int as uint8_t,
                flags: 0 as libc::c_int as uint8_t,
                sym: 0 as libc::c_int as uint8_t,
            };
            init
        },
    ],
    [
        {
            let mut init = decode_el {
                state: 3 as libc::c_int as uint8_t,
                flags: 0x2 as libc::c_int as uint8_t,
                sym: 63 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 6 as libc::c_int as uint8_t,
                flags: 0x2 as libc::c_int as uint8_t,
                sym: 63 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 10 as libc::c_int as uint8_t,
                flags: 0x2 as libc::c_int as uint8_t,
                sym: 63 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 15 as libc::c_int as uint8_t,
                flags: 0x2 as libc::c_int as uint8_t,
                sym: 63 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 24 as libc::c_int as uint8_t,
                flags: 0x2 as libc::c_int as uint8_t,
                sym: 63 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 31 as libc::c_int as uint8_t,
                flags: 0x2 as libc::c_int as uint8_t,
                sym: 63 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 41 as libc::c_int as uint8_t,
                flags: 0x2 as libc::c_int as uint8_t,
                sym: 63 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 56 as libc::c_int as uint8_t,
                flags: 0x3 as libc::c_int as uint8_t,
                sym: 63 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 2 as libc::c_int as uint8_t,
                flags: 0x2 as libc::c_int as uint8_t,
                sym: 39 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 9 as libc::c_int as uint8_t,
                flags: 0x2 as libc::c_int as uint8_t,
                sym: 39 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 23 as libc::c_int as uint8_t,
                flags: 0x2 as libc::c_int as uint8_t,
                sym: 39 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 40 as libc::c_int as uint8_t,
                flags: 0x3 as libc::c_int as uint8_t,
                sym: 39 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 2 as libc::c_int as uint8_t,
                flags: 0x2 as libc::c_int as uint8_t,
                sym: 43 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 9 as libc::c_int as uint8_t,
                flags: 0x2 as libc::c_int as uint8_t,
                sym: 43 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 23 as libc::c_int as uint8_t,
                flags: 0x2 as libc::c_int as uint8_t,
                sym: 43 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 40 as libc::c_int as uint8_t,
                flags: 0x3 as libc::c_int as uint8_t,
                sym: 43 as libc::c_int as uint8_t,
            };
            init
        },
    ],
    [
        {
            let mut init = decode_el {
                state: 3 as libc::c_int as uint8_t,
                flags: 0x2 as libc::c_int as uint8_t,
                sym: 39 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 6 as libc::c_int as uint8_t,
                flags: 0x2 as libc::c_int as uint8_t,
                sym: 39 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 10 as libc::c_int as uint8_t,
                flags: 0x2 as libc::c_int as uint8_t,
                sym: 39 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 15 as libc::c_int as uint8_t,
                flags: 0x2 as libc::c_int as uint8_t,
                sym: 39 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 24 as libc::c_int as uint8_t,
                flags: 0x2 as libc::c_int as uint8_t,
                sym: 39 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 31 as libc::c_int as uint8_t,
                flags: 0x2 as libc::c_int as uint8_t,
                sym: 39 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 41 as libc::c_int as uint8_t,
                flags: 0x2 as libc::c_int as uint8_t,
                sym: 39 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 56 as libc::c_int as uint8_t,
                flags: 0x3 as libc::c_int as uint8_t,
                sym: 39 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 3 as libc::c_int as uint8_t,
                flags: 0x2 as libc::c_int as uint8_t,
                sym: 43 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 6 as libc::c_int as uint8_t,
                flags: 0x2 as libc::c_int as uint8_t,
                sym: 43 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 10 as libc::c_int as uint8_t,
                flags: 0x2 as libc::c_int as uint8_t,
                sym: 43 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 15 as libc::c_int as uint8_t,
                flags: 0x2 as libc::c_int as uint8_t,
                sym: 43 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 24 as libc::c_int as uint8_t,
                flags: 0x2 as libc::c_int as uint8_t,
                sym: 43 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 31 as libc::c_int as uint8_t,
                flags: 0x2 as libc::c_int as uint8_t,
                sym: 43 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 41 as libc::c_int as uint8_t,
                flags: 0x2 as libc::c_int as uint8_t,
                sym: 43 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 56 as libc::c_int as uint8_t,
                flags: 0x3 as libc::c_int as uint8_t,
                sym: 43 as libc::c_int as uint8_t,
            };
            init
        },
    ],
    [
        {
            let mut init = decode_el {
                state: 2 as libc::c_int as uint8_t,
                flags: 0x2 as libc::c_int as uint8_t,
                sym: 124 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 9 as libc::c_int as uint8_t,
                flags: 0x2 as libc::c_int as uint8_t,
                sym: 124 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 23 as libc::c_int as uint8_t,
                flags: 0x2 as libc::c_int as uint8_t,
                sym: 124 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 40 as libc::c_int as uint8_t,
                flags: 0x3 as libc::c_int as uint8_t,
                sym: 124 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 1 as libc::c_int as uint8_t,
                flags: 0x2 as libc::c_int as uint8_t,
                sym: 35 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 22 as libc::c_int as uint8_t,
                flags: 0x3 as libc::c_int as uint8_t,
                sym: 35 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 1 as libc::c_int as uint8_t,
                flags: 0x2 as libc::c_int as uint8_t,
                sym: 62 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 22 as libc::c_int as uint8_t,
                flags: 0x3 as libc::c_int as uint8_t,
                sym: 62 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 0 as libc::c_int as uint8_t,
                flags: 0x3 as libc::c_int as uint8_t,
                sym: 0 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 0 as libc::c_int as uint8_t,
                flags: 0x3 as libc::c_int as uint8_t,
                sym: 36 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 0 as libc::c_int as uint8_t,
                flags: 0x3 as libc::c_int as uint8_t,
                sym: 64 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 0 as libc::c_int as uint8_t,
                flags: 0x3 as libc::c_int as uint8_t,
                sym: 91 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 0 as libc::c_int as uint8_t,
                flags: 0x3 as libc::c_int as uint8_t,
                sym: 93 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 0 as libc::c_int as uint8_t,
                flags: 0x3 as libc::c_int as uint8_t,
                sym: 126 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 91 as libc::c_int as uint8_t,
                flags: 0 as libc::c_int as uint8_t,
                sym: 0 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 92 as libc::c_int as uint8_t,
                flags: 0 as libc::c_int as uint8_t,
                sym: 0 as libc::c_int as uint8_t,
            };
            init
        },
    ],
    [
        {
            let mut init = decode_el {
                state: 3 as libc::c_int as uint8_t,
                flags: 0x2 as libc::c_int as uint8_t,
                sym: 124 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 6 as libc::c_int as uint8_t,
                flags: 0x2 as libc::c_int as uint8_t,
                sym: 124 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 10 as libc::c_int as uint8_t,
                flags: 0x2 as libc::c_int as uint8_t,
                sym: 124 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 15 as libc::c_int as uint8_t,
                flags: 0x2 as libc::c_int as uint8_t,
                sym: 124 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 24 as libc::c_int as uint8_t,
                flags: 0x2 as libc::c_int as uint8_t,
                sym: 124 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 31 as libc::c_int as uint8_t,
                flags: 0x2 as libc::c_int as uint8_t,
                sym: 124 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 41 as libc::c_int as uint8_t,
                flags: 0x2 as libc::c_int as uint8_t,
                sym: 124 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 56 as libc::c_int as uint8_t,
                flags: 0x3 as libc::c_int as uint8_t,
                sym: 124 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 2 as libc::c_int as uint8_t,
                flags: 0x2 as libc::c_int as uint8_t,
                sym: 35 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 9 as libc::c_int as uint8_t,
                flags: 0x2 as libc::c_int as uint8_t,
                sym: 35 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 23 as libc::c_int as uint8_t,
                flags: 0x2 as libc::c_int as uint8_t,
                sym: 35 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 40 as libc::c_int as uint8_t,
                flags: 0x3 as libc::c_int as uint8_t,
                sym: 35 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 2 as libc::c_int as uint8_t,
                flags: 0x2 as libc::c_int as uint8_t,
                sym: 62 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 9 as libc::c_int as uint8_t,
                flags: 0x2 as libc::c_int as uint8_t,
                sym: 62 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 23 as libc::c_int as uint8_t,
                flags: 0x2 as libc::c_int as uint8_t,
                sym: 62 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 40 as libc::c_int as uint8_t,
                flags: 0x3 as libc::c_int as uint8_t,
                sym: 62 as libc::c_int as uint8_t,
            };
            init
        },
    ],
    [
        {
            let mut init = decode_el {
                state: 3 as libc::c_int as uint8_t,
                flags: 0x2 as libc::c_int as uint8_t,
                sym: 35 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 6 as libc::c_int as uint8_t,
                flags: 0x2 as libc::c_int as uint8_t,
                sym: 35 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 10 as libc::c_int as uint8_t,
                flags: 0x2 as libc::c_int as uint8_t,
                sym: 35 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 15 as libc::c_int as uint8_t,
                flags: 0x2 as libc::c_int as uint8_t,
                sym: 35 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 24 as libc::c_int as uint8_t,
                flags: 0x2 as libc::c_int as uint8_t,
                sym: 35 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 31 as libc::c_int as uint8_t,
                flags: 0x2 as libc::c_int as uint8_t,
                sym: 35 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 41 as libc::c_int as uint8_t,
                flags: 0x2 as libc::c_int as uint8_t,
                sym: 35 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 56 as libc::c_int as uint8_t,
                flags: 0x3 as libc::c_int as uint8_t,
                sym: 35 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 3 as libc::c_int as uint8_t,
                flags: 0x2 as libc::c_int as uint8_t,
                sym: 62 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 6 as libc::c_int as uint8_t,
                flags: 0x2 as libc::c_int as uint8_t,
                sym: 62 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 10 as libc::c_int as uint8_t,
                flags: 0x2 as libc::c_int as uint8_t,
                sym: 62 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 15 as libc::c_int as uint8_t,
                flags: 0x2 as libc::c_int as uint8_t,
                sym: 62 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 24 as libc::c_int as uint8_t,
                flags: 0x2 as libc::c_int as uint8_t,
                sym: 62 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 31 as libc::c_int as uint8_t,
                flags: 0x2 as libc::c_int as uint8_t,
                sym: 62 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 41 as libc::c_int as uint8_t,
                flags: 0x2 as libc::c_int as uint8_t,
                sym: 62 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 56 as libc::c_int as uint8_t,
                flags: 0x3 as libc::c_int as uint8_t,
                sym: 62 as libc::c_int as uint8_t,
            };
            init
        },
    ],
    [
        {
            let mut init = decode_el {
                state: 1 as libc::c_int as uint8_t,
                flags: 0x2 as libc::c_int as uint8_t,
                sym: 0 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 22 as libc::c_int as uint8_t,
                flags: 0x3 as libc::c_int as uint8_t,
                sym: 0 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 1 as libc::c_int as uint8_t,
                flags: 0x2 as libc::c_int as uint8_t,
                sym: 36 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 22 as libc::c_int as uint8_t,
                flags: 0x3 as libc::c_int as uint8_t,
                sym: 36 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 1 as libc::c_int as uint8_t,
                flags: 0x2 as libc::c_int as uint8_t,
                sym: 64 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 22 as libc::c_int as uint8_t,
                flags: 0x3 as libc::c_int as uint8_t,
                sym: 64 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 1 as libc::c_int as uint8_t,
                flags: 0x2 as libc::c_int as uint8_t,
                sym: 91 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 22 as libc::c_int as uint8_t,
                flags: 0x3 as libc::c_int as uint8_t,
                sym: 91 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 1 as libc::c_int as uint8_t,
                flags: 0x2 as libc::c_int as uint8_t,
                sym: 93 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 22 as libc::c_int as uint8_t,
                flags: 0x3 as libc::c_int as uint8_t,
                sym: 93 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 1 as libc::c_int as uint8_t,
                flags: 0x2 as libc::c_int as uint8_t,
                sym: 126 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 22 as libc::c_int as uint8_t,
                flags: 0x3 as libc::c_int as uint8_t,
                sym: 126 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 0 as libc::c_int as uint8_t,
                flags: 0x3 as libc::c_int as uint8_t,
                sym: 94 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 0 as libc::c_int as uint8_t,
                flags: 0x3 as libc::c_int as uint8_t,
                sym: 125 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 93 as libc::c_int as uint8_t,
                flags: 0 as libc::c_int as uint8_t,
                sym: 0 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 94 as libc::c_int as uint8_t,
                flags: 0 as libc::c_int as uint8_t,
                sym: 0 as libc::c_int as uint8_t,
            };
            init
        },
    ],
    [
        {
            let mut init = decode_el {
                state: 2 as libc::c_int as uint8_t,
                flags: 0x2 as libc::c_int as uint8_t,
                sym: 0 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 9 as libc::c_int as uint8_t,
                flags: 0x2 as libc::c_int as uint8_t,
                sym: 0 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 23 as libc::c_int as uint8_t,
                flags: 0x2 as libc::c_int as uint8_t,
                sym: 0 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 40 as libc::c_int as uint8_t,
                flags: 0x3 as libc::c_int as uint8_t,
                sym: 0 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 2 as libc::c_int as uint8_t,
                flags: 0x2 as libc::c_int as uint8_t,
                sym: 36 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 9 as libc::c_int as uint8_t,
                flags: 0x2 as libc::c_int as uint8_t,
                sym: 36 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 23 as libc::c_int as uint8_t,
                flags: 0x2 as libc::c_int as uint8_t,
                sym: 36 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 40 as libc::c_int as uint8_t,
                flags: 0x3 as libc::c_int as uint8_t,
                sym: 36 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 2 as libc::c_int as uint8_t,
                flags: 0x2 as libc::c_int as uint8_t,
                sym: 64 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 9 as libc::c_int as uint8_t,
                flags: 0x2 as libc::c_int as uint8_t,
                sym: 64 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 23 as libc::c_int as uint8_t,
                flags: 0x2 as libc::c_int as uint8_t,
                sym: 64 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 40 as libc::c_int as uint8_t,
                flags: 0x3 as libc::c_int as uint8_t,
                sym: 64 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 2 as libc::c_int as uint8_t,
                flags: 0x2 as libc::c_int as uint8_t,
                sym: 91 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 9 as libc::c_int as uint8_t,
                flags: 0x2 as libc::c_int as uint8_t,
                sym: 91 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 23 as libc::c_int as uint8_t,
                flags: 0x2 as libc::c_int as uint8_t,
                sym: 91 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 40 as libc::c_int as uint8_t,
                flags: 0x3 as libc::c_int as uint8_t,
                sym: 91 as libc::c_int as uint8_t,
            };
            init
        },
    ],
    [
        {
            let mut init = decode_el {
                state: 3 as libc::c_int as uint8_t,
                flags: 0x2 as libc::c_int as uint8_t,
                sym: 0 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 6 as libc::c_int as uint8_t,
                flags: 0x2 as libc::c_int as uint8_t,
                sym: 0 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 10 as libc::c_int as uint8_t,
                flags: 0x2 as libc::c_int as uint8_t,
                sym: 0 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 15 as libc::c_int as uint8_t,
                flags: 0x2 as libc::c_int as uint8_t,
                sym: 0 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 24 as libc::c_int as uint8_t,
                flags: 0x2 as libc::c_int as uint8_t,
                sym: 0 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 31 as libc::c_int as uint8_t,
                flags: 0x2 as libc::c_int as uint8_t,
                sym: 0 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 41 as libc::c_int as uint8_t,
                flags: 0x2 as libc::c_int as uint8_t,
                sym: 0 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 56 as libc::c_int as uint8_t,
                flags: 0x3 as libc::c_int as uint8_t,
                sym: 0 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 3 as libc::c_int as uint8_t,
                flags: 0x2 as libc::c_int as uint8_t,
                sym: 36 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 6 as libc::c_int as uint8_t,
                flags: 0x2 as libc::c_int as uint8_t,
                sym: 36 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 10 as libc::c_int as uint8_t,
                flags: 0x2 as libc::c_int as uint8_t,
                sym: 36 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 15 as libc::c_int as uint8_t,
                flags: 0x2 as libc::c_int as uint8_t,
                sym: 36 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 24 as libc::c_int as uint8_t,
                flags: 0x2 as libc::c_int as uint8_t,
                sym: 36 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 31 as libc::c_int as uint8_t,
                flags: 0x2 as libc::c_int as uint8_t,
                sym: 36 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 41 as libc::c_int as uint8_t,
                flags: 0x2 as libc::c_int as uint8_t,
                sym: 36 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 56 as libc::c_int as uint8_t,
                flags: 0x3 as libc::c_int as uint8_t,
                sym: 36 as libc::c_int as uint8_t,
            };
            init
        },
    ],
    [
        {
            let mut init = decode_el {
                state: 3 as libc::c_int as uint8_t,
                flags: 0x2 as libc::c_int as uint8_t,
                sym: 64 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 6 as libc::c_int as uint8_t,
                flags: 0x2 as libc::c_int as uint8_t,
                sym: 64 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 10 as libc::c_int as uint8_t,
                flags: 0x2 as libc::c_int as uint8_t,
                sym: 64 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 15 as libc::c_int as uint8_t,
                flags: 0x2 as libc::c_int as uint8_t,
                sym: 64 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 24 as libc::c_int as uint8_t,
                flags: 0x2 as libc::c_int as uint8_t,
                sym: 64 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 31 as libc::c_int as uint8_t,
                flags: 0x2 as libc::c_int as uint8_t,
                sym: 64 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 41 as libc::c_int as uint8_t,
                flags: 0x2 as libc::c_int as uint8_t,
                sym: 64 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 56 as libc::c_int as uint8_t,
                flags: 0x3 as libc::c_int as uint8_t,
                sym: 64 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 3 as libc::c_int as uint8_t,
                flags: 0x2 as libc::c_int as uint8_t,
                sym: 91 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 6 as libc::c_int as uint8_t,
                flags: 0x2 as libc::c_int as uint8_t,
                sym: 91 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 10 as libc::c_int as uint8_t,
                flags: 0x2 as libc::c_int as uint8_t,
                sym: 91 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 15 as libc::c_int as uint8_t,
                flags: 0x2 as libc::c_int as uint8_t,
                sym: 91 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 24 as libc::c_int as uint8_t,
                flags: 0x2 as libc::c_int as uint8_t,
                sym: 91 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 31 as libc::c_int as uint8_t,
                flags: 0x2 as libc::c_int as uint8_t,
                sym: 91 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 41 as libc::c_int as uint8_t,
                flags: 0x2 as libc::c_int as uint8_t,
                sym: 91 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 56 as libc::c_int as uint8_t,
                flags: 0x3 as libc::c_int as uint8_t,
                sym: 91 as libc::c_int as uint8_t,
            };
            init
        },
    ],
    [
        {
            let mut init = decode_el {
                state: 2 as libc::c_int as uint8_t,
                flags: 0x2 as libc::c_int as uint8_t,
                sym: 93 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 9 as libc::c_int as uint8_t,
                flags: 0x2 as libc::c_int as uint8_t,
                sym: 93 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 23 as libc::c_int as uint8_t,
                flags: 0x2 as libc::c_int as uint8_t,
                sym: 93 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 40 as libc::c_int as uint8_t,
                flags: 0x3 as libc::c_int as uint8_t,
                sym: 93 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 2 as libc::c_int as uint8_t,
                flags: 0x2 as libc::c_int as uint8_t,
                sym: 126 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 9 as libc::c_int as uint8_t,
                flags: 0x2 as libc::c_int as uint8_t,
                sym: 126 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 23 as libc::c_int as uint8_t,
                flags: 0x2 as libc::c_int as uint8_t,
                sym: 126 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 40 as libc::c_int as uint8_t,
                flags: 0x3 as libc::c_int as uint8_t,
                sym: 126 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 1 as libc::c_int as uint8_t,
                flags: 0x2 as libc::c_int as uint8_t,
                sym: 94 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 22 as libc::c_int as uint8_t,
                flags: 0x3 as libc::c_int as uint8_t,
                sym: 94 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 1 as libc::c_int as uint8_t,
                flags: 0x2 as libc::c_int as uint8_t,
                sym: 125 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 22 as libc::c_int as uint8_t,
                flags: 0x3 as libc::c_int as uint8_t,
                sym: 125 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 0 as libc::c_int as uint8_t,
                flags: 0x3 as libc::c_int as uint8_t,
                sym: 60 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 0 as libc::c_int as uint8_t,
                flags: 0x3 as libc::c_int as uint8_t,
                sym: 96 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 0 as libc::c_int as uint8_t,
                flags: 0x3 as libc::c_int as uint8_t,
                sym: 123 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 95 as libc::c_int as uint8_t,
                flags: 0 as libc::c_int as uint8_t,
                sym: 0 as libc::c_int as uint8_t,
            };
            init
        },
    ],
    [
        {
            let mut init = decode_el {
                state: 3 as libc::c_int as uint8_t,
                flags: 0x2 as libc::c_int as uint8_t,
                sym: 93 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 6 as libc::c_int as uint8_t,
                flags: 0x2 as libc::c_int as uint8_t,
                sym: 93 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 10 as libc::c_int as uint8_t,
                flags: 0x2 as libc::c_int as uint8_t,
                sym: 93 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 15 as libc::c_int as uint8_t,
                flags: 0x2 as libc::c_int as uint8_t,
                sym: 93 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 24 as libc::c_int as uint8_t,
                flags: 0x2 as libc::c_int as uint8_t,
                sym: 93 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 31 as libc::c_int as uint8_t,
                flags: 0x2 as libc::c_int as uint8_t,
                sym: 93 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 41 as libc::c_int as uint8_t,
                flags: 0x2 as libc::c_int as uint8_t,
                sym: 93 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 56 as libc::c_int as uint8_t,
                flags: 0x3 as libc::c_int as uint8_t,
                sym: 93 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 3 as libc::c_int as uint8_t,
                flags: 0x2 as libc::c_int as uint8_t,
                sym: 126 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 6 as libc::c_int as uint8_t,
                flags: 0x2 as libc::c_int as uint8_t,
                sym: 126 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 10 as libc::c_int as uint8_t,
                flags: 0x2 as libc::c_int as uint8_t,
                sym: 126 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 15 as libc::c_int as uint8_t,
                flags: 0x2 as libc::c_int as uint8_t,
                sym: 126 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 24 as libc::c_int as uint8_t,
                flags: 0x2 as libc::c_int as uint8_t,
                sym: 126 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 31 as libc::c_int as uint8_t,
                flags: 0x2 as libc::c_int as uint8_t,
                sym: 126 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 41 as libc::c_int as uint8_t,
                flags: 0x2 as libc::c_int as uint8_t,
                sym: 126 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 56 as libc::c_int as uint8_t,
                flags: 0x3 as libc::c_int as uint8_t,
                sym: 126 as libc::c_int as uint8_t,
            };
            init
        },
    ],
    [
        {
            let mut init = decode_el {
                state: 2 as libc::c_int as uint8_t,
                flags: 0x2 as libc::c_int as uint8_t,
                sym: 94 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 9 as libc::c_int as uint8_t,
                flags: 0x2 as libc::c_int as uint8_t,
                sym: 94 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 23 as libc::c_int as uint8_t,
                flags: 0x2 as libc::c_int as uint8_t,
                sym: 94 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 40 as libc::c_int as uint8_t,
                flags: 0x3 as libc::c_int as uint8_t,
                sym: 94 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 2 as libc::c_int as uint8_t,
                flags: 0x2 as libc::c_int as uint8_t,
                sym: 125 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 9 as libc::c_int as uint8_t,
                flags: 0x2 as libc::c_int as uint8_t,
                sym: 125 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 23 as libc::c_int as uint8_t,
                flags: 0x2 as libc::c_int as uint8_t,
                sym: 125 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 40 as libc::c_int as uint8_t,
                flags: 0x3 as libc::c_int as uint8_t,
                sym: 125 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 1 as libc::c_int as uint8_t,
                flags: 0x2 as libc::c_int as uint8_t,
                sym: 60 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 22 as libc::c_int as uint8_t,
                flags: 0x3 as libc::c_int as uint8_t,
                sym: 60 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 1 as libc::c_int as uint8_t,
                flags: 0x2 as libc::c_int as uint8_t,
                sym: 96 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 22 as libc::c_int as uint8_t,
                flags: 0x3 as libc::c_int as uint8_t,
                sym: 96 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 1 as libc::c_int as uint8_t,
                flags: 0x2 as libc::c_int as uint8_t,
                sym: 123 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 22 as libc::c_int as uint8_t,
                flags: 0x3 as libc::c_int as uint8_t,
                sym: 123 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 96 as libc::c_int as uint8_t,
                flags: 0 as libc::c_int as uint8_t,
                sym: 0 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 110 as libc::c_int as uint8_t,
                flags: 0 as libc::c_int as uint8_t,
                sym: 0 as libc::c_int as uint8_t,
            };
            init
        },
    ],
    [
        {
            let mut init = decode_el {
                state: 3 as libc::c_int as uint8_t,
                flags: 0x2 as libc::c_int as uint8_t,
                sym: 94 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 6 as libc::c_int as uint8_t,
                flags: 0x2 as libc::c_int as uint8_t,
                sym: 94 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 10 as libc::c_int as uint8_t,
                flags: 0x2 as libc::c_int as uint8_t,
                sym: 94 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 15 as libc::c_int as uint8_t,
                flags: 0x2 as libc::c_int as uint8_t,
                sym: 94 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 24 as libc::c_int as uint8_t,
                flags: 0x2 as libc::c_int as uint8_t,
                sym: 94 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 31 as libc::c_int as uint8_t,
                flags: 0x2 as libc::c_int as uint8_t,
                sym: 94 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 41 as libc::c_int as uint8_t,
                flags: 0x2 as libc::c_int as uint8_t,
                sym: 94 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 56 as libc::c_int as uint8_t,
                flags: 0x3 as libc::c_int as uint8_t,
                sym: 94 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 3 as libc::c_int as uint8_t,
                flags: 0x2 as libc::c_int as uint8_t,
                sym: 125 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 6 as libc::c_int as uint8_t,
                flags: 0x2 as libc::c_int as uint8_t,
                sym: 125 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 10 as libc::c_int as uint8_t,
                flags: 0x2 as libc::c_int as uint8_t,
                sym: 125 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 15 as libc::c_int as uint8_t,
                flags: 0x2 as libc::c_int as uint8_t,
                sym: 125 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 24 as libc::c_int as uint8_t,
                flags: 0x2 as libc::c_int as uint8_t,
                sym: 125 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 31 as libc::c_int as uint8_t,
                flags: 0x2 as libc::c_int as uint8_t,
                sym: 125 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 41 as libc::c_int as uint8_t,
                flags: 0x2 as libc::c_int as uint8_t,
                sym: 125 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 56 as libc::c_int as uint8_t,
                flags: 0x3 as libc::c_int as uint8_t,
                sym: 125 as libc::c_int as uint8_t,
            };
            init
        },
    ],
    [
        {
            let mut init = decode_el {
                state: 2 as libc::c_int as uint8_t,
                flags: 0x2 as libc::c_int as uint8_t,
                sym: 60 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 9 as libc::c_int as uint8_t,
                flags: 0x2 as libc::c_int as uint8_t,
                sym: 60 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 23 as libc::c_int as uint8_t,
                flags: 0x2 as libc::c_int as uint8_t,
                sym: 60 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 40 as libc::c_int as uint8_t,
                flags: 0x3 as libc::c_int as uint8_t,
                sym: 60 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 2 as libc::c_int as uint8_t,
                flags: 0x2 as libc::c_int as uint8_t,
                sym: 96 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 9 as libc::c_int as uint8_t,
                flags: 0x2 as libc::c_int as uint8_t,
                sym: 96 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 23 as libc::c_int as uint8_t,
                flags: 0x2 as libc::c_int as uint8_t,
                sym: 96 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 40 as libc::c_int as uint8_t,
                flags: 0x3 as libc::c_int as uint8_t,
                sym: 96 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 2 as libc::c_int as uint8_t,
                flags: 0x2 as libc::c_int as uint8_t,
                sym: 123 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 9 as libc::c_int as uint8_t,
                flags: 0x2 as libc::c_int as uint8_t,
                sym: 123 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 23 as libc::c_int as uint8_t,
                flags: 0x2 as libc::c_int as uint8_t,
                sym: 123 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 40 as libc::c_int as uint8_t,
                flags: 0x3 as libc::c_int as uint8_t,
                sym: 123 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 97 as libc::c_int as uint8_t,
                flags: 0 as libc::c_int as uint8_t,
                sym: 0 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 101 as libc::c_int as uint8_t,
                flags: 0 as libc::c_int as uint8_t,
                sym: 0 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 111 as libc::c_int as uint8_t,
                flags: 0 as libc::c_int as uint8_t,
                sym: 0 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 133 as libc::c_int as uint8_t,
                flags: 0 as libc::c_int as uint8_t,
                sym: 0 as libc::c_int as uint8_t,
            };
            init
        },
    ],
    [
        {
            let mut init = decode_el {
                state: 3 as libc::c_int as uint8_t,
                flags: 0x2 as libc::c_int as uint8_t,
                sym: 60 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 6 as libc::c_int as uint8_t,
                flags: 0x2 as libc::c_int as uint8_t,
                sym: 60 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 10 as libc::c_int as uint8_t,
                flags: 0x2 as libc::c_int as uint8_t,
                sym: 60 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 15 as libc::c_int as uint8_t,
                flags: 0x2 as libc::c_int as uint8_t,
                sym: 60 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 24 as libc::c_int as uint8_t,
                flags: 0x2 as libc::c_int as uint8_t,
                sym: 60 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 31 as libc::c_int as uint8_t,
                flags: 0x2 as libc::c_int as uint8_t,
                sym: 60 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 41 as libc::c_int as uint8_t,
                flags: 0x2 as libc::c_int as uint8_t,
                sym: 60 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 56 as libc::c_int as uint8_t,
                flags: 0x3 as libc::c_int as uint8_t,
                sym: 60 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 3 as libc::c_int as uint8_t,
                flags: 0x2 as libc::c_int as uint8_t,
                sym: 96 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 6 as libc::c_int as uint8_t,
                flags: 0x2 as libc::c_int as uint8_t,
                sym: 96 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 10 as libc::c_int as uint8_t,
                flags: 0x2 as libc::c_int as uint8_t,
                sym: 96 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 15 as libc::c_int as uint8_t,
                flags: 0x2 as libc::c_int as uint8_t,
                sym: 96 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 24 as libc::c_int as uint8_t,
                flags: 0x2 as libc::c_int as uint8_t,
                sym: 96 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 31 as libc::c_int as uint8_t,
                flags: 0x2 as libc::c_int as uint8_t,
                sym: 96 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 41 as libc::c_int as uint8_t,
                flags: 0x2 as libc::c_int as uint8_t,
                sym: 96 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 56 as libc::c_int as uint8_t,
                flags: 0x3 as libc::c_int as uint8_t,
                sym: 96 as libc::c_int as uint8_t,
            };
            init
        },
    ],
    [
        {
            let mut init = decode_el {
                state: 3 as libc::c_int as uint8_t,
                flags: 0x2 as libc::c_int as uint8_t,
                sym: 123 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 6 as libc::c_int as uint8_t,
                flags: 0x2 as libc::c_int as uint8_t,
                sym: 123 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 10 as libc::c_int as uint8_t,
                flags: 0x2 as libc::c_int as uint8_t,
                sym: 123 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 15 as libc::c_int as uint8_t,
                flags: 0x2 as libc::c_int as uint8_t,
                sym: 123 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 24 as libc::c_int as uint8_t,
                flags: 0x2 as libc::c_int as uint8_t,
                sym: 123 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 31 as libc::c_int as uint8_t,
                flags: 0x2 as libc::c_int as uint8_t,
                sym: 123 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 41 as libc::c_int as uint8_t,
                flags: 0x2 as libc::c_int as uint8_t,
                sym: 123 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 56 as libc::c_int as uint8_t,
                flags: 0x3 as libc::c_int as uint8_t,
                sym: 123 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 98 as libc::c_int as uint8_t,
                flags: 0 as libc::c_int as uint8_t,
                sym: 0 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 99 as libc::c_int as uint8_t,
                flags: 0 as libc::c_int as uint8_t,
                sym: 0 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 102 as libc::c_int as uint8_t,
                flags: 0 as libc::c_int as uint8_t,
                sym: 0 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 105 as libc::c_int as uint8_t,
                flags: 0 as libc::c_int as uint8_t,
                sym: 0 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 112 as libc::c_int as uint8_t,
                flags: 0 as libc::c_int as uint8_t,
                sym: 0 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 119 as libc::c_int as uint8_t,
                flags: 0 as libc::c_int as uint8_t,
                sym: 0 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 134 as libc::c_int as uint8_t,
                flags: 0 as libc::c_int as uint8_t,
                sym: 0 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 153 as libc::c_int as uint8_t,
                flags: 0 as libc::c_int as uint8_t,
                sym: 0 as libc::c_int as uint8_t,
            };
            init
        },
    ],
    [
        {
            let mut init = decode_el {
                state: 0 as libc::c_int as uint8_t,
                flags: 0x3 as libc::c_int as uint8_t,
                sym: 92 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 0 as libc::c_int as uint8_t,
                flags: 0x3 as libc::c_int as uint8_t,
                sym: 195 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 0 as libc::c_int as uint8_t,
                flags: 0x3 as libc::c_int as uint8_t,
                sym: 208 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 100 as libc::c_int as uint8_t,
                flags: 0 as libc::c_int as uint8_t,
                sym: 0 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 103 as libc::c_int as uint8_t,
                flags: 0 as libc::c_int as uint8_t,
                sym: 0 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 104 as libc::c_int as uint8_t,
                flags: 0 as libc::c_int as uint8_t,
                sym: 0 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 106 as libc::c_int as uint8_t,
                flags: 0 as libc::c_int as uint8_t,
                sym: 0 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 107 as libc::c_int as uint8_t,
                flags: 0 as libc::c_int as uint8_t,
                sym: 0 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 113 as libc::c_int as uint8_t,
                flags: 0 as libc::c_int as uint8_t,
                sym: 0 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 116 as libc::c_int as uint8_t,
                flags: 0 as libc::c_int as uint8_t,
                sym: 0 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 120 as libc::c_int as uint8_t,
                flags: 0 as libc::c_int as uint8_t,
                sym: 0 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 126 as libc::c_int as uint8_t,
                flags: 0 as libc::c_int as uint8_t,
                sym: 0 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 135 as libc::c_int as uint8_t,
                flags: 0 as libc::c_int as uint8_t,
                sym: 0 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 142 as libc::c_int as uint8_t,
                flags: 0 as libc::c_int as uint8_t,
                sym: 0 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 154 as libc::c_int as uint8_t,
                flags: 0 as libc::c_int as uint8_t,
                sym: 0 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 169 as libc::c_int as uint8_t,
                flags: 0 as libc::c_int as uint8_t,
                sym: 0 as libc::c_int as uint8_t,
            };
            init
        },
    ],
    [
        {
            let mut init = decode_el {
                state: 1 as libc::c_int as uint8_t,
                flags: 0x2 as libc::c_int as uint8_t,
                sym: 92 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 22 as libc::c_int as uint8_t,
                flags: 0x3 as libc::c_int as uint8_t,
                sym: 92 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 1 as libc::c_int as uint8_t,
                flags: 0x2 as libc::c_int as uint8_t,
                sym: 195 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 22 as libc::c_int as uint8_t,
                flags: 0x3 as libc::c_int as uint8_t,
                sym: 195 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 1 as libc::c_int as uint8_t,
                flags: 0x2 as libc::c_int as uint8_t,
                sym: 208 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 22 as libc::c_int as uint8_t,
                flags: 0x3 as libc::c_int as uint8_t,
                sym: 208 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 0 as libc::c_int as uint8_t,
                flags: 0x3 as libc::c_int as uint8_t,
                sym: 128 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 0 as libc::c_int as uint8_t,
                flags: 0x3 as libc::c_int as uint8_t,
                sym: 130 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 0 as libc::c_int as uint8_t,
                flags: 0x3 as libc::c_int as uint8_t,
                sym: 131 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 0 as libc::c_int as uint8_t,
                flags: 0x3 as libc::c_int as uint8_t,
                sym: 162 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 0 as libc::c_int as uint8_t,
                flags: 0x3 as libc::c_int as uint8_t,
                sym: 184 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 0 as libc::c_int as uint8_t,
                flags: 0x3 as libc::c_int as uint8_t,
                sym: 194 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 0 as libc::c_int as uint8_t,
                flags: 0x3 as libc::c_int as uint8_t,
                sym: 224 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 0 as libc::c_int as uint8_t,
                flags: 0x3 as libc::c_int as uint8_t,
                sym: 226 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 108 as libc::c_int as uint8_t,
                flags: 0 as libc::c_int as uint8_t,
                sym: 0 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 109 as libc::c_int as uint8_t,
                flags: 0 as libc::c_int as uint8_t,
                sym: 0 as libc::c_int as uint8_t,
            };
            init
        },
    ],
    [
        {
            let mut init = decode_el {
                state: 2 as libc::c_int as uint8_t,
                flags: 0x2 as libc::c_int as uint8_t,
                sym: 92 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 9 as libc::c_int as uint8_t,
                flags: 0x2 as libc::c_int as uint8_t,
                sym: 92 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 23 as libc::c_int as uint8_t,
                flags: 0x2 as libc::c_int as uint8_t,
                sym: 92 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 40 as libc::c_int as uint8_t,
                flags: 0x3 as libc::c_int as uint8_t,
                sym: 92 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 2 as libc::c_int as uint8_t,
                flags: 0x2 as libc::c_int as uint8_t,
                sym: 195 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 9 as libc::c_int as uint8_t,
                flags: 0x2 as libc::c_int as uint8_t,
                sym: 195 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 23 as libc::c_int as uint8_t,
                flags: 0x2 as libc::c_int as uint8_t,
                sym: 195 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 40 as libc::c_int as uint8_t,
                flags: 0x3 as libc::c_int as uint8_t,
                sym: 195 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 2 as libc::c_int as uint8_t,
                flags: 0x2 as libc::c_int as uint8_t,
                sym: 208 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 9 as libc::c_int as uint8_t,
                flags: 0x2 as libc::c_int as uint8_t,
                sym: 208 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 23 as libc::c_int as uint8_t,
                flags: 0x2 as libc::c_int as uint8_t,
                sym: 208 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 40 as libc::c_int as uint8_t,
                flags: 0x3 as libc::c_int as uint8_t,
                sym: 208 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 1 as libc::c_int as uint8_t,
                flags: 0x2 as libc::c_int as uint8_t,
                sym: 128 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 22 as libc::c_int as uint8_t,
                flags: 0x3 as libc::c_int as uint8_t,
                sym: 128 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 1 as libc::c_int as uint8_t,
                flags: 0x2 as libc::c_int as uint8_t,
                sym: 130 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 22 as libc::c_int as uint8_t,
                flags: 0x3 as libc::c_int as uint8_t,
                sym: 130 as libc::c_int as uint8_t,
            };
            init
        },
    ],
    [
        {
            let mut init = decode_el {
                state: 3 as libc::c_int as uint8_t,
                flags: 0x2 as libc::c_int as uint8_t,
                sym: 92 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 6 as libc::c_int as uint8_t,
                flags: 0x2 as libc::c_int as uint8_t,
                sym: 92 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 10 as libc::c_int as uint8_t,
                flags: 0x2 as libc::c_int as uint8_t,
                sym: 92 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 15 as libc::c_int as uint8_t,
                flags: 0x2 as libc::c_int as uint8_t,
                sym: 92 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 24 as libc::c_int as uint8_t,
                flags: 0x2 as libc::c_int as uint8_t,
                sym: 92 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 31 as libc::c_int as uint8_t,
                flags: 0x2 as libc::c_int as uint8_t,
                sym: 92 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 41 as libc::c_int as uint8_t,
                flags: 0x2 as libc::c_int as uint8_t,
                sym: 92 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 56 as libc::c_int as uint8_t,
                flags: 0x3 as libc::c_int as uint8_t,
                sym: 92 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 3 as libc::c_int as uint8_t,
                flags: 0x2 as libc::c_int as uint8_t,
                sym: 195 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 6 as libc::c_int as uint8_t,
                flags: 0x2 as libc::c_int as uint8_t,
                sym: 195 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 10 as libc::c_int as uint8_t,
                flags: 0x2 as libc::c_int as uint8_t,
                sym: 195 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 15 as libc::c_int as uint8_t,
                flags: 0x2 as libc::c_int as uint8_t,
                sym: 195 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 24 as libc::c_int as uint8_t,
                flags: 0x2 as libc::c_int as uint8_t,
                sym: 195 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 31 as libc::c_int as uint8_t,
                flags: 0x2 as libc::c_int as uint8_t,
                sym: 195 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 41 as libc::c_int as uint8_t,
                flags: 0x2 as libc::c_int as uint8_t,
                sym: 195 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 56 as libc::c_int as uint8_t,
                flags: 0x3 as libc::c_int as uint8_t,
                sym: 195 as libc::c_int as uint8_t,
            };
            init
        },
    ],
    [
        {
            let mut init = decode_el {
                state: 3 as libc::c_int as uint8_t,
                flags: 0x2 as libc::c_int as uint8_t,
                sym: 208 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 6 as libc::c_int as uint8_t,
                flags: 0x2 as libc::c_int as uint8_t,
                sym: 208 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 10 as libc::c_int as uint8_t,
                flags: 0x2 as libc::c_int as uint8_t,
                sym: 208 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 15 as libc::c_int as uint8_t,
                flags: 0x2 as libc::c_int as uint8_t,
                sym: 208 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 24 as libc::c_int as uint8_t,
                flags: 0x2 as libc::c_int as uint8_t,
                sym: 208 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 31 as libc::c_int as uint8_t,
                flags: 0x2 as libc::c_int as uint8_t,
                sym: 208 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 41 as libc::c_int as uint8_t,
                flags: 0x2 as libc::c_int as uint8_t,
                sym: 208 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 56 as libc::c_int as uint8_t,
                flags: 0x3 as libc::c_int as uint8_t,
                sym: 208 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 2 as libc::c_int as uint8_t,
                flags: 0x2 as libc::c_int as uint8_t,
                sym: 128 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 9 as libc::c_int as uint8_t,
                flags: 0x2 as libc::c_int as uint8_t,
                sym: 128 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 23 as libc::c_int as uint8_t,
                flags: 0x2 as libc::c_int as uint8_t,
                sym: 128 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 40 as libc::c_int as uint8_t,
                flags: 0x3 as libc::c_int as uint8_t,
                sym: 128 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 2 as libc::c_int as uint8_t,
                flags: 0x2 as libc::c_int as uint8_t,
                sym: 130 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 9 as libc::c_int as uint8_t,
                flags: 0x2 as libc::c_int as uint8_t,
                sym: 130 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 23 as libc::c_int as uint8_t,
                flags: 0x2 as libc::c_int as uint8_t,
                sym: 130 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 40 as libc::c_int as uint8_t,
                flags: 0x3 as libc::c_int as uint8_t,
                sym: 130 as libc::c_int as uint8_t,
            };
            init
        },
    ],
    [
        {
            let mut init = decode_el {
                state: 3 as libc::c_int as uint8_t,
                flags: 0x2 as libc::c_int as uint8_t,
                sym: 128 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 6 as libc::c_int as uint8_t,
                flags: 0x2 as libc::c_int as uint8_t,
                sym: 128 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 10 as libc::c_int as uint8_t,
                flags: 0x2 as libc::c_int as uint8_t,
                sym: 128 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 15 as libc::c_int as uint8_t,
                flags: 0x2 as libc::c_int as uint8_t,
                sym: 128 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 24 as libc::c_int as uint8_t,
                flags: 0x2 as libc::c_int as uint8_t,
                sym: 128 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 31 as libc::c_int as uint8_t,
                flags: 0x2 as libc::c_int as uint8_t,
                sym: 128 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 41 as libc::c_int as uint8_t,
                flags: 0x2 as libc::c_int as uint8_t,
                sym: 128 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 56 as libc::c_int as uint8_t,
                flags: 0x3 as libc::c_int as uint8_t,
                sym: 128 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 3 as libc::c_int as uint8_t,
                flags: 0x2 as libc::c_int as uint8_t,
                sym: 130 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 6 as libc::c_int as uint8_t,
                flags: 0x2 as libc::c_int as uint8_t,
                sym: 130 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 10 as libc::c_int as uint8_t,
                flags: 0x2 as libc::c_int as uint8_t,
                sym: 130 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 15 as libc::c_int as uint8_t,
                flags: 0x2 as libc::c_int as uint8_t,
                sym: 130 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 24 as libc::c_int as uint8_t,
                flags: 0x2 as libc::c_int as uint8_t,
                sym: 130 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 31 as libc::c_int as uint8_t,
                flags: 0x2 as libc::c_int as uint8_t,
                sym: 130 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 41 as libc::c_int as uint8_t,
                flags: 0x2 as libc::c_int as uint8_t,
                sym: 130 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 56 as libc::c_int as uint8_t,
                flags: 0x3 as libc::c_int as uint8_t,
                sym: 130 as libc::c_int as uint8_t,
            };
            init
        },
    ],
    [
        {
            let mut init = decode_el {
                state: 1 as libc::c_int as uint8_t,
                flags: 0x2 as libc::c_int as uint8_t,
                sym: 131 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 22 as libc::c_int as uint8_t,
                flags: 0x3 as libc::c_int as uint8_t,
                sym: 131 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 1 as libc::c_int as uint8_t,
                flags: 0x2 as libc::c_int as uint8_t,
                sym: 162 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 22 as libc::c_int as uint8_t,
                flags: 0x3 as libc::c_int as uint8_t,
                sym: 162 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 1 as libc::c_int as uint8_t,
                flags: 0x2 as libc::c_int as uint8_t,
                sym: 184 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 22 as libc::c_int as uint8_t,
                flags: 0x3 as libc::c_int as uint8_t,
                sym: 184 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 1 as libc::c_int as uint8_t,
                flags: 0x2 as libc::c_int as uint8_t,
                sym: 194 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 22 as libc::c_int as uint8_t,
                flags: 0x3 as libc::c_int as uint8_t,
                sym: 194 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 1 as libc::c_int as uint8_t,
                flags: 0x2 as libc::c_int as uint8_t,
                sym: 224 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 22 as libc::c_int as uint8_t,
                flags: 0x3 as libc::c_int as uint8_t,
                sym: 224 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 1 as libc::c_int as uint8_t,
                flags: 0x2 as libc::c_int as uint8_t,
                sym: 226 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 22 as libc::c_int as uint8_t,
                flags: 0x3 as libc::c_int as uint8_t,
                sym: 226 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 0 as libc::c_int as uint8_t,
                flags: 0x3 as libc::c_int as uint8_t,
                sym: 153 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 0 as libc::c_int as uint8_t,
                flags: 0x3 as libc::c_int as uint8_t,
                sym: 161 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 0 as libc::c_int as uint8_t,
                flags: 0x3 as libc::c_int as uint8_t,
                sym: 167 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 0 as libc::c_int as uint8_t,
                flags: 0x3 as libc::c_int as uint8_t,
                sym: 172 as libc::c_int as uint8_t,
            };
            init
        },
    ],
    [
        {
            let mut init = decode_el {
                state: 2 as libc::c_int as uint8_t,
                flags: 0x2 as libc::c_int as uint8_t,
                sym: 131 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 9 as libc::c_int as uint8_t,
                flags: 0x2 as libc::c_int as uint8_t,
                sym: 131 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 23 as libc::c_int as uint8_t,
                flags: 0x2 as libc::c_int as uint8_t,
                sym: 131 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 40 as libc::c_int as uint8_t,
                flags: 0x3 as libc::c_int as uint8_t,
                sym: 131 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 2 as libc::c_int as uint8_t,
                flags: 0x2 as libc::c_int as uint8_t,
                sym: 162 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 9 as libc::c_int as uint8_t,
                flags: 0x2 as libc::c_int as uint8_t,
                sym: 162 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 23 as libc::c_int as uint8_t,
                flags: 0x2 as libc::c_int as uint8_t,
                sym: 162 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 40 as libc::c_int as uint8_t,
                flags: 0x3 as libc::c_int as uint8_t,
                sym: 162 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 2 as libc::c_int as uint8_t,
                flags: 0x2 as libc::c_int as uint8_t,
                sym: 184 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 9 as libc::c_int as uint8_t,
                flags: 0x2 as libc::c_int as uint8_t,
                sym: 184 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 23 as libc::c_int as uint8_t,
                flags: 0x2 as libc::c_int as uint8_t,
                sym: 184 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 40 as libc::c_int as uint8_t,
                flags: 0x3 as libc::c_int as uint8_t,
                sym: 184 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 2 as libc::c_int as uint8_t,
                flags: 0x2 as libc::c_int as uint8_t,
                sym: 194 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 9 as libc::c_int as uint8_t,
                flags: 0x2 as libc::c_int as uint8_t,
                sym: 194 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 23 as libc::c_int as uint8_t,
                flags: 0x2 as libc::c_int as uint8_t,
                sym: 194 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 40 as libc::c_int as uint8_t,
                flags: 0x3 as libc::c_int as uint8_t,
                sym: 194 as libc::c_int as uint8_t,
            };
            init
        },
    ],
    [
        {
            let mut init = decode_el {
                state: 3 as libc::c_int as uint8_t,
                flags: 0x2 as libc::c_int as uint8_t,
                sym: 131 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 6 as libc::c_int as uint8_t,
                flags: 0x2 as libc::c_int as uint8_t,
                sym: 131 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 10 as libc::c_int as uint8_t,
                flags: 0x2 as libc::c_int as uint8_t,
                sym: 131 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 15 as libc::c_int as uint8_t,
                flags: 0x2 as libc::c_int as uint8_t,
                sym: 131 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 24 as libc::c_int as uint8_t,
                flags: 0x2 as libc::c_int as uint8_t,
                sym: 131 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 31 as libc::c_int as uint8_t,
                flags: 0x2 as libc::c_int as uint8_t,
                sym: 131 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 41 as libc::c_int as uint8_t,
                flags: 0x2 as libc::c_int as uint8_t,
                sym: 131 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 56 as libc::c_int as uint8_t,
                flags: 0x3 as libc::c_int as uint8_t,
                sym: 131 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 3 as libc::c_int as uint8_t,
                flags: 0x2 as libc::c_int as uint8_t,
                sym: 162 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 6 as libc::c_int as uint8_t,
                flags: 0x2 as libc::c_int as uint8_t,
                sym: 162 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 10 as libc::c_int as uint8_t,
                flags: 0x2 as libc::c_int as uint8_t,
                sym: 162 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 15 as libc::c_int as uint8_t,
                flags: 0x2 as libc::c_int as uint8_t,
                sym: 162 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 24 as libc::c_int as uint8_t,
                flags: 0x2 as libc::c_int as uint8_t,
                sym: 162 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 31 as libc::c_int as uint8_t,
                flags: 0x2 as libc::c_int as uint8_t,
                sym: 162 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 41 as libc::c_int as uint8_t,
                flags: 0x2 as libc::c_int as uint8_t,
                sym: 162 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 56 as libc::c_int as uint8_t,
                flags: 0x3 as libc::c_int as uint8_t,
                sym: 162 as libc::c_int as uint8_t,
            };
            init
        },
    ],
    [
        {
            let mut init = decode_el {
                state: 3 as libc::c_int as uint8_t,
                flags: 0x2 as libc::c_int as uint8_t,
                sym: 184 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 6 as libc::c_int as uint8_t,
                flags: 0x2 as libc::c_int as uint8_t,
                sym: 184 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 10 as libc::c_int as uint8_t,
                flags: 0x2 as libc::c_int as uint8_t,
                sym: 184 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 15 as libc::c_int as uint8_t,
                flags: 0x2 as libc::c_int as uint8_t,
                sym: 184 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 24 as libc::c_int as uint8_t,
                flags: 0x2 as libc::c_int as uint8_t,
                sym: 184 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 31 as libc::c_int as uint8_t,
                flags: 0x2 as libc::c_int as uint8_t,
                sym: 184 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 41 as libc::c_int as uint8_t,
                flags: 0x2 as libc::c_int as uint8_t,
                sym: 184 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 56 as libc::c_int as uint8_t,
                flags: 0x3 as libc::c_int as uint8_t,
                sym: 184 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 3 as libc::c_int as uint8_t,
                flags: 0x2 as libc::c_int as uint8_t,
                sym: 194 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 6 as libc::c_int as uint8_t,
                flags: 0x2 as libc::c_int as uint8_t,
                sym: 194 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 10 as libc::c_int as uint8_t,
                flags: 0x2 as libc::c_int as uint8_t,
                sym: 194 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 15 as libc::c_int as uint8_t,
                flags: 0x2 as libc::c_int as uint8_t,
                sym: 194 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 24 as libc::c_int as uint8_t,
                flags: 0x2 as libc::c_int as uint8_t,
                sym: 194 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 31 as libc::c_int as uint8_t,
                flags: 0x2 as libc::c_int as uint8_t,
                sym: 194 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 41 as libc::c_int as uint8_t,
                flags: 0x2 as libc::c_int as uint8_t,
                sym: 194 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 56 as libc::c_int as uint8_t,
                flags: 0x3 as libc::c_int as uint8_t,
                sym: 194 as libc::c_int as uint8_t,
            };
            init
        },
    ],
    [
        {
            let mut init = decode_el {
                state: 2 as libc::c_int as uint8_t,
                flags: 0x2 as libc::c_int as uint8_t,
                sym: 224 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 9 as libc::c_int as uint8_t,
                flags: 0x2 as libc::c_int as uint8_t,
                sym: 224 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 23 as libc::c_int as uint8_t,
                flags: 0x2 as libc::c_int as uint8_t,
                sym: 224 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 40 as libc::c_int as uint8_t,
                flags: 0x3 as libc::c_int as uint8_t,
                sym: 224 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 2 as libc::c_int as uint8_t,
                flags: 0x2 as libc::c_int as uint8_t,
                sym: 226 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 9 as libc::c_int as uint8_t,
                flags: 0x2 as libc::c_int as uint8_t,
                sym: 226 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 23 as libc::c_int as uint8_t,
                flags: 0x2 as libc::c_int as uint8_t,
                sym: 226 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 40 as libc::c_int as uint8_t,
                flags: 0x3 as libc::c_int as uint8_t,
                sym: 226 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 1 as libc::c_int as uint8_t,
                flags: 0x2 as libc::c_int as uint8_t,
                sym: 153 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 22 as libc::c_int as uint8_t,
                flags: 0x3 as libc::c_int as uint8_t,
                sym: 153 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 1 as libc::c_int as uint8_t,
                flags: 0x2 as libc::c_int as uint8_t,
                sym: 161 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 22 as libc::c_int as uint8_t,
                flags: 0x3 as libc::c_int as uint8_t,
                sym: 161 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 1 as libc::c_int as uint8_t,
                flags: 0x2 as libc::c_int as uint8_t,
                sym: 167 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 22 as libc::c_int as uint8_t,
                flags: 0x3 as libc::c_int as uint8_t,
                sym: 167 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 1 as libc::c_int as uint8_t,
                flags: 0x2 as libc::c_int as uint8_t,
                sym: 172 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 22 as libc::c_int as uint8_t,
                flags: 0x3 as libc::c_int as uint8_t,
                sym: 172 as libc::c_int as uint8_t,
            };
            init
        },
    ],
    [
        {
            let mut init = decode_el {
                state: 3 as libc::c_int as uint8_t,
                flags: 0x2 as libc::c_int as uint8_t,
                sym: 224 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 6 as libc::c_int as uint8_t,
                flags: 0x2 as libc::c_int as uint8_t,
                sym: 224 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 10 as libc::c_int as uint8_t,
                flags: 0x2 as libc::c_int as uint8_t,
                sym: 224 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 15 as libc::c_int as uint8_t,
                flags: 0x2 as libc::c_int as uint8_t,
                sym: 224 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 24 as libc::c_int as uint8_t,
                flags: 0x2 as libc::c_int as uint8_t,
                sym: 224 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 31 as libc::c_int as uint8_t,
                flags: 0x2 as libc::c_int as uint8_t,
                sym: 224 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 41 as libc::c_int as uint8_t,
                flags: 0x2 as libc::c_int as uint8_t,
                sym: 224 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 56 as libc::c_int as uint8_t,
                flags: 0x3 as libc::c_int as uint8_t,
                sym: 224 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 3 as libc::c_int as uint8_t,
                flags: 0x2 as libc::c_int as uint8_t,
                sym: 226 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 6 as libc::c_int as uint8_t,
                flags: 0x2 as libc::c_int as uint8_t,
                sym: 226 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 10 as libc::c_int as uint8_t,
                flags: 0x2 as libc::c_int as uint8_t,
                sym: 226 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 15 as libc::c_int as uint8_t,
                flags: 0x2 as libc::c_int as uint8_t,
                sym: 226 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 24 as libc::c_int as uint8_t,
                flags: 0x2 as libc::c_int as uint8_t,
                sym: 226 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 31 as libc::c_int as uint8_t,
                flags: 0x2 as libc::c_int as uint8_t,
                sym: 226 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 41 as libc::c_int as uint8_t,
                flags: 0x2 as libc::c_int as uint8_t,
                sym: 226 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 56 as libc::c_int as uint8_t,
                flags: 0x3 as libc::c_int as uint8_t,
                sym: 226 as libc::c_int as uint8_t,
            };
            init
        },
    ],
    [
        {
            let mut init = decode_el {
                state: 2 as libc::c_int as uint8_t,
                flags: 0x2 as libc::c_int as uint8_t,
                sym: 153 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 9 as libc::c_int as uint8_t,
                flags: 0x2 as libc::c_int as uint8_t,
                sym: 153 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 23 as libc::c_int as uint8_t,
                flags: 0x2 as libc::c_int as uint8_t,
                sym: 153 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 40 as libc::c_int as uint8_t,
                flags: 0x3 as libc::c_int as uint8_t,
                sym: 153 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 2 as libc::c_int as uint8_t,
                flags: 0x2 as libc::c_int as uint8_t,
                sym: 161 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 9 as libc::c_int as uint8_t,
                flags: 0x2 as libc::c_int as uint8_t,
                sym: 161 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 23 as libc::c_int as uint8_t,
                flags: 0x2 as libc::c_int as uint8_t,
                sym: 161 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 40 as libc::c_int as uint8_t,
                flags: 0x3 as libc::c_int as uint8_t,
                sym: 161 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 2 as libc::c_int as uint8_t,
                flags: 0x2 as libc::c_int as uint8_t,
                sym: 167 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 9 as libc::c_int as uint8_t,
                flags: 0x2 as libc::c_int as uint8_t,
                sym: 167 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 23 as libc::c_int as uint8_t,
                flags: 0x2 as libc::c_int as uint8_t,
                sym: 167 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 40 as libc::c_int as uint8_t,
                flags: 0x3 as libc::c_int as uint8_t,
                sym: 167 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 2 as libc::c_int as uint8_t,
                flags: 0x2 as libc::c_int as uint8_t,
                sym: 172 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 9 as libc::c_int as uint8_t,
                flags: 0x2 as libc::c_int as uint8_t,
                sym: 172 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 23 as libc::c_int as uint8_t,
                flags: 0x2 as libc::c_int as uint8_t,
                sym: 172 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 40 as libc::c_int as uint8_t,
                flags: 0x3 as libc::c_int as uint8_t,
                sym: 172 as libc::c_int as uint8_t,
            };
            init
        },
    ],
    [
        {
            let mut init = decode_el {
                state: 3 as libc::c_int as uint8_t,
                flags: 0x2 as libc::c_int as uint8_t,
                sym: 153 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 6 as libc::c_int as uint8_t,
                flags: 0x2 as libc::c_int as uint8_t,
                sym: 153 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 10 as libc::c_int as uint8_t,
                flags: 0x2 as libc::c_int as uint8_t,
                sym: 153 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 15 as libc::c_int as uint8_t,
                flags: 0x2 as libc::c_int as uint8_t,
                sym: 153 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 24 as libc::c_int as uint8_t,
                flags: 0x2 as libc::c_int as uint8_t,
                sym: 153 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 31 as libc::c_int as uint8_t,
                flags: 0x2 as libc::c_int as uint8_t,
                sym: 153 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 41 as libc::c_int as uint8_t,
                flags: 0x2 as libc::c_int as uint8_t,
                sym: 153 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 56 as libc::c_int as uint8_t,
                flags: 0x3 as libc::c_int as uint8_t,
                sym: 153 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 3 as libc::c_int as uint8_t,
                flags: 0x2 as libc::c_int as uint8_t,
                sym: 161 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 6 as libc::c_int as uint8_t,
                flags: 0x2 as libc::c_int as uint8_t,
                sym: 161 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 10 as libc::c_int as uint8_t,
                flags: 0x2 as libc::c_int as uint8_t,
                sym: 161 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 15 as libc::c_int as uint8_t,
                flags: 0x2 as libc::c_int as uint8_t,
                sym: 161 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 24 as libc::c_int as uint8_t,
                flags: 0x2 as libc::c_int as uint8_t,
                sym: 161 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 31 as libc::c_int as uint8_t,
                flags: 0x2 as libc::c_int as uint8_t,
                sym: 161 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 41 as libc::c_int as uint8_t,
                flags: 0x2 as libc::c_int as uint8_t,
                sym: 161 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 56 as libc::c_int as uint8_t,
                flags: 0x3 as libc::c_int as uint8_t,
                sym: 161 as libc::c_int as uint8_t,
            };
            init
        },
    ],
    [
        {
            let mut init = decode_el {
                state: 3 as libc::c_int as uint8_t,
                flags: 0x2 as libc::c_int as uint8_t,
                sym: 167 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 6 as libc::c_int as uint8_t,
                flags: 0x2 as libc::c_int as uint8_t,
                sym: 167 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 10 as libc::c_int as uint8_t,
                flags: 0x2 as libc::c_int as uint8_t,
                sym: 167 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 15 as libc::c_int as uint8_t,
                flags: 0x2 as libc::c_int as uint8_t,
                sym: 167 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 24 as libc::c_int as uint8_t,
                flags: 0x2 as libc::c_int as uint8_t,
                sym: 167 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 31 as libc::c_int as uint8_t,
                flags: 0x2 as libc::c_int as uint8_t,
                sym: 167 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 41 as libc::c_int as uint8_t,
                flags: 0x2 as libc::c_int as uint8_t,
                sym: 167 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 56 as libc::c_int as uint8_t,
                flags: 0x3 as libc::c_int as uint8_t,
                sym: 167 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 3 as libc::c_int as uint8_t,
                flags: 0x2 as libc::c_int as uint8_t,
                sym: 172 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 6 as libc::c_int as uint8_t,
                flags: 0x2 as libc::c_int as uint8_t,
                sym: 172 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 10 as libc::c_int as uint8_t,
                flags: 0x2 as libc::c_int as uint8_t,
                sym: 172 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 15 as libc::c_int as uint8_t,
                flags: 0x2 as libc::c_int as uint8_t,
                sym: 172 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 24 as libc::c_int as uint8_t,
                flags: 0x2 as libc::c_int as uint8_t,
                sym: 172 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 31 as libc::c_int as uint8_t,
                flags: 0x2 as libc::c_int as uint8_t,
                sym: 172 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 41 as libc::c_int as uint8_t,
                flags: 0x2 as libc::c_int as uint8_t,
                sym: 172 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 56 as libc::c_int as uint8_t,
                flags: 0x3 as libc::c_int as uint8_t,
                sym: 172 as libc::c_int as uint8_t,
            };
            init
        },
    ],
    [
        {
            let mut init = decode_el {
                state: 114 as libc::c_int as uint8_t,
                flags: 0 as libc::c_int as uint8_t,
                sym: 0 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 115 as libc::c_int as uint8_t,
                flags: 0 as libc::c_int as uint8_t,
                sym: 0 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 117 as libc::c_int as uint8_t,
                flags: 0 as libc::c_int as uint8_t,
                sym: 0 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 118 as libc::c_int as uint8_t,
                flags: 0 as libc::c_int as uint8_t,
                sym: 0 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 121 as libc::c_int as uint8_t,
                flags: 0 as libc::c_int as uint8_t,
                sym: 0 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 123 as libc::c_int as uint8_t,
                flags: 0 as libc::c_int as uint8_t,
                sym: 0 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 127 as libc::c_int as uint8_t,
                flags: 0 as libc::c_int as uint8_t,
                sym: 0 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 130 as libc::c_int as uint8_t,
                flags: 0 as libc::c_int as uint8_t,
                sym: 0 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 136 as libc::c_int as uint8_t,
                flags: 0 as libc::c_int as uint8_t,
                sym: 0 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 139 as libc::c_int as uint8_t,
                flags: 0 as libc::c_int as uint8_t,
                sym: 0 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 143 as libc::c_int as uint8_t,
                flags: 0 as libc::c_int as uint8_t,
                sym: 0 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 146 as libc::c_int as uint8_t,
                flags: 0 as libc::c_int as uint8_t,
                sym: 0 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 155 as libc::c_int as uint8_t,
                flags: 0 as libc::c_int as uint8_t,
                sym: 0 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 162 as libc::c_int as uint8_t,
                flags: 0 as libc::c_int as uint8_t,
                sym: 0 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 170 as libc::c_int as uint8_t,
                flags: 0 as libc::c_int as uint8_t,
                sym: 0 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 180 as libc::c_int as uint8_t,
                flags: 0 as libc::c_int as uint8_t,
                sym: 0 as libc::c_int as uint8_t,
            };
            init
        },
    ],
    [
        {
            let mut init = decode_el {
                state: 0 as libc::c_int as uint8_t,
                flags: 0x3 as libc::c_int as uint8_t,
                sym: 176 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 0 as libc::c_int as uint8_t,
                flags: 0x3 as libc::c_int as uint8_t,
                sym: 177 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 0 as libc::c_int as uint8_t,
                flags: 0x3 as libc::c_int as uint8_t,
                sym: 179 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 0 as libc::c_int as uint8_t,
                flags: 0x3 as libc::c_int as uint8_t,
                sym: 209 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 0 as libc::c_int as uint8_t,
                flags: 0x3 as libc::c_int as uint8_t,
                sym: 216 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 0 as libc::c_int as uint8_t,
                flags: 0x3 as libc::c_int as uint8_t,
                sym: 217 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 0 as libc::c_int as uint8_t,
                flags: 0x3 as libc::c_int as uint8_t,
                sym: 227 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 0 as libc::c_int as uint8_t,
                flags: 0x3 as libc::c_int as uint8_t,
                sym: 229 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 0 as libc::c_int as uint8_t,
                flags: 0x3 as libc::c_int as uint8_t,
                sym: 230 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 122 as libc::c_int as uint8_t,
                flags: 0 as libc::c_int as uint8_t,
                sym: 0 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 124 as libc::c_int as uint8_t,
                flags: 0 as libc::c_int as uint8_t,
                sym: 0 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 125 as libc::c_int as uint8_t,
                flags: 0 as libc::c_int as uint8_t,
                sym: 0 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 128 as libc::c_int as uint8_t,
                flags: 0 as libc::c_int as uint8_t,
                sym: 0 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 129 as libc::c_int as uint8_t,
                flags: 0 as libc::c_int as uint8_t,
                sym: 0 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 131 as libc::c_int as uint8_t,
                flags: 0 as libc::c_int as uint8_t,
                sym: 0 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 132 as libc::c_int as uint8_t,
                flags: 0 as libc::c_int as uint8_t,
                sym: 0 as libc::c_int as uint8_t,
            };
            init
        },
    ],
    [
        {
            let mut init = decode_el {
                state: 1 as libc::c_int as uint8_t,
                flags: 0x2 as libc::c_int as uint8_t,
                sym: 176 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 22 as libc::c_int as uint8_t,
                flags: 0x3 as libc::c_int as uint8_t,
                sym: 176 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 1 as libc::c_int as uint8_t,
                flags: 0x2 as libc::c_int as uint8_t,
                sym: 177 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 22 as libc::c_int as uint8_t,
                flags: 0x3 as libc::c_int as uint8_t,
                sym: 177 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 1 as libc::c_int as uint8_t,
                flags: 0x2 as libc::c_int as uint8_t,
                sym: 179 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 22 as libc::c_int as uint8_t,
                flags: 0x3 as libc::c_int as uint8_t,
                sym: 179 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 1 as libc::c_int as uint8_t,
                flags: 0x2 as libc::c_int as uint8_t,
                sym: 209 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 22 as libc::c_int as uint8_t,
                flags: 0x3 as libc::c_int as uint8_t,
                sym: 209 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 1 as libc::c_int as uint8_t,
                flags: 0x2 as libc::c_int as uint8_t,
                sym: 216 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 22 as libc::c_int as uint8_t,
                flags: 0x3 as libc::c_int as uint8_t,
                sym: 216 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 1 as libc::c_int as uint8_t,
                flags: 0x2 as libc::c_int as uint8_t,
                sym: 217 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 22 as libc::c_int as uint8_t,
                flags: 0x3 as libc::c_int as uint8_t,
                sym: 217 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 1 as libc::c_int as uint8_t,
                flags: 0x2 as libc::c_int as uint8_t,
                sym: 227 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 22 as libc::c_int as uint8_t,
                flags: 0x3 as libc::c_int as uint8_t,
                sym: 227 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 1 as libc::c_int as uint8_t,
                flags: 0x2 as libc::c_int as uint8_t,
                sym: 229 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 22 as libc::c_int as uint8_t,
                flags: 0x3 as libc::c_int as uint8_t,
                sym: 229 as libc::c_int as uint8_t,
            };
            init
        },
    ],
    [
        {
            let mut init = decode_el {
                state: 2 as libc::c_int as uint8_t,
                flags: 0x2 as libc::c_int as uint8_t,
                sym: 176 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 9 as libc::c_int as uint8_t,
                flags: 0x2 as libc::c_int as uint8_t,
                sym: 176 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 23 as libc::c_int as uint8_t,
                flags: 0x2 as libc::c_int as uint8_t,
                sym: 176 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 40 as libc::c_int as uint8_t,
                flags: 0x3 as libc::c_int as uint8_t,
                sym: 176 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 2 as libc::c_int as uint8_t,
                flags: 0x2 as libc::c_int as uint8_t,
                sym: 177 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 9 as libc::c_int as uint8_t,
                flags: 0x2 as libc::c_int as uint8_t,
                sym: 177 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 23 as libc::c_int as uint8_t,
                flags: 0x2 as libc::c_int as uint8_t,
                sym: 177 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 40 as libc::c_int as uint8_t,
                flags: 0x3 as libc::c_int as uint8_t,
                sym: 177 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 2 as libc::c_int as uint8_t,
                flags: 0x2 as libc::c_int as uint8_t,
                sym: 179 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 9 as libc::c_int as uint8_t,
                flags: 0x2 as libc::c_int as uint8_t,
                sym: 179 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 23 as libc::c_int as uint8_t,
                flags: 0x2 as libc::c_int as uint8_t,
                sym: 179 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 40 as libc::c_int as uint8_t,
                flags: 0x3 as libc::c_int as uint8_t,
                sym: 179 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 2 as libc::c_int as uint8_t,
                flags: 0x2 as libc::c_int as uint8_t,
                sym: 209 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 9 as libc::c_int as uint8_t,
                flags: 0x2 as libc::c_int as uint8_t,
                sym: 209 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 23 as libc::c_int as uint8_t,
                flags: 0x2 as libc::c_int as uint8_t,
                sym: 209 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 40 as libc::c_int as uint8_t,
                flags: 0x3 as libc::c_int as uint8_t,
                sym: 209 as libc::c_int as uint8_t,
            };
            init
        },
    ],
    [
        {
            let mut init = decode_el {
                state: 3 as libc::c_int as uint8_t,
                flags: 0x2 as libc::c_int as uint8_t,
                sym: 176 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 6 as libc::c_int as uint8_t,
                flags: 0x2 as libc::c_int as uint8_t,
                sym: 176 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 10 as libc::c_int as uint8_t,
                flags: 0x2 as libc::c_int as uint8_t,
                sym: 176 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 15 as libc::c_int as uint8_t,
                flags: 0x2 as libc::c_int as uint8_t,
                sym: 176 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 24 as libc::c_int as uint8_t,
                flags: 0x2 as libc::c_int as uint8_t,
                sym: 176 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 31 as libc::c_int as uint8_t,
                flags: 0x2 as libc::c_int as uint8_t,
                sym: 176 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 41 as libc::c_int as uint8_t,
                flags: 0x2 as libc::c_int as uint8_t,
                sym: 176 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 56 as libc::c_int as uint8_t,
                flags: 0x3 as libc::c_int as uint8_t,
                sym: 176 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 3 as libc::c_int as uint8_t,
                flags: 0x2 as libc::c_int as uint8_t,
                sym: 177 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 6 as libc::c_int as uint8_t,
                flags: 0x2 as libc::c_int as uint8_t,
                sym: 177 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 10 as libc::c_int as uint8_t,
                flags: 0x2 as libc::c_int as uint8_t,
                sym: 177 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 15 as libc::c_int as uint8_t,
                flags: 0x2 as libc::c_int as uint8_t,
                sym: 177 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 24 as libc::c_int as uint8_t,
                flags: 0x2 as libc::c_int as uint8_t,
                sym: 177 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 31 as libc::c_int as uint8_t,
                flags: 0x2 as libc::c_int as uint8_t,
                sym: 177 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 41 as libc::c_int as uint8_t,
                flags: 0x2 as libc::c_int as uint8_t,
                sym: 177 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 56 as libc::c_int as uint8_t,
                flags: 0x3 as libc::c_int as uint8_t,
                sym: 177 as libc::c_int as uint8_t,
            };
            init
        },
    ],
    [
        {
            let mut init = decode_el {
                state: 3 as libc::c_int as uint8_t,
                flags: 0x2 as libc::c_int as uint8_t,
                sym: 179 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 6 as libc::c_int as uint8_t,
                flags: 0x2 as libc::c_int as uint8_t,
                sym: 179 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 10 as libc::c_int as uint8_t,
                flags: 0x2 as libc::c_int as uint8_t,
                sym: 179 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 15 as libc::c_int as uint8_t,
                flags: 0x2 as libc::c_int as uint8_t,
                sym: 179 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 24 as libc::c_int as uint8_t,
                flags: 0x2 as libc::c_int as uint8_t,
                sym: 179 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 31 as libc::c_int as uint8_t,
                flags: 0x2 as libc::c_int as uint8_t,
                sym: 179 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 41 as libc::c_int as uint8_t,
                flags: 0x2 as libc::c_int as uint8_t,
                sym: 179 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 56 as libc::c_int as uint8_t,
                flags: 0x3 as libc::c_int as uint8_t,
                sym: 179 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 3 as libc::c_int as uint8_t,
                flags: 0x2 as libc::c_int as uint8_t,
                sym: 209 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 6 as libc::c_int as uint8_t,
                flags: 0x2 as libc::c_int as uint8_t,
                sym: 209 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 10 as libc::c_int as uint8_t,
                flags: 0x2 as libc::c_int as uint8_t,
                sym: 209 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 15 as libc::c_int as uint8_t,
                flags: 0x2 as libc::c_int as uint8_t,
                sym: 209 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 24 as libc::c_int as uint8_t,
                flags: 0x2 as libc::c_int as uint8_t,
                sym: 209 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 31 as libc::c_int as uint8_t,
                flags: 0x2 as libc::c_int as uint8_t,
                sym: 209 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 41 as libc::c_int as uint8_t,
                flags: 0x2 as libc::c_int as uint8_t,
                sym: 209 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 56 as libc::c_int as uint8_t,
                flags: 0x3 as libc::c_int as uint8_t,
                sym: 209 as libc::c_int as uint8_t,
            };
            init
        },
    ],
    [
        {
            let mut init = decode_el {
                state: 2 as libc::c_int as uint8_t,
                flags: 0x2 as libc::c_int as uint8_t,
                sym: 216 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 9 as libc::c_int as uint8_t,
                flags: 0x2 as libc::c_int as uint8_t,
                sym: 216 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 23 as libc::c_int as uint8_t,
                flags: 0x2 as libc::c_int as uint8_t,
                sym: 216 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 40 as libc::c_int as uint8_t,
                flags: 0x3 as libc::c_int as uint8_t,
                sym: 216 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 2 as libc::c_int as uint8_t,
                flags: 0x2 as libc::c_int as uint8_t,
                sym: 217 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 9 as libc::c_int as uint8_t,
                flags: 0x2 as libc::c_int as uint8_t,
                sym: 217 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 23 as libc::c_int as uint8_t,
                flags: 0x2 as libc::c_int as uint8_t,
                sym: 217 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 40 as libc::c_int as uint8_t,
                flags: 0x3 as libc::c_int as uint8_t,
                sym: 217 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 2 as libc::c_int as uint8_t,
                flags: 0x2 as libc::c_int as uint8_t,
                sym: 227 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 9 as libc::c_int as uint8_t,
                flags: 0x2 as libc::c_int as uint8_t,
                sym: 227 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 23 as libc::c_int as uint8_t,
                flags: 0x2 as libc::c_int as uint8_t,
                sym: 227 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 40 as libc::c_int as uint8_t,
                flags: 0x3 as libc::c_int as uint8_t,
                sym: 227 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 2 as libc::c_int as uint8_t,
                flags: 0x2 as libc::c_int as uint8_t,
                sym: 229 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 9 as libc::c_int as uint8_t,
                flags: 0x2 as libc::c_int as uint8_t,
                sym: 229 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 23 as libc::c_int as uint8_t,
                flags: 0x2 as libc::c_int as uint8_t,
                sym: 229 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 40 as libc::c_int as uint8_t,
                flags: 0x3 as libc::c_int as uint8_t,
                sym: 229 as libc::c_int as uint8_t,
            };
            init
        },
    ],
    [
        {
            let mut init = decode_el {
                state: 3 as libc::c_int as uint8_t,
                flags: 0x2 as libc::c_int as uint8_t,
                sym: 216 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 6 as libc::c_int as uint8_t,
                flags: 0x2 as libc::c_int as uint8_t,
                sym: 216 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 10 as libc::c_int as uint8_t,
                flags: 0x2 as libc::c_int as uint8_t,
                sym: 216 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 15 as libc::c_int as uint8_t,
                flags: 0x2 as libc::c_int as uint8_t,
                sym: 216 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 24 as libc::c_int as uint8_t,
                flags: 0x2 as libc::c_int as uint8_t,
                sym: 216 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 31 as libc::c_int as uint8_t,
                flags: 0x2 as libc::c_int as uint8_t,
                sym: 216 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 41 as libc::c_int as uint8_t,
                flags: 0x2 as libc::c_int as uint8_t,
                sym: 216 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 56 as libc::c_int as uint8_t,
                flags: 0x3 as libc::c_int as uint8_t,
                sym: 216 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 3 as libc::c_int as uint8_t,
                flags: 0x2 as libc::c_int as uint8_t,
                sym: 217 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 6 as libc::c_int as uint8_t,
                flags: 0x2 as libc::c_int as uint8_t,
                sym: 217 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 10 as libc::c_int as uint8_t,
                flags: 0x2 as libc::c_int as uint8_t,
                sym: 217 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 15 as libc::c_int as uint8_t,
                flags: 0x2 as libc::c_int as uint8_t,
                sym: 217 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 24 as libc::c_int as uint8_t,
                flags: 0x2 as libc::c_int as uint8_t,
                sym: 217 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 31 as libc::c_int as uint8_t,
                flags: 0x2 as libc::c_int as uint8_t,
                sym: 217 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 41 as libc::c_int as uint8_t,
                flags: 0x2 as libc::c_int as uint8_t,
                sym: 217 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 56 as libc::c_int as uint8_t,
                flags: 0x3 as libc::c_int as uint8_t,
                sym: 217 as libc::c_int as uint8_t,
            };
            init
        },
    ],
    [
        {
            let mut init = decode_el {
                state: 3 as libc::c_int as uint8_t,
                flags: 0x2 as libc::c_int as uint8_t,
                sym: 227 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 6 as libc::c_int as uint8_t,
                flags: 0x2 as libc::c_int as uint8_t,
                sym: 227 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 10 as libc::c_int as uint8_t,
                flags: 0x2 as libc::c_int as uint8_t,
                sym: 227 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 15 as libc::c_int as uint8_t,
                flags: 0x2 as libc::c_int as uint8_t,
                sym: 227 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 24 as libc::c_int as uint8_t,
                flags: 0x2 as libc::c_int as uint8_t,
                sym: 227 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 31 as libc::c_int as uint8_t,
                flags: 0x2 as libc::c_int as uint8_t,
                sym: 227 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 41 as libc::c_int as uint8_t,
                flags: 0x2 as libc::c_int as uint8_t,
                sym: 227 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 56 as libc::c_int as uint8_t,
                flags: 0x3 as libc::c_int as uint8_t,
                sym: 227 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 3 as libc::c_int as uint8_t,
                flags: 0x2 as libc::c_int as uint8_t,
                sym: 229 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 6 as libc::c_int as uint8_t,
                flags: 0x2 as libc::c_int as uint8_t,
                sym: 229 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 10 as libc::c_int as uint8_t,
                flags: 0x2 as libc::c_int as uint8_t,
                sym: 229 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 15 as libc::c_int as uint8_t,
                flags: 0x2 as libc::c_int as uint8_t,
                sym: 229 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 24 as libc::c_int as uint8_t,
                flags: 0x2 as libc::c_int as uint8_t,
                sym: 229 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 31 as libc::c_int as uint8_t,
                flags: 0x2 as libc::c_int as uint8_t,
                sym: 229 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 41 as libc::c_int as uint8_t,
                flags: 0x2 as libc::c_int as uint8_t,
                sym: 229 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 56 as libc::c_int as uint8_t,
                flags: 0x3 as libc::c_int as uint8_t,
                sym: 229 as libc::c_int as uint8_t,
            };
            init
        },
    ],
    [
        {
            let mut init = decode_el {
                state: 1 as libc::c_int as uint8_t,
                flags: 0x2 as libc::c_int as uint8_t,
                sym: 230 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 22 as libc::c_int as uint8_t,
                flags: 0x3 as libc::c_int as uint8_t,
                sym: 230 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 0 as libc::c_int as uint8_t,
                flags: 0x3 as libc::c_int as uint8_t,
                sym: 129 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 0 as libc::c_int as uint8_t,
                flags: 0x3 as libc::c_int as uint8_t,
                sym: 132 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 0 as libc::c_int as uint8_t,
                flags: 0x3 as libc::c_int as uint8_t,
                sym: 133 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 0 as libc::c_int as uint8_t,
                flags: 0x3 as libc::c_int as uint8_t,
                sym: 134 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 0 as libc::c_int as uint8_t,
                flags: 0x3 as libc::c_int as uint8_t,
                sym: 136 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 0 as libc::c_int as uint8_t,
                flags: 0x3 as libc::c_int as uint8_t,
                sym: 146 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 0 as libc::c_int as uint8_t,
                flags: 0x3 as libc::c_int as uint8_t,
                sym: 154 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 0 as libc::c_int as uint8_t,
                flags: 0x3 as libc::c_int as uint8_t,
                sym: 156 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 0 as libc::c_int as uint8_t,
                flags: 0x3 as libc::c_int as uint8_t,
                sym: 160 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 0 as libc::c_int as uint8_t,
                flags: 0x3 as libc::c_int as uint8_t,
                sym: 163 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 0 as libc::c_int as uint8_t,
                flags: 0x3 as libc::c_int as uint8_t,
                sym: 164 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 0 as libc::c_int as uint8_t,
                flags: 0x3 as libc::c_int as uint8_t,
                sym: 169 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 0 as libc::c_int as uint8_t,
                flags: 0x3 as libc::c_int as uint8_t,
                sym: 170 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 0 as libc::c_int as uint8_t,
                flags: 0x3 as libc::c_int as uint8_t,
                sym: 173 as libc::c_int as uint8_t,
            };
            init
        },
    ],
    [
        {
            let mut init = decode_el {
                state: 2 as libc::c_int as uint8_t,
                flags: 0x2 as libc::c_int as uint8_t,
                sym: 230 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 9 as libc::c_int as uint8_t,
                flags: 0x2 as libc::c_int as uint8_t,
                sym: 230 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 23 as libc::c_int as uint8_t,
                flags: 0x2 as libc::c_int as uint8_t,
                sym: 230 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 40 as libc::c_int as uint8_t,
                flags: 0x3 as libc::c_int as uint8_t,
                sym: 230 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 1 as libc::c_int as uint8_t,
                flags: 0x2 as libc::c_int as uint8_t,
                sym: 129 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 22 as libc::c_int as uint8_t,
                flags: 0x3 as libc::c_int as uint8_t,
                sym: 129 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 1 as libc::c_int as uint8_t,
                flags: 0x2 as libc::c_int as uint8_t,
                sym: 132 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 22 as libc::c_int as uint8_t,
                flags: 0x3 as libc::c_int as uint8_t,
                sym: 132 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 1 as libc::c_int as uint8_t,
                flags: 0x2 as libc::c_int as uint8_t,
                sym: 133 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 22 as libc::c_int as uint8_t,
                flags: 0x3 as libc::c_int as uint8_t,
                sym: 133 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 1 as libc::c_int as uint8_t,
                flags: 0x2 as libc::c_int as uint8_t,
                sym: 134 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 22 as libc::c_int as uint8_t,
                flags: 0x3 as libc::c_int as uint8_t,
                sym: 134 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 1 as libc::c_int as uint8_t,
                flags: 0x2 as libc::c_int as uint8_t,
                sym: 136 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 22 as libc::c_int as uint8_t,
                flags: 0x3 as libc::c_int as uint8_t,
                sym: 136 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 1 as libc::c_int as uint8_t,
                flags: 0x2 as libc::c_int as uint8_t,
                sym: 146 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 22 as libc::c_int as uint8_t,
                flags: 0x3 as libc::c_int as uint8_t,
                sym: 146 as libc::c_int as uint8_t,
            };
            init
        },
    ],
    [
        {
            let mut init = decode_el {
                state: 3 as libc::c_int as uint8_t,
                flags: 0x2 as libc::c_int as uint8_t,
                sym: 230 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 6 as libc::c_int as uint8_t,
                flags: 0x2 as libc::c_int as uint8_t,
                sym: 230 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 10 as libc::c_int as uint8_t,
                flags: 0x2 as libc::c_int as uint8_t,
                sym: 230 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 15 as libc::c_int as uint8_t,
                flags: 0x2 as libc::c_int as uint8_t,
                sym: 230 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 24 as libc::c_int as uint8_t,
                flags: 0x2 as libc::c_int as uint8_t,
                sym: 230 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 31 as libc::c_int as uint8_t,
                flags: 0x2 as libc::c_int as uint8_t,
                sym: 230 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 41 as libc::c_int as uint8_t,
                flags: 0x2 as libc::c_int as uint8_t,
                sym: 230 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 56 as libc::c_int as uint8_t,
                flags: 0x3 as libc::c_int as uint8_t,
                sym: 230 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 2 as libc::c_int as uint8_t,
                flags: 0x2 as libc::c_int as uint8_t,
                sym: 129 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 9 as libc::c_int as uint8_t,
                flags: 0x2 as libc::c_int as uint8_t,
                sym: 129 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 23 as libc::c_int as uint8_t,
                flags: 0x2 as libc::c_int as uint8_t,
                sym: 129 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 40 as libc::c_int as uint8_t,
                flags: 0x3 as libc::c_int as uint8_t,
                sym: 129 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 2 as libc::c_int as uint8_t,
                flags: 0x2 as libc::c_int as uint8_t,
                sym: 132 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 9 as libc::c_int as uint8_t,
                flags: 0x2 as libc::c_int as uint8_t,
                sym: 132 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 23 as libc::c_int as uint8_t,
                flags: 0x2 as libc::c_int as uint8_t,
                sym: 132 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 40 as libc::c_int as uint8_t,
                flags: 0x3 as libc::c_int as uint8_t,
                sym: 132 as libc::c_int as uint8_t,
            };
            init
        },
    ],
    [
        {
            let mut init = decode_el {
                state: 3 as libc::c_int as uint8_t,
                flags: 0x2 as libc::c_int as uint8_t,
                sym: 129 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 6 as libc::c_int as uint8_t,
                flags: 0x2 as libc::c_int as uint8_t,
                sym: 129 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 10 as libc::c_int as uint8_t,
                flags: 0x2 as libc::c_int as uint8_t,
                sym: 129 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 15 as libc::c_int as uint8_t,
                flags: 0x2 as libc::c_int as uint8_t,
                sym: 129 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 24 as libc::c_int as uint8_t,
                flags: 0x2 as libc::c_int as uint8_t,
                sym: 129 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 31 as libc::c_int as uint8_t,
                flags: 0x2 as libc::c_int as uint8_t,
                sym: 129 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 41 as libc::c_int as uint8_t,
                flags: 0x2 as libc::c_int as uint8_t,
                sym: 129 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 56 as libc::c_int as uint8_t,
                flags: 0x3 as libc::c_int as uint8_t,
                sym: 129 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 3 as libc::c_int as uint8_t,
                flags: 0x2 as libc::c_int as uint8_t,
                sym: 132 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 6 as libc::c_int as uint8_t,
                flags: 0x2 as libc::c_int as uint8_t,
                sym: 132 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 10 as libc::c_int as uint8_t,
                flags: 0x2 as libc::c_int as uint8_t,
                sym: 132 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 15 as libc::c_int as uint8_t,
                flags: 0x2 as libc::c_int as uint8_t,
                sym: 132 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 24 as libc::c_int as uint8_t,
                flags: 0x2 as libc::c_int as uint8_t,
                sym: 132 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 31 as libc::c_int as uint8_t,
                flags: 0x2 as libc::c_int as uint8_t,
                sym: 132 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 41 as libc::c_int as uint8_t,
                flags: 0x2 as libc::c_int as uint8_t,
                sym: 132 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 56 as libc::c_int as uint8_t,
                flags: 0x3 as libc::c_int as uint8_t,
                sym: 132 as libc::c_int as uint8_t,
            };
            init
        },
    ],
    [
        {
            let mut init = decode_el {
                state: 2 as libc::c_int as uint8_t,
                flags: 0x2 as libc::c_int as uint8_t,
                sym: 133 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 9 as libc::c_int as uint8_t,
                flags: 0x2 as libc::c_int as uint8_t,
                sym: 133 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 23 as libc::c_int as uint8_t,
                flags: 0x2 as libc::c_int as uint8_t,
                sym: 133 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 40 as libc::c_int as uint8_t,
                flags: 0x3 as libc::c_int as uint8_t,
                sym: 133 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 2 as libc::c_int as uint8_t,
                flags: 0x2 as libc::c_int as uint8_t,
                sym: 134 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 9 as libc::c_int as uint8_t,
                flags: 0x2 as libc::c_int as uint8_t,
                sym: 134 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 23 as libc::c_int as uint8_t,
                flags: 0x2 as libc::c_int as uint8_t,
                sym: 134 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 40 as libc::c_int as uint8_t,
                flags: 0x3 as libc::c_int as uint8_t,
                sym: 134 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 2 as libc::c_int as uint8_t,
                flags: 0x2 as libc::c_int as uint8_t,
                sym: 136 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 9 as libc::c_int as uint8_t,
                flags: 0x2 as libc::c_int as uint8_t,
                sym: 136 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 23 as libc::c_int as uint8_t,
                flags: 0x2 as libc::c_int as uint8_t,
                sym: 136 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 40 as libc::c_int as uint8_t,
                flags: 0x3 as libc::c_int as uint8_t,
                sym: 136 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 2 as libc::c_int as uint8_t,
                flags: 0x2 as libc::c_int as uint8_t,
                sym: 146 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 9 as libc::c_int as uint8_t,
                flags: 0x2 as libc::c_int as uint8_t,
                sym: 146 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 23 as libc::c_int as uint8_t,
                flags: 0x2 as libc::c_int as uint8_t,
                sym: 146 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 40 as libc::c_int as uint8_t,
                flags: 0x3 as libc::c_int as uint8_t,
                sym: 146 as libc::c_int as uint8_t,
            };
            init
        },
    ],
    [
        {
            let mut init = decode_el {
                state: 3 as libc::c_int as uint8_t,
                flags: 0x2 as libc::c_int as uint8_t,
                sym: 133 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 6 as libc::c_int as uint8_t,
                flags: 0x2 as libc::c_int as uint8_t,
                sym: 133 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 10 as libc::c_int as uint8_t,
                flags: 0x2 as libc::c_int as uint8_t,
                sym: 133 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 15 as libc::c_int as uint8_t,
                flags: 0x2 as libc::c_int as uint8_t,
                sym: 133 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 24 as libc::c_int as uint8_t,
                flags: 0x2 as libc::c_int as uint8_t,
                sym: 133 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 31 as libc::c_int as uint8_t,
                flags: 0x2 as libc::c_int as uint8_t,
                sym: 133 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 41 as libc::c_int as uint8_t,
                flags: 0x2 as libc::c_int as uint8_t,
                sym: 133 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 56 as libc::c_int as uint8_t,
                flags: 0x3 as libc::c_int as uint8_t,
                sym: 133 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 3 as libc::c_int as uint8_t,
                flags: 0x2 as libc::c_int as uint8_t,
                sym: 134 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 6 as libc::c_int as uint8_t,
                flags: 0x2 as libc::c_int as uint8_t,
                sym: 134 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 10 as libc::c_int as uint8_t,
                flags: 0x2 as libc::c_int as uint8_t,
                sym: 134 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 15 as libc::c_int as uint8_t,
                flags: 0x2 as libc::c_int as uint8_t,
                sym: 134 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 24 as libc::c_int as uint8_t,
                flags: 0x2 as libc::c_int as uint8_t,
                sym: 134 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 31 as libc::c_int as uint8_t,
                flags: 0x2 as libc::c_int as uint8_t,
                sym: 134 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 41 as libc::c_int as uint8_t,
                flags: 0x2 as libc::c_int as uint8_t,
                sym: 134 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 56 as libc::c_int as uint8_t,
                flags: 0x3 as libc::c_int as uint8_t,
                sym: 134 as libc::c_int as uint8_t,
            };
            init
        },
    ],
    [
        {
            let mut init = decode_el {
                state: 3 as libc::c_int as uint8_t,
                flags: 0x2 as libc::c_int as uint8_t,
                sym: 136 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 6 as libc::c_int as uint8_t,
                flags: 0x2 as libc::c_int as uint8_t,
                sym: 136 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 10 as libc::c_int as uint8_t,
                flags: 0x2 as libc::c_int as uint8_t,
                sym: 136 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 15 as libc::c_int as uint8_t,
                flags: 0x2 as libc::c_int as uint8_t,
                sym: 136 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 24 as libc::c_int as uint8_t,
                flags: 0x2 as libc::c_int as uint8_t,
                sym: 136 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 31 as libc::c_int as uint8_t,
                flags: 0x2 as libc::c_int as uint8_t,
                sym: 136 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 41 as libc::c_int as uint8_t,
                flags: 0x2 as libc::c_int as uint8_t,
                sym: 136 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 56 as libc::c_int as uint8_t,
                flags: 0x3 as libc::c_int as uint8_t,
                sym: 136 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 3 as libc::c_int as uint8_t,
                flags: 0x2 as libc::c_int as uint8_t,
                sym: 146 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 6 as libc::c_int as uint8_t,
                flags: 0x2 as libc::c_int as uint8_t,
                sym: 146 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 10 as libc::c_int as uint8_t,
                flags: 0x2 as libc::c_int as uint8_t,
                sym: 146 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 15 as libc::c_int as uint8_t,
                flags: 0x2 as libc::c_int as uint8_t,
                sym: 146 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 24 as libc::c_int as uint8_t,
                flags: 0x2 as libc::c_int as uint8_t,
                sym: 146 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 31 as libc::c_int as uint8_t,
                flags: 0x2 as libc::c_int as uint8_t,
                sym: 146 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 41 as libc::c_int as uint8_t,
                flags: 0x2 as libc::c_int as uint8_t,
                sym: 146 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 56 as libc::c_int as uint8_t,
                flags: 0x3 as libc::c_int as uint8_t,
                sym: 146 as libc::c_int as uint8_t,
            };
            init
        },
    ],
    [
        {
            let mut init = decode_el {
                state: 1 as libc::c_int as uint8_t,
                flags: 0x2 as libc::c_int as uint8_t,
                sym: 154 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 22 as libc::c_int as uint8_t,
                flags: 0x3 as libc::c_int as uint8_t,
                sym: 154 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 1 as libc::c_int as uint8_t,
                flags: 0x2 as libc::c_int as uint8_t,
                sym: 156 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 22 as libc::c_int as uint8_t,
                flags: 0x3 as libc::c_int as uint8_t,
                sym: 156 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 1 as libc::c_int as uint8_t,
                flags: 0x2 as libc::c_int as uint8_t,
                sym: 160 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 22 as libc::c_int as uint8_t,
                flags: 0x3 as libc::c_int as uint8_t,
                sym: 160 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 1 as libc::c_int as uint8_t,
                flags: 0x2 as libc::c_int as uint8_t,
                sym: 163 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 22 as libc::c_int as uint8_t,
                flags: 0x3 as libc::c_int as uint8_t,
                sym: 163 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 1 as libc::c_int as uint8_t,
                flags: 0x2 as libc::c_int as uint8_t,
                sym: 164 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 22 as libc::c_int as uint8_t,
                flags: 0x3 as libc::c_int as uint8_t,
                sym: 164 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 1 as libc::c_int as uint8_t,
                flags: 0x2 as libc::c_int as uint8_t,
                sym: 169 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 22 as libc::c_int as uint8_t,
                flags: 0x3 as libc::c_int as uint8_t,
                sym: 169 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 1 as libc::c_int as uint8_t,
                flags: 0x2 as libc::c_int as uint8_t,
                sym: 170 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 22 as libc::c_int as uint8_t,
                flags: 0x3 as libc::c_int as uint8_t,
                sym: 170 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 1 as libc::c_int as uint8_t,
                flags: 0x2 as libc::c_int as uint8_t,
                sym: 173 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 22 as libc::c_int as uint8_t,
                flags: 0x3 as libc::c_int as uint8_t,
                sym: 173 as libc::c_int as uint8_t,
            };
            init
        },
    ],
    [
        {
            let mut init = decode_el {
                state: 2 as libc::c_int as uint8_t,
                flags: 0x2 as libc::c_int as uint8_t,
                sym: 154 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 9 as libc::c_int as uint8_t,
                flags: 0x2 as libc::c_int as uint8_t,
                sym: 154 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 23 as libc::c_int as uint8_t,
                flags: 0x2 as libc::c_int as uint8_t,
                sym: 154 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 40 as libc::c_int as uint8_t,
                flags: 0x3 as libc::c_int as uint8_t,
                sym: 154 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 2 as libc::c_int as uint8_t,
                flags: 0x2 as libc::c_int as uint8_t,
                sym: 156 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 9 as libc::c_int as uint8_t,
                flags: 0x2 as libc::c_int as uint8_t,
                sym: 156 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 23 as libc::c_int as uint8_t,
                flags: 0x2 as libc::c_int as uint8_t,
                sym: 156 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 40 as libc::c_int as uint8_t,
                flags: 0x3 as libc::c_int as uint8_t,
                sym: 156 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 2 as libc::c_int as uint8_t,
                flags: 0x2 as libc::c_int as uint8_t,
                sym: 160 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 9 as libc::c_int as uint8_t,
                flags: 0x2 as libc::c_int as uint8_t,
                sym: 160 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 23 as libc::c_int as uint8_t,
                flags: 0x2 as libc::c_int as uint8_t,
                sym: 160 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 40 as libc::c_int as uint8_t,
                flags: 0x3 as libc::c_int as uint8_t,
                sym: 160 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 2 as libc::c_int as uint8_t,
                flags: 0x2 as libc::c_int as uint8_t,
                sym: 163 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 9 as libc::c_int as uint8_t,
                flags: 0x2 as libc::c_int as uint8_t,
                sym: 163 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 23 as libc::c_int as uint8_t,
                flags: 0x2 as libc::c_int as uint8_t,
                sym: 163 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 40 as libc::c_int as uint8_t,
                flags: 0x3 as libc::c_int as uint8_t,
                sym: 163 as libc::c_int as uint8_t,
            };
            init
        },
    ],
    [
        {
            let mut init = decode_el {
                state: 3 as libc::c_int as uint8_t,
                flags: 0x2 as libc::c_int as uint8_t,
                sym: 154 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 6 as libc::c_int as uint8_t,
                flags: 0x2 as libc::c_int as uint8_t,
                sym: 154 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 10 as libc::c_int as uint8_t,
                flags: 0x2 as libc::c_int as uint8_t,
                sym: 154 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 15 as libc::c_int as uint8_t,
                flags: 0x2 as libc::c_int as uint8_t,
                sym: 154 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 24 as libc::c_int as uint8_t,
                flags: 0x2 as libc::c_int as uint8_t,
                sym: 154 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 31 as libc::c_int as uint8_t,
                flags: 0x2 as libc::c_int as uint8_t,
                sym: 154 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 41 as libc::c_int as uint8_t,
                flags: 0x2 as libc::c_int as uint8_t,
                sym: 154 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 56 as libc::c_int as uint8_t,
                flags: 0x3 as libc::c_int as uint8_t,
                sym: 154 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 3 as libc::c_int as uint8_t,
                flags: 0x2 as libc::c_int as uint8_t,
                sym: 156 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 6 as libc::c_int as uint8_t,
                flags: 0x2 as libc::c_int as uint8_t,
                sym: 156 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 10 as libc::c_int as uint8_t,
                flags: 0x2 as libc::c_int as uint8_t,
                sym: 156 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 15 as libc::c_int as uint8_t,
                flags: 0x2 as libc::c_int as uint8_t,
                sym: 156 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 24 as libc::c_int as uint8_t,
                flags: 0x2 as libc::c_int as uint8_t,
                sym: 156 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 31 as libc::c_int as uint8_t,
                flags: 0x2 as libc::c_int as uint8_t,
                sym: 156 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 41 as libc::c_int as uint8_t,
                flags: 0x2 as libc::c_int as uint8_t,
                sym: 156 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 56 as libc::c_int as uint8_t,
                flags: 0x3 as libc::c_int as uint8_t,
                sym: 156 as libc::c_int as uint8_t,
            };
            init
        },
    ],
    [
        {
            let mut init = decode_el {
                state: 3 as libc::c_int as uint8_t,
                flags: 0x2 as libc::c_int as uint8_t,
                sym: 160 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 6 as libc::c_int as uint8_t,
                flags: 0x2 as libc::c_int as uint8_t,
                sym: 160 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 10 as libc::c_int as uint8_t,
                flags: 0x2 as libc::c_int as uint8_t,
                sym: 160 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 15 as libc::c_int as uint8_t,
                flags: 0x2 as libc::c_int as uint8_t,
                sym: 160 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 24 as libc::c_int as uint8_t,
                flags: 0x2 as libc::c_int as uint8_t,
                sym: 160 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 31 as libc::c_int as uint8_t,
                flags: 0x2 as libc::c_int as uint8_t,
                sym: 160 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 41 as libc::c_int as uint8_t,
                flags: 0x2 as libc::c_int as uint8_t,
                sym: 160 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 56 as libc::c_int as uint8_t,
                flags: 0x3 as libc::c_int as uint8_t,
                sym: 160 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 3 as libc::c_int as uint8_t,
                flags: 0x2 as libc::c_int as uint8_t,
                sym: 163 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 6 as libc::c_int as uint8_t,
                flags: 0x2 as libc::c_int as uint8_t,
                sym: 163 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 10 as libc::c_int as uint8_t,
                flags: 0x2 as libc::c_int as uint8_t,
                sym: 163 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 15 as libc::c_int as uint8_t,
                flags: 0x2 as libc::c_int as uint8_t,
                sym: 163 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 24 as libc::c_int as uint8_t,
                flags: 0x2 as libc::c_int as uint8_t,
                sym: 163 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 31 as libc::c_int as uint8_t,
                flags: 0x2 as libc::c_int as uint8_t,
                sym: 163 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 41 as libc::c_int as uint8_t,
                flags: 0x2 as libc::c_int as uint8_t,
                sym: 163 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 56 as libc::c_int as uint8_t,
                flags: 0x3 as libc::c_int as uint8_t,
                sym: 163 as libc::c_int as uint8_t,
            };
            init
        },
    ],
    [
        {
            let mut init = decode_el {
                state: 2 as libc::c_int as uint8_t,
                flags: 0x2 as libc::c_int as uint8_t,
                sym: 164 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 9 as libc::c_int as uint8_t,
                flags: 0x2 as libc::c_int as uint8_t,
                sym: 164 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 23 as libc::c_int as uint8_t,
                flags: 0x2 as libc::c_int as uint8_t,
                sym: 164 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 40 as libc::c_int as uint8_t,
                flags: 0x3 as libc::c_int as uint8_t,
                sym: 164 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 2 as libc::c_int as uint8_t,
                flags: 0x2 as libc::c_int as uint8_t,
                sym: 169 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 9 as libc::c_int as uint8_t,
                flags: 0x2 as libc::c_int as uint8_t,
                sym: 169 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 23 as libc::c_int as uint8_t,
                flags: 0x2 as libc::c_int as uint8_t,
                sym: 169 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 40 as libc::c_int as uint8_t,
                flags: 0x3 as libc::c_int as uint8_t,
                sym: 169 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 2 as libc::c_int as uint8_t,
                flags: 0x2 as libc::c_int as uint8_t,
                sym: 170 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 9 as libc::c_int as uint8_t,
                flags: 0x2 as libc::c_int as uint8_t,
                sym: 170 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 23 as libc::c_int as uint8_t,
                flags: 0x2 as libc::c_int as uint8_t,
                sym: 170 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 40 as libc::c_int as uint8_t,
                flags: 0x3 as libc::c_int as uint8_t,
                sym: 170 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 2 as libc::c_int as uint8_t,
                flags: 0x2 as libc::c_int as uint8_t,
                sym: 173 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 9 as libc::c_int as uint8_t,
                flags: 0x2 as libc::c_int as uint8_t,
                sym: 173 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 23 as libc::c_int as uint8_t,
                flags: 0x2 as libc::c_int as uint8_t,
                sym: 173 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 40 as libc::c_int as uint8_t,
                flags: 0x3 as libc::c_int as uint8_t,
                sym: 173 as libc::c_int as uint8_t,
            };
            init
        },
    ],
    [
        {
            let mut init = decode_el {
                state: 3 as libc::c_int as uint8_t,
                flags: 0x2 as libc::c_int as uint8_t,
                sym: 164 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 6 as libc::c_int as uint8_t,
                flags: 0x2 as libc::c_int as uint8_t,
                sym: 164 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 10 as libc::c_int as uint8_t,
                flags: 0x2 as libc::c_int as uint8_t,
                sym: 164 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 15 as libc::c_int as uint8_t,
                flags: 0x2 as libc::c_int as uint8_t,
                sym: 164 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 24 as libc::c_int as uint8_t,
                flags: 0x2 as libc::c_int as uint8_t,
                sym: 164 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 31 as libc::c_int as uint8_t,
                flags: 0x2 as libc::c_int as uint8_t,
                sym: 164 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 41 as libc::c_int as uint8_t,
                flags: 0x2 as libc::c_int as uint8_t,
                sym: 164 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 56 as libc::c_int as uint8_t,
                flags: 0x3 as libc::c_int as uint8_t,
                sym: 164 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 3 as libc::c_int as uint8_t,
                flags: 0x2 as libc::c_int as uint8_t,
                sym: 169 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 6 as libc::c_int as uint8_t,
                flags: 0x2 as libc::c_int as uint8_t,
                sym: 169 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 10 as libc::c_int as uint8_t,
                flags: 0x2 as libc::c_int as uint8_t,
                sym: 169 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 15 as libc::c_int as uint8_t,
                flags: 0x2 as libc::c_int as uint8_t,
                sym: 169 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 24 as libc::c_int as uint8_t,
                flags: 0x2 as libc::c_int as uint8_t,
                sym: 169 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 31 as libc::c_int as uint8_t,
                flags: 0x2 as libc::c_int as uint8_t,
                sym: 169 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 41 as libc::c_int as uint8_t,
                flags: 0x2 as libc::c_int as uint8_t,
                sym: 169 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 56 as libc::c_int as uint8_t,
                flags: 0x3 as libc::c_int as uint8_t,
                sym: 169 as libc::c_int as uint8_t,
            };
            init
        },
    ],
    [
        {
            let mut init = decode_el {
                state: 3 as libc::c_int as uint8_t,
                flags: 0x2 as libc::c_int as uint8_t,
                sym: 170 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 6 as libc::c_int as uint8_t,
                flags: 0x2 as libc::c_int as uint8_t,
                sym: 170 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 10 as libc::c_int as uint8_t,
                flags: 0x2 as libc::c_int as uint8_t,
                sym: 170 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 15 as libc::c_int as uint8_t,
                flags: 0x2 as libc::c_int as uint8_t,
                sym: 170 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 24 as libc::c_int as uint8_t,
                flags: 0x2 as libc::c_int as uint8_t,
                sym: 170 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 31 as libc::c_int as uint8_t,
                flags: 0x2 as libc::c_int as uint8_t,
                sym: 170 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 41 as libc::c_int as uint8_t,
                flags: 0x2 as libc::c_int as uint8_t,
                sym: 170 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 56 as libc::c_int as uint8_t,
                flags: 0x3 as libc::c_int as uint8_t,
                sym: 170 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 3 as libc::c_int as uint8_t,
                flags: 0x2 as libc::c_int as uint8_t,
                sym: 173 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 6 as libc::c_int as uint8_t,
                flags: 0x2 as libc::c_int as uint8_t,
                sym: 173 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 10 as libc::c_int as uint8_t,
                flags: 0x2 as libc::c_int as uint8_t,
                sym: 173 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 15 as libc::c_int as uint8_t,
                flags: 0x2 as libc::c_int as uint8_t,
                sym: 173 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 24 as libc::c_int as uint8_t,
                flags: 0x2 as libc::c_int as uint8_t,
                sym: 173 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 31 as libc::c_int as uint8_t,
                flags: 0x2 as libc::c_int as uint8_t,
                sym: 173 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 41 as libc::c_int as uint8_t,
                flags: 0x2 as libc::c_int as uint8_t,
                sym: 173 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 56 as libc::c_int as uint8_t,
                flags: 0x3 as libc::c_int as uint8_t,
                sym: 173 as libc::c_int as uint8_t,
            };
            init
        },
    ],
    [
        {
            let mut init = decode_el {
                state: 137 as libc::c_int as uint8_t,
                flags: 0 as libc::c_int as uint8_t,
                sym: 0 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 138 as libc::c_int as uint8_t,
                flags: 0 as libc::c_int as uint8_t,
                sym: 0 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 140 as libc::c_int as uint8_t,
                flags: 0 as libc::c_int as uint8_t,
                sym: 0 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 141 as libc::c_int as uint8_t,
                flags: 0 as libc::c_int as uint8_t,
                sym: 0 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 144 as libc::c_int as uint8_t,
                flags: 0 as libc::c_int as uint8_t,
                sym: 0 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 145 as libc::c_int as uint8_t,
                flags: 0 as libc::c_int as uint8_t,
                sym: 0 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 147 as libc::c_int as uint8_t,
                flags: 0 as libc::c_int as uint8_t,
                sym: 0 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 150 as libc::c_int as uint8_t,
                flags: 0 as libc::c_int as uint8_t,
                sym: 0 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 156 as libc::c_int as uint8_t,
                flags: 0 as libc::c_int as uint8_t,
                sym: 0 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 159 as libc::c_int as uint8_t,
                flags: 0 as libc::c_int as uint8_t,
                sym: 0 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 163 as libc::c_int as uint8_t,
                flags: 0 as libc::c_int as uint8_t,
                sym: 0 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 166 as libc::c_int as uint8_t,
                flags: 0 as libc::c_int as uint8_t,
                sym: 0 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 171 as libc::c_int as uint8_t,
                flags: 0 as libc::c_int as uint8_t,
                sym: 0 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 174 as libc::c_int as uint8_t,
                flags: 0 as libc::c_int as uint8_t,
                sym: 0 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 181 as libc::c_int as uint8_t,
                flags: 0 as libc::c_int as uint8_t,
                sym: 0 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 190 as libc::c_int as uint8_t,
                flags: 0 as libc::c_int as uint8_t,
                sym: 0 as libc::c_int as uint8_t,
            };
            init
        },
    ],
    [
        {
            let mut init = decode_el {
                state: 0 as libc::c_int as uint8_t,
                flags: 0x3 as libc::c_int as uint8_t,
                sym: 178 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 0 as libc::c_int as uint8_t,
                flags: 0x3 as libc::c_int as uint8_t,
                sym: 181 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 0 as libc::c_int as uint8_t,
                flags: 0x3 as libc::c_int as uint8_t,
                sym: 185 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 0 as libc::c_int as uint8_t,
                flags: 0x3 as libc::c_int as uint8_t,
                sym: 186 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 0 as libc::c_int as uint8_t,
                flags: 0x3 as libc::c_int as uint8_t,
                sym: 187 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 0 as libc::c_int as uint8_t,
                flags: 0x3 as libc::c_int as uint8_t,
                sym: 189 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 0 as libc::c_int as uint8_t,
                flags: 0x3 as libc::c_int as uint8_t,
                sym: 190 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 0 as libc::c_int as uint8_t,
                flags: 0x3 as libc::c_int as uint8_t,
                sym: 196 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 0 as libc::c_int as uint8_t,
                flags: 0x3 as libc::c_int as uint8_t,
                sym: 198 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 0 as libc::c_int as uint8_t,
                flags: 0x3 as libc::c_int as uint8_t,
                sym: 228 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 0 as libc::c_int as uint8_t,
                flags: 0x3 as libc::c_int as uint8_t,
                sym: 232 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 0 as libc::c_int as uint8_t,
                flags: 0x3 as libc::c_int as uint8_t,
                sym: 233 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 148 as libc::c_int as uint8_t,
                flags: 0 as libc::c_int as uint8_t,
                sym: 0 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 149 as libc::c_int as uint8_t,
                flags: 0 as libc::c_int as uint8_t,
                sym: 0 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 151 as libc::c_int as uint8_t,
                flags: 0 as libc::c_int as uint8_t,
                sym: 0 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 152 as libc::c_int as uint8_t,
                flags: 0 as libc::c_int as uint8_t,
                sym: 0 as libc::c_int as uint8_t,
            };
            init
        },
    ],
    [
        {
            let mut init = decode_el {
                state: 1 as libc::c_int as uint8_t,
                flags: 0x2 as libc::c_int as uint8_t,
                sym: 178 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 22 as libc::c_int as uint8_t,
                flags: 0x3 as libc::c_int as uint8_t,
                sym: 178 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 1 as libc::c_int as uint8_t,
                flags: 0x2 as libc::c_int as uint8_t,
                sym: 181 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 22 as libc::c_int as uint8_t,
                flags: 0x3 as libc::c_int as uint8_t,
                sym: 181 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 1 as libc::c_int as uint8_t,
                flags: 0x2 as libc::c_int as uint8_t,
                sym: 185 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 22 as libc::c_int as uint8_t,
                flags: 0x3 as libc::c_int as uint8_t,
                sym: 185 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 1 as libc::c_int as uint8_t,
                flags: 0x2 as libc::c_int as uint8_t,
                sym: 186 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 22 as libc::c_int as uint8_t,
                flags: 0x3 as libc::c_int as uint8_t,
                sym: 186 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 1 as libc::c_int as uint8_t,
                flags: 0x2 as libc::c_int as uint8_t,
                sym: 187 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 22 as libc::c_int as uint8_t,
                flags: 0x3 as libc::c_int as uint8_t,
                sym: 187 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 1 as libc::c_int as uint8_t,
                flags: 0x2 as libc::c_int as uint8_t,
                sym: 189 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 22 as libc::c_int as uint8_t,
                flags: 0x3 as libc::c_int as uint8_t,
                sym: 189 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 1 as libc::c_int as uint8_t,
                flags: 0x2 as libc::c_int as uint8_t,
                sym: 190 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 22 as libc::c_int as uint8_t,
                flags: 0x3 as libc::c_int as uint8_t,
                sym: 190 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 1 as libc::c_int as uint8_t,
                flags: 0x2 as libc::c_int as uint8_t,
                sym: 196 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 22 as libc::c_int as uint8_t,
                flags: 0x3 as libc::c_int as uint8_t,
                sym: 196 as libc::c_int as uint8_t,
            };
            init
        },
    ],
    [
        {
            let mut init = decode_el {
                state: 2 as libc::c_int as uint8_t,
                flags: 0x2 as libc::c_int as uint8_t,
                sym: 178 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 9 as libc::c_int as uint8_t,
                flags: 0x2 as libc::c_int as uint8_t,
                sym: 178 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 23 as libc::c_int as uint8_t,
                flags: 0x2 as libc::c_int as uint8_t,
                sym: 178 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 40 as libc::c_int as uint8_t,
                flags: 0x3 as libc::c_int as uint8_t,
                sym: 178 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 2 as libc::c_int as uint8_t,
                flags: 0x2 as libc::c_int as uint8_t,
                sym: 181 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 9 as libc::c_int as uint8_t,
                flags: 0x2 as libc::c_int as uint8_t,
                sym: 181 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 23 as libc::c_int as uint8_t,
                flags: 0x2 as libc::c_int as uint8_t,
                sym: 181 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 40 as libc::c_int as uint8_t,
                flags: 0x3 as libc::c_int as uint8_t,
                sym: 181 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 2 as libc::c_int as uint8_t,
                flags: 0x2 as libc::c_int as uint8_t,
                sym: 185 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 9 as libc::c_int as uint8_t,
                flags: 0x2 as libc::c_int as uint8_t,
                sym: 185 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 23 as libc::c_int as uint8_t,
                flags: 0x2 as libc::c_int as uint8_t,
                sym: 185 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 40 as libc::c_int as uint8_t,
                flags: 0x3 as libc::c_int as uint8_t,
                sym: 185 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 2 as libc::c_int as uint8_t,
                flags: 0x2 as libc::c_int as uint8_t,
                sym: 186 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 9 as libc::c_int as uint8_t,
                flags: 0x2 as libc::c_int as uint8_t,
                sym: 186 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 23 as libc::c_int as uint8_t,
                flags: 0x2 as libc::c_int as uint8_t,
                sym: 186 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 40 as libc::c_int as uint8_t,
                flags: 0x3 as libc::c_int as uint8_t,
                sym: 186 as libc::c_int as uint8_t,
            };
            init
        },
    ],
    [
        {
            let mut init = decode_el {
                state: 3 as libc::c_int as uint8_t,
                flags: 0x2 as libc::c_int as uint8_t,
                sym: 178 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 6 as libc::c_int as uint8_t,
                flags: 0x2 as libc::c_int as uint8_t,
                sym: 178 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 10 as libc::c_int as uint8_t,
                flags: 0x2 as libc::c_int as uint8_t,
                sym: 178 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 15 as libc::c_int as uint8_t,
                flags: 0x2 as libc::c_int as uint8_t,
                sym: 178 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 24 as libc::c_int as uint8_t,
                flags: 0x2 as libc::c_int as uint8_t,
                sym: 178 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 31 as libc::c_int as uint8_t,
                flags: 0x2 as libc::c_int as uint8_t,
                sym: 178 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 41 as libc::c_int as uint8_t,
                flags: 0x2 as libc::c_int as uint8_t,
                sym: 178 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 56 as libc::c_int as uint8_t,
                flags: 0x3 as libc::c_int as uint8_t,
                sym: 178 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 3 as libc::c_int as uint8_t,
                flags: 0x2 as libc::c_int as uint8_t,
                sym: 181 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 6 as libc::c_int as uint8_t,
                flags: 0x2 as libc::c_int as uint8_t,
                sym: 181 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 10 as libc::c_int as uint8_t,
                flags: 0x2 as libc::c_int as uint8_t,
                sym: 181 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 15 as libc::c_int as uint8_t,
                flags: 0x2 as libc::c_int as uint8_t,
                sym: 181 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 24 as libc::c_int as uint8_t,
                flags: 0x2 as libc::c_int as uint8_t,
                sym: 181 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 31 as libc::c_int as uint8_t,
                flags: 0x2 as libc::c_int as uint8_t,
                sym: 181 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 41 as libc::c_int as uint8_t,
                flags: 0x2 as libc::c_int as uint8_t,
                sym: 181 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 56 as libc::c_int as uint8_t,
                flags: 0x3 as libc::c_int as uint8_t,
                sym: 181 as libc::c_int as uint8_t,
            };
            init
        },
    ],
    [
        {
            let mut init = decode_el {
                state: 3 as libc::c_int as uint8_t,
                flags: 0x2 as libc::c_int as uint8_t,
                sym: 185 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 6 as libc::c_int as uint8_t,
                flags: 0x2 as libc::c_int as uint8_t,
                sym: 185 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 10 as libc::c_int as uint8_t,
                flags: 0x2 as libc::c_int as uint8_t,
                sym: 185 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 15 as libc::c_int as uint8_t,
                flags: 0x2 as libc::c_int as uint8_t,
                sym: 185 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 24 as libc::c_int as uint8_t,
                flags: 0x2 as libc::c_int as uint8_t,
                sym: 185 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 31 as libc::c_int as uint8_t,
                flags: 0x2 as libc::c_int as uint8_t,
                sym: 185 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 41 as libc::c_int as uint8_t,
                flags: 0x2 as libc::c_int as uint8_t,
                sym: 185 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 56 as libc::c_int as uint8_t,
                flags: 0x3 as libc::c_int as uint8_t,
                sym: 185 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 3 as libc::c_int as uint8_t,
                flags: 0x2 as libc::c_int as uint8_t,
                sym: 186 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 6 as libc::c_int as uint8_t,
                flags: 0x2 as libc::c_int as uint8_t,
                sym: 186 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 10 as libc::c_int as uint8_t,
                flags: 0x2 as libc::c_int as uint8_t,
                sym: 186 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 15 as libc::c_int as uint8_t,
                flags: 0x2 as libc::c_int as uint8_t,
                sym: 186 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 24 as libc::c_int as uint8_t,
                flags: 0x2 as libc::c_int as uint8_t,
                sym: 186 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 31 as libc::c_int as uint8_t,
                flags: 0x2 as libc::c_int as uint8_t,
                sym: 186 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 41 as libc::c_int as uint8_t,
                flags: 0x2 as libc::c_int as uint8_t,
                sym: 186 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 56 as libc::c_int as uint8_t,
                flags: 0x3 as libc::c_int as uint8_t,
                sym: 186 as libc::c_int as uint8_t,
            };
            init
        },
    ],
    [
        {
            let mut init = decode_el {
                state: 2 as libc::c_int as uint8_t,
                flags: 0x2 as libc::c_int as uint8_t,
                sym: 187 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 9 as libc::c_int as uint8_t,
                flags: 0x2 as libc::c_int as uint8_t,
                sym: 187 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 23 as libc::c_int as uint8_t,
                flags: 0x2 as libc::c_int as uint8_t,
                sym: 187 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 40 as libc::c_int as uint8_t,
                flags: 0x3 as libc::c_int as uint8_t,
                sym: 187 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 2 as libc::c_int as uint8_t,
                flags: 0x2 as libc::c_int as uint8_t,
                sym: 189 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 9 as libc::c_int as uint8_t,
                flags: 0x2 as libc::c_int as uint8_t,
                sym: 189 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 23 as libc::c_int as uint8_t,
                flags: 0x2 as libc::c_int as uint8_t,
                sym: 189 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 40 as libc::c_int as uint8_t,
                flags: 0x3 as libc::c_int as uint8_t,
                sym: 189 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 2 as libc::c_int as uint8_t,
                flags: 0x2 as libc::c_int as uint8_t,
                sym: 190 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 9 as libc::c_int as uint8_t,
                flags: 0x2 as libc::c_int as uint8_t,
                sym: 190 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 23 as libc::c_int as uint8_t,
                flags: 0x2 as libc::c_int as uint8_t,
                sym: 190 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 40 as libc::c_int as uint8_t,
                flags: 0x3 as libc::c_int as uint8_t,
                sym: 190 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 2 as libc::c_int as uint8_t,
                flags: 0x2 as libc::c_int as uint8_t,
                sym: 196 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 9 as libc::c_int as uint8_t,
                flags: 0x2 as libc::c_int as uint8_t,
                sym: 196 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 23 as libc::c_int as uint8_t,
                flags: 0x2 as libc::c_int as uint8_t,
                sym: 196 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 40 as libc::c_int as uint8_t,
                flags: 0x3 as libc::c_int as uint8_t,
                sym: 196 as libc::c_int as uint8_t,
            };
            init
        },
    ],
    [
        {
            let mut init = decode_el {
                state: 3 as libc::c_int as uint8_t,
                flags: 0x2 as libc::c_int as uint8_t,
                sym: 187 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 6 as libc::c_int as uint8_t,
                flags: 0x2 as libc::c_int as uint8_t,
                sym: 187 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 10 as libc::c_int as uint8_t,
                flags: 0x2 as libc::c_int as uint8_t,
                sym: 187 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 15 as libc::c_int as uint8_t,
                flags: 0x2 as libc::c_int as uint8_t,
                sym: 187 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 24 as libc::c_int as uint8_t,
                flags: 0x2 as libc::c_int as uint8_t,
                sym: 187 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 31 as libc::c_int as uint8_t,
                flags: 0x2 as libc::c_int as uint8_t,
                sym: 187 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 41 as libc::c_int as uint8_t,
                flags: 0x2 as libc::c_int as uint8_t,
                sym: 187 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 56 as libc::c_int as uint8_t,
                flags: 0x3 as libc::c_int as uint8_t,
                sym: 187 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 3 as libc::c_int as uint8_t,
                flags: 0x2 as libc::c_int as uint8_t,
                sym: 189 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 6 as libc::c_int as uint8_t,
                flags: 0x2 as libc::c_int as uint8_t,
                sym: 189 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 10 as libc::c_int as uint8_t,
                flags: 0x2 as libc::c_int as uint8_t,
                sym: 189 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 15 as libc::c_int as uint8_t,
                flags: 0x2 as libc::c_int as uint8_t,
                sym: 189 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 24 as libc::c_int as uint8_t,
                flags: 0x2 as libc::c_int as uint8_t,
                sym: 189 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 31 as libc::c_int as uint8_t,
                flags: 0x2 as libc::c_int as uint8_t,
                sym: 189 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 41 as libc::c_int as uint8_t,
                flags: 0x2 as libc::c_int as uint8_t,
                sym: 189 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 56 as libc::c_int as uint8_t,
                flags: 0x3 as libc::c_int as uint8_t,
                sym: 189 as libc::c_int as uint8_t,
            };
            init
        },
    ],
    [
        {
            let mut init = decode_el {
                state: 3 as libc::c_int as uint8_t,
                flags: 0x2 as libc::c_int as uint8_t,
                sym: 190 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 6 as libc::c_int as uint8_t,
                flags: 0x2 as libc::c_int as uint8_t,
                sym: 190 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 10 as libc::c_int as uint8_t,
                flags: 0x2 as libc::c_int as uint8_t,
                sym: 190 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 15 as libc::c_int as uint8_t,
                flags: 0x2 as libc::c_int as uint8_t,
                sym: 190 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 24 as libc::c_int as uint8_t,
                flags: 0x2 as libc::c_int as uint8_t,
                sym: 190 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 31 as libc::c_int as uint8_t,
                flags: 0x2 as libc::c_int as uint8_t,
                sym: 190 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 41 as libc::c_int as uint8_t,
                flags: 0x2 as libc::c_int as uint8_t,
                sym: 190 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 56 as libc::c_int as uint8_t,
                flags: 0x3 as libc::c_int as uint8_t,
                sym: 190 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 3 as libc::c_int as uint8_t,
                flags: 0x2 as libc::c_int as uint8_t,
                sym: 196 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 6 as libc::c_int as uint8_t,
                flags: 0x2 as libc::c_int as uint8_t,
                sym: 196 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 10 as libc::c_int as uint8_t,
                flags: 0x2 as libc::c_int as uint8_t,
                sym: 196 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 15 as libc::c_int as uint8_t,
                flags: 0x2 as libc::c_int as uint8_t,
                sym: 196 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 24 as libc::c_int as uint8_t,
                flags: 0x2 as libc::c_int as uint8_t,
                sym: 196 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 31 as libc::c_int as uint8_t,
                flags: 0x2 as libc::c_int as uint8_t,
                sym: 196 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 41 as libc::c_int as uint8_t,
                flags: 0x2 as libc::c_int as uint8_t,
                sym: 196 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 56 as libc::c_int as uint8_t,
                flags: 0x3 as libc::c_int as uint8_t,
                sym: 196 as libc::c_int as uint8_t,
            };
            init
        },
    ],
    [
        {
            let mut init = decode_el {
                state: 1 as libc::c_int as uint8_t,
                flags: 0x2 as libc::c_int as uint8_t,
                sym: 198 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 22 as libc::c_int as uint8_t,
                flags: 0x3 as libc::c_int as uint8_t,
                sym: 198 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 1 as libc::c_int as uint8_t,
                flags: 0x2 as libc::c_int as uint8_t,
                sym: 228 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 22 as libc::c_int as uint8_t,
                flags: 0x3 as libc::c_int as uint8_t,
                sym: 228 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 1 as libc::c_int as uint8_t,
                flags: 0x2 as libc::c_int as uint8_t,
                sym: 232 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 22 as libc::c_int as uint8_t,
                flags: 0x3 as libc::c_int as uint8_t,
                sym: 232 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 1 as libc::c_int as uint8_t,
                flags: 0x2 as libc::c_int as uint8_t,
                sym: 233 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 22 as libc::c_int as uint8_t,
                flags: 0x3 as libc::c_int as uint8_t,
                sym: 233 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 0 as libc::c_int as uint8_t,
                flags: 0x3 as libc::c_int as uint8_t,
                sym: 1 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 0 as libc::c_int as uint8_t,
                flags: 0x3 as libc::c_int as uint8_t,
                sym: 135 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 0 as libc::c_int as uint8_t,
                flags: 0x3 as libc::c_int as uint8_t,
                sym: 137 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 0 as libc::c_int as uint8_t,
                flags: 0x3 as libc::c_int as uint8_t,
                sym: 138 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 0 as libc::c_int as uint8_t,
                flags: 0x3 as libc::c_int as uint8_t,
                sym: 139 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 0 as libc::c_int as uint8_t,
                flags: 0x3 as libc::c_int as uint8_t,
                sym: 140 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 0 as libc::c_int as uint8_t,
                flags: 0x3 as libc::c_int as uint8_t,
                sym: 141 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 0 as libc::c_int as uint8_t,
                flags: 0x3 as libc::c_int as uint8_t,
                sym: 143 as libc::c_int as uint8_t,
            };
            init
        },
    ],
    [
        {
            let mut init = decode_el {
                state: 2 as libc::c_int as uint8_t,
                flags: 0x2 as libc::c_int as uint8_t,
                sym: 198 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 9 as libc::c_int as uint8_t,
                flags: 0x2 as libc::c_int as uint8_t,
                sym: 198 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 23 as libc::c_int as uint8_t,
                flags: 0x2 as libc::c_int as uint8_t,
                sym: 198 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 40 as libc::c_int as uint8_t,
                flags: 0x3 as libc::c_int as uint8_t,
                sym: 198 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 2 as libc::c_int as uint8_t,
                flags: 0x2 as libc::c_int as uint8_t,
                sym: 228 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 9 as libc::c_int as uint8_t,
                flags: 0x2 as libc::c_int as uint8_t,
                sym: 228 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 23 as libc::c_int as uint8_t,
                flags: 0x2 as libc::c_int as uint8_t,
                sym: 228 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 40 as libc::c_int as uint8_t,
                flags: 0x3 as libc::c_int as uint8_t,
                sym: 228 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 2 as libc::c_int as uint8_t,
                flags: 0x2 as libc::c_int as uint8_t,
                sym: 232 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 9 as libc::c_int as uint8_t,
                flags: 0x2 as libc::c_int as uint8_t,
                sym: 232 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 23 as libc::c_int as uint8_t,
                flags: 0x2 as libc::c_int as uint8_t,
                sym: 232 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 40 as libc::c_int as uint8_t,
                flags: 0x3 as libc::c_int as uint8_t,
                sym: 232 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 2 as libc::c_int as uint8_t,
                flags: 0x2 as libc::c_int as uint8_t,
                sym: 233 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 9 as libc::c_int as uint8_t,
                flags: 0x2 as libc::c_int as uint8_t,
                sym: 233 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 23 as libc::c_int as uint8_t,
                flags: 0x2 as libc::c_int as uint8_t,
                sym: 233 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 40 as libc::c_int as uint8_t,
                flags: 0x3 as libc::c_int as uint8_t,
                sym: 233 as libc::c_int as uint8_t,
            };
            init
        },
    ],
    [
        {
            let mut init = decode_el {
                state: 3 as libc::c_int as uint8_t,
                flags: 0x2 as libc::c_int as uint8_t,
                sym: 198 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 6 as libc::c_int as uint8_t,
                flags: 0x2 as libc::c_int as uint8_t,
                sym: 198 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 10 as libc::c_int as uint8_t,
                flags: 0x2 as libc::c_int as uint8_t,
                sym: 198 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 15 as libc::c_int as uint8_t,
                flags: 0x2 as libc::c_int as uint8_t,
                sym: 198 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 24 as libc::c_int as uint8_t,
                flags: 0x2 as libc::c_int as uint8_t,
                sym: 198 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 31 as libc::c_int as uint8_t,
                flags: 0x2 as libc::c_int as uint8_t,
                sym: 198 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 41 as libc::c_int as uint8_t,
                flags: 0x2 as libc::c_int as uint8_t,
                sym: 198 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 56 as libc::c_int as uint8_t,
                flags: 0x3 as libc::c_int as uint8_t,
                sym: 198 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 3 as libc::c_int as uint8_t,
                flags: 0x2 as libc::c_int as uint8_t,
                sym: 228 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 6 as libc::c_int as uint8_t,
                flags: 0x2 as libc::c_int as uint8_t,
                sym: 228 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 10 as libc::c_int as uint8_t,
                flags: 0x2 as libc::c_int as uint8_t,
                sym: 228 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 15 as libc::c_int as uint8_t,
                flags: 0x2 as libc::c_int as uint8_t,
                sym: 228 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 24 as libc::c_int as uint8_t,
                flags: 0x2 as libc::c_int as uint8_t,
                sym: 228 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 31 as libc::c_int as uint8_t,
                flags: 0x2 as libc::c_int as uint8_t,
                sym: 228 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 41 as libc::c_int as uint8_t,
                flags: 0x2 as libc::c_int as uint8_t,
                sym: 228 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 56 as libc::c_int as uint8_t,
                flags: 0x3 as libc::c_int as uint8_t,
                sym: 228 as libc::c_int as uint8_t,
            };
            init
        },
    ],
    [
        {
            let mut init = decode_el {
                state: 3 as libc::c_int as uint8_t,
                flags: 0x2 as libc::c_int as uint8_t,
                sym: 232 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 6 as libc::c_int as uint8_t,
                flags: 0x2 as libc::c_int as uint8_t,
                sym: 232 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 10 as libc::c_int as uint8_t,
                flags: 0x2 as libc::c_int as uint8_t,
                sym: 232 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 15 as libc::c_int as uint8_t,
                flags: 0x2 as libc::c_int as uint8_t,
                sym: 232 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 24 as libc::c_int as uint8_t,
                flags: 0x2 as libc::c_int as uint8_t,
                sym: 232 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 31 as libc::c_int as uint8_t,
                flags: 0x2 as libc::c_int as uint8_t,
                sym: 232 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 41 as libc::c_int as uint8_t,
                flags: 0x2 as libc::c_int as uint8_t,
                sym: 232 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 56 as libc::c_int as uint8_t,
                flags: 0x3 as libc::c_int as uint8_t,
                sym: 232 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 3 as libc::c_int as uint8_t,
                flags: 0x2 as libc::c_int as uint8_t,
                sym: 233 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 6 as libc::c_int as uint8_t,
                flags: 0x2 as libc::c_int as uint8_t,
                sym: 233 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 10 as libc::c_int as uint8_t,
                flags: 0x2 as libc::c_int as uint8_t,
                sym: 233 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 15 as libc::c_int as uint8_t,
                flags: 0x2 as libc::c_int as uint8_t,
                sym: 233 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 24 as libc::c_int as uint8_t,
                flags: 0x2 as libc::c_int as uint8_t,
                sym: 233 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 31 as libc::c_int as uint8_t,
                flags: 0x2 as libc::c_int as uint8_t,
                sym: 233 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 41 as libc::c_int as uint8_t,
                flags: 0x2 as libc::c_int as uint8_t,
                sym: 233 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 56 as libc::c_int as uint8_t,
                flags: 0x3 as libc::c_int as uint8_t,
                sym: 233 as libc::c_int as uint8_t,
            };
            init
        },
    ],
    [
        {
            let mut init = decode_el {
                state: 1 as libc::c_int as uint8_t,
                flags: 0x2 as libc::c_int as uint8_t,
                sym: 1 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 22 as libc::c_int as uint8_t,
                flags: 0x3 as libc::c_int as uint8_t,
                sym: 1 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 1 as libc::c_int as uint8_t,
                flags: 0x2 as libc::c_int as uint8_t,
                sym: 135 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 22 as libc::c_int as uint8_t,
                flags: 0x3 as libc::c_int as uint8_t,
                sym: 135 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 1 as libc::c_int as uint8_t,
                flags: 0x2 as libc::c_int as uint8_t,
                sym: 137 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 22 as libc::c_int as uint8_t,
                flags: 0x3 as libc::c_int as uint8_t,
                sym: 137 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 1 as libc::c_int as uint8_t,
                flags: 0x2 as libc::c_int as uint8_t,
                sym: 138 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 22 as libc::c_int as uint8_t,
                flags: 0x3 as libc::c_int as uint8_t,
                sym: 138 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 1 as libc::c_int as uint8_t,
                flags: 0x2 as libc::c_int as uint8_t,
                sym: 139 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 22 as libc::c_int as uint8_t,
                flags: 0x3 as libc::c_int as uint8_t,
                sym: 139 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 1 as libc::c_int as uint8_t,
                flags: 0x2 as libc::c_int as uint8_t,
                sym: 140 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 22 as libc::c_int as uint8_t,
                flags: 0x3 as libc::c_int as uint8_t,
                sym: 140 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 1 as libc::c_int as uint8_t,
                flags: 0x2 as libc::c_int as uint8_t,
                sym: 141 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 22 as libc::c_int as uint8_t,
                flags: 0x3 as libc::c_int as uint8_t,
                sym: 141 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 1 as libc::c_int as uint8_t,
                flags: 0x2 as libc::c_int as uint8_t,
                sym: 143 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 22 as libc::c_int as uint8_t,
                flags: 0x3 as libc::c_int as uint8_t,
                sym: 143 as libc::c_int as uint8_t,
            };
            init
        },
    ],
    [
        {
            let mut init = decode_el {
                state: 2 as libc::c_int as uint8_t,
                flags: 0x2 as libc::c_int as uint8_t,
                sym: 1 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 9 as libc::c_int as uint8_t,
                flags: 0x2 as libc::c_int as uint8_t,
                sym: 1 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 23 as libc::c_int as uint8_t,
                flags: 0x2 as libc::c_int as uint8_t,
                sym: 1 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 40 as libc::c_int as uint8_t,
                flags: 0x3 as libc::c_int as uint8_t,
                sym: 1 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 2 as libc::c_int as uint8_t,
                flags: 0x2 as libc::c_int as uint8_t,
                sym: 135 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 9 as libc::c_int as uint8_t,
                flags: 0x2 as libc::c_int as uint8_t,
                sym: 135 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 23 as libc::c_int as uint8_t,
                flags: 0x2 as libc::c_int as uint8_t,
                sym: 135 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 40 as libc::c_int as uint8_t,
                flags: 0x3 as libc::c_int as uint8_t,
                sym: 135 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 2 as libc::c_int as uint8_t,
                flags: 0x2 as libc::c_int as uint8_t,
                sym: 137 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 9 as libc::c_int as uint8_t,
                flags: 0x2 as libc::c_int as uint8_t,
                sym: 137 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 23 as libc::c_int as uint8_t,
                flags: 0x2 as libc::c_int as uint8_t,
                sym: 137 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 40 as libc::c_int as uint8_t,
                flags: 0x3 as libc::c_int as uint8_t,
                sym: 137 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 2 as libc::c_int as uint8_t,
                flags: 0x2 as libc::c_int as uint8_t,
                sym: 138 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 9 as libc::c_int as uint8_t,
                flags: 0x2 as libc::c_int as uint8_t,
                sym: 138 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 23 as libc::c_int as uint8_t,
                flags: 0x2 as libc::c_int as uint8_t,
                sym: 138 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 40 as libc::c_int as uint8_t,
                flags: 0x3 as libc::c_int as uint8_t,
                sym: 138 as libc::c_int as uint8_t,
            };
            init
        },
    ],
    [
        {
            let mut init = decode_el {
                state: 3 as libc::c_int as uint8_t,
                flags: 0x2 as libc::c_int as uint8_t,
                sym: 1 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 6 as libc::c_int as uint8_t,
                flags: 0x2 as libc::c_int as uint8_t,
                sym: 1 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 10 as libc::c_int as uint8_t,
                flags: 0x2 as libc::c_int as uint8_t,
                sym: 1 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 15 as libc::c_int as uint8_t,
                flags: 0x2 as libc::c_int as uint8_t,
                sym: 1 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 24 as libc::c_int as uint8_t,
                flags: 0x2 as libc::c_int as uint8_t,
                sym: 1 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 31 as libc::c_int as uint8_t,
                flags: 0x2 as libc::c_int as uint8_t,
                sym: 1 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 41 as libc::c_int as uint8_t,
                flags: 0x2 as libc::c_int as uint8_t,
                sym: 1 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 56 as libc::c_int as uint8_t,
                flags: 0x3 as libc::c_int as uint8_t,
                sym: 1 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 3 as libc::c_int as uint8_t,
                flags: 0x2 as libc::c_int as uint8_t,
                sym: 135 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 6 as libc::c_int as uint8_t,
                flags: 0x2 as libc::c_int as uint8_t,
                sym: 135 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 10 as libc::c_int as uint8_t,
                flags: 0x2 as libc::c_int as uint8_t,
                sym: 135 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 15 as libc::c_int as uint8_t,
                flags: 0x2 as libc::c_int as uint8_t,
                sym: 135 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 24 as libc::c_int as uint8_t,
                flags: 0x2 as libc::c_int as uint8_t,
                sym: 135 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 31 as libc::c_int as uint8_t,
                flags: 0x2 as libc::c_int as uint8_t,
                sym: 135 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 41 as libc::c_int as uint8_t,
                flags: 0x2 as libc::c_int as uint8_t,
                sym: 135 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 56 as libc::c_int as uint8_t,
                flags: 0x3 as libc::c_int as uint8_t,
                sym: 135 as libc::c_int as uint8_t,
            };
            init
        },
    ],
    [
        {
            let mut init = decode_el {
                state: 3 as libc::c_int as uint8_t,
                flags: 0x2 as libc::c_int as uint8_t,
                sym: 137 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 6 as libc::c_int as uint8_t,
                flags: 0x2 as libc::c_int as uint8_t,
                sym: 137 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 10 as libc::c_int as uint8_t,
                flags: 0x2 as libc::c_int as uint8_t,
                sym: 137 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 15 as libc::c_int as uint8_t,
                flags: 0x2 as libc::c_int as uint8_t,
                sym: 137 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 24 as libc::c_int as uint8_t,
                flags: 0x2 as libc::c_int as uint8_t,
                sym: 137 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 31 as libc::c_int as uint8_t,
                flags: 0x2 as libc::c_int as uint8_t,
                sym: 137 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 41 as libc::c_int as uint8_t,
                flags: 0x2 as libc::c_int as uint8_t,
                sym: 137 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 56 as libc::c_int as uint8_t,
                flags: 0x3 as libc::c_int as uint8_t,
                sym: 137 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 3 as libc::c_int as uint8_t,
                flags: 0x2 as libc::c_int as uint8_t,
                sym: 138 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 6 as libc::c_int as uint8_t,
                flags: 0x2 as libc::c_int as uint8_t,
                sym: 138 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 10 as libc::c_int as uint8_t,
                flags: 0x2 as libc::c_int as uint8_t,
                sym: 138 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 15 as libc::c_int as uint8_t,
                flags: 0x2 as libc::c_int as uint8_t,
                sym: 138 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 24 as libc::c_int as uint8_t,
                flags: 0x2 as libc::c_int as uint8_t,
                sym: 138 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 31 as libc::c_int as uint8_t,
                flags: 0x2 as libc::c_int as uint8_t,
                sym: 138 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 41 as libc::c_int as uint8_t,
                flags: 0x2 as libc::c_int as uint8_t,
                sym: 138 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 56 as libc::c_int as uint8_t,
                flags: 0x3 as libc::c_int as uint8_t,
                sym: 138 as libc::c_int as uint8_t,
            };
            init
        },
    ],
    [
        {
            let mut init = decode_el {
                state: 2 as libc::c_int as uint8_t,
                flags: 0x2 as libc::c_int as uint8_t,
                sym: 139 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 9 as libc::c_int as uint8_t,
                flags: 0x2 as libc::c_int as uint8_t,
                sym: 139 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 23 as libc::c_int as uint8_t,
                flags: 0x2 as libc::c_int as uint8_t,
                sym: 139 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 40 as libc::c_int as uint8_t,
                flags: 0x3 as libc::c_int as uint8_t,
                sym: 139 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 2 as libc::c_int as uint8_t,
                flags: 0x2 as libc::c_int as uint8_t,
                sym: 140 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 9 as libc::c_int as uint8_t,
                flags: 0x2 as libc::c_int as uint8_t,
                sym: 140 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 23 as libc::c_int as uint8_t,
                flags: 0x2 as libc::c_int as uint8_t,
                sym: 140 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 40 as libc::c_int as uint8_t,
                flags: 0x3 as libc::c_int as uint8_t,
                sym: 140 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 2 as libc::c_int as uint8_t,
                flags: 0x2 as libc::c_int as uint8_t,
                sym: 141 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 9 as libc::c_int as uint8_t,
                flags: 0x2 as libc::c_int as uint8_t,
                sym: 141 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 23 as libc::c_int as uint8_t,
                flags: 0x2 as libc::c_int as uint8_t,
                sym: 141 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 40 as libc::c_int as uint8_t,
                flags: 0x3 as libc::c_int as uint8_t,
                sym: 141 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 2 as libc::c_int as uint8_t,
                flags: 0x2 as libc::c_int as uint8_t,
                sym: 143 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 9 as libc::c_int as uint8_t,
                flags: 0x2 as libc::c_int as uint8_t,
                sym: 143 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 23 as libc::c_int as uint8_t,
                flags: 0x2 as libc::c_int as uint8_t,
                sym: 143 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 40 as libc::c_int as uint8_t,
                flags: 0x3 as libc::c_int as uint8_t,
                sym: 143 as libc::c_int as uint8_t,
            };
            init
        },
    ],
    [
        {
            let mut init = decode_el {
                state: 3 as libc::c_int as uint8_t,
                flags: 0x2 as libc::c_int as uint8_t,
                sym: 139 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 6 as libc::c_int as uint8_t,
                flags: 0x2 as libc::c_int as uint8_t,
                sym: 139 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 10 as libc::c_int as uint8_t,
                flags: 0x2 as libc::c_int as uint8_t,
                sym: 139 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 15 as libc::c_int as uint8_t,
                flags: 0x2 as libc::c_int as uint8_t,
                sym: 139 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 24 as libc::c_int as uint8_t,
                flags: 0x2 as libc::c_int as uint8_t,
                sym: 139 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 31 as libc::c_int as uint8_t,
                flags: 0x2 as libc::c_int as uint8_t,
                sym: 139 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 41 as libc::c_int as uint8_t,
                flags: 0x2 as libc::c_int as uint8_t,
                sym: 139 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 56 as libc::c_int as uint8_t,
                flags: 0x3 as libc::c_int as uint8_t,
                sym: 139 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 3 as libc::c_int as uint8_t,
                flags: 0x2 as libc::c_int as uint8_t,
                sym: 140 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 6 as libc::c_int as uint8_t,
                flags: 0x2 as libc::c_int as uint8_t,
                sym: 140 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 10 as libc::c_int as uint8_t,
                flags: 0x2 as libc::c_int as uint8_t,
                sym: 140 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 15 as libc::c_int as uint8_t,
                flags: 0x2 as libc::c_int as uint8_t,
                sym: 140 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 24 as libc::c_int as uint8_t,
                flags: 0x2 as libc::c_int as uint8_t,
                sym: 140 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 31 as libc::c_int as uint8_t,
                flags: 0x2 as libc::c_int as uint8_t,
                sym: 140 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 41 as libc::c_int as uint8_t,
                flags: 0x2 as libc::c_int as uint8_t,
                sym: 140 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 56 as libc::c_int as uint8_t,
                flags: 0x3 as libc::c_int as uint8_t,
                sym: 140 as libc::c_int as uint8_t,
            };
            init
        },
    ],
    [
        {
            let mut init = decode_el {
                state: 3 as libc::c_int as uint8_t,
                flags: 0x2 as libc::c_int as uint8_t,
                sym: 141 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 6 as libc::c_int as uint8_t,
                flags: 0x2 as libc::c_int as uint8_t,
                sym: 141 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 10 as libc::c_int as uint8_t,
                flags: 0x2 as libc::c_int as uint8_t,
                sym: 141 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 15 as libc::c_int as uint8_t,
                flags: 0x2 as libc::c_int as uint8_t,
                sym: 141 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 24 as libc::c_int as uint8_t,
                flags: 0x2 as libc::c_int as uint8_t,
                sym: 141 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 31 as libc::c_int as uint8_t,
                flags: 0x2 as libc::c_int as uint8_t,
                sym: 141 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 41 as libc::c_int as uint8_t,
                flags: 0x2 as libc::c_int as uint8_t,
                sym: 141 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 56 as libc::c_int as uint8_t,
                flags: 0x3 as libc::c_int as uint8_t,
                sym: 141 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 3 as libc::c_int as uint8_t,
                flags: 0x2 as libc::c_int as uint8_t,
                sym: 143 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 6 as libc::c_int as uint8_t,
                flags: 0x2 as libc::c_int as uint8_t,
                sym: 143 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 10 as libc::c_int as uint8_t,
                flags: 0x2 as libc::c_int as uint8_t,
                sym: 143 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 15 as libc::c_int as uint8_t,
                flags: 0x2 as libc::c_int as uint8_t,
                sym: 143 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 24 as libc::c_int as uint8_t,
                flags: 0x2 as libc::c_int as uint8_t,
                sym: 143 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 31 as libc::c_int as uint8_t,
                flags: 0x2 as libc::c_int as uint8_t,
                sym: 143 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 41 as libc::c_int as uint8_t,
                flags: 0x2 as libc::c_int as uint8_t,
                sym: 143 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 56 as libc::c_int as uint8_t,
                flags: 0x3 as libc::c_int as uint8_t,
                sym: 143 as libc::c_int as uint8_t,
            };
            init
        },
    ],
    [
        {
            let mut init = decode_el {
                state: 157 as libc::c_int as uint8_t,
                flags: 0 as libc::c_int as uint8_t,
                sym: 0 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 158 as libc::c_int as uint8_t,
                flags: 0 as libc::c_int as uint8_t,
                sym: 0 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 160 as libc::c_int as uint8_t,
                flags: 0 as libc::c_int as uint8_t,
                sym: 0 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 161 as libc::c_int as uint8_t,
                flags: 0 as libc::c_int as uint8_t,
                sym: 0 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 164 as libc::c_int as uint8_t,
                flags: 0 as libc::c_int as uint8_t,
                sym: 0 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 165 as libc::c_int as uint8_t,
                flags: 0 as libc::c_int as uint8_t,
                sym: 0 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 167 as libc::c_int as uint8_t,
                flags: 0 as libc::c_int as uint8_t,
                sym: 0 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 168 as libc::c_int as uint8_t,
                flags: 0 as libc::c_int as uint8_t,
                sym: 0 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 172 as libc::c_int as uint8_t,
                flags: 0 as libc::c_int as uint8_t,
                sym: 0 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 173 as libc::c_int as uint8_t,
                flags: 0 as libc::c_int as uint8_t,
                sym: 0 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 175 as libc::c_int as uint8_t,
                flags: 0 as libc::c_int as uint8_t,
                sym: 0 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 177 as libc::c_int as uint8_t,
                flags: 0 as libc::c_int as uint8_t,
                sym: 0 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 182 as libc::c_int as uint8_t,
                flags: 0 as libc::c_int as uint8_t,
                sym: 0 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 185 as libc::c_int as uint8_t,
                flags: 0 as libc::c_int as uint8_t,
                sym: 0 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 191 as libc::c_int as uint8_t,
                flags: 0 as libc::c_int as uint8_t,
                sym: 0 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 207 as libc::c_int as uint8_t,
                flags: 0 as libc::c_int as uint8_t,
                sym: 0 as libc::c_int as uint8_t,
            };
            init
        },
    ],
    [
        {
            let mut init = decode_el {
                state: 0 as libc::c_int as uint8_t,
                flags: 0x3 as libc::c_int as uint8_t,
                sym: 147 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 0 as libc::c_int as uint8_t,
                flags: 0x3 as libc::c_int as uint8_t,
                sym: 149 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 0 as libc::c_int as uint8_t,
                flags: 0x3 as libc::c_int as uint8_t,
                sym: 150 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 0 as libc::c_int as uint8_t,
                flags: 0x3 as libc::c_int as uint8_t,
                sym: 151 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 0 as libc::c_int as uint8_t,
                flags: 0x3 as libc::c_int as uint8_t,
                sym: 152 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 0 as libc::c_int as uint8_t,
                flags: 0x3 as libc::c_int as uint8_t,
                sym: 155 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 0 as libc::c_int as uint8_t,
                flags: 0x3 as libc::c_int as uint8_t,
                sym: 157 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 0 as libc::c_int as uint8_t,
                flags: 0x3 as libc::c_int as uint8_t,
                sym: 158 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 0 as libc::c_int as uint8_t,
                flags: 0x3 as libc::c_int as uint8_t,
                sym: 165 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 0 as libc::c_int as uint8_t,
                flags: 0x3 as libc::c_int as uint8_t,
                sym: 166 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 0 as libc::c_int as uint8_t,
                flags: 0x3 as libc::c_int as uint8_t,
                sym: 168 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 0 as libc::c_int as uint8_t,
                flags: 0x3 as libc::c_int as uint8_t,
                sym: 174 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 0 as libc::c_int as uint8_t,
                flags: 0x3 as libc::c_int as uint8_t,
                sym: 175 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 0 as libc::c_int as uint8_t,
                flags: 0x3 as libc::c_int as uint8_t,
                sym: 180 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 0 as libc::c_int as uint8_t,
                flags: 0x3 as libc::c_int as uint8_t,
                sym: 182 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 0 as libc::c_int as uint8_t,
                flags: 0x3 as libc::c_int as uint8_t,
                sym: 183 as libc::c_int as uint8_t,
            };
            init
        },
    ],
    [
        {
            let mut init = decode_el {
                state: 1 as libc::c_int as uint8_t,
                flags: 0x2 as libc::c_int as uint8_t,
                sym: 147 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 22 as libc::c_int as uint8_t,
                flags: 0x3 as libc::c_int as uint8_t,
                sym: 147 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 1 as libc::c_int as uint8_t,
                flags: 0x2 as libc::c_int as uint8_t,
                sym: 149 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 22 as libc::c_int as uint8_t,
                flags: 0x3 as libc::c_int as uint8_t,
                sym: 149 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 1 as libc::c_int as uint8_t,
                flags: 0x2 as libc::c_int as uint8_t,
                sym: 150 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 22 as libc::c_int as uint8_t,
                flags: 0x3 as libc::c_int as uint8_t,
                sym: 150 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 1 as libc::c_int as uint8_t,
                flags: 0x2 as libc::c_int as uint8_t,
                sym: 151 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 22 as libc::c_int as uint8_t,
                flags: 0x3 as libc::c_int as uint8_t,
                sym: 151 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 1 as libc::c_int as uint8_t,
                flags: 0x2 as libc::c_int as uint8_t,
                sym: 152 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 22 as libc::c_int as uint8_t,
                flags: 0x3 as libc::c_int as uint8_t,
                sym: 152 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 1 as libc::c_int as uint8_t,
                flags: 0x2 as libc::c_int as uint8_t,
                sym: 155 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 22 as libc::c_int as uint8_t,
                flags: 0x3 as libc::c_int as uint8_t,
                sym: 155 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 1 as libc::c_int as uint8_t,
                flags: 0x2 as libc::c_int as uint8_t,
                sym: 157 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 22 as libc::c_int as uint8_t,
                flags: 0x3 as libc::c_int as uint8_t,
                sym: 157 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 1 as libc::c_int as uint8_t,
                flags: 0x2 as libc::c_int as uint8_t,
                sym: 158 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 22 as libc::c_int as uint8_t,
                flags: 0x3 as libc::c_int as uint8_t,
                sym: 158 as libc::c_int as uint8_t,
            };
            init
        },
    ],
    [
        {
            let mut init = decode_el {
                state: 2 as libc::c_int as uint8_t,
                flags: 0x2 as libc::c_int as uint8_t,
                sym: 147 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 9 as libc::c_int as uint8_t,
                flags: 0x2 as libc::c_int as uint8_t,
                sym: 147 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 23 as libc::c_int as uint8_t,
                flags: 0x2 as libc::c_int as uint8_t,
                sym: 147 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 40 as libc::c_int as uint8_t,
                flags: 0x3 as libc::c_int as uint8_t,
                sym: 147 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 2 as libc::c_int as uint8_t,
                flags: 0x2 as libc::c_int as uint8_t,
                sym: 149 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 9 as libc::c_int as uint8_t,
                flags: 0x2 as libc::c_int as uint8_t,
                sym: 149 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 23 as libc::c_int as uint8_t,
                flags: 0x2 as libc::c_int as uint8_t,
                sym: 149 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 40 as libc::c_int as uint8_t,
                flags: 0x3 as libc::c_int as uint8_t,
                sym: 149 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 2 as libc::c_int as uint8_t,
                flags: 0x2 as libc::c_int as uint8_t,
                sym: 150 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 9 as libc::c_int as uint8_t,
                flags: 0x2 as libc::c_int as uint8_t,
                sym: 150 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 23 as libc::c_int as uint8_t,
                flags: 0x2 as libc::c_int as uint8_t,
                sym: 150 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 40 as libc::c_int as uint8_t,
                flags: 0x3 as libc::c_int as uint8_t,
                sym: 150 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 2 as libc::c_int as uint8_t,
                flags: 0x2 as libc::c_int as uint8_t,
                sym: 151 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 9 as libc::c_int as uint8_t,
                flags: 0x2 as libc::c_int as uint8_t,
                sym: 151 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 23 as libc::c_int as uint8_t,
                flags: 0x2 as libc::c_int as uint8_t,
                sym: 151 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 40 as libc::c_int as uint8_t,
                flags: 0x3 as libc::c_int as uint8_t,
                sym: 151 as libc::c_int as uint8_t,
            };
            init
        },
    ],
    [
        {
            let mut init = decode_el {
                state: 3 as libc::c_int as uint8_t,
                flags: 0x2 as libc::c_int as uint8_t,
                sym: 147 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 6 as libc::c_int as uint8_t,
                flags: 0x2 as libc::c_int as uint8_t,
                sym: 147 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 10 as libc::c_int as uint8_t,
                flags: 0x2 as libc::c_int as uint8_t,
                sym: 147 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 15 as libc::c_int as uint8_t,
                flags: 0x2 as libc::c_int as uint8_t,
                sym: 147 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 24 as libc::c_int as uint8_t,
                flags: 0x2 as libc::c_int as uint8_t,
                sym: 147 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 31 as libc::c_int as uint8_t,
                flags: 0x2 as libc::c_int as uint8_t,
                sym: 147 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 41 as libc::c_int as uint8_t,
                flags: 0x2 as libc::c_int as uint8_t,
                sym: 147 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 56 as libc::c_int as uint8_t,
                flags: 0x3 as libc::c_int as uint8_t,
                sym: 147 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 3 as libc::c_int as uint8_t,
                flags: 0x2 as libc::c_int as uint8_t,
                sym: 149 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 6 as libc::c_int as uint8_t,
                flags: 0x2 as libc::c_int as uint8_t,
                sym: 149 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 10 as libc::c_int as uint8_t,
                flags: 0x2 as libc::c_int as uint8_t,
                sym: 149 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 15 as libc::c_int as uint8_t,
                flags: 0x2 as libc::c_int as uint8_t,
                sym: 149 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 24 as libc::c_int as uint8_t,
                flags: 0x2 as libc::c_int as uint8_t,
                sym: 149 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 31 as libc::c_int as uint8_t,
                flags: 0x2 as libc::c_int as uint8_t,
                sym: 149 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 41 as libc::c_int as uint8_t,
                flags: 0x2 as libc::c_int as uint8_t,
                sym: 149 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 56 as libc::c_int as uint8_t,
                flags: 0x3 as libc::c_int as uint8_t,
                sym: 149 as libc::c_int as uint8_t,
            };
            init
        },
    ],
    [
        {
            let mut init = decode_el {
                state: 3 as libc::c_int as uint8_t,
                flags: 0x2 as libc::c_int as uint8_t,
                sym: 150 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 6 as libc::c_int as uint8_t,
                flags: 0x2 as libc::c_int as uint8_t,
                sym: 150 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 10 as libc::c_int as uint8_t,
                flags: 0x2 as libc::c_int as uint8_t,
                sym: 150 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 15 as libc::c_int as uint8_t,
                flags: 0x2 as libc::c_int as uint8_t,
                sym: 150 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 24 as libc::c_int as uint8_t,
                flags: 0x2 as libc::c_int as uint8_t,
                sym: 150 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 31 as libc::c_int as uint8_t,
                flags: 0x2 as libc::c_int as uint8_t,
                sym: 150 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 41 as libc::c_int as uint8_t,
                flags: 0x2 as libc::c_int as uint8_t,
                sym: 150 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 56 as libc::c_int as uint8_t,
                flags: 0x3 as libc::c_int as uint8_t,
                sym: 150 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 3 as libc::c_int as uint8_t,
                flags: 0x2 as libc::c_int as uint8_t,
                sym: 151 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 6 as libc::c_int as uint8_t,
                flags: 0x2 as libc::c_int as uint8_t,
                sym: 151 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 10 as libc::c_int as uint8_t,
                flags: 0x2 as libc::c_int as uint8_t,
                sym: 151 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 15 as libc::c_int as uint8_t,
                flags: 0x2 as libc::c_int as uint8_t,
                sym: 151 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 24 as libc::c_int as uint8_t,
                flags: 0x2 as libc::c_int as uint8_t,
                sym: 151 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 31 as libc::c_int as uint8_t,
                flags: 0x2 as libc::c_int as uint8_t,
                sym: 151 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 41 as libc::c_int as uint8_t,
                flags: 0x2 as libc::c_int as uint8_t,
                sym: 151 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 56 as libc::c_int as uint8_t,
                flags: 0x3 as libc::c_int as uint8_t,
                sym: 151 as libc::c_int as uint8_t,
            };
            init
        },
    ],
    [
        {
            let mut init = decode_el {
                state: 2 as libc::c_int as uint8_t,
                flags: 0x2 as libc::c_int as uint8_t,
                sym: 152 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 9 as libc::c_int as uint8_t,
                flags: 0x2 as libc::c_int as uint8_t,
                sym: 152 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 23 as libc::c_int as uint8_t,
                flags: 0x2 as libc::c_int as uint8_t,
                sym: 152 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 40 as libc::c_int as uint8_t,
                flags: 0x3 as libc::c_int as uint8_t,
                sym: 152 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 2 as libc::c_int as uint8_t,
                flags: 0x2 as libc::c_int as uint8_t,
                sym: 155 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 9 as libc::c_int as uint8_t,
                flags: 0x2 as libc::c_int as uint8_t,
                sym: 155 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 23 as libc::c_int as uint8_t,
                flags: 0x2 as libc::c_int as uint8_t,
                sym: 155 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 40 as libc::c_int as uint8_t,
                flags: 0x3 as libc::c_int as uint8_t,
                sym: 155 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 2 as libc::c_int as uint8_t,
                flags: 0x2 as libc::c_int as uint8_t,
                sym: 157 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 9 as libc::c_int as uint8_t,
                flags: 0x2 as libc::c_int as uint8_t,
                sym: 157 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 23 as libc::c_int as uint8_t,
                flags: 0x2 as libc::c_int as uint8_t,
                sym: 157 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 40 as libc::c_int as uint8_t,
                flags: 0x3 as libc::c_int as uint8_t,
                sym: 157 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 2 as libc::c_int as uint8_t,
                flags: 0x2 as libc::c_int as uint8_t,
                sym: 158 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 9 as libc::c_int as uint8_t,
                flags: 0x2 as libc::c_int as uint8_t,
                sym: 158 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 23 as libc::c_int as uint8_t,
                flags: 0x2 as libc::c_int as uint8_t,
                sym: 158 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 40 as libc::c_int as uint8_t,
                flags: 0x3 as libc::c_int as uint8_t,
                sym: 158 as libc::c_int as uint8_t,
            };
            init
        },
    ],
    [
        {
            let mut init = decode_el {
                state: 3 as libc::c_int as uint8_t,
                flags: 0x2 as libc::c_int as uint8_t,
                sym: 152 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 6 as libc::c_int as uint8_t,
                flags: 0x2 as libc::c_int as uint8_t,
                sym: 152 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 10 as libc::c_int as uint8_t,
                flags: 0x2 as libc::c_int as uint8_t,
                sym: 152 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 15 as libc::c_int as uint8_t,
                flags: 0x2 as libc::c_int as uint8_t,
                sym: 152 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 24 as libc::c_int as uint8_t,
                flags: 0x2 as libc::c_int as uint8_t,
                sym: 152 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 31 as libc::c_int as uint8_t,
                flags: 0x2 as libc::c_int as uint8_t,
                sym: 152 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 41 as libc::c_int as uint8_t,
                flags: 0x2 as libc::c_int as uint8_t,
                sym: 152 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 56 as libc::c_int as uint8_t,
                flags: 0x3 as libc::c_int as uint8_t,
                sym: 152 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 3 as libc::c_int as uint8_t,
                flags: 0x2 as libc::c_int as uint8_t,
                sym: 155 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 6 as libc::c_int as uint8_t,
                flags: 0x2 as libc::c_int as uint8_t,
                sym: 155 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 10 as libc::c_int as uint8_t,
                flags: 0x2 as libc::c_int as uint8_t,
                sym: 155 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 15 as libc::c_int as uint8_t,
                flags: 0x2 as libc::c_int as uint8_t,
                sym: 155 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 24 as libc::c_int as uint8_t,
                flags: 0x2 as libc::c_int as uint8_t,
                sym: 155 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 31 as libc::c_int as uint8_t,
                flags: 0x2 as libc::c_int as uint8_t,
                sym: 155 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 41 as libc::c_int as uint8_t,
                flags: 0x2 as libc::c_int as uint8_t,
                sym: 155 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 56 as libc::c_int as uint8_t,
                flags: 0x3 as libc::c_int as uint8_t,
                sym: 155 as libc::c_int as uint8_t,
            };
            init
        },
    ],
    [
        {
            let mut init = decode_el {
                state: 3 as libc::c_int as uint8_t,
                flags: 0x2 as libc::c_int as uint8_t,
                sym: 157 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 6 as libc::c_int as uint8_t,
                flags: 0x2 as libc::c_int as uint8_t,
                sym: 157 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 10 as libc::c_int as uint8_t,
                flags: 0x2 as libc::c_int as uint8_t,
                sym: 157 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 15 as libc::c_int as uint8_t,
                flags: 0x2 as libc::c_int as uint8_t,
                sym: 157 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 24 as libc::c_int as uint8_t,
                flags: 0x2 as libc::c_int as uint8_t,
                sym: 157 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 31 as libc::c_int as uint8_t,
                flags: 0x2 as libc::c_int as uint8_t,
                sym: 157 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 41 as libc::c_int as uint8_t,
                flags: 0x2 as libc::c_int as uint8_t,
                sym: 157 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 56 as libc::c_int as uint8_t,
                flags: 0x3 as libc::c_int as uint8_t,
                sym: 157 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 3 as libc::c_int as uint8_t,
                flags: 0x2 as libc::c_int as uint8_t,
                sym: 158 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 6 as libc::c_int as uint8_t,
                flags: 0x2 as libc::c_int as uint8_t,
                sym: 158 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 10 as libc::c_int as uint8_t,
                flags: 0x2 as libc::c_int as uint8_t,
                sym: 158 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 15 as libc::c_int as uint8_t,
                flags: 0x2 as libc::c_int as uint8_t,
                sym: 158 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 24 as libc::c_int as uint8_t,
                flags: 0x2 as libc::c_int as uint8_t,
                sym: 158 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 31 as libc::c_int as uint8_t,
                flags: 0x2 as libc::c_int as uint8_t,
                sym: 158 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 41 as libc::c_int as uint8_t,
                flags: 0x2 as libc::c_int as uint8_t,
                sym: 158 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 56 as libc::c_int as uint8_t,
                flags: 0x3 as libc::c_int as uint8_t,
                sym: 158 as libc::c_int as uint8_t,
            };
            init
        },
    ],
    [
        {
            let mut init = decode_el {
                state: 1 as libc::c_int as uint8_t,
                flags: 0x2 as libc::c_int as uint8_t,
                sym: 165 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 22 as libc::c_int as uint8_t,
                flags: 0x3 as libc::c_int as uint8_t,
                sym: 165 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 1 as libc::c_int as uint8_t,
                flags: 0x2 as libc::c_int as uint8_t,
                sym: 166 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 22 as libc::c_int as uint8_t,
                flags: 0x3 as libc::c_int as uint8_t,
                sym: 166 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 1 as libc::c_int as uint8_t,
                flags: 0x2 as libc::c_int as uint8_t,
                sym: 168 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 22 as libc::c_int as uint8_t,
                flags: 0x3 as libc::c_int as uint8_t,
                sym: 168 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 1 as libc::c_int as uint8_t,
                flags: 0x2 as libc::c_int as uint8_t,
                sym: 174 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 22 as libc::c_int as uint8_t,
                flags: 0x3 as libc::c_int as uint8_t,
                sym: 174 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 1 as libc::c_int as uint8_t,
                flags: 0x2 as libc::c_int as uint8_t,
                sym: 175 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 22 as libc::c_int as uint8_t,
                flags: 0x3 as libc::c_int as uint8_t,
                sym: 175 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 1 as libc::c_int as uint8_t,
                flags: 0x2 as libc::c_int as uint8_t,
                sym: 180 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 22 as libc::c_int as uint8_t,
                flags: 0x3 as libc::c_int as uint8_t,
                sym: 180 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 1 as libc::c_int as uint8_t,
                flags: 0x2 as libc::c_int as uint8_t,
                sym: 182 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 22 as libc::c_int as uint8_t,
                flags: 0x3 as libc::c_int as uint8_t,
                sym: 182 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 1 as libc::c_int as uint8_t,
                flags: 0x2 as libc::c_int as uint8_t,
                sym: 183 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 22 as libc::c_int as uint8_t,
                flags: 0x3 as libc::c_int as uint8_t,
                sym: 183 as libc::c_int as uint8_t,
            };
            init
        },
    ],
    [
        {
            let mut init = decode_el {
                state: 2 as libc::c_int as uint8_t,
                flags: 0x2 as libc::c_int as uint8_t,
                sym: 165 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 9 as libc::c_int as uint8_t,
                flags: 0x2 as libc::c_int as uint8_t,
                sym: 165 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 23 as libc::c_int as uint8_t,
                flags: 0x2 as libc::c_int as uint8_t,
                sym: 165 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 40 as libc::c_int as uint8_t,
                flags: 0x3 as libc::c_int as uint8_t,
                sym: 165 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 2 as libc::c_int as uint8_t,
                flags: 0x2 as libc::c_int as uint8_t,
                sym: 166 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 9 as libc::c_int as uint8_t,
                flags: 0x2 as libc::c_int as uint8_t,
                sym: 166 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 23 as libc::c_int as uint8_t,
                flags: 0x2 as libc::c_int as uint8_t,
                sym: 166 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 40 as libc::c_int as uint8_t,
                flags: 0x3 as libc::c_int as uint8_t,
                sym: 166 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 2 as libc::c_int as uint8_t,
                flags: 0x2 as libc::c_int as uint8_t,
                sym: 168 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 9 as libc::c_int as uint8_t,
                flags: 0x2 as libc::c_int as uint8_t,
                sym: 168 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 23 as libc::c_int as uint8_t,
                flags: 0x2 as libc::c_int as uint8_t,
                sym: 168 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 40 as libc::c_int as uint8_t,
                flags: 0x3 as libc::c_int as uint8_t,
                sym: 168 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 2 as libc::c_int as uint8_t,
                flags: 0x2 as libc::c_int as uint8_t,
                sym: 174 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 9 as libc::c_int as uint8_t,
                flags: 0x2 as libc::c_int as uint8_t,
                sym: 174 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 23 as libc::c_int as uint8_t,
                flags: 0x2 as libc::c_int as uint8_t,
                sym: 174 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 40 as libc::c_int as uint8_t,
                flags: 0x3 as libc::c_int as uint8_t,
                sym: 174 as libc::c_int as uint8_t,
            };
            init
        },
    ],
    [
        {
            let mut init = decode_el {
                state: 3 as libc::c_int as uint8_t,
                flags: 0x2 as libc::c_int as uint8_t,
                sym: 165 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 6 as libc::c_int as uint8_t,
                flags: 0x2 as libc::c_int as uint8_t,
                sym: 165 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 10 as libc::c_int as uint8_t,
                flags: 0x2 as libc::c_int as uint8_t,
                sym: 165 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 15 as libc::c_int as uint8_t,
                flags: 0x2 as libc::c_int as uint8_t,
                sym: 165 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 24 as libc::c_int as uint8_t,
                flags: 0x2 as libc::c_int as uint8_t,
                sym: 165 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 31 as libc::c_int as uint8_t,
                flags: 0x2 as libc::c_int as uint8_t,
                sym: 165 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 41 as libc::c_int as uint8_t,
                flags: 0x2 as libc::c_int as uint8_t,
                sym: 165 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 56 as libc::c_int as uint8_t,
                flags: 0x3 as libc::c_int as uint8_t,
                sym: 165 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 3 as libc::c_int as uint8_t,
                flags: 0x2 as libc::c_int as uint8_t,
                sym: 166 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 6 as libc::c_int as uint8_t,
                flags: 0x2 as libc::c_int as uint8_t,
                sym: 166 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 10 as libc::c_int as uint8_t,
                flags: 0x2 as libc::c_int as uint8_t,
                sym: 166 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 15 as libc::c_int as uint8_t,
                flags: 0x2 as libc::c_int as uint8_t,
                sym: 166 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 24 as libc::c_int as uint8_t,
                flags: 0x2 as libc::c_int as uint8_t,
                sym: 166 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 31 as libc::c_int as uint8_t,
                flags: 0x2 as libc::c_int as uint8_t,
                sym: 166 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 41 as libc::c_int as uint8_t,
                flags: 0x2 as libc::c_int as uint8_t,
                sym: 166 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 56 as libc::c_int as uint8_t,
                flags: 0x3 as libc::c_int as uint8_t,
                sym: 166 as libc::c_int as uint8_t,
            };
            init
        },
    ],
    [
        {
            let mut init = decode_el {
                state: 3 as libc::c_int as uint8_t,
                flags: 0x2 as libc::c_int as uint8_t,
                sym: 168 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 6 as libc::c_int as uint8_t,
                flags: 0x2 as libc::c_int as uint8_t,
                sym: 168 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 10 as libc::c_int as uint8_t,
                flags: 0x2 as libc::c_int as uint8_t,
                sym: 168 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 15 as libc::c_int as uint8_t,
                flags: 0x2 as libc::c_int as uint8_t,
                sym: 168 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 24 as libc::c_int as uint8_t,
                flags: 0x2 as libc::c_int as uint8_t,
                sym: 168 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 31 as libc::c_int as uint8_t,
                flags: 0x2 as libc::c_int as uint8_t,
                sym: 168 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 41 as libc::c_int as uint8_t,
                flags: 0x2 as libc::c_int as uint8_t,
                sym: 168 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 56 as libc::c_int as uint8_t,
                flags: 0x3 as libc::c_int as uint8_t,
                sym: 168 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 3 as libc::c_int as uint8_t,
                flags: 0x2 as libc::c_int as uint8_t,
                sym: 174 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 6 as libc::c_int as uint8_t,
                flags: 0x2 as libc::c_int as uint8_t,
                sym: 174 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 10 as libc::c_int as uint8_t,
                flags: 0x2 as libc::c_int as uint8_t,
                sym: 174 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 15 as libc::c_int as uint8_t,
                flags: 0x2 as libc::c_int as uint8_t,
                sym: 174 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 24 as libc::c_int as uint8_t,
                flags: 0x2 as libc::c_int as uint8_t,
                sym: 174 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 31 as libc::c_int as uint8_t,
                flags: 0x2 as libc::c_int as uint8_t,
                sym: 174 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 41 as libc::c_int as uint8_t,
                flags: 0x2 as libc::c_int as uint8_t,
                sym: 174 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 56 as libc::c_int as uint8_t,
                flags: 0x3 as libc::c_int as uint8_t,
                sym: 174 as libc::c_int as uint8_t,
            };
            init
        },
    ],
    [
        {
            let mut init = decode_el {
                state: 2 as libc::c_int as uint8_t,
                flags: 0x2 as libc::c_int as uint8_t,
                sym: 175 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 9 as libc::c_int as uint8_t,
                flags: 0x2 as libc::c_int as uint8_t,
                sym: 175 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 23 as libc::c_int as uint8_t,
                flags: 0x2 as libc::c_int as uint8_t,
                sym: 175 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 40 as libc::c_int as uint8_t,
                flags: 0x3 as libc::c_int as uint8_t,
                sym: 175 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 2 as libc::c_int as uint8_t,
                flags: 0x2 as libc::c_int as uint8_t,
                sym: 180 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 9 as libc::c_int as uint8_t,
                flags: 0x2 as libc::c_int as uint8_t,
                sym: 180 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 23 as libc::c_int as uint8_t,
                flags: 0x2 as libc::c_int as uint8_t,
                sym: 180 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 40 as libc::c_int as uint8_t,
                flags: 0x3 as libc::c_int as uint8_t,
                sym: 180 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 2 as libc::c_int as uint8_t,
                flags: 0x2 as libc::c_int as uint8_t,
                sym: 182 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 9 as libc::c_int as uint8_t,
                flags: 0x2 as libc::c_int as uint8_t,
                sym: 182 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 23 as libc::c_int as uint8_t,
                flags: 0x2 as libc::c_int as uint8_t,
                sym: 182 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 40 as libc::c_int as uint8_t,
                flags: 0x3 as libc::c_int as uint8_t,
                sym: 182 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 2 as libc::c_int as uint8_t,
                flags: 0x2 as libc::c_int as uint8_t,
                sym: 183 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 9 as libc::c_int as uint8_t,
                flags: 0x2 as libc::c_int as uint8_t,
                sym: 183 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 23 as libc::c_int as uint8_t,
                flags: 0x2 as libc::c_int as uint8_t,
                sym: 183 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 40 as libc::c_int as uint8_t,
                flags: 0x3 as libc::c_int as uint8_t,
                sym: 183 as libc::c_int as uint8_t,
            };
            init
        },
    ],
    [
        {
            let mut init = decode_el {
                state: 3 as libc::c_int as uint8_t,
                flags: 0x2 as libc::c_int as uint8_t,
                sym: 175 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 6 as libc::c_int as uint8_t,
                flags: 0x2 as libc::c_int as uint8_t,
                sym: 175 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 10 as libc::c_int as uint8_t,
                flags: 0x2 as libc::c_int as uint8_t,
                sym: 175 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 15 as libc::c_int as uint8_t,
                flags: 0x2 as libc::c_int as uint8_t,
                sym: 175 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 24 as libc::c_int as uint8_t,
                flags: 0x2 as libc::c_int as uint8_t,
                sym: 175 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 31 as libc::c_int as uint8_t,
                flags: 0x2 as libc::c_int as uint8_t,
                sym: 175 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 41 as libc::c_int as uint8_t,
                flags: 0x2 as libc::c_int as uint8_t,
                sym: 175 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 56 as libc::c_int as uint8_t,
                flags: 0x3 as libc::c_int as uint8_t,
                sym: 175 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 3 as libc::c_int as uint8_t,
                flags: 0x2 as libc::c_int as uint8_t,
                sym: 180 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 6 as libc::c_int as uint8_t,
                flags: 0x2 as libc::c_int as uint8_t,
                sym: 180 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 10 as libc::c_int as uint8_t,
                flags: 0x2 as libc::c_int as uint8_t,
                sym: 180 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 15 as libc::c_int as uint8_t,
                flags: 0x2 as libc::c_int as uint8_t,
                sym: 180 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 24 as libc::c_int as uint8_t,
                flags: 0x2 as libc::c_int as uint8_t,
                sym: 180 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 31 as libc::c_int as uint8_t,
                flags: 0x2 as libc::c_int as uint8_t,
                sym: 180 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 41 as libc::c_int as uint8_t,
                flags: 0x2 as libc::c_int as uint8_t,
                sym: 180 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 56 as libc::c_int as uint8_t,
                flags: 0x3 as libc::c_int as uint8_t,
                sym: 180 as libc::c_int as uint8_t,
            };
            init
        },
    ],
    [
        {
            let mut init = decode_el {
                state: 3 as libc::c_int as uint8_t,
                flags: 0x2 as libc::c_int as uint8_t,
                sym: 182 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 6 as libc::c_int as uint8_t,
                flags: 0x2 as libc::c_int as uint8_t,
                sym: 182 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 10 as libc::c_int as uint8_t,
                flags: 0x2 as libc::c_int as uint8_t,
                sym: 182 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 15 as libc::c_int as uint8_t,
                flags: 0x2 as libc::c_int as uint8_t,
                sym: 182 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 24 as libc::c_int as uint8_t,
                flags: 0x2 as libc::c_int as uint8_t,
                sym: 182 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 31 as libc::c_int as uint8_t,
                flags: 0x2 as libc::c_int as uint8_t,
                sym: 182 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 41 as libc::c_int as uint8_t,
                flags: 0x2 as libc::c_int as uint8_t,
                sym: 182 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 56 as libc::c_int as uint8_t,
                flags: 0x3 as libc::c_int as uint8_t,
                sym: 182 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 3 as libc::c_int as uint8_t,
                flags: 0x2 as libc::c_int as uint8_t,
                sym: 183 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 6 as libc::c_int as uint8_t,
                flags: 0x2 as libc::c_int as uint8_t,
                sym: 183 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 10 as libc::c_int as uint8_t,
                flags: 0x2 as libc::c_int as uint8_t,
                sym: 183 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 15 as libc::c_int as uint8_t,
                flags: 0x2 as libc::c_int as uint8_t,
                sym: 183 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 24 as libc::c_int as uint8_t,
                flags: 0x2 as libc::c_int as uint8_t,
                sym: 183 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 31 as libc::c_int as uint8_t,
                flags: 0x2 as libc::c_int as uint8_t,
                sym: 183 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 41 as libc::c_int as uint8_t,
                flags: 0x2 as libc::c_int as uint8_t,
                sym: 183 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 56 as libc::c_int as uint8_t,
                flags: 0x3 as libc::c_int as uint8_t,
                sym: 183 as libc::c_int as uint8_t,
            };
            init
        },
    ],
    [
        {
            let mut init = decode_el {
                state: 0 as libc::c_int as uint8_t,
                flags: 0x3 as libc::c_int as uint8_t,
                sym: 188 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 0 as libc::c_int as uint8_t,
                flags: 0x3 as libc::c_int as uint8_t,
                sym: 191 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 0 as libc::c_int as uint8_t,
                flags: 0x3 as libc::c_int as uint8_t,
                sym: 197 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 0 as libc::c_int as uint8_t,
                flags: 0x3 as libc::c_int as uint8_t,
                sym: 231 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 0 as libc::c_int as uint8_t,
                flags: 0x3 as libc::c_int as uint8_t,
                sym: 239 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 176 as libc::c_int as uint8_t,
                flags: 0 as libc::c_int as uint8_t,
                sym: 0 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 178 as libc::c_int as uint8_t,
                flags: 0 as libc::c_int as uint8_t,
                sym: 0 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 179 as libc::c_int as uint8_t,
                flags: 0 as libc::c_int as uint8_t,
                sym: 0 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 183 as libc::c_int as uint8_t,
                flags: 0 as libc::c_int as uint8_t,
                sym: 0 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 184 as libc::c_int as uint8_t,
                flags: 0 as libc::c_int as uint8_t,
                sym: 0 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 186 as libc::c_int as uint8_t,
                flags: 0 as libc::c_int as uint8_t,
                sym: 0 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 187 as libc::c_int as uint8_t,
                flags: 0 as libc::c_int as uint8_t,
                sym: 0 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 192 as libc::c_int as uint8_t,
                flags: 0 as libc::c_int as uint8_t,
                sym: 0 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 199 as libc::c_int as uint8_t,
                flags: 0 as libc::c_int as uint8_t,
                sym: 0 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 208 as libc::c_int as uint8_t,
                flags: 0 as libc::c_int as uint8_t,
                sym: 0 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 223 as libc::c_int as uint8_t,
                flags: 0 as libc::c_int as uint8_t,
                sym: 0 as libc::c_int as uint8_t,
            };
            init
        },
    ],
    [
        {
            let mut init = decode_el {
                state: 1 as libc::c_int as uint8_t,
                flags: 0x2 as libc::c_int as uint8_t,
                sym: 188 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 22 as libc::c_int as uint8_t,
                flags: 0x3 as libc::c_int as uint8_t,
                sym: 188 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 1 as libc::c_int as uint8_t,
                flags: 0x2 as libc::c_int as uint8_t,
                sym: 191 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 22 as libc::c_int as uint8_t,
                flags: 0x3 as libc::c_int as uint8_t,
                sym: 191 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 1 as libc::c_int as uint8_t,
                flags: 0x2 as libc::c_int as uint8_t,
                sym: 197 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 22 as libc::c_int as uint8_t,
                flags: 0x3 as libc::c_int as uint8_t,
                sym: 197 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 1 as libc::c_int as uint8_t,
                flags: 0x2 as libc::c_int as uint8_t,
                sym: 231 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 22 as libc::c_int as uint8_t,
                flags: 0x3 as libc::c_int as uint8_t,
                sym: 231 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 1 as libc::c_int as uint8_t,
                flags: 0x2 as libc::c_int as uint8_t,
                sym: 239 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 22 as libc::c_int as uint8_t,
                flags: 0x3 as libc::c_int as uint8_t,
                sym: 239 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 0 as libc::c_int as uint8_t,
                flags: 0x3 as libc::c_int as uint8_t,
                sym: 9 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 0 as libc::c_int as uint8_t,
                flags: 0x3 as libc::c_int as uint8_t,
                sym: 142 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 0 as libc::c_int as uint8_t,
                flags: 0x3 as libc::c_int as uint8_t,
                sym: 144 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 0 as libc::c_int as uint8_t,
                flags: 0x3 as libc::c_int as uint8_t,
                sym: 145 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 0 as libc::c_int as uint8_t,
                flags: 0x3 as libc::c_int as uint8_t,
                sym: 148 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 0 as libc::c_int as uint8_t,
                flags: 0x3 as libc::c_int as uint8_t,
                sym: 159 as libc::c_int as uint8_t,
            };
            init
        },
    ],
    [
        {
            let mut init = decode_el {
                state: 2 as libc::c_int as uint8_t,
                flags: 0x2 as libc::c_int as uint8_t,
                sym: 188 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 9 as libc::c_int as uint8_t,
                flags: 0x2 as libc::c_int as uint8_t,
                sym: 188 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 23 as libc::c_int as uint8_t,
                flags: 0x2 as libc::c_int as uint8_t,
                sym: 188 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 40 as libc::c_int as uint8_t,
                flags: 0x3 as libc::c_int as uint8_t,
                sym: 188 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 2 as libc::c_int as uint8_t,
                flags: 0x2 as libc::c_int as uint8_t,
                sym: 191 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 9 as libc::c_int as uint8_t,
                flags: 0x2 as libc::c_int as uint8_t,
                sym: 191 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 23 as libc::c_int as uint8_t,
                flags: 0x2 as libc::c_int as uint8_t,
                sym: 191 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 40 as libc::c_int as uint8_t,
                flags: 0x3 as libc::c_int as uint8_t,
                sym: 191 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 2 as libc::c_int as uint8_t,
                flags: 0x2 as libc::c_int as uint8_t,
                sym: 197 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 9 as libc::c_int as uint8_t,
                flags: 0x2 as libc::c_int as uint8_t,
                sym: 197 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 23 as libc::c_int as uint8_t,
                flags: 0x2 as libc::c_int as uint8_t,
                sym: 197 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 40 as libc::c_int as uint8_t,
                flags: 0x3 as libc::c_int as uint8_t,
                sym: 197 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 2 as libc::c_int as uint8_t,
                flags: 0x2 as libc::c_int as uint8_t,
                sym: 231 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 9 as libc::c_int as uint8_t,
                flags: 0x2 as libc::c_int as uint8_t,
                sym: 231 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 23 as libc::c_int as uint8_t,
                flags: 0x2 as libc::c_int as uint8_t,
                sym: 231 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 40 as libc::c_int as uint8_t,
                flags: 0x3 as libc::c_int as uint8_t,
                sym: 231 as libc::c_int as uint8_t,
            };
            init
        },
    ],
    [
        {
            let mut init = decode_el {
                state: 3 as libc::c_int as uint8_t,
                flags: 0x2 as libc::c_int as uint8_t,
                sym: 188 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 6 as libc::c_int as uint8_t,
                flags: 0x2 as libc::c_int as uint8_t,
                sym: 188 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 10 as libc::c_int as uint8_t,
                flags: 0x2 as libc::c_int as uint8_t,
                sym: 188 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 15 as libc::c_int as uint8_t,
                flags: 0x2 as libc::c_int as uint8_t,
                sym: 188 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 24 as libc::c_int as uint8_t,
                flags: 0x2 as libc::c_int as uint8_t,
                sym: 188 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 31 as libc::c_int as uint8_t,
                flags: 0x2 as libc::c_int as uint8_t,
                sym: 188 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 41 as libc::c_int as uint8_t,
                flags: 0x2 as libc::c_int as uint8_t,
                sym: 188 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 56 as libc::c_int as uint8_t,
                flags: 0x3 as libc::c_int as uint8_t,
                sym: 188 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 3 as libc::c_int as uint8_t,
                flags: 0x2 as libc::c_int as uint8_t,
                sym: 191 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 6 as libc::c_int as uint8_t,
                flags: 0x2 as libc::c_int as uint8_t,
                sym: 191 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 10 as libc::c_int as uint8_t,
                flags: 0x2 as libc::c_int as uint8_t,
                sym: 191 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 15 as libc::c_int as uint8_t,
                flags: 0x2 as libc::c_int as uint8_t,
                sym: 191 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 24 as libc::c_int as uint8_t,
                flags: 0x2 as libc::c_int as uint8_t,
                sym: 191 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 31 as libc::c_int as uint8_t,
                flags: 0x2 as libc::c_int as uint8_t,
                sym: 191 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 41 as libc::c_int as uint8_t,
                flags: 0x2 as libc::c_int as uint8_t,
                sym: 191 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 56 as libc::c_int as uint8_t,
                flags: 0x3 as libc::c_int as uint8_t,
                sym: 191 as libc::c_int as uint8_t,
            };
            init
        },
    ],
    [
        {
            let mut init = decode_el {
                state: 3 as libc::c_int as uint8_t,
                flags: 0x2 as libc::c_int as uint8_t,
                sym: 197 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 6 as libc::c_int as uint8_t,
                flags: 0x2 as libc::c_int as uint8_t,
                sym: 197 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 10 as libc::c_int as uint8_t,
                flags: 0x2 as libc::c_int as uint8_t,
                sym: 197 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 15 as libc::c_int as uint8_t,
                flags: 0x2 as libc::c_int as uint8_t,
                sym: 197 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 24 as libc::c_int as uint8_t,
                flags: 0x2 as libc::c_int as uint8_t,
                sym: 197 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 31 as libc::c_int as uint8_t,
                flags: 0x2 as libc::c_int as uint8_t,
                sym: 197 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 41 as libc::c_int as uint8_t,
                flags: 0x2 as libc::c_int as uint8_t,
                sym: 197 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 56 as libc::c_int as uint8_t,
                flags: 0x3 as libc::c_int as uint8_t,
                sym: 197 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 3 as libc::c_int as uint8_t,
                flags: 0x2 as libc::c_int as uint8_t,
                sym: 231 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 6 as libc::c_int as uint8_t,
                flags: 0x2 as libc::c_int as uint8_t,
                sym: 231 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 10 as libc::c_int as uint8_t,
                flags: 0x2 as libc::c_int as uint8_t,
                sym: 231 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 15 as libc::c_int as uint8_t,
                flags: 0x2 as libc::c_int as uint8_t,
                sym: 231 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 24 as libc::c_int as uint8_t,
                flags: 0x2 as libc::c_int as uint8_t,
                sym: 231 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 31 as libc::c_int as uint8_t,
                flags: 0x2 as libc::c_int as uint8_t,
                sym: 231 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 41 as libc::c_int as uint8_t,
                flags: 0x2 as libc::c_int as uint8_t,
                sym: 231 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 56 as libc::c_int as uint8_t,
                flags: 0x3 as libc::c_int as uint8_t,
                sym: 231 as libc::c_int as uint8_t,
            };
            init
        },
    ],
    [
        {
            let mut init = decode_el {
                state: 2 as libc::c_int as uint8_t,
                flags: 0x2 as libc::c_int as uint8_t,
                sym: 239 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 9 as libc::c_int as uint8_t,
                flags: 0x2 as libc::c_int as uint8_t,
                sym: 239 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 23 as libc::c_int as uint8_t,
                flags: 0x2 as libc::c_int as uint8_t,
                sym: 239 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 40 as libc::c_int as uint8_t,
                flags: 0x3 as libc::c_int as uint8_t,
                sym: 239 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 1 as libc::c_int as uint8_t,
                flags: 0x2 as libc::c_int as uint8_t,
                sym: 9 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 22 as libc::c_int as uint8_t,
                flags: 0x3 as libc::c_int as uint8_t,
                sym: 9 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 1 as libc::c_int as uint8_t,
                flags: 0x2 as libc::c_int as uint8_t,
                sym: 142 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 22 as libc::c_int as uint8_t,
                flags: 0x3 as libc::c_int as uint8_t,
                sym: 142 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 1 as libc::c_int as uint8_t,
                flags: 0x2 as libc::c_int as uint8_t,
                sym: 144 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 22 as libc::c_int as uint8_t,
                flags: 0x3 as libc::c_int as uint8_t,
                sym: 144 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 1 as libc::c_int as uint8_t,
                flags: 0x2 as libc::c_int as uint8_t,
                sym: 145 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 22 as libc::c_int as uint8_t,
                flags: 0x3 as libc::c_int as uint8_t,
                sym: 145 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 1 as libc::c_int as uint8_t,
                flags: 0x2 as libc::c_int as uint8_t,
                sym: 148 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 22 as libc::c_int as uint8_t,
                flags: 0x3 as libc::c_int as uint8_t,
                sym: 148 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 1 as libc::c_int as uint8_t,
                flags: 0x2 as libc::c_int as uint8_t,
                sym: 159 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 22 as libc::c_int as uint8_t,
                flags: 0x3 as libc::c_int as uint8_t,
                sym: 159 as libc::c_int as uint8_t,
            };
            init
        },
    ],
    [
        {
            let mut init = decode_el {
                state: 3 as libc::c_int as uint8_t,
                flags: 0x2 as libc::c_int as uint8_t,
                sym: 239 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 6 as libc::c_int as uint8_t,
                flags: 0x2 as libc::c_int as uint8_t,
                sym: 239 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 10 as libc::c_int as uint8_t,
                flags: 0x2 as libc::c_int as uint8_t,
                sym: 239 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 15 as libc::c_int as uint8_t,
                flags: 0x2 as libc::c_int as uint8_t,
                sym: 239 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 24 as libc::c_int as uint8_t,
                flags: 0x2 as libc::c_int as uint8_t,
                sym: 239 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 31 as libc::c_int as uint8_t,
                flags: 0x2 as libc::c_int as uint8_t,
                sym: 239 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 41 as libc::c_int as uint8_t,
                flags: 0x2 as libc::c_int as uint8_t,
                sym: 239 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 56 as libc::c_int as uint8_t,
                flags: 0x3 as libc::c_int as uint8_t,
                sym: 239 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 2 as libc::c_int as uint8_t,
                flags: 0x2 as libc::c_int as uint8_t,
                sym: 9 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 9 as libc::c_int as uint8_t,
                flags: 0x2 as libc::c_int as uint8_t,
                sym: 9 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 23 as libc::c_int as uint8_t,
                flags: 0x2 as libc::c_int as uint8_t,
                sym: 9 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 40 as libc::c_int as uint8_t,
                flags: 0x3 as libc::c_int as uint8_t,
                sym: 9 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 2 as libc::c_int as uint8_t,
                flags: 0x2 as libc::c_int as uint8_t,
                sym: 142 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 9 as libc::c_int as uint8_t,
                flags: 0x2 as libc::c_int as uint8_t,
                sym: 142 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 23 as libc::c_int as uint8_t,
                flags: 0x2 as libc::c_int as uint8_t,
                sym: 142 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 40 as libc::c_int as uint8_t,
                flags: 0x3 as libc::c_int as uint8_t,
                sym: 142 as libc::c_int as uint8_t,
            };
            init
        },
    ],
    [
        {
            let mut init = decode_el {
                state: 3 as libc::c_int as uint8_t,
                flags: 0x2 as libc::c_int as uint8_t,
                sym: 9 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 6 as libc::c_int as uint8_t,
                flags: 0x2 as libc::c_int as uint8_t,
                sym: 9 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 10 as libc::c_int as uint8_t,
                flags: 0x2 as libc::c_int as uint8_t,
                sym: 9 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 15 as libc::c_int as uint8_t,
                flags: 0x2 as libc::c_int as uint8_t,
                sym: 9 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 24 as libc::c_int as uint8_t,
                flags: 0x2 as libc::c_int as uint8_t,
                sym: 9 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 31 as libc::c_int as uint8_t,
                flags: 0x2 as libc::c_int as uint8_t,
                sym: 9 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 41 as libc::c_int as uint8_t,
                flags: 0x2 as libc::c_int as uint8_t,
                sym: 9 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 56 as libc::c_int as uint8_t,
                flags: 0x3 as libc::c_int as uint8_t,
                sym: 9 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 3 as libc::c_int as uint8_t,
                flags: 0x2 as libc::c_int as uint8_t,
                sym: 142 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 6 as libc::c_int as uint8_t,
                flags: 0x2 as libc::c_int as uint8_t,
                sym: 142 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 10 as libc::c_int as uint8_t,
                flags: 0x2 as libc::c_int as uint8_t,
                sym: 142 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 15 as libc::c_int as uint8_t,
                flags: 0x2 as libc::c_int as uint8_t,
                sym: 142 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 24 as libc::c_int as uint8_t,
                flags: 0x2 as libc::c_int as uint8_t,
                sym: 142 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 31 as libc::c_int as uint8_t,
                flags: 0x2 as libc::c_int as uint8_t,
                sym: 142 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 41 as libc::c_int as uint8_t,
                flags: 0x2 as libc::c_int as uint8_t,
                sym: 142 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 56 as libc::c_int as uint8_t,
                flags: 0x3 as libc::c_int as uint8_t,
                sym: 142 as libc::c_int as uint8_t,
            };
            init
        },
    ],
    [
        {
            let mut init = decode_el {
                state: 2 as libc::c_int as uint8_t,
                flags: 0x2 as libc::c_int as uint8_t,
                sym: 144 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 9 as libc::c_int as uint8_t,
                flags: 0x2 as libc::c_int as uint8_t,
                sym: 144 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 23 as libc::c_int as uint8_t,
                flags: 0x2 as libc::c_int as uint8_t,
                sym: 144 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 40 as libc::c_int as uint8_t,
                flags: 0x3 as libc::c_int as uint8_t,
                sym: 144 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 2 as libc::c_int as uint8_t,
                flags: 0x2 as libc::c_int as uint8_t,
                sym: 145 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 9 as libc::c_int as uint8_t,
                flags: 0x2 as libc::c_int as uint8_t,
                sym: 145 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 23 as libc::c_int as uint8_t,
                flags: 0x2 as libc::c_int as uint8_t,
                sym: 145 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 40 as libc::c_int as uint8_t,
                flags: 0x3 as libc::c_int as uint8_t,
                sym: 145 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 2 as libc::c_int as uint8_t,
                flags: 0x2 as libc::c_int as uint8_t,
                sym: 148 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 9 as libc::c_int as uint8_t,
                flags: 0x2 as libc::c_int as uint8_t,
                sym: 148 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 23 as libc::c_int as uint8_t,
                flags: 0x2 as libc::c_int as uint8_t,
                sym: 148 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 40 as libc::c_int as uint8_t,
                flags: 0x3 as libc::c_int as uint8_t,
                sym: 148 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 2 as libc::c_int as uint8_t,
                flags: 0x2 as libc::c_int as uint8_t,
                sym: 159 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 9 as libc::c_int as uint8_t,
                flags: 0x2 as libc::c_int as uint8_t,
                sym: 159 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 23 as libc::c_int as uint8_t,
                flags: 0x2 as libc::c_int as uint8_t,
                sym: 159 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 40 as libc::c_int as uint8_t,
                flags: 0x3 as libc::c_int as uint8_t,
                sym: 159 as libc::c_int as uint8_t,
            };
            init
        },
    ],
    [
        {
            let mut init = decode_el {
                state: 3 as libc::c_int as uint8_t,
                flags: 0x2 as libc::c_int as uint8_t,
                sym: 144 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 6 as libc::c_int as uint8_t,
                flags: 0x2 as libc::c_int as uint8_t,
                sym: 144 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 10 as libc::c_int as uint8_t,
                flags: 0x2 as libc::c_int as uint8_t,
                sym: 144 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 15 as libc::c_int as uint8_t,
                flags: 0x2 as libc::c_int as uint8_t,
                sym: 144 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 24 as libc::c_int as uint8_t,
                flags: 0x2 as libc::c_int as uint8_t,
                sym: 144 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 31 as libc::c_int as uint8_t,
                flags: 0x2 as libc::c_int as uint8_t,
                sym: 144 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 41 as libc::c_int as uint8_t,
                flags: 0x2 as libc::c_int as uint8_t,
                sym: 144 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 56 as libc::c_int as uint8_t,
                flags: 0x3 as libc::c_int as uint8_t,
                sym: 144 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 3 as libc::c_int as uint8_t,
                flags: 0x2 as libc::c_int as uint8_t,
                sym: 145 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 6 as libc::c_int as uint8_t,
                flags: 0x2 as libc::c_int as uint8_t,
                sym: 145 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 10 as libc::c_int as uint8_t,
                flags: 0x2 as libc::c_int as uint8_t,
                sym: 145 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 15 as libc::c_int as uint8_t,
                flags: 0x2 as libc::c_int as uint8_t,
                sym: 145 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 24 as libc::c_int as uint8_t,
                flags: 0x2 as libc::c_int as uint8_t,
                sym: 145 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 31 as libc::c_int as uint8_t,
                flags: 0x2 as libc::c_int as uint8_t,
                sym: 145 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 41 as libc::c_int as uint8_t,
                flags: 0x2 as libc::c_int as uint8_t,
                sym: 145 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 56 as libc::c_int as uint8_t,
                flags: 0x3 as libc::c_int as uint8_t,
                sym: 145 as libc::c_int as uint8_t,
            };
            init
        },
    ],
    [
        {
            let mut init = decode_el {
                state: 3 as libc::c_int as uint8_t,
                flags: 0x2 as libc::c_int as uint8_t,
                sym: 148 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 6 as libc::c_int as uint8_t,
                flags: 0x2 as libc::c_int as uint8_t,
                sym: 148 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 10 as libc::c_int as uint8_t,
                flags: 0x2 as libc::c_int as uint8_t,
                sym: 148 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 15 as libc::c_int as uint8_t,
                flags: 0x2 as libc::c_int as uint8_t,
                sym: 148 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 24 as libc::c_int as uint8_t,
                flags: 0x2 as libc::c_int as uint8_t,
                sym: 148 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 31 as libc::c_int as uint8_t,
                flags: 0x2 as libc::c_int as uint8_t,
                sym: 148 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 41 as libc::c_int as uint8_t,
                flags: 0x2 as libc::c_int as uint8_t,
                sym: 148 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 56 as libc::c_int as uint8_t,
                flags: 0x3 as libc::c_int as uint8_t,
                sym: 148 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 3 as libc::c_int as uint8_t,
                flags: 0x2 as libc::c_int as uint8_t,
                sym: 159 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 6 as libc::c_int as uint8_t,
                flags: 0x2 as libc::c_int as uint8_t,
                sym: 159 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 10 as libc::c_int as uint8_t,
                flags: 0x2 as libc::c_int as uint8_t,
                sym: 159 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 15 as libc::c_int as uint8_t,
                flags: 0x2 as libc::c_int as uint8_t,
                sym: 159 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 24 as libc::c_int as uint8_t,
                flags: 0x2 as libc::c_int as uint8_t,
                sym: 159 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 31 as libc::c_int as uint8_t,
                flags: 0x2 as libc::c_int as uint8_t,
                sym: 159 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 41 as libc::c_int as uint8_t,
                flags: 0x2 as libc::c_int as uint8_t,
                sym: 159 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 56 as libc::c_int as uint8_t,
                flags: 0x3 as libc::c_int as uint8_t,
                sym: 159 as libc::c_int as uint8_t,
            };
            init
        },
    ],
    [
        {
            let mut init = decode_el {
                state: 0 as libc::c_int as uint8_t,
                flags: 0x3 as libc::c_int as uint8_t,
                sym: 171 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 0 as libc::c_int as uint8_t,
                flags: 0x3 as libc::c_int as uint8_t,
                sym: 206 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 0 as libc::c_int as uint8_t,
                flags: 0x3 as libc::c_int as uint8_t,
                sym: 215 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 0 as libc::c_int as uint8_t,
                flags: 0x3 as libc::c_int as uint8_t,
                sym: 225 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 0 as libc::c_int as uint8_t,
                flags: 0x3 as libc::c_int as uint8_t,
                sym: 236 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 0 as libc::c_int as uint8_t,
                flags: 0x3 as libc::c_int as uint8_t,
                sym: 237 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 188 as libc::c_int as uint8_t,
                flags: 0 as libc::c_int as uint8_t,
                sym: 0 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 189 as libc::c_int as uint8_t,
                flags: 0 as libc::c_int as uint8_t,
                sym: 0 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 193 as libc::c_int as uint8_t,
                flags: 0 as libc::c_int as uint8_t,
                sym: 0 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 196 as libc::c_int as uint8_t,
                flags: 0 as libc::c_int as uint8_t,
                sym: 0 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 200 as libc::c_int as uint8_t,
                flags: 0 as libc::c_int as uint8_t,
                sym: 0 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 203 as libc::c_int as uint8_t,
                flags: 0 as libc::c_int as uint8_t,
                sym: 0 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 209 as libc::c_int as uint8_t,
                flags: 0 as libc::c_int as uint8_t,
                sym: 0 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 216 as libc::c_int as uint8_t,
                flags: 0 as libc::c_int as uint8_t,
                sym: 0 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 224 as libc::c_int as uint8_t,
                flags: 0 as libc::c_int as uint8_t,
                sym: 0 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 238 as libc::c_int as uint8_t,
                flags: 0 as libc::c_int as uint8_t,
                sym: 0 as libc::c_int as uint8_t,
            };
            init
        },
    ],
    [
        {
            let mut init = decode_el {
                state: 1 as libc::c_int as uint8_t,
                flags: 0x2 as libc::c_int as uint8_t,
                sym: 171 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 22 as libc::c_int as uint8_t,
                flags: 0x3 as libc::c_int as uint8_t,
                sym: 171 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 1 as libc::c_int as uint8_t,
                flags: 0x2 as libc::c_int as uint8_t,
                sym: 206 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 22 as libc::c_int as uint8_t,
                flags: 0x3 as libc::c_int as uint8_t,
                sym: 206 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 1 as libc::c_int as uint8_t,
                flags: 0x2 as libc::c_int as uint8_t,
                sym: 215 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 22 as libc::c_int as uint8_t,
                flags: 0x3 as libc::c_int as uint8_t,
                sym: 215 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 1 as libc::c_int as uint8_t,
                flags: 0x2 as libc::c_int as uint8_t,
                sym: 225 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 22 as libc::c_int as uint8_t,
                flags: 0x3 as libc::c_int as uint8_t,
                sym: 225 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 1 as libc::c_int as uint8_t,
                flags: 0x2 as libc::c_int as uint8_t,
                sym: 236 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 22 as libc::c_int as uint8_t,
                flags: 0x3 as libc::c_int as uint8_t,
                sym: 236 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 1 as libc::c_int as uint8_t,
                flags: 0x2 as libc::c_int as uint8_t,
                sym: 237 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 22 as libc::c_int as uint8_t,
                flags: 0x3 as libc::c_int as uint8_t,
                sym: 237 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 0 as libc::c_int as uint8_t,
                flags: 0x3 as libc::c_int as uint8_t,
                sym: 199 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 0 as libc::c_int as uint8_t,
                flags: 0x3 as libc::c_int as uint8_t,
                sym: 207 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 0 as libc::c_int as uint8_t,
                flags: 0x3 as libc::c_int as uint8_t,
                sym: 234 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 0 as libc::c_int as uint8_t,
                flags: 0x3 as libc::c_int as uint8_t,
                sym: 235 as libc::c_int as uint8_t,
            };
            init
        },
    ],
    [
        {
            let mut init = decode_el {
                state: 2 as libc::c_int as uint8_t,
                flags: 0x2 as libc::c_int as uint8_t,
                sym: 171 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 9 as libc::c_int as uint8_t,
                flags: 0x2 as libc::c_int as uint8_t,
                sym: 171 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 23 as libc::c_int as uint8_t,
                flags: 0x2 as libc::c_int as uint8_t,
                sym: 171 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 40 as libc::c_int as uint8_t,
                flags: 0x3 as libc::c_int as uint8_t,
                sym: 171 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 2 as libc::c_int as uint8_t,
                flags: 0x2 as libc::c_int as uint8_t,
                sym: 206 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 9 as libc::c_int as uint8_t,
                flags: 0x2 as libc::c_int as uint8_t,
                sym: 206 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 23 as libc::c_int as uint8_t,
                flags: 0x2 as libc::c_int as uint8_t,
                sym: 206 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 40 as libc::c_int as uint8_t,
                flags: 0x3 as libc::c_int as uint8_t,
                sym: 206 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 2 as libc::c_int as uint8_t,
                flags: 0x2 as libc::c_int as uint8_t,
                sym: 215 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 9 as libc::c_int as uint8_t,
                flags: 0x2 as libc::c_int as uint8_t,
                sym: 215 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 23 as libc::c_int as uint8_t,
                flags: 0x2 as libc::c_int as uint8_t,
                sym: 215 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 40 as libc::c_int as uint8_t,
                flags: 0x3 as libc::c_int as uint8_t,
                sym: 215 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 2 as libc::c_int as uint8_t,
                flags: 0x2 as libc::c_int as uint8_t,
                sym: 225 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 9 as libc::c_int as uint8_t,
                flags: 0x2 as libc::c_int as uint8_t,
                sym: 225 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 23 as libc::c_int as uint8_t,
                flags: 0x2 as libc::c_int as uint8_t,
                sym: 225 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 40 as libc::c_int as uint8_t,
                flags: 0x3 as libc::c_int as uint8_t,
                sym: 225 as libc::c_int as uint8_t,
            };
            init
        },
    ],
    [
        {
            let mut init = decode_el {
                state: 3 as libc::c_int as uint8_t,
                flags: 0x2 as libc::c_int as uint8_t,
                sym: 171 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 6 as libc::c_int as uint8_t,
                flags: 0x2 as libc::c_int as uint8_t,
                sym: 171 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 10 as libc::c_int as uint8_t,
                flags: 0x2 as libc::c_int as uint8_t,
                sym: 171 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 15 as libc::c_int as uint8_t,
                flags: 0x2 as libc::c_int as uint8_t,
                sym: 171 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 24 as libc::c_int as uint8_t,
                flags: 0x2 as libc::c_int as uint8_t,
                sym: 171 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 31 as libc::c_int as uint8_t,
                flags: 0x2 as libc::c_int as uint8_t,
                sym: 171 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 41 as libc::c_int as uint8_t,
                flags: 0x2 as libc::c_int as uint8_t,
                sym: 171 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 56 as libc::c_int as uint8_t,
                flags: 0x3 as libc::c_int as uint8_t,
                sym: 171 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 3 as libc::c_int as uint8_t,
                flags: 0x2 as libc::c_int as uint8_t,
                sym: 206 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 6 as libc::c_int as uint8_t,
                flags: 0x2 as libc::c_int as uint8_t,
                sym: 206 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 10 as libc::c_int as uint8_t,
                flags: 0x2 as libc::c_int as uint8_t,
                sym: 206 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 15 as libc::c_int as uint8_t,
                flags: 0x2 as libc::c_int as uint8_t,
                sym: 206 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 24 as libc::c_int as uint8_t,
                flags: 0x2 as libc::c_int as uint8_t,
                sym: 206 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 31 as libc::c_int as uint8_t,
                flags: 0x2 as libc::c_int as uint8_t,
                sym: 206 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 41 as libc::c_int as uint8_t,
                flags: 0x2 as libc::c_int as uint8_t,
                sym: 206 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 56 as libc::c_int as uint8_t,
                flags: 0x3 as libc::c_int as uint8_t,
                sym: 206 as libc::c_int as uint8_t,
            };
            init
        },
    ],
    [
        {
            let mut init = decode_el {
                state: 3 as libc::c_int as uint8_t,
                flags: 0x2 as libc::c_int as uint8_t,
                sym: 215 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 6 as libc::c_int as uint8_t,
                flags: 0x2 as libc::c_int as uint8_t,
                sym: 215 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 10 as libc::c_int as uint8_t,
                flags: 0x2 as libc::c_int as uint8_t,
                sym: 215 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 15 as libc::c_int as uint8_t,
                flags: 0x2 as libc::c_int as uint8_t,
                sym: 215 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 24 as libc::c_int as uint8_t,
                flags: 0x2 as libc::c_int as uint8_t,
                sym: 215 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 31 as libc::c_int as uint8_t,
                flags: 0x2 as libc::c_int as uint8_t,
                sym: 215 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 41 as libc::c_int as uint8_t,
                flags: 0x2 as libc::c_int as uint8_t,
                sym: 215 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 56 as libc::c_int as uint8_t,
                flags: 0x3 as libc::c_int as uint8_t,
                sym: 215 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 3 as libc::c_int as uint8_t,
                flags: 0x2 as libc::c_int as uint8_t,
                sym: 225 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 6 as libc::c_int as uint8_t,
                flags: 0x2 as libc::c_int as uint8_t,
                sym: 225 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 10 as libc::c_int as uint8_t,
                flags: 0x2 as libc::c_int as uint8_t,
                sym: 225 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 15 as libc::c_int as uint8_t,
                flags: 0x2 as libc::c_int as uint8_t,
                sym: 225 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 24 as libc::c_int as uint8_t,
                flags: 0x2 as libc::c_int as uint8_t,
                sym: 225 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 31 as libc::c_int as uint8_t,
                flags: 0x2 as libc::c_int as uint8_t,
                sym: 225 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 41 as libc::c_int as uint8_t,
                flags: 0x2 as libc::c_int as uint8_t,
                sym: 225 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 56 as libc::c_int as uint8_t,
                flags: 0x3 as libc::c_int as uint8_t,
                sym: 225 as libc::c_int as uint8_t,
            };
            init
        },
    ],
    [
        {
            let mut init = decode_el {
                state: 2 as libc::c_int as uint8_t,
                flags: 0x2 as libc::c_int as uint8_t,
                sym: 236 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 9 as libc::c_int as uint8_t,
                flags: 0x2 as libc::c_int as uint8_t,
                sym: 236 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 23 as libc::c_int as uint8_t,
                flags: 0x2 as libc::c_int as uint8_t,
                sym: 236 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 40 as libc::c_int as uint8_t,
                flags: 0x3 as libc::c_int as uint8_t,
                sym: 236 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 2 as libc::c_int as uint8_t,
                flags: 0x2 as libc::c_int as uint8_t,
                sym: 237 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 9 as libc::c_int as uint8_t,
                flags: 0x2 as libc::c_int as uint8_t,
                sym: 237 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 23 as libc::c_int as uint8_t,
                flags: 0x2 as libc::c_int as uint8_t,
                sym: 237 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 40 as libc::c_int as uint8_t,
                flags: 0x3 as libc::c_int as uint8_t,
                sym: 237 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 1 as libc::c_int as uint8_t,
                flags: 0x2 as libc::c_int as uint8_t,
                sym: 199 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 22 as libc::c_int as uint8_t,
                flags: 0x3 as libc::c_int as uint8_t,
                sym: 199 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 1 as libc::c_int as uint8_t,
                flags: 0x2 as libc::c_int as uint8_t,
                sym: 207 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 22 as libc::c_int as uint8_t,
                flags: 0x3 as libc::c_int as uint8_t,
                sym: 207 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 1 as libc::c_int as uint8_t,
                flags: 0x2 as libc::c_int as uint8_t,
                sym: 234 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 22 as libc::c_int as uint8_t,
                flags: 0x3 as libc::c_int as uint8_t,
                sym: 234 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 1 as libc::c_int as uint8_t,
                flags: 0x2 as libc::c_int as uint8_t,
                sym: 235 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 22 as libc::c_int as uint8_t,
                flags: 0x3 as libc::c_int as uint8_t,
                sym: 235 as libc::c_int as uint8_t,
            };
            init
        },
    ],
    [
        {
            let mut init = decode_el {
                state: 3 as libc::c_int as uint8_t,
                flags: 0x2 as libc::c_int as uint8_t,
                sym: 236 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 6 as libc::c_int as uint8_t,
                flags: 0x2 as libc::c_int as uint8_t,
                sym: 236 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 10 as libc::c_int as uint8_t,
                flags: 0x2 as libc::c_int as uint8_t,
                sym: 236 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 15 as libc::c_int as uint8_t,
                flags: 0x2 as libc::c_int as uint8_t,
                sym: 236 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 24 as libc::c_int as uint8_t,
                flags: 0x2 as libc::c_int as uint8_t,
                sym: 236 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 31 as libc::c_int as uint8_t,
                flags: 0x2 as libc::c_int as uint8_t,
                sym: 236 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 41 as libc::c_int as uint8_t,
                flags: 0x2 as libc::c_int as uint8_t,
                sym: 236 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 56 as libc::c_int as uint8_t,
                flags: 0x3 as libc::c_int as uint8_t,
                sym: 236 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 3 as libc::c_int as uint8_t,
                flags: 0x2 as libc::c_int as uint8_t,
                sym: 237 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 6 as libc::c_int as uint8_t,
                flags: 0x2 as libc::c_int as uint8_t,
                sym: 237 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 10 as libc::c_int as uint8_t,
                flags: 0x2 as libc::c_int as uint8_t,
                sym: 237 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 15 as libc::c_int as uint8_t,
                flags: 0x2 as libc::c_int as uint8_t,
                sym: 237 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 24 as libc::c_int as uint8_t,
                flags: 0x2 as libc::c_int as uint8_t,
                sym: 237 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 31 as libc::c_int as uint8_t,
                flags: 0x2 as libc::c_int as uint8_t,
                sym: 237 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 41 as libc::c_int as uint8_t,
                flags: 0x2 as libc::c_int as uint8_t,
                sym: 237 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 56 as libc::c_int as uint8_t,
                flags: 0x3 as libc::c_int as uint8_t,
                sym: 237 as libc::c_int as uint8_t,
            };
            init
        },
    ],
    [
        {
            let mut init = decode_el {
                state: 2 as libc::c_int as uint8_t,
                flags: 0x2 as libc::c_int as uint8_t,
                sym: 199 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 9 as libc::c_int as uint8_t,
                flags: 0x2 as libc::c_int as uint8_t,
                sym: 199 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 23 as libc::c_int as uint8_t,
                flags: 0x2 as libc::c_int as uint8_t,
                sym: 199 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 40 as libc::c_int as uint8_t,
                flags: 0x3 as libc::c_int as uint8_t,
                sym: 199 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 2 as libc::c_int as uint8_t,
                flags: 0x2 as libc::c_int as uint8_t,
                sym: 207 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 9 as libc::c_int as uint8_t,
                flags: 0x2 as libc::c_int as uint8_t,
                sym: 207 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 23 as libc::c_int as uint8_t,
                flags: 0x2 as libc::c_int as uint8_t,
                sym: 207 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 40 as libc::c_int as uint8_t,
                flags: 0x3 as libc::c_int as uint8_t,
                sym: 207 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 2 as libc::c_int as uint8_t,
                flags: 0x2 as libc::c_int as uint8_t,
                sym: 234 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 9 as libc::c_int as uint8_t,
                flags: 0x2 as libc::c_int as uint8_t,
                sym: 234 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 23 as libc::c_int as uint8_t,
                flags: 0x2 as libc::c_int as uint8_t,
                sym: 234 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 40 as libc::c_int as uint8_t,
                flags: 0x3 as libc::c_int as uint8_t,
                sym: 234 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 2 as libc::c_int as uint8_t,
                flags: 0x2 as libc::c_int as uint8_t,
                sym: 235 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 9 as libc::c_int as uint8_t,
                flags: 0x2 as libc::c_int as uint8_t,
                sym: 235 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 23 as libc::c_int as uint8_t,
                flags: 0x2 as libc::c_int as uint8_t,
                sym: 235 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 40 as libc::c_int as uint8_t,
                flags: 0x3 as libc::c_int as uint8_t,
                sym: 235 as libc::c_int as uint8_t,
            };
            init
        },
    ],
    [
        {
            let mut init = decode_el {
                state: 3 as libc::c_int as uint8_t,
                flags: 0x2 as libc::c_int as uint8_t,
                sym: 199 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 6 as libc::c_int as uint8_t,
                flags: 0x2 as libc::c_int as uint8_t,
                sym: 199 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 10 as libc::c_int as uint8_t,
                flags: 0x2 as libc::c_int as uint8_t,
                sym: 199 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 15 as libc::c_int as uint8_t,
                flags: 0x2 as libc::c_int as uint8_t,
                sym: 199 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 24 as libc::c_int as uint8_t,
                flags: 0x2 as libc::c_int as uint8_t,
                sym: 199 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 31 as libc::c_int as uint8_t,
                flags: 0x2 as libc::c_int as uint8_t,
                sym: 199 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 41 as libc::c_int as uint8_t,
                flags: 0x2 as libc::c_int as uint8_t,
                sym: 199 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 56 as libc::c_int as uint8_t,
                flags: 0x3 as libc::c_int as uint8_t,
                sym: 199 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 3 as libc::c_int as uint8_t,
                flags: 0x2 as libc::c_int as uint8_t,
                sym: 207 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 6 as libc::c_int as uint8_t,
                flags: 0x2 as libc::c_int as uint8_t,
                sym: 207 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 10 as libc::c_int as uint8_t,
                flags: 0x2 as libc::c_int as uint8_t,
                sym: 207 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 15 as libc::c_int as uint8_t,
                flags: 0x2 as libc::c_int as uint8_t,
                sym: 207 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 24 as libc::c_int as uint8_t,
                flags: 0x2 as libc::c_int as uint8_t,
                sym: 207 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 31 as libc::c_int as uint8_t,
                flags: 0x2 as libc::c_int as uint8_t,
                sym: 207 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 41 as libc::c_int as uint8_t,
                flags: 0x2 as libc::c_int as uint8_t,
                sym: 207 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 56 as libc::c_int as uint8_t,
                flags: 0x3 as libc::c_int as uint8_t,
                sym: 207 as libc::c_int as uint8_t,
            };
            init
        },
    ],
    [
        {
            let mut init = decode_el {
                state: 3 as libc::c_int as uint8_t,
                flags: 0x2 as libc::c_int as uint8_t,
                sym: 234 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 6 as libc::c_int as uint8_t,
                flags: 0x2 as libc::c_int as uint8_t,
                sym: 234 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 10 as libc::c_int as uint8_t,
                flags: 0x2 as libc::c_int as uint8_t,
                sym: 234 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 15 as libc::c_int as uint8_t,
                flags: 0x2 as libc::c_int as uint8_t,
                sym: 234 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 24 as libc::c_int as uint8_t,
                flags: 0x2 as libc::c_int as uint8_t,
                sym: 234 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 31 as libc::c_int as uint8_t,
                flags: 0x2 as libc::c_int as uint8_t,
                sym: 234 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 41 as libc::c_int as uint8_t,
                flags: 0x2 as libc::c_int as uint8_t,
                sym: 234 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 56 as libc::c_int as uint8_t,
                flags: 0x3 as libc::c_int as uint8_t,
                sym: 234 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 3 as libc::c_int as uint8_t,
                flags: 0x2 as libc::c_int as uint8_t,
                sym: 235 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 6 as libc::c_int as uint8_t,
                flags: 0x2 as libc::c_int as uint8_t,
                sym: 235 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 10 as libc::c_int as uint8_t,
                flags: 0x2 as libc::c_int as uint8_t,
                sym: 235 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 15 as libc::c_int as uint8_t,
                flags: 0x2 as libc::c_int as uint8_t,
                sym: 235 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 24 as libc::c_int as uint8_t,
                flags: 0x2 as libc::c_int as uint8_t,
                sym: 235 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 31 as libc::c_int as uint8_t,
                flags: 0x2 as libc::c_int as uint8_t,
                sym: 235 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 41 as libc::c_int as uint8_t,
                flags: 0x2 as libc::c_int as uint8_t,
                sym: 235 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 56 as libc::c_int as uint8_t,
                flags: 0x3 as libc::c_int as uint8_t,
                sym: 235 as libc::c_int as uint8_t,
            };
            init
        },
    ],
    [
        {
            let mut init = decode_el {
                state: 194 as libc::c_int as uint8_t,
                flags: 0 as libc::c_int as uint8_t,
                sym: 0 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 195 as libc::c_int as uint8_t,
                flags: 0 as libc::c_int as uint8_t,
                sym: 0 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 197 as libc::c_int as uint8_t,
                flags: 0 as libc::c_int as uint8_t,
                sym: 0 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 198 as libc::c_int as uint8_t,
                flags: 0 as libc::c_int as uint8_t,
                sym: 0 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 201 as libc::c_int as uint8_t,
                flags: 0 as libc::c_int as uint8_t,
                sym: 0 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 202 as libc::c_int as uint8_t,
                flags: 0 as libc::c_int as uint8_t,
                sym: 0 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 204 as libc::c_int as uint8_t,
                flags: 0 as libc::c_int as uint8_t,
                sym: 0 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 205 as libc::c_int as uint8_t,
                flags: 0 as libc::c_int as uint8_t,
                sym: 0 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 210 as libc::c_int as uint8_t,
                flags: 0 as libc::c_int as uint8_t,
                sym: 0 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 213 as libc::c_int as uint8_t,
                flags: 0 as libc::c_int as uint8_t,
                sym: 0 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 217 as libc::c_int as uint8_t,
                flags: 0 as libc::c_int as uint8_t,
                sym: 0 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 220 as libc::c_int as uint8_t,
                flags: 0 as libc::c_int as uint8_t,
                sym: 0 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 225 as libc::c_int as uint8_t,
                flags: 0 as libc::c_int as uint8_t,
                sym: 0 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 231 as libc::c_int as uint8_t,
                flags: 0 as libc::c_int as uint8_t,
                sym: 0 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 239 as libc::c_int as uint8_t,
                flags: 0 as libc::c_int as uint8_t,
                sym: 0 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 246 as libc::c_int as uint8_t,
                flags: 0 as libc::c_int as uint8_t,
                sym: 0 as libc::c_int as uint8_t,
            };
            init
        },
    ],
    [
        {
            let mut init = decode_el {
                state: 0 as libc::c_int as uint8_t,
                flags: 0x3 as libc::c_int as uint8_t,
                sym: 192 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 0 as libc::c_int as uint8_t,
                flags: 0x3 as libc::c_int as uint8_t,
                sym: 193 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 0 as libc::c_int as uint8_t,
                flags: 0x3 as libc::c_int as uint8_t,
                sym: 200 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 0 as libc::c_int as uint8_t,
                flags: 0x3 as libc::c_int as uint8_t,
                sym: 201 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 0 as libc::c_int as uint8_t,
                flags: 0x3 as libc::c_int as uint8_t,
                sym: 202 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 0 as libc::c_int as uint8_t,
                flags: 0x3 as libc::c_int as uint8_t,
                sym: 205 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 0 as libc::c_int as uint8_t,
                flags: 0x3 as libc::c_int as uint8_t,
                sym: 210 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 0 as libc::c_int as uint8_t,
                flags: 0x3 as libc::c_int as uint8_t,
                sym: 213 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 0 as libc::c_int as uint8_t,
                flags: 0x3 as libc::c_int as uint8_t,
                sym: 218 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 0 as libc::c_int as uint8_t,
                flags: 0x3 as libc::c_int as uint8_t,
                sym: 219 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 0 as libc::c_int as uint8_t,
                flags: 0x3 as libc::c_int as uint8_t,
                sym: 238 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 0 as libc::c_int as uint8_t,
                flags: 0x3 as libc::c_int as uint8_t,
                sym: 240 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 0 as libc::c_int as uint8_t,
                flags: 0x3 as libc::c_int as uint8_t,
                sym: 242 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 0 as libc::c_int as uint8_t,
                flags: 0x3 as libc::c_int as uint8_t,
                sym: 243 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 0 as libc::c_int as uint8_t,
                flags: 0x3 as libc::c_int as uint8_t,
                sym: 255 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 206 as libc::c_int as uint8_t,
                flags: 0 as libc::c_int as uint8_t,
                sym: 0 as libc::c_int as uint8_t,
            };
            init
        },
    ],
    [
        {
            let mut init = decode_el {
                state: 1 as libc::c_int as uint8_t,
                flags: 0x2 as libc::c_int as uint8_t,
                sym: 192 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 22 as libc::c_int as uint8_t,
                flags: 0x3 as libc::c_int as uint8_t,
                sym: 192 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 1 as libc::c_int as uint8_t,
                flags: 0x2 as libc::c_int as uint8_t,
                sym: 193 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 22 as libc::c_int as uint8_t,
                flags: 0x3 as libc::c_int as uint8_t,
                sym: 193 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 1 as libc::c_int as uint8_t,
                flags: 0x2 as libc::c_int as uint8_t,
                sym: 200 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 22 as libc::c_int as uint8_t,
                flags: 0x3 as libc::c_int as uint8_t,
                sym: 200 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 1 as libc::c_int as uint8_t,
                flags: 0x2 as libc::c_int as uint8_t,
                sym: 201 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 22 as libc::c_int as uint8_t,
                flags: 0x3 as libc::c_int as uint8_t,
                sym: 201 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 1 as libc::c_int as uint8_t,
                flags: 0x2 as libc::c_int as uint8_t,
                sym: 202 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 22 as libc::c_int as uint8_t,
                flags: 0x3 as libc::c_int as uint8_t,
                sym: 202 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 1 as libc::c_int as uint8_t,
                flags: 0x2 as libc::c_int as uint8_t,
                sym: 205 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 22 as libc::c_int as uint8_t,
                flags: 0x3 as libc::c_int as uint8_t,
                sym: 205 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 1 as libc::c_int as uint8_t,
                flags: 0x2 as libc::c_int as uint8_t,
                sym: 210 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 22 as libc::c_int as uint8_t,
                flags: 0x3 as libc::c_int as uint8_t,
                sym: 210 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 1 as libc::c_int as uint8_t,
                flags: 0x2 as libc::c_int as uint8_t,
                sym: 213 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 22 as libc::c_int as uint8_t,
                flags: 0x3 as libc::c_int as uint8_t,
                sym: 213 as libc::c_int as uint8_t,
            };
            init
        },
    ],
    [
        {
            let mut init = decode_el {
                state: 2 as libc::c_int as uint8_t,
                flags: 0x2 as libc::c_int as uint8_t,
                sym: 192 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 9 as libc::c_int as uint8_t,
                flags: 0x2 as libc::c_int as uint8_t,
                sym: 192 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 23 as libc::c_int as uint8_t,
                flags: 0x2 as libc::c_int as uint8_t,
                sym: 192 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 40 as libc::c_int as uint8_t,
                flags: 0x3 as libc::c_int as uint8_t,
                sym: 192 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 2 as libc::c_int as uint8_t,
                flags: 0x2 as libc::c_int as uint8_t,
                sym: 193 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 9 as libc::c_int as uint8_t,
                flags: 0x2 as libc::c_int as uint8_t,
                sym: 193 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 23 as libc::c_int as uint8_t,
                flags: 0x2 as libc::c_int as uint8_t,
                sym: 193 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 40 as libc::c_int as uint8_t,
                flags: 0x3 as libc::c_int as uint8_t,
                sym: 193 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 2 as libc::c_int as uint8_t,
                flags: 0x2 as libc::c_int as uint8_t,
                sym: 200 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 9 as libc::c_int as uint8_t,
                flags: 0x2 as libc::c_int as uint8_t,
                sym: 200 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 23 as libc::c_int as uint8_t,
                flags: 0x2 as libc::c_int as uint8_t,
                sym: 200 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 40 as libc::c_int as uint8_t,
                flags: 0x3 as libc::c_int as uint8_t,
                sym: 200 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 2 as libc::c_int as uint8_t,
                flags: 0x2 as libc::c_int as uint8_t,
                sym: 201 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 9 as libc::c_int as uint8_t,
                flags: 0x2 as libc::c_int as uint8_t,
                sym: 201 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 23 as libc::c_int as uint8_t,
                flags: 0x2 as libc::c_int as uint8_t,
                sym: 201 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 40 as libc::c_int as uint8_t,
                flags: 0x3 as libc::c_int as uint8_t,
                sym: 201 as libc::c_int as uint8_t,
            };
            init
        },
    ],
    [
        {
            let mut init = decode_el {
                state: 3 as libc::c_int as uint8_t,
                flags: 0x2 as libc::c_int as uint8_t,
                sym: 192 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 6 as libc::c_int as uint8_t,
                flags: 0x2 as libc::c_int as uint8_t,
                sym: 192 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 10 as libc::c_int as uint8_t,
                flags: 0x2 as libc::c_int as uint8_t,
                sym: 192 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 15 as libc::c_int as uint8_t,
                flags: 0x2 as libc::c_int as uint8_t,
                sym: 192 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 24 as libc::c_int as uint8_t,
                flags: 0x2 as libc::c_int as uint8_t,
                sym: 192 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 31 as libc::c_int as uint8_t,
                flags: 0x2 as libc::c_int as uint8_t,
                sym: 192 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 41 as libc::c_int as uint8_t,
                flags: 0x2 as libc::c_int as uint8_t,
                sym: 192 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 56 as libc::c_int as uint8_t,
                flags: 0x3 as libc::c_int as uint8_t,
                sym: 192 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 3 as libc::c_int as uint8_t,
                flags: 0x2 as libc::c_int as uint8_t,
                sym: 193 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 6 as libc::c_int as uint8_t,
                flags: 0x2 as libc::c_int as uint8_t,
                sym: 193 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 10 as libc::c_int as uint8_t,
                flags: 0x2 as libc::c_int as uint8_t,
                sym: 193 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 15 as libc::c_int as uint8_t,
                flags: 0x2 as libc::c_int as uint8_t,
                sym: 193 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 24 as libc::c_int as uint8_t,
                flags: 0x2 as libc::c_int as uint8_t,
                sym: 193 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 31 as libc::c_int as uint8_t,
                flags: 0x2 as libc::c_int as uint8_t,
                sym: 193 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 41 as libc::c_int as uint8_t,
                flags: 0x2 as libc::c_int as uint8_t,
                sym: 193 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 56 as libc::c_int as uint8_t,
                flags: 0x3 as libc::c_int as uint8_t,
                sym: 193 as libc::c_int as uint8_t,
            };
            init
        },
    ],
    [
        {
            let mut init = decode_el {
                state: 3 as libc::c_int as uint8_t,
                flags: 0x2 as libc::c_int as uint8_t,
                sym: 200 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 6 as libc::c_int as uint8_t,
                flags: 0x2 as libc::c_int as uint8_t,
                sym: 200 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 10 as libc::c_int as uint8_t,
                flags: 0x2 as libc::c_int as uint8_t,
                sym: 200 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 15 as libc::c_int as uint8_t,
                flags: 0x2 as libc::c_int as uint8_t,
                sym: 200 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 24 as libc::c_int as uint8_t,
                flags: 0x2 as libc::c_int as uint8_t,
                sym: 200 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 31 as libc::c_int as uint8_t,
                flags: 0x2 as libc::c_int as uint8_t,
                sym: 200 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 41 as libc::c_int as uint8_t,
                flags: 0x2 as libc::c_int as uint8_t,
                sym: 200 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 56 as libc::c_int as uint8_t,
                flags: 0x3 as libc::c_int as uint8_t,
                sym: 200 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 3 as libc::c_int as uint8_t,
                flags: 0x2 as libc::c_int as uint8_t,
                sym: 201 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 6 as libc::c_int as uint8_t,
                flags: 0x2 as libc::c_int as uint8_t,
                sym: 201 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 10 as libc::c_int as uint8_t,
                flags: 0x2 as libc::c_int as uint8_t,
                sym: 201 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 15 as libc::c_int as uint8_t,
                flags: 0x2 as libc::c_int as uint8_t,
                sym: 201 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 24 as libc::c_int as uint8_t,
                flags: 0x2 as libc::c_int as uint8_t,
                sym: 201 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 31 as libc::c_int as uint8_t,
                flags: 0x2 as libc::c_int as uint8_t,
                sym: 201 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 41 as libc::c_int as uint8_t,
                flags: 0x2 as libc::c_int as uint8_t,
                sym: 201 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 56 as libc::c_int as uint8_t,
                flags: 0x3 as libc::c_int as uint8_t,
                sym: 201 as libc::c_int as uint8_t,
            };
            init
        },
    ],
    [
        {
            let mut init = decode_el {
                state: 2 as libc::c_int as uint8_t,
                flags: 0x2 as libc::c_int as uint8_t,
                sym: 202 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 9 as libc::c_int as uint8_t,
                flags: 0x2 as libc::c_int as uint8_t,
                sym: 202 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 23 as libc::c_int as uint8_t,
                flags: 0x2 as libc::c_int as uint8_t,
                sym: 202 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 40 as libc::c_int as uint8_t,
                flags: 0x3 as libc::c_int as uint8_t,
                sym: 202 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 2 as libc::c_int as uint8_t,
                flags: 0x2 as libc::c_int as uint8_t,
                sym: 205 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 9 as libc::c_int as uint8_t,
                flags: 0x2 as libc::c_int as uint8_t,
                sym: 205 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 23 as libc::c_int as uint8_t,
                flags: 0x2 as libc::c_int as uint8_t,
                sym: 205 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 40 as libc::c_int as uint8_t,
                flags: 0x3 as libc::c_int as uint8_t,
                sym: 205 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 2 as libc::c_int as uint8_t,
                flags: 0x2 as libc::c_int as uint8_t,
                sym: 210 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 9 as libc::c_int as uint8_t,
                flags: 0x2 as libc::c_int as uint8_t,
                sym: 210 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 23 as libc::c_int as uint8_t,
                flags: 0x2 as libc::c_int as uint8_t,
                sym: 210 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 40 as libc::c_int as uint8_t,
                flags: 0x3 as libc::c_int as uint8_t,
                sym: 210 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 2 as libc::c_int as uint8_t,
                flags: 0x2 as libc::c_int as uint8_t,
                sym: 213 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 9 as libc::c_int as uint8_t,
                flags: 0x2 as libc::c_int as uint8_t,
                sym: 213 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 23 as libc::c_int as uint8_t,
                flags: 0x2 as libc::c_int as uint8_t,
                sym: 213 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 40 as libc::c_int as uint8_t,
                flags: 0x3 as libc::c_int as uint8_t,
                sym: 213 as libc::c_int as uint8_t,
            };
            init
        },
    ],
    [
        {
            let mut init = decode_el {
                state: 3 as libc::c_int as uint8_t,
                flags: 0x2 as libc::c_int as uint8_t,
                sym: 202 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 6 as libc::c_int as uint8_t,
                flags: 0x2 as libc::c_int as uint8_t,
                sym: 202 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 10 as libc::c_int as uint8_t,
                flags: 0x2 as libc::c_int as uint8_t,
                sym: 202 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 15 as libc::c_int as uint8_t,
                flags: 0x2 as libc::c_int as uint8_t,
                sym: 202 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 24 as libc::c_int as uint8_t,
                flags: 0x2 as libc::c_int as uint8_t,
                sym: 202 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 31 as libc::c_int as uint8_t,
                flags: 0x2 as libc::c_int as uint8_t,
                sym: 202 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 41 as libc::c_int as uint8_t,
                flags: 0x2 as libc::c_int as uint8_t,
                sym: 202 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 56 as libc::c_int as uint8_t,
                flags: 0x3 as libc::c_int as uint8_t,
                sym: 202 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 3 as libc::c_int as uint8_t,
                flags: 0x2 as libc::c_int as uint8_t,
                sym: 205 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 6 as libc::c_int as uint8_t,
                flags: 0x2 as libc::c_int as uint8_t,
                sym: 205 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 10 as libc::c_int as uint8_t,
                flags: 0x2 as libc::c_int as uint8_t,
                sym: 205 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 15 as libc::c_int as uint8_t,
                flags: 0x2 as libc::c_int as uint8_t,
                sym: 205 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 24 as libc::c_int as uint8_t,
                flags: 0x2 as libc::c_int as uint8_t,
                sym: 205 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 31 as libc::c_int as uint8_t,
                flags: 0x2 as libc::c_int as uint8_t,
                sym: 205 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 41 as libc::c_int as uint8_t,
                flags: 0x2 as libc::c_int as uint8_t,
                sym: 205 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 56 as libc::c_int as uint8_t,
                flags: 0x3 as libc::c_int as uint8_t,
                sym: 205 as libc::c_int as uint8_t,
            };
            init
        },
    ],
    [
        {
            let mut init = decode_el {
                state: 3 as libc::c_int as uint8_t,
                flags: 0x2 as libc::c_int as uint8_t,
                sym: 210 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 6 as libc::c_int as uint8_t,
                flags: 0x2 as libc::c_int as uint8_t,
                sym: 210 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 10 as libc::c_int as uint8_t,
                flags: 0x2 as libc::c_int as uint8_t,
                sym: 210 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 15 as libc::c_int as uint8_t,
                flags: 0x2 as libc::c_int as uint8_t,
                sym: 210 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 24 as libc::c_int as uint8_t,
                flags: 0x2 as libc::c_int as uint8_t,
                sym: 210 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 31 as libc::c_int as uint8_t,
                flags: 0x2 as libc::c_int as uint8_t,
                sym: 210 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 41 as libc::c_int as uint8_t,
                flags: 0x2 as libc::c_int as uint8_t,
                sym: 210 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 56 as libc::c_int as uint8_t,
                flags: 0x3 as libc::c_int as uint8_t,
                sym: 210 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 3 as libc::c_int as uint8_t,
                flags: 0x2 as libc::c_int as uint8_t,
                sym: 213 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 6 as libc::c_int as uint8_t,
                flags: 0x2 as libc::c_int as uint8_t,
                sym: 213 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 10 as libc::c_int as uint8_t,
                flags: 0x2 as libc::c_int as uint8_t,
                sym: 213 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 15 as libc::c_int as uint8_t,
                flags: 0x2 as libc::c_int as uint8_t,
                sym: 213 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 24 as libc::c_int as uint8_t,
                flags: 0x2 as libc::c_int as uint8_t,
                sym: 213 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 31 as libc::c_int as uint8_t,
                flags: 0x2 as libc::c_int as uint8_t,
                sym: 213 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 41 as libc::c_int as uint8_t,
                flags: 0x2 as libc::c_int as uint8_t,
                sym: 213 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 56 as libc::c_int as uint8_t,
                flags: 0x3 as libc::c_int as uint8_t,
                sym: 213 as libc::c_int as uint8_t,
            };
            init
        },
    ],
    [
        {
            let mut init = decode_el {
                state: 1 as libc::c_int as uint8_t,
                flags: 0x2 as libc::c_int as uint8_t,
                sym: 218 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 22 as libc::c_int as uint8_t,
                flags: 0x3 as libc::c_int as uint8_t,
                sym: 218 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 1 as libc::c_int as uint8_t,
                flags: 0x2 as libc::c_int as uint8_t,
                sym: 219 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 22 as libc::c_int as uint8_t,
                flags: 0x3 as libc::c_int as uint8_t,
                sym: 219 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 1 as libc::c_int as uint8_t,
                flags: 0x2 as libc::c_int as uint8_t,
                sym: 238 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 22 as libc::c_int as uint8_t,
                flags: 0x3 as libc::c_int as uint8_t,
                sym: 238 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 1 as libc::c_int as uint8_t,
                flags: 0x2 as libc::c_int as uint8_t,
                sym: 240 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 22 as libc::c_int as uint8_t,
                flags: 0x3 as libc::c_int as uint8_t,
                sym: 240 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 1 as libc::c_int as uint8_t,
                flags: 0x2 as libc::c_int as uint8_t,
                sym: 242 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 22 as libc::c_int as uint8_t,
                flags: 0x3 as libc::c_int as uint8_t,
                sym: 242 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 1 as libc::c_int as uint8_t,
                flags: 0x2 as libc::c_int as uint8_t,
                sym: 243 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 22 as libc::c_int as uint8_t,
                flags: 0x3 as libc::c_int as uint8_t,
                sym: 243 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 1 as libc::c_int as uint8_t,
                flags: 0x2 as libc::c_int as uint8_t,
                sym: 255 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 22 as libc::c_int as uint8_t,
                flags: 0x3 as libc::c_int as uint8_t,
                sym: 255 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 0 as libc::c_int as uint8_t,
                flags: 0x3 as libc::c_int as uint8_t,
                sym: 203 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 0 as libc::c_int as uint8_t,
                flags: 0x3 as libc::c_int as uint8_t,
                sym: 204 as libc::c_int as uint8_t,
            };
            init
        },
    ],
    [
        {
            let mut init = decode_el {
                state: 2 as libc::c_int as uint8_t,
                flags: 0x2 as libc::c_int as uint8_t,
                sym: 218 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 9 as libc::c_int as uint8_t,
                flags: 0x2 as libc::c_int as uint8_t,
                sym: 218 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 23 as libc::c_int as uint8_t,
                flags: 0x2 as libc::c_int as uint8_t,
                sym: 218 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 40 as libc::c_int as uint8_t,
                flags: 0x3 as libc::c_int as uint8_t,
                sym: 218 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 2 as libc::c_int as uint8_t,
                flags: 0x2 as libc::c_int as uint8_t,
                sym: 219 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 9 as libc::c_int as uint8_t,
                flags: 0x2 as libc::c_int as uint8_t,
                sym: 219 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 23 as libc::c_int as uint8_t,
                flags: 0x2 as libc::c_int as uint8_t,
                sym: 219 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 40 as libc::c_int as uint8_t,
                flags: 0x3 as libc::c_int as uint8_t,
                sym: 219 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 2 as libc::c_int as uint8_t,
                flags: 0x2 as libc::c_int as uint8_t,
                sym: 238 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 9 as libc::c_int as uint8_t,
                flags: 0x2 as libc::c_int as uint8_t,
                sym: 238 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 23 as libc::c_int as uint8_t,
                flags: 0x2 as libc::c_int as uint8_t,
                sym: 238 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 40 as libc::c_int as uint8_t,
                flags: 0x3 as libc::c_int as uint8_t,
                sym: 238 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 2 as libc::c_int as uint8_t,
                flags: 0x2 as libc::c_int as uint8_t,
                sym: 240 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 9 as libc::c_int as uint8_t,
                flags: 0x2 as libc::c_int as uint8_t,
                sym: 240 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 23 as libc::c_int as uint8_t,
                flags: 0x2 as libc::c_int as uint8_t,
                sym: 240 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 40 as libc::c_int as uint8_t,
                flags: 0x3 as libc::c_int as uint8_t,
                sym: 240 as libc::c_int as uint8_t,
            };
            init
        },
    ],
    [
        {
            let mut init = decode_el {
                state: 3 as libc::c_int as uint8_t,
                flags: 0x2 as libc::c_int as uint8_t,
                sym: 218 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 6 as libc::c_int as uint8_t,
                flags: 0x2 as libc::c_int as uint8_t,
                sym: 218 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 10 as libc::c_int as uint8_t,
                flags: 0x2 as libc::c_int as uint8_t,
                sym: 218 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 15 as libc::c_int as uint8_t,
                flags: 0x2 as libc::c_int as uint8_t,
                sym: 218 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 24 as libc::c_int as uint8_t,
                flags: 0x2 as libc::c_int as uint8_t,
                sym: 218 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 31 as libc::c_int as uint8_t,
                flags: 0x2 as libc::c_int as uint8_t,
                sym: 218 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 41 as libc::c_int as uint8_t,
                flags: 0x2 as libc::c_int as uint8_t,
                sym: 218 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 56 as libc::c_int as uint8_t,
                flags: 0x3 as libc::c_int as uint8_t,
                sym: 218 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 3 as libc::c_int as uint8_t,
                flags: 0x2 as libc::c_int as uint8_t,
                sym: 219 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 6 as libc::c_int as uint8_t,
                flags: 0x2 as libc::c_int as uint8_t,
                sym: 219 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 10 as libc::c_int as uint8_t,
                flags: 0x2 as libc::c_int as uint8_t,
                sym: 219 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 15 as libc::c_int as uint8_t,
                flags: 0x2 as libc::c_int as uint8_t,
                sym: 219 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 24 as libc::c_int as uint8_t,
                flags: 0x2 as libc::c_int as uint8_t,
                sym: 219 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 31 as libc::c_int as uint8_t,
                flags: 0x2 as libc::c_int as uint8_t,
                sym: 219 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 41 as libc::c_int as uint8_t,
                flags: 0x2 as libc::c_int as uint8_t,
                sym: 219 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 56 as libc::c_int as uint8_t,
                flags: 0x3 as libc::c_int as uint8_t,
                sym: 219 as libc::c_int as uint8_t,
            };
            init
        },
    ],
    [
        {
            let mut init = decode_el {
                state: 3 as libc::c_int as uint8_t,
                flags: 0x2 as libc::c_int as uint8_t,
                sym: 238 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 6 as libc::c_int as uint8_t,
                flags: 0x2 as libc::c_int as uint8_t,
                sym: 238 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 10 as libc::c_int as uint8_t,
                flags: 0x2 as libc::c_int as uint8_t,
                sym: 238 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 15 as libc::c_int as uint8_t,
                flags: 0x2 as libc::c_int as uint8_t,
                sym: 238 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 24 as libc::c_int as uint8_t,
                flags: 0x2 as libc::c_int as uint8_t,
                sym: 238 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 31 as libc::c_int as uint8_t,
                flags: 0x2 as libc::c_int as uint8_t,
                sym: 238 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 41 as libc::c_int as uint8_t,
                flags: 0x2 as libc::c_int as uint8_t,
                sym: 238 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 56 as libc::c_int as uint8_t,
                flags: 0x3 as libc::c_int as uint8_t,
                sym: 238 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 3 as libc::c_int as uint8_t,
                flags: 0x2 as libc::c_int as uint8_t,
                sym: 240 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 6 as libc::c_int as uint8_t,
                flags: 0x2 as libc::c_int as uint8_t,
                sym: 240 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 10 as libc::c_int as uint8_t,
                flags: 0x2 as libc::c_int as uint8_t,
                sym: 240 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 15 as libc::c_int as uint8_t,
                flags: 0x2 as libc::c_int as uint8_t,
                sym: 240 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 24 as libc::c_int as uint8_t,
                flags: 0x2 as libc::c_int as uint8_t,
                sym: 240 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 31 as libc::c_int as uint8_t,
                flags: 0x2 as libc::c_int as uint8_t,
                sym: 240 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 41 as libc::c_int as uint8_t,
                flags: 0x2 as libc::c_int as uint8_t,
                sym: 240 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 56 as libc::c_int as uint8_t,
                flags: 0x3 as libc::c_int as uint8_t,
                sym: 240 as libc::c_int as uint8_t,
            };
            init
        },
    ],
    [
        {
            let mut init = decode_el {
                state: 2 as libc::c_int as uint8_t,
                flags: 0x2 as libc::c_int as uint8_t,
                sym: 242 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 9 as libc::c_int as uint8_t,
                flags: 0x2 as libc::c_int as uint8_t,
                sym: 242 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 23 as libc::c_int as uint8_t,
                flags: 0x2 as libc::c_int as uint8_t,
                sym: 242 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 40 as libc::c_int as uint8_t,
                flags: 0x3 as libc::c_int as uint8_t,
                sym: 242 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 2 as libc::c_int as uint8_t,
                flags: 0x2 as libc::c_int as uint8_t,
                sym: 243 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 9 as libc::c_int as uint8_t,
                flags: 0x2 as libc::c_int as uint8_t,
                sym: 243 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 23 as libc::c_int as uint8_t,
                flags: 0x2 as libc::c_int as uint8_t,
                sym: 243 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 40 as libc::c_int as uint8_t,
                flags: 0x3 as libc::c_int as uint8_t,
                sym: 243 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 2 as libc::c_int as uint8_t,
                flags: 0x2 as libc::c_int as uint8_t,
                sym: 255 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 9 as libc::c_int as uint8_t,
                flags: 0x2 as libc::c_int as uint8_t,
                sym: 255 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 23 as libc::c_int as uint8_t,
                flags: 0x2 as libc::c_int as uint8_t,
                sym: 255 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 40 as libc::c_int as uint8_t,
                flags: 0x3 as libc::c_int as uint8_t,
                sym: 255 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 1 as libc::c_int as uint8_t,
                flags: 0x2 as libc::c_int as uint8_t,
                sym: 203 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 22 as libc::c_int as uint8_t,
                flags: 0x3 as libc::c_int as uint8_t,
                sym: 203 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 1 as libc::c_int as uint8_t,
                flags: 0x2 as libc::c_int as uint8_t,
                sym: 204 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 22 as libc::c_int as uint8_t,
                flags: 0x3 as libc::c_int as uint8_t,
                sym: 204 as libc::c_int as uint8_t,
            };
            init
        },
    ],
    [
        {
            let mut init = decode_el {
                state: 3 as libc::c_int as uint8_t,
                flags: 0x2 as libc::c_int as uint8_t,
                sym: 242 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 6 as libc::c_int as uint8_t,
                flags: 0x2 as libc::c_int as uint8_t,
                sym: 242 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 10 as libc::c_int as uint8_t,
                flags: 0x2 as libc::c_int as uint8_t,
                sym: 242 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 15 as libc::c_int as uint8_t,
                flags: 0x2 as libc::c_int as uint8_t,
                sym: 242 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 24 as libc::c_int as uint8_t,
                flags: 0x2 as libc::c_int as uint8_t,
                sym: 242 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 31 as libc::c_int as uint8_t,
                flags: 0x2 as libc::c_int as uint8_t,
                sym: 242 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 41 as libc::c_int as uint8_t,
                flags: 0x2 as libc::c_int as uint8_t,
                sym: 242 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 56 as libc::c_int as uint8_t,
                flags: 0x3 as libc::c_int as uint8_t,
                sym: 242 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 3 as libc::c_int as uint8_t,
                flags: 0x2 as libc::c_int as uint8_t,
                sym: 243 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 6 as libc::c_int as uint8_t,
                flags: 0x2 as libc::c_int as uint8_t,
                sym: 243 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 10 as libc::c_int as uint8_t,
                flags: 0x2 as libc::c_int as uint8_t,
                sym: 243 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 15 as libc::c_int as uint8_t,
                flags: 0x2 as libc::c_int as uint8_t,
                sym: 243 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 24 as libc::c_int as uint8_t,
                flags: 0x2 as libc::c_int as uint8_t,
                sym: 243 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 31 as libc::c_int as uint8_t,
                flags: 0x2 as libc::c_int as uint8_t,
                sym: 243 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 41 as libc::c_int as uint8_t,
                flags: 0x2 as libc::c_int as uint8_t,
                sym: 243 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 56 as libc::c_int as uint8_t,
                flags: 0x3 as libc::c_int as uint8_t,
                sym: 243 as libc::c_int as uint8_t,
            };
            init
        },
    ],
    [
        {
            let mut init = decode_el {
                state: 3 as libc::c_int as uint8_t,
                flags: 0x2 as libc::c_int as uint8_t,
                sym: 255 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 6 as libc::c_int as uint8_t,
                flags: 0x2 as libc::c_int as uint8_t,
                sym: 255 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 10 as libc::c_int as uint8_t,
                flags: 0x2 as libc::c_int as uint8_t,
                sym: 255 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 15 as libc::c_int as uint8_t,
                flags: 0x2 as libc::c_int as uint8_t,
                sym: 255 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 24 as libc::c_int as uint8_t,
                flags: 0x2 as libc::c_int as uint8_t,
                sym: 255 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 31 as libc::c_int as uint8_t,
                flags: 0x2 as libc::c_int as uint8_t,
                sym: 255 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 41 as libc::c_int as uint8_t,
                flags: 0x2 as libc::c_int as uint8_t,
                sym: 255 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 56 as libc::c_int as uint8_t,
                flags: 0x3 as libc::c_int as uint8_t,
                sym: 255 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 2 as libc::c_int as uint8_t,
                flags: 0x2 as libc::c_int as uint8_t,
                sym: 203 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 9 as libc::c_int as uint8_t,
                flags: 0x2 as libc::c_int as uint8_t,
                sym: 203 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 23 as libc::c_int as uint8_t,
                flags: 0x2 as libc::c_int as uint8_t,
                sym: 203 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 40 as libc::c_int as uint8_t,
                flags: 0x3 as libc::c_int as uint8_t,
                sym: 203 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 2 as libc::c_int as uint8_t,
                flags: 0x2 as libc::c_int as uint8_t,
                sym: 204 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 9 as libc::c_int as uint8_t,
                flags: 0x2 as libc::c_int as uint8_t,
                sym: 204 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 23 as libc::c_int as uint8_t,
                flags: 0x2 as libc::c_int as uint8_t,
                sym: 204 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 40 as libc::c_int as uint8_t,
                flags: 0x3 as libc::c_int as uint8_t,
                sym: 204 as libc::c_int as uint8_t,
            };
            init
        },
    ],
    [
        {
            let mut init = decode_el {
                state: 3 as libc::c_int as uint8_t,
                flags: 0x2 as libc::c_int as uint8_t,
                sym: 203 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 6 as libc::c_int as uint8_t,
                flags: 0x2 as libc::c_int as uint8_t,
                sym: 203 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 10 as libc::c_int as uint8_t,
                flags: 0x2 as libc::c_int as uint8_t,
                sym: 203 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 15 as libc::c_int as uint8_t,
                flags: 0x2 as libc::c_int as uint8_t,
                sym: 203 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 24 as libc::c_int as uint8_t,
                flags: 0x2 as libc::c_int as uint8_t,
                sym: 203 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 31 as libc::c_int as uint8_t,
                flags: 0x2 as libc::c_int as uint8_t,
                sym: 203 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 41 as libc::c_int as uint8_t,
                flags: 0x2 as libc::c_int as uint8_t,
                sym: 203 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 56 as libc::c_int as uint8_t,
                flags: 0x3 as libc::c_int as uint8_t,
                sym: 203 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 3 as libc::c_int as uint8_t,
                flags: 0x2 as libc::c_int as uint8_t,
                sym: 204 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 6 as libc::c_int as uint8_t,
                flags: 0x2 as libc::c_int as uint8_t,
                sym: 204 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 10 as libc::c_int as uint8_t,
                flags: 0x2 as libc::c_int as uint8_t,
                sym: 204 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 15 as libc::c_int as uint8_t,
                flags: 0x2 as libc::c_int as uint8_t,
                sym: 204 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 24 as libc::c_int as uint8_t,
                flags: 0x2 as libc::c_int as uint8_t,
                sym: 204 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 31 as libc::c_int as uint8_t,
                flags: 0x2 as libc::c_int as uint8_t,
                sym: 204 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 41 as libc::c_int as uint8_t,
                flags: 0x2 as libc::c_int as uint8_t,
                sym: 204 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 56 as libc::c_int as uint8_t,
                flags: 0x3 as libc::c_int as uint8_t,
                sym: 204 as libc::c_int as uint8_t,
            };
            init
        },
    ],
    [
        {
            let mut init = decode_el {
                state: 211 as libc::c_int as uint8_t,
                flags: 0 as libc::c_int as uint8_t,
                sym: 0 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 212 as libc::c_int as uint8_t,
                flags: 0 as libc::c_int as uint8_t,
                sym: 0 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 214 as libc::c_int as uint8_t,
                flags: 0 as libc::c_int as uint8_t,
                sym: 0 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 215 as libc::c_int as uint8_t,
                flags: 0 as libc::c_int as uint8_t,
                sym: 0 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 218 as libc::c_int as uint8_t,
                flags: 0 as libc::c_int as uint8_t,
                sym: 0 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 219 as libc::c_int as uint8_t,
                flags: 0 as libc::c_int as uint8_t,
                sym: 0 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 221 as libc::c_int as uint8_t,
                flags: 0 as libc::c_int as uint8_t,
                sym: 0 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 222 as libc::c_int as uint8_t,
                flags: 0 as libc::c_int as uint8_t,
                sym: 0 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 226 as libc::c_int as uint8_t,
                flags: 0 as libc::c_int as uint8_t,
                sym: 0 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 228 as libc::c_int as uint8_t,
                flags: 0 as libc::c_int as uint8_t,
                sym: 0 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 232 as libc::c_int as uint8_t,
                flags: 0 as libc::c_int as uint8_t,
                sym: 0 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 235 as libc::c_int as uint8_t,
                flags: 0 as libc::c_int as uint8_t,
                sym: 0 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 240 as libc::c_int as uint8_t,
                flags: 0 as libc::c_int as uint8_t,
                sym: 0 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 243 as libc::c_int as uint8_t,
                flags: 0 as libc::c_int as uint8_t,
                sym: 0 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 247 as libc::c_int as uint8_t,
                flags: 0 as libc::c_int as uint8_t,
                sym: 0 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 250 as libc::c_int as uint8_t,
                flags: 0 as libc::c_int as uint8_t,
                sym: 0 as libc::c_int as uint8_t,
            };
            init
        },
    ],
    [
        {
            let mut init = decode_el {
                state: 0 as libc::c_int as uint8_t,
                flags: 0x3 as libc::c_int as uint8_t,
                sym: 211 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 0 as libc::c_int as uint8_t,
                flags: 0x3 as libc::c_int as uint8_t,
                sym: 212 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 0 as libc::c_int as uint8_t,
                flags: 0x3 as libc::c_int as uint8_t,
                sym: 214 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 0 as libc::c_int as uint8_t,
                flags: 0x3 as libc::c_int as uint8_t,
                sym: 221 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 0 as libc::c_int as uint8_t,
                flags: 0x3 as libc::c_int as uint8_t,
                sym: 222 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 0 as libc::c_int as uint8_t,
                flags: 0x3 as libc::c_int as uint8_t,
                sym: 223 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 0 as libc::c_int as uint8_t,
                flags: 0x3 as libc::c_int as uint8_t,
                sym: 241 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 0 as libc::c_int as uint8_t,
                flags: 0x3 as libc::c_int as uint8_t,
                sym: 244 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 0 as libc::c_int as uint8_t,
                flags: 0x3 as libc::c_int as uint8_t,
                sym: 245 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 0 as libc::c_int as uint8_t,
                flags: 0x3 as libc::c_int as uint8_t,
                sym: 246 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 0 as libc::c_int as uint8_t,
                flags: 0x3 as libc::c_int as uint8_t,
                sym: 247 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 0 as libc::c_int as uint8_t,
                flags: 0x3 as libc::c_int as uint8_t,
                sym: 248 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 0 as libc::c_int as uint8_t,
                flags: 0x3 as libc::c_int as uint8_t,
                sym: 250 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 0 as libc::c_int as uint8_t,
                flags: 0x3 as libc::c_int as uint8_t,
                sym: 251 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 0 as libc::c_int as uint8_t,
                flags: 0x3 as libc::c_int as uint8_t,
                sym: 252 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 0 as libc::c_int as uint8_t,
                flags: 0x3 as libc::c_int as uint8_t,
                sym: 253 as libc::c_int as uint8_t,
            };
            init
        },
    ],
    [
        {
            let mut init = decode_el {
                state: 1 as libc::c_int as uint8_t,
                flags: 0x2 as libc::c_int as uint8_t,
                sym: 211 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 22 as libc::c_int as uint8_t,
                flags: 0x3 as libc::c_int as uint8_t,
                sym: 211 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 1 as libc::c_int as uint8_t,
                flags: 0x2 as libc::c_int as uint8_t,
                sym: 212 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 22 as libc::c_int as uint8_t,
                flags: 0x3 as libc::c_int as uint8_t,
                sym: 212 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 1 as libc::c_int as uint8_t,
                flags: 0x2 as libc::c_int as uint8_t,
                sym: 214 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 22 as libc::c_int as uint8_t,
                flags: 0x3 as libc::c_int as uint8_t,
                sym: 214 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 1 as libc::c_int as uint8_t,
                flags: 0x2 as libc::c_int as uint8_t,
                sym: 221 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 22 as libc::c_int as uint8_t,
                flags: 0x3 as libc::c_int as uint8_t,
                sym: 221 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 1 as libc::c_int as uint8_t,
                flags: 0x2 as libc::c_int as uint8_t,
                sym: 222 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 22 as libc::c_int as uint8_t,
                flags: 0x3 as libc::c_int as uint8_t,
                sym: 222 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 1 as libc::c_int as uint8_t,
                flags: 0x2 as libc::c_int as uint8_t,
                sym: 223 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 22 as libc::c_int as uint8_t,
                flags: 0x3 as libc::c_int as uint8_t,
                sym: 223 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 1 as libc::c_int as uint8_t,
                flags: 0x2 as libc::c_int as uint8_t,
                sym: 241 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 22 as libc::c_int as uint8_t,
                flags: 0x3 as libc::c_int as uint8_t,
                sym: 241 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 1 as libc::c_int as uint8_t,
                flags: 0x2 as libc::c_int as uint8_t,
                sym: 244 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 22 as libc::c_int as uint8_t,
                flags: 0x3 as libc::c_int as uint8_t,
                sym: 244 as libc::c_int as uint8_t,
            };
            init
        },
    ],
    [
        {
            let mut init = decode_el {
                state: 2 as libc::c_int as uint8_t,
                flags: 0x2 as libc::c_int as uint8_t,
                sym: 211 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 9 as libc::c_int as uint8_t,
                flags: 0x2 as libc::c_int as uint8_t,
                sym: 211 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 23 as libc::c_int as uint8_t,
                flags: 0x2 as libc::c_int as uint8_t,
                sym: 211 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 40 as libc::c_int as uint8_t,
                flags: 0x3 as libc::c_int as uint8_t,
                sym: 211 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 2 as libc::c_int as uint8_t,
                flags: 0x2 as libc::c_int as uint8_t,
                sym: 212 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 9 as libc::c_int as uint8_t,
                flags: 0x2 as libc::c_int as uint8_t,
                sym: 212 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 23 as libc::c_int as uint8_t,
                flags: 0x2 as libc::c_int as uint8_t,
                sym: 212 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 40 as libc::c_int as uint8_t,
                flags: 0x3 as libc::c_int as uint8_t,
                sym: 212 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 2 as libc::c_int as uint8_t,
                flags: 0x2 as libc::c_int as uint8_t,
                sym: 214 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 9 as libc::c_int as uint8_t,
                flags: 0x2 as libc::c_int as uint8_t,
                sym: 214 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 23 as libc::c_int as uint8_t,
                flags: 0x2 as libc::c_int as uint8_t,
                sym: 214 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 40 as libc::c_int as uint8_t,
                flags: 0x3 as libc::c_int as uint8_t,
                sym: 214 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 2 as libc::c_int as uint8_t,
                flags: 0x2 as libc::c_int as uint8_t,
                sym: 221 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 9 as libc::c_int as uint8_t,
                flags: 0x2 as libc::c_int as uint8_t,
                sym: 221 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 23 as libc::c_int as uint8_t,
                flags: 0x2 as libc::c_int as uint8_t,
                sym: 221 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 40 as libc::c_int as uint8_t,
                flags: 0x3 as libc::c_int as uint8_t,
                sym: 221 as libc::c_int as uint8_t,
            };
            init
        },
    ],
    [
        {
            let mut init = decode_el {
                state: 3 as libc::c_int as uint8_t,
                flags: 0x2 as libc::c_int as uint8_t,
                sym: 211 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 6 as libc::c_int as uint8_t,
                flags: 0x2 as libc::c_int as uint8_t,
                sym: 211 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 10 as libc::c_int as uint8_t,
                flags: 0x2 as libc::c_int as uint8_t,
                sym: 211 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 15 as libc::c_int as uint8_t,
                flags: 0x2 as libc::c_int as uint8_t,
                sym: 211 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 24 as libc::c_int as uint8_t,
                flags: 0x2 as libc::c_int as uint8_t,
                sym: 211 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 31 as libc::c_int as uint8_t,
                flags: 0x2 as libc::c_int as uint8_t,
                sym: 211 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 41 as libc::c_int as uint8_t,
                flags: 0x2 as libc::c_int as uint8_t,
                sym: 211 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 56 as libc::c_int as uint8_t,
                flags: 0x3 as libc::c_int as uint8_t,
                sym: 211 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 3 as libc::c_int as uint8_t,
                flags: 0x2 as libc::c_int as uint8_t,
                sym: 212 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 6 as libc::c_int as uint8_t,
                flags: 0x2 as libc::c_int as uint8_t,
                sym: 212 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 10 as libc::c_int as uint8_t,
                flags: 0x2 as libc::c_int as uint8_t,
                sym: 212 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 15 as libc::c_int as uint8_t,
                flags: 0x2 as libc::c_int as uint8_t,
                sym: 212 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 24 as libc::c_int as uint8_t,
                flags: 0x2 as libc::c_int as uint8_t,
                sym: 212 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 31 as libc::c_int as uint8_t,
                flags: 0x2 as libc::c_int as uint8_t,
                sym: 212 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 41 as libc::c_int as uint8_t,
                flags: 0x2 as libc::c_int as uint8_t,
                sym: 212 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 56 as libc::c_int as uint8_t,
                flags: 0x3 as libc::c_int as uint8_t,
                sym: 212 as libc::c_int as uint8_t,
            };
            init
        },
    ],
    [
        {
            let mut init = decode_el {
                state: 3 as libc::c_int as uint8_t,
                flags: 0x2 as libc::c_int as uint8_t,
                sym: 214 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 6 as libc::c_int as uint8_t,
                flags: 0x2 as libc::c_int as uint8_t,
                sym: 214 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 10 as libc::c_int as uint8_t,
                flags: 0x2 as libc::c_int as uint8_t,
                sym: 214 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 15 as libc::c_int as uint8_t,
                flags: 0x2 as libc::c_int as uint8_t,
                sym: 214 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 24 as libc::c_int as uint8_t,
                flags: 0x2 as libc::c_int as uint8_t,
                sym: 214 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 31 as libc::c_int as uint8_t,
                flags: 0x2 as libc::c_int as uint8_t,
                sym: 214 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 41 as libc::c_int as uint8_t,
                flags: 0x2 as libc::c_int as uint8_t,
                sym: 214 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 56 as libc::c_int as uint8_t,
                flags: 0x3 as libc::c_int as uint8_t,
                sym: 214 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 3 as libc::c_int as uint8_t,
                flags: 0x2 as libc::c_int as uint8_t,
                sym: 221 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 6 as libc::c_int as uint8_t,
                flags: 0x2 as libc::c_int as uint8_t,
                sym: 221 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 10 as libc::c_int as uint8_t,
                flags: 0x2 as libc::c_int as uint8_t,
                sym: 221 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 15 as libc::c_int as uint8_t,
                flags: 0x2 as libc::c_int as uint8_t,
                sym: 221 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 24 as libc::c_int as uint8_t,
                flags: 0x2 as libc::c_int as uint8_t,
                sym: 221 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 31 as libc::c_int as uint8_t,
                flags: 0x2 as libc::c_int as uint8_t,
                sym: 221 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 41 as libc::c_int as uint8_t,
                flags: 0x2 as libc::c_int as uint8_t,
                sym: 221 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 56 as libc::c_int as uint8_t,
                flags: 0x3 as libc::c_int as uint8_t,
                sym: 221 as libc::c_int as uint8_t,
            };
            init
        },
    ],
    [
        {
            let mut init = decode_el {
                state: 2 as libc::c_int as uint8_t,
                flags: 0x2 as libc::c_int as uint8_t,
                sym: 222 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 9 as libc::c_int as uint8_t,
                flags: 0x2 as libc::c_int as uint8_t,
                sym: 222 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 23 as libc::c_int as uint8_t,
                flags: 0x2 as libc::c_int as uint8_t,
                sym: 222 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 40 as libc::c_int as uint8_t,
                flags: 0x3 as libc::c_int as uint8_t,
                sym: 222 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 2 as libc::c_int as uint8_t,
                flags: 0x2 as libc::c_int as uint8_t,
                sym: 223 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 9 as libc::c_int as uint8_t,
                flags: 0x2 as libc::c_int as uint8_t,
                sym: 223 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 23 as libc::c_int as uint8_t,
                flags: 0x2 as libc::c_int as uint8_t,
                sym: 223 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 40 as libc::c_int as uint8_t,
                flags: 0x3 as libc::c_int as uint8_t,
                sym: 223 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 2 as libc::c_int as uint8_t,
                flags: 0x2 as libc::c_int as uint8_t,
                sym: 241 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 9 as libc::c_int as uint8_t,
                flags: 0x2 as libc::c_int as uint8_t,
                sym: 241 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 23 as libc::c_int as uint8_t,
                flags: 0x2 as libc::c_int as uint8_t,
                sym: 241 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 40 as libc::c_int as uint8_t,
                flags: 0x3 as libc::c_int as uint8_t,
                sym: 241 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 2 as libc::c_int as uint8_t,
                flags: 0x2 as libc::c_int as uint8_t,
                sym: 244 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 9 as libc::c_int as uint8_t,
                flags: 0x2 as libc::c_int as uint8_t,
                sym: 244 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 23 as libc::c_int as uint8_t,
                flags: 0x2 as libc::c_int as uint8_t,
                sym: 244 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 40 as libc::c_int as uint8_t,
                flags: 0x3 as libc::c_int as uint8_t,
                sym: 244 as libc::c_int as uint8_t,
            };
            init
        },
    ],
    [
        {
            let mut init = decode_el {
                state: 3 as libc::c_int as uint8_t,
                flags: 0x2 as libc::c_int as uint8_t,
                sym: 222 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 6 as libc::c_int as uint8_t,
                flags: 0x2 as libc::c_int as uint8_t,
                sym: 222 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 10 as libc::c_int as uint8_t,
                flags: 0x2 as libc::c_int as uint8_t,
                sym: 222 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 15 as libc::c_int as uint8_t,
                flags: 0x2 as libc::c_int as uint8_t,
                sym: 222 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 24 as libc::c_int as uint8_t,
                flags: 0x2 as libc::c_int as uint8_t,
                sym: 222 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 31 as libc::c_int as uint8_t,
                flags: 0x2 as libc::c_int as uint8_t,
                sym: 222 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 41 as libc::c_int as uint8_t,
                flags: 0x2 as libc::c_int as uint8_t,
                sym: 222 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 56 as libc::c_int as uint8_t,
                flags: 0x3 as libc::c_int as uint8_t,
                sym: 222 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 3 as libc::c_int as uint8_t,
                flags: 0x2 as libc::c_int as uint8_t,
                sym: 223 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 6 as libc::c_int as uint8_t,
                flags: 0x2 as libc::c_int as uint8_t,
                sym: 223 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 10 as libc::c_int as uint8_t,
                flags: 0x2 as libc::c_int as uint8_t,
                sym: 223 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 15 as libc::c_int as uint8_t,
                flags: 0x2 as libc::c_int as uint8_t,
                sym: 223 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 24 as libc::c_int as uint8_t,
                flags: 0x2 as libc::c_int as uint8_t,
                sym: 223 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 31 as libc::c_int as uint8_t,
                flags: 0x2 as libc::c_int as uint8_t,
                sym: 223 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 41 as libc::c_int as uint8_t,
                flags: 0x2 as libc::c_int as uint8_t,
                sym: 223 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 56 as libc::c_int as uint8_t,
                flags: 0x3 as libc::c_int as uint8_t,
                sym: 223 as libc::c_int as uint8_t,
            };
            init
        },
    ],
    [
        {
            let mut init = decode_el {
                state: 3 as libc::c_int as uint8_t,
                flags: 0x2 as libc::c_int as uint8_t,
                sym: 241 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 6 as libc::c_int as uint8_t,
                flags: 0x2 as libc::c_int as uint8_t,
                sym: 241 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 10 as libc::c_int as uint8_t,
                flags: 0x2 as libc::c_int as uint8_t,
                sym: 241 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 15 as libc::c_int as uint8_t,
                flags: 0x2 as libc::c_int as uint8_t,
                sym: 241 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 24 as libc::c_int as uint8_t,
                flags: 0x2 as libc::c_int as uint8_t,
                sym: 241 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 31 as libc::c_int as uint8_t,
                flags: 0x2 as libc::c_int as uint8_t,
                sym: 241 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 41 as libc::c_int as uint8_t,
                flags: 0x2 as libc::c_int as uint8_t,
                sym: 241 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 56 as libc::c_int as uint8_t,
                flags: 0x3 as libc::c_int as uint8_t,
                sym: 241 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 3 as libc::c_int as uint8_t,
                flags: 0x2 as libc::c_int as uint8_t,
                sym: 244 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 6 as libc::c_int as uint8_t,
                flags: 0x2 as libc::c_int as uint8_t,
                sym: 244 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 10 as libc::c_int as uint8_t,
                flags: 0x2 as libc::c_int as uint8_t,
                sym: 244 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 15 as libc::c_int as uint8_t,
                flags: 0x2 as libc::c_int as uint8_t,
                sym: 244 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 24 as libc::c_int as uint8_t,
                flags: 0x2 as libc::c_int as uint8_t,
                sym: 244 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 31 as libc::c_int as uint8_t,
                flags: 0x2 as libc::c_int as uint8_t,
                sym: 244 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 41 as libc::c_int as uint8_t,
                flags: 0x2 as libc::c_int as uint8_t,
                sym: 244 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 56 as libc::c_int as uint8_t,
                flags: 0x3 as libc::c_int as uint8_t,
                sym: 244 as libc::c_int as uint8_t,
            };
            init
        },
    ],
    [
        {
            let mut init = decode_el {
                state: 1 as libc::c_int as uint8_t,
                flags: 0x2 as libc::c_int as uint8_t,
                sym: 245 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 22 as libc::c_int as uint8_t,
                flags: 0x3 as libc::c_int as uint8_t,
                sym: 245 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 1 as libc::c_int as uint8_t,
                flags: 0x2 as libc::c_int as uint8_t,
                sym: 246 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 22 as libc::c_int as uint8_t,
                flags: 0x3 as libc::c_int as uint8_t,
                sym: 246 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 1 as libc::c_int as uint8_t,
                flags: 0x2 as libc::c_int as uint8_t,
                sym: 247 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 22 as libc::c_int as uint8_t,
                flags: 0x3 as libc::c_int as uint8_t,
                sym: 247 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 1 as libc::c_int as uint8_t,
                flags: 0x2 as libc::c_int as uint8_t,
                sym: 248 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 22 as libc::c_int as uint8_t,
                flags: 0x3 as libc::c_int as uint8_t,
                sym: 248 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 1 as libc::c_int as uint8_t,
                flags: 0x2 as libc::c_int as uint8_t,
                sym: 250 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 22 as libc::c_int as uint8_t,
                flags: 0x3 as libc::c_int as uint8_t,
                sym: 250 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 1 as libc::c_int as uint8_t,
                flags: 0x2 as libc::c_int as uint8_t,
                sym: 251 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 22 as libc::c_int as uint8_t,
                flags: 0x3 as libc::c_int as uint8_t,
                sym: 251 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 1 as libc::c_int as uint8_t,
                flags: 0x2 as libc::c_int as uint8_t,
                sym: 252 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 22 as libc::c_int as uint8_t,
                flags: 0x3 as libc::c_int as uint8_t,
                sym: 252 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 1 as libc::c_int as uint8_t,
                flags: 0x2 as libc::c_int as uint8_t,
                sym: 253 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 22 as libc::c_int as uint8_t,
                flags: 0x3 as libc::c_int as uint8_t,
                sym: 253 as libc::c_int as uint8_t,
            };
            init
        },
    ],
    [
        {
            let mut init = decode_el {
                state: 2 as libc::c_int as uint8_t,
                flags: 0x2 as libc::c_int as uint8_t,
                sym: 245 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 9 as libc::c_int as uint8_t,
                flags: 0x2 as libc::c_int as uint8_t,
                sym: 245 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 23 as libc::c_int as uint8_t,
                flags: 0x2 as libc::c_int as uint8_t,
                sym: 245 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 40 as libc::c_int as uint8_t,
                flags: 0x3 as libc::c_int as uint8_t,
                sym: 245 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 2 as libc::c_int as uint8_t,
                flags: 0x2 as libc::c_int as uint8_t,
                sym: 246 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 9 as libc::c_int as uint8_t,
                flags: 0x2 as libc::c_int as uint8_t,
                sym: 246 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 23 as libc::c_int as uint8_t,
                flags: 0x2 as libc::c_int as uint8_t,
                sym: 246 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 40 as libc::c_int as uint8_t,
                flags: 0x3 as libc::c_int as uint8_t,
                sym: 246 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 2 as libc::c_int as uint8_t,
                flags: 0x2 as libc::c_int as uint8_t,
                sym: 247 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 9 as libc::c_int as uint8_t,
                flags: 0x2 as libc::c_int as uint8_t,
                sym: 247 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 23 as libc::c_int as uint8_t,
                flags: 0x2 as libc::c_int as uint8_t,
                sym: 247 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 40 as libc::c_int as uint8_t,
                flags: 0x3 as libc::c_int as uint8_t,
                sym: 247 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 2 as libc::c_int as uint8_t,
                flags: 0x2 as libc::c_int as uint8_t,
                sym: 248 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 9 as libc::c_int as uint8_t,
                flags: 0x2 as libc::c_int as uint8_t,
                sym: 248 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 23 as libc::c_int as uint8_t,
                flags: 0x2 as libc::c_int as uint8_t,
                sym: 248 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 40 as libc::c_int as uint8_t,
                flags: 0x3 as libc::c_int as uint8_t,
                sym: 248 as libc::c_int as uint8_t,
            };
            init
        },
    ],
    [
        {
            let mut init = decode_el {
                state: 3 as libc::c_int as uint8_t,
                flags: 0x2 as libc::c_int as uint8_t,
                sym: 245 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 6 as libc::c_int as uint8_t,
                flags: 0x2 as libc::c_int as uint8_t,
                sym: 245 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 10 as libc::c_int as uint8_t,
                flags: 0x2 as libc::c_int as uint8_t,
                sym: 245 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 15 as libc::c_int as uint8_t,
                flags: 0x2 as libc::c_int as uint8_t,
                sym: 245 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 24 as libc::c_int as uint8_t,
                flags: 0x2 as libc::c_int as uint8_t,
                sym: 245 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 31 as libc::c_int as uint8_t,
                flags: 0x2 as libc::c_int as uint8_t,
                sym: 245 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 41 as libc::c_int as uint8_t,
                flags: 0x2 as libc::c_int as uint8_t,
                sym: 245 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 56 as libc::c_int as uint8_t,
                flags: 0x3 as libc::c_int as uint8_t,
                sym: 245 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 3 as libc::c_int as uint8_t,
                flags: 0x2 as libc::c_int as uint8_t,
                sym: 246 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 6 as libc::c_int as uint8_t,
                flags: 0x2 as libc::c_int as uint8_t,
                sym: 246 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 10 as libc::c_int as uint8_t,
                flags: 0x2 as libc::c_int as uint8_t,
                sym: 246 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 15 as libc::c_int as uint8_t,
                flags: 0x2 as libc::c_int as uint8_t,
                sym: 246 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 24 as libc::c_int as uint8_t,
                flags: 0x2 as libc::c_int as uint8_t,
                sym: 246 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 31 as libc::c_int as uint8_t,
                flags: 0x2 as libc::c_int as uint8_t,
                sym: 246 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 41 as libc::c_int as uint8_t,
                flags: 0x2 as libc::c_int as uint8_t,
                sym: 246 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 56 as libc::c_int as uint8_t,
                flags: 0x3 as libc::c_int as uint8_t,
                sym: 246 as libc::c_int as uint8_t,
            };
            init
        },
    ],
    [
        {
            let mut init = decode_el {
                state: 3 as libc::c_int as uint8_t,
                flags: 0x2 as libc::c_int as uint8_t,
                sym: 247 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 6 as libc::c_int as uint8_t,
                flags: 0x2 as libc::c_int as uint8_t,
                sym: 247 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 10 as libc::c_int as uint8_t,
                flags: 0x2 as libc::c_int as uint8_t,
                sym: 247 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 15 as libc::c_int as uint8_t,
                flags: 0x2 as libc::c_int as uint8_t,
                sym: 247 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 24 as libc::c_int as uint8_t,
                flags: 0x2 as libc::c_int as uint8_t,
                sym: 247 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 31 as libc::c_int as uint8_t,
                flags: 0x2 as libc::c_int as uint8_t,
                sym: 247 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 41 as libc::c_int as uint8_t,
                flags: 0x2 as libc::c_int as uint8_t,
                sym: 247 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 56 as libc::c_int as uint8_t,
                flags: 0x3 as libc::c_int as uint8_t,
                sym: 247 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 3 as libc::c_int as uint8_t,
                flags: 0x2 as libc::c_int as uint8_t,
                sym: 248 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 6 as libc::c_int as uint8_t,
                flags: 0x2 as libc::c_int as uint8_t,
                sym: 248 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 10 as libc::c_int as uint8_t,
                flags: 0x2 as libc::c_int as uint8_t,
                sym: 248 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 15 as libc::c_int as uint8_t,
                flags: 0x2 as libc::c_int as uint8_t,
                sym: 248 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 24 as libc::c_int as uint8_t,
                flags: 0x2 as libc::c_int as uint8_t,
                sym: 248 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 31 as libc::c_int as uint8_t,
                flags: 0x2 as libc::c_int as uint8_t,
                sym: 248 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 41 as libc::c_int as uint8_t,
                flags: 0x2 as libc::c_int as uint8_t,
                sym: 248 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 56 as libc::c_int as uint8_t,
                flags: 0x3 as libc::c_int as uint8_t,
                sym: 248 as libc::c_int as uint8_t,
            };
            init
        },
    ],
    [
        {
            let mut init = decode_el {
                state: 2 as libc::c_int as uint8_t,
                flags: 0x2 as libc::c_int as uint8_t,
                sym: 250 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 9 as libc::c_int as uint8_t,
                flags: 0x2 as libc::c_int as uint8_t,
                sym: 250 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 23 as libc::c_int as uint8_t,
                flags: 0x2 as libc::c_int as uint8_t,
                sym: 250 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 40 as libc::c_int as uint8_t,
                flags: 0x3 as libc::c_int as uint8_t,
                sym: 250 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 2 as libc::c_int as uint8_t,
                flags: 0x2 as libc::c_int as uint8_t,
                sym: 251 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 9 as libc::c_int as uint8_t,
                flags: 0x2 as libc::c_int as uint8_t,
                sym: 251 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 23 as libc::c_int as uint8_t,
                flags: 0x2 as libc::c_int as uint8_t,
                sym: 251 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 40 as libc::c_int as uint8_t,
                flags: 0x3 as libc::c_int as uint8_t,
                sym: 251 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 2 as libc::c_int as uint8_t,
                flags: 0x2 as libc::c_int as uint8_t,
                sym: 252 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 9 as libc::c_int as uint8_t,
                flags: 0x2 as libc::c_int as uint8_t,
                sym: 252 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 23 as libc::c_int as uint8_t,
                flags: 0x2 as libc::c_int as uint8_t,
                sym: 252 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 40 as libc::c_int as uint8_t,
                flags: 0x3 as libc::c_int as uint8_t,
                sym: 252 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 2 as libc::c_int as uint8_t,
                flags: 0x2 as libc::c_int as uint8_t,
                sym: 253 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 9 as libc::c_int as uint8_t,
                flags: 0x2 as libc::c_int as uint8_t,
                sym: 253 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 23 as libc::c_int as uint8_t,
                flags: 0x2 as libc::c_int as uint8_t,
                sym: 253 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 40 as libc::c_int as uint8_t,
                flags: 0x3 as libc::c_int as uint8_t,
                sym: 253 as libc::c_int as uint8_t,
            };
            init
        },
    ],
    [
        {
            let mut init = decode_el {
                state: 3 as libc::c_int as uint8_t,
                flags: 0x2 as libc::c_int as uint8_t,
                sym: 250 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 6 as libc::c_int as uint8_t,
                flags: 0x2 as libc::c_int as uint8_t,
                sym: 250 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 10 as libc::c_int as uint8_t,
                flags: 0x2 as libc::c_int as uint8_t,
                sym: 250 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 15 as libc::c_int as uint8_t,
                flags: 0x2 as libc::c_int as uint8_t,
                sym: 250 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 24 as libc::c_int as uint8_t,
                flags: 0x2 as libc::c_int as uint8_t,
                sym: 250 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 31 as libc::c_int as uint8_t,
                flags: 0x2 as libc::c_int as uint8_t,
                sym: 250 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 41 as libc::c_int as uint8_t,
                flags: 0x2 as libc::c_int as uint8_t,
                sym: 250 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 56 as libc::c_int as uint8_t,
                flags: 0x3 as libc::c_int as uint8_t,
                sym: 250 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 3 as libc::c_int as uint8_t,
                flags: 0x2 as libc::c_int as uint8_t,
                sym: 251 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 6 as libc::c_int as uint8_t,
                flags: 0x2 as libc::c_int as uint8_t,
                sym: 251 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 10 as libc::c_int as uint8_t,
                flags: 0x2 as libc::c_int as uint8_t,
                sym: 251 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 15 as libc::c_int as uint8_t,
                flags: 0x2 as libc::c_int as uint8_t,
                sym: 251 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 24 as libc::c_int as uint8_t,
                flags: 0x2 as libc::c_int as uint8_t,
                sym: 251 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 31 as libc::c_int as uint8_t,
                flags: 0x2 as libc::c_int as uint8_t,
                sym: 251 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 41 as libc::c_int as uint8_t,
                flags: 0x2 as libc::c_int as uint8_t,
                sym: 251 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 56 as libc::c_int as uint8_t,
                flags: 0x3 as libc::c_int as uint8_t,
                sym: 251 as libc::c_int as uint8_t,
            };
            init
        },
    ],
    [
        {
            let mut init = decode_el {
                state: 3 as libc::c_int as uint8_t,
                flags: 0x2 as libc::c_int as uint8_t,
                sym: 252 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 6 as libc::c_int as uint8_t,
                flags: 0x2 as libc::c_int as uint8_t,
                sym: 252 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 10 as libc::c_int as uint8_t,
                flags: 0x2 as libc::c_int as uint8_t,
                sym: 252 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 15 as libc::c_int as uint8_t,
                flags: 0x2 as libc::c_int as uint8_t,
                sym: 252 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 24 as libc::c_int as uint8_t,
                flags: 0x2 as libc::c_int as uint8_t,
                sym: 252 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 31 as libc::c_int as uint8_t,
                flags: 0x2 as libc::c_int as uint8_t,
                sym: 252 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 41 as libc::c_int as uint8_t,
                flags: 0x2 as libc::c_int as uint8_t,
                sym: 252 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 56 as libc::c_int as uint8_t,
                flags: 0x3 as libc::c_int as uint8_t,
                sym: 252 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 3 as libc::c_int as uint8_t,
                flags: 0x2 as libc::c_int as uint8_t,
                sym: 253 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 6 as libc::c_int as uint8_t,
                flags: 0x2 as libc::c_int as uint8_t,
                sym: 253 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 10 as libc::c_int as uint8_t,
                flags: 0x2 as libc::c_int as uint8_t,
                sym: 253 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 15 as libc::c_int as uint8_t,
                flags: 0x2 as libc::c_int as uint8_t,
                sym: 253 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 24 as libc::c_int as uint8_t,
                flags: 0x2 as libc::c_int as uint8_t,
                sym: 253 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 31 as libc::c_int as uint8_t,
                flags: 0x2 as libc::c_int as uint8_t,
                sym: 253 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 41 as libc::c_int as uint8_t,
                flags: 0x2 as libc::c_int as uint8_t,
                sym: 253 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 56 as libc::c_int as uint8_t,
                flags: 0x3 as libc::c_int as uint8_t,
                sym: 253 as libc::c_int as uint8_t,
            };
            init
        },
    ],
    [
        {
            let mut init = decode_el {
                state: 0 as libc::c_int as uint8_t,
                flags: 0x3 as libc::c_int as uint8_t,
                sym: 254 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 227 as libc::c_int as uint8_t,
                flags: 0 as libc::c_int as uint8_t,
                sym: 0 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 229 as libc::c_int as uint8_t,
                flags: 0 as libc::c_int as uint8_t,
                sym: 0 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 230 as libc::c_int as uint8_t,
                flags: 0 as libc::c_int as uint8_t,
                sym: 0 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 233 as libc::c_int as uint8_t,
                flags: 0 as libc::c_int as uint8_t,
                sym: 0 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 234 as libc::c_int as uint8_t,
                flags: 0 as libc::c_int as uint8_t,
                sym: 0 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 236 as libc::c_int as uint8_t,
                flags: 0 as libc::c_int as uint8_t,
                sym: 0 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 237 as libc::c_int as uint8_t,
                flags: 0 as libc::c_int as uint8_t,
                sym: 0 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 241 as libc::c_int as uint8_t,
                flags: 0 as libc::c_int as uint8_t,
                sym: 0 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 242 as libc::c_int as uint8_t,
                flags: 0 as libc::c_int as uint8_t,
                sym: 0 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 244 as libc::c_int as uint8_t,
                flags: 0 as libc::c_int as uint8_t,
                sym: 0 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 245 as libc::c_int as uint8_t,
                flags: 0 as libc::c_int as uint8_t,
                sym: 0 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 248 as libc::c_int as uint8_t,
                flags: 0 as libc::c_int as uint8_t,
                sym: 0 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 249 as libc::c_int as uint8_t,
                flags: 0 as libc::c_int as uint8_t,
                sym: 0 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 251 as libc::c_int as uint8_t,
                flags: 0 as libc::c_int as uint8_t,
                sym: 0 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 252 as libc::c_int as uint8_t,
                flags: 0 as libc::c_int as uint8_t,
                sym: 0 as libc::c_int as uint8_t,
            };
            init
        },
    ],
    [
        {
            let mut init = decode_el {
                state: 1 as libc::c_int as uint8_t,
                flags: 0x2 as libc::c_int as uint8_t,
                sym: 254 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 22 as libc::c_int as uint8_t,
                flags: 0x3 as libc::c_int as uint8_t,
                sym: 254 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 0 as libc::c_int as uint8_t,
                flags: 0x3 as libc::c_int as uint8_t,
                sym: 2 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 0 as libc::c_int as uint8_t,
                flags: 0x3 as libc::c_int as uint8_t,
                sym: 3 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 0 as libc::c_int as uint8_t,
                flags: 0x3 as libc::c_int as uint8_t,
                sym: 4 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 0 as libc::c_int as uint8_t,
                flags: 0x3 as libc::c_int as uint8_t,
                sym: 5 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 0 as libc::c_int as uint8_t,
                flags: 0x3 as libc::c_int as uint8_t,
                sym: 6 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 0 as libc::c_int as uint8_t,
                flags: 0x3 as libc::c_int as uint8_t,
                sym: 7 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 0 as libc::c_int as uint8_t,
                flags: 0x3 as libc::c_int as uint8_t,
                sym: 8 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 0 as libc::c_int as uint8_t,
                flags: 0x3 as libc::c_int as uint8_t,
                sym: 11 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 0 as libc::c_int as uint8_t,
                flags: 0x3 as libc::c_int as uint8_t,
                sym: 12 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 0 as libc::c_int as uint8_t,
                flags: 0x3 as libc::c_int as uint8_t,
                sym: 14 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 0 as libc::c_int as uint8_t,
                flags: 0x3 as libc::c_int as uint8_t,
                sym: 15 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 0 as libc::c_int as uint8_t,
                flags: 0x3 as libc::c_int as uint8_t,
                sym: 16 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 0 as libc::c_int as uint8_t,
                flags: 0x3 as libc::c_int as uint8_t,
                sym: 17 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 0 as libc::c_int as uint8_t,
                flags: 0x3 as libc::c_int as uint8_t,
                sym: 18 as libc::c_int as uint8_t,
            };
            init
        },
    ],
    [
        {
            let mut init = decode_el {
                state: 2 as libc::c_int as uint8_t,
                flags: 0x2 as libc::c_int as uint8_t,
                sym: 254 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 9 as libc::c_int as uint8_t,
                flags: 0x2 as libc::c_int as uint8_t,
                sym: 254 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 23 as libc::c_int as uint8_t,
                flags: 0x2 as libc::c_int as uint8_t,
                sym: 254 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 40 as libc::c_int as uint8_t,
                flags: 0x3 as libc::c_int as uint8_t,
                sym: 254 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 1 as libc::c_int as uint8_t,
                flags: 0x2 as libc::c_int as uint8_t,
                sym: 2 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 22 as libc::c_int as uint8_t,
                flags: 0x3 as libc::c_int as uint8_t,
                sym: 2 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 1 as libc::c_int as uint8_t,
                flags: 0x2 as libc::c_int as uint8_t,
                sym: 3 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 22 as libc::c_int as uint8_t,
                flags: 0x3 as libc::c_int as uint8_t,
                sym: 3 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 1 as libc::c_int as uint8_t,
                flags: 0x2 as libc::c_int as uint8_t,
                sym: 4 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 22 as libc::c_int as uint8_t,
                flags: 0x3 as libc::c_int as uint8_t,
                sym: 4 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 1 as libc::c_int as uint8_t,
                flags: 0x2 as libc::c_int as uint8_t,
                sym: 5 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 22 as libc::c_int as uint8_t,
                flags: 0x3 as libc::c_int as uint8_t,
                sym: 5 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 1 as libc::c_int as uint8_t,
                flags: 0x2 as libc::c_int as uint8_t,
                sym: 6 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 22 as libc::c_int as uint8_t,
                flags: 0x3 as libc::c_int as uint8_t,
                sym: 6 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 1 as libc::c_int as uint8_t,
                flags: 0x2 as libc::c_int as uint8_t,
                sym: 7 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 22 as libc::c_int as uint8_t,
                flags: 0x3 as libc::c_int as uint8_t,
                sym: 7 as libc::c_int as uint8_t,
            };
            init
        },
    ],
    [
        {
            let mut init = decode_el {
                state: 3 as libc::c_int as uint8_t,
                flags: 0x2 as libc::c_int as uint8_t,
                sym: 254 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 6 as libc::c_int as uint8_t,
                flags: 0x2 as libc::c_int as uint8_t,
                sym: 254 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 10 as libc::c_int as uint8_t,
                flags: 0x2 as libc::c_int as uint8_t,
                sym: 254 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 15 as libc::c_int as uint8_t,
                flags: 0x2 as libc::c_int as uint8_t,
                sym: 254 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 24 as libc::c_int as uint8_t,
                flags: 0x2 as libc::c_int as uint8_t,
                sym: 254 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 31 as libc::c_int as uint8_t,
                flags: 0x2 as libc::c_int as uint8_t,
                sym: 254 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 41 as libc::c_int as uint8_t,
                flags: 0x2 as libc::c_int as uint8_t,
                sym: 254 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 56 as libc::c_int as uint8_t,
                flags: 0x3 as libc::c_int as uint8_t,
                sym: 254 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 2 as libc::c_int as uint8_t,
                flags: 0x2 as libc::c_int as uint8_t,
                sym: 2 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 9 as libc::c_int as uint8_t,
                flags: 0x2 as libc::c_int as uint8_t,
                sym: 2 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 23 as libc::c_int as uint8_t,
                flags: 0x2 as libc::c_int as uint8_t,
                sym: 2 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 40 as libc::c_int as uint8_t,
                flags: 0x3 as libc::c_int as uint8_t,
                sym: 2 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 2 as libc::c_int as uint8_t,
                flags: 0x2 as libc::c_int as uint8_t,
                sym: 3 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 9 as libc::c_int as uint8_t,
                flags: 0x2 as libc::c_int as uint8_t,
                sym: 3 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 23 as libc::c_int as uint8_t,
                flags: 0x2 as libc::c_int as uint8_t,
                sym: 3 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 40 as libc::c_int as uint8_t,
                flags: 0x3 as libc::c_int as uint8_t,
                sym: 3 as libc::c_int as uint8_t,
            };
            init
        },
    ],
    [
        {
            let mut init = decode_el {
                state: 3 as libc::c_int as uint8_t,
                flags: 0x2 as libc::c_int as uint8_t,
                sym: 2 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 6 as libc::c_int as uint8_t,
                flags: 0x2 as libc::c_int as uint8_t,
                sym: 2 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 10 as libc::c_int as uint8_t,
                flags: 0x2 as libc::c_int as uint8_t,
                sym: 2 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 15 as libc::c_int as uint8_t,
                flags: 0x2 as libc::c_int as uint8_t,
                sym: 2 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 24 as libc::c_int as uint8_t,
                flags: 0x2 as libc::c_int as uint8_t,
                sym: 2 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 31 as libc::c_int as uint8_t,
                flags: 0x2 as libc::c_int as uint8_t,
                sym: 2 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 41 as libc::c_int as uint8_t,
                flags: 0x2 as libc::c_int as uint8_t,
                sym: 2 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 56 as libc::c_int as uint8_t,
                flags: 0x3 as libc::c_int as uint8_t,
                sym: 2 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 3 as libc::c_int as uint8_t,
                flags: 0x2 as libc::c_int as uint8_t,
                sym: 3 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 6 as libc::c_int as uint8_t,
                flags: 0x2 as libc::c_int as uint8_t,
                sym: 3 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 10 as libc::c_int as uint8_t,
                flags: 0x2 as libc::c_int as uint8_t,
                sym: 3 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 15 as libc::c_int as uint8_t,
                flags: 0x2 as libc::c_int as uint8_t,
                sym: 3 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 24 as libc::c_int as uint8_t,
                flags: 0x2 as libc::c_int as uint8_t,
                sym: 3 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 31 as libc::c_int as uint8_t,
                flags: 0x2 as libc::c_int as uint8_t,
                sym: 3 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 41 as libc::c_int as uint8_t,
                flags: 0x2 as libc::c_int as uint8_t,
                sym: 3 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 56 as libc::c_int as uint8_t,
                flags: 0x3 as libc::c_int as uint8_t,
                sym: 3 as libc::c_int as uint8_t,
            };
            init
        },
    ],
    [
        {
            let mut init = decode_el {
                state: 2 as libc::c_int as uint8_t,
                flags: 0x2 as libc::c_int as uint8_t,
                sym: 4 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 9 as libc::c_int as uint8_t,
                flags: 0x2 as libc::c_int as uint8_t,
                sym: 4 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 23 as libc::c_int as uint8_t,
                flags: 0x2 as libc::c_int as uint8_t,
                sym: 4 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 40 as libc::c_int as uint8_t,
                flags: 0x3 as libc::c_int as uint8_t,
                sym: 4 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 2 as libc::c_int as uint8_t,
                flags: 0x2 as libc::c_int as uint8_t,
                sym: 5 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 9 as libc::c_int as uint8_t,
                flags: 0x2 as libc::c_int as uint8_t,
                sym: 5 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 23 as libc::c_int as uint8_t,
                flags: 0x2 as libc::c_int as uint8_t,
                sym: 5 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 40 as libc::c_int as uint8_t,
                flags: 0x3 as libc::c_int as uint8_t,
                sym: 5 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 2 as libc::c_int as uint8_t,
                flags: 0x2 as libc::c_int as uint8_t,
                sym: 6 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 9 as libc::c_int as uint8_t,
                flags: 0x2 as libc::c_int as uint8_t,
                sym: 6 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 23 as libc::c_int as uint8_t,
                flags: 0x2 as libc::c_int as uint8_t,
                sym: 6 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 40 as libc::c_int as uint8_t,
                flags: 0x3 as libc::c_int as uint8_t,
                sym: 6 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 2 as libc::c_int as uint8_t,
                flags: 0x2 as libc::c_int as uint8_t,
                sym: 7 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 9 as libc::c_int as uint8_t,
                flags: 0x2 as libc::c_int as uint8_t,
                sym: 7 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 23 as libc::c_int as uint8_t,
                flags: 0x2 as libc::c_int as uint8_t,
                sym: 7 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 40 as libc::c_int as uint8_t,
                flags: 0x3 as libc::c_int as uint8_t,
                sym: 7 as libc::c_int as uint8_t,
            };
            init
        },
    ],
    [
        {
            let mut init = decode_el {
                state: 3 as libc::c_int as uint8_t,
                flags: 0x2 as libc::c_int as uint8_t,
                sym: 4 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 6 as libc::c_int as uint8_t,
                flags: 0x2 as libc::c_int as uint8_t,
                sym: 4 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 10 as libc::c_int as uint8_t,
                flags: 0x2 as libc::c_int as uint8_t,
                sym: 4 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 15 as libc::c_int as uint8_t,
                flags: 0x2 as libc::c_int as uint8_t,
                sym: 4 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 24 as libc::c_int as uint8_t,
                flags: 0x2 as libc::c_int as uint8_t,
                sym: 4 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 31 as libc::c_int as uint8_t,
                flags: 0x2 as libc::c_int as uint8_t,
                sym: 4 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 41 as libc::c_int as uint8_t,
                flags: 0x2 as libc::c_int as uint8_t,
                sym: 4 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 56 as libc::c_int as uint8_t,
                flags: 0x3 as libc::c_int as uint8_t,
                sym: 4 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 3 as libc::c_int as uint8_t,
                flags: 0x2 as libc::c_int as uint8_t,
                sym: 5 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 6 as libc::c_int as uint8_t,
                flags: 0x2 as libc::c_int as uint8_t,
                sym: 5 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 10 as libc::c_int as uint8_t,
                flags: 0x2 as libc::c_int as uint8_t,
                sym: 5 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 15 as libc::c_int as uint8_t,
                flags: 0x2 as libc::c_int as uint8_t,
                sym: 5 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 24 as libc::c_int as uint8_t,
                flags: 0x2 as libc::c_int as uint8_t,
                sym: 5 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 31 as libc::c_int as uint8_t,
                flags: 0x2 as libc::c_int as uint8_t,
                sym: 5 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 41 as libc::c_int as uint8_t,
                flags: 0x2 as libc::c_int as uint8_t,
                sym: 5 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 56 as libc::c_int as uint8_t,
                flags: 0x3 as libc::c_int as uint8_t,
                sym: 5 as libc::c_int as uint8_t,
            };
            init
        },
    ],
    [
        {
            let mut init = decode_el {
                state: 3 as libc::c_int as uint8_t,
                flags: 0x2 as libc::c_int as uint8_t,
                sym: 6 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 6 as libc::c_int as uint8_t,
                flags: 0x2 as libc::c_int as uint8_t,
                sym: 6 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 10 as libc::c_int as uint8_t,
                flags: 0x2 as libc::c_int as uint8_t,
                sym: 6 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 15 as libc::c_int as uint8_t,
                flags: 0x2 as libc::c_int as uint8_t,
                sym: 6 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 24 as libc::c_int as uint8_t,
                flags: 0x2 as libc::c_int as uint8_t,
                sym: 6 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 31 as libc::c_int as uint8_t,
                flags: 0x2 as libc::c_int as uint8_t,
                sym: 6 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 41 as libc::c_int as uint8_t,
                flags: 0x2 as libc::c_int as uint8_t,
                sym: 6 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 56 as libc::c_int as uint8_t,
                flags: 0x3 as libc::c_int as uint8_t,
                sym: 6 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 3 as libc::c_int as uint8_t,
                flags: 0x2 as libc::c_int as uint8_t,
                sym: 7 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 6 as libc::c_int as uint8_t,
                flags: 0x2 as libc::c_int as uint8_t,
                sym: 7 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 10 as libc::c_int as uint8_t,
                flags: 0x2 as libc::c_int as uint8_t,
                sym: 7 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 15 as libc::c_int as uint8_t,
                flags: 0x2 as libc::c_int as uint8_t,
                sym: 7 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 24 as libc::c_int as uint8_t,
                flags: 0x2 as libc::c_int as uint8_t,
                sym: 7 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 31 as libc::c_int as uint8_t,
                flags: 0x2 as libc::c_int as uint8_t,
                sym: 7 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 41 as libc::c_int as uint8_t,
                flags: 0x2 as libc::c_int as uint8_t,
                sym: 7 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 56 as libc::c_int as uint8_t,
                flags: 0x3 as libc::c_int as uint8_t,
                sym: 7 as libc::c_int as uint8_t,
            };
            init
        },
    ],
    [
        {
            let mut init = decode_el {
                state: 1 as libc::c_int as uint8_t,
                flags: 0x2 as libc::c_int as uint8_t,
                sym: 8 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 22 as libc::c_int as uint8_t,
                flags: 0x3 as libc::c_int as uint8_t,
                sym: 8 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 1 as libc::c_int as uint8_t,
                flags: 0x2 as libc::c_int as uint8_t,
                sym: 11 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 22 as libc::c_int as uint8_t,
                flags: 0x3 as libc::c_int as uint8_t,
                sym: 11 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 1 as libc::c_int as uint8_t,
                flags: 0x2 as libc::c_int as uint8_t,
                sym: 12 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 22 as libc::c_int as uint8_t,
                flags: 0x3 as libc::c_int as uint8_t,
                sym: 12 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 1 as libc::c_int as uint8_t,
                flags: 0x2 as libc::c_int as uint8_t,
                sym: 14 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 22 as libc::c_int as uint8_t,
                flags: 0x3 as libc::c_int as uint8_t,
                sym: 14 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 1 as libc::c_int as uint8_t,
                flags: 0x2 as libc::c_int as uint8_t,
                sym: 15 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 22 as libc::c_int as uint8_t,
                flags: 0x3 as libc::c_int as uint8_t,
                sym: 15 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 1 as libc::c_int as uint8_t,
                flags: 0x2 as libc::c_int as uint8_t,
                sym: 16 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 22 as libc::c_int as uint8_t,
                flags: 0x3 as libc::c_int as uint8_t,
                sym: 16 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 1 as libc::c_int as uint8_t,
                flags: 0x2 as libc::c_int as uint8_t,
                sym: 17 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 22 as libc::c_int as uint8_t,
                flags: 0x3 as libc::c_int as uint8_t,
                sym: 17 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 1 as libc::c_int as uint8_t,
                flags: 0x2 as libc::c_int as uint8_t,
                sym: 18 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 22 as libc::c_int as uint8_t,
                flags: 0x3 as libc::c_int as uint8_t,
                sym: 18 as libc::c_int as uint8_t,
            };
            init
        },
    ],
    [
        {
            let mut init = decode_el {
                state: 2 as libc::c_int as uint8_t,
                flags: 0x2 as libc::c_int as uint8_t,
                sym: 8 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 9 as libc::c_int as uint8_t,
                flags: 0x2 as libc::c_int as uint8_t,
                sym: 8 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 23 as libc::c_int as uint8_t,
                flags: 0x2 as libc::c_int as uint8_t,
                sym: 8 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 40 as libc::c_int as uint8_t,
                flags: 0x3 as libc::c_int as uint8_t,
                sym: 8 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 2 as libc::c_int as uint8_t,
                flags: 0x2 as libc::c_int as uint8_t,
                sym: 11 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 9 as libc::c_int as uint8_t,
                flags: 0x2 as libc::c_int as uint8_t,
                sym: 11 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 23 as libc::c_int as uint8_t,
                flags: 0x2 as libc::c_int as uint8_t,
                sym: 11 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 40 as libc::c_int as uint8_t,
                flags: 0x3 as libc::c_int as uint8_t,
                sym: 11 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 2 as libc::c_int as uint8_t,
                flags: 0x2 as libc::c_int as uint8_t,
                sym: 12 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 9 as libc::c_int as uint8_t,
                flags: 0x2 as libc::c_int as uint8_t,
                sym: 12 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 23 as libc::c_int as uint8_t,
                flags: 0x2 as libc::c_int as uint8_t,
                sym: 12 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 40 as libc::c_int as uint8_t,
                flags: 0x3 as libc::c_int as uint8_t,
                sym: 12 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 2 as libc::c_int as uint8_t,
                flags: 0x2 as libc::c_int as uint8_t,
                sym: 14 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 9 as libc::c_int as uint8_t,
                flags: 0x2 as libc::c_int as uint8_t,
                sym: 14 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 23 as libc::c_int as uint8_t,
                flags: 0x2 as libc::c_int as uint8_t,
                sym: 14 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 40 as libc::c_int as uint8_t,
                flags: 0x3 as libc::c_int as uint8_t,
                sym: 14 as libc::c_int as uint8_t,
            };
            init
        },
    ],
    [
        {
            let mut init = decode_el {
                state: 3 as libc::c_int as uint8_t,
                flags: 0x2 as libc::c_int as uint8_t,
                sym: 8 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 6 as libc::c_int as uint8_t,
                flags: 0x2 as libc::c_int as uint8_t,
                sym: 8 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 10 as libc::c_int as uint8_t,
                flags: 0x2 as libc::c_int as uint8_t,
                sym: 8 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 15 as libc::c_int as uint8_t,
                flags: 0x2 as libc::c_int as uint8_t,
                sym: 8 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 24 as libc::c_int as uint8_t,
                flags: 0x2 as libc::c_int as uint8_t,
                sym: 8 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 31 as libc::c_int as uint8_t,
                flags: 0x2 as libc::c_int as uint8_t,
                sym: 8 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 41 as libc::c_int as uint8_t,
                flags: 0x2 as libc::c_int as uint8_t,
                sym: 8 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 56 as libc::c_int as uint8_t,
                flags: 0x3 as libc::c_int as uint8_t,
                sym: 8 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 3 as libc::c_int as uint8_t,
                flags: 0x2 as libc::c_int as uint8_t,
                sym: 11 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 6 as libc::c_int as uint8_t,
                flags: 0x2 as libc::c_int as uint8_t,
                sym: 11 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 10 as libc::c_int as uint8_t,
                flags: 0x2 as libc::c_int as uint8_t,
                sym: 11 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 15 as libc::c_int as uint8_t,
                flags: 0x2 as libc::c_int as uint8_t,
                sym: 11 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 24 as libc::c_int as uint8_t,
                flags: 0x2 as libc::c_int as uint8_t,
                sym: 11 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 31 as libc::c_int as uint8_t,
                flags: 0x2 as libc::c_int as uint8_t,
                sym: 11 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 41 as libc::c_int as uint8_t,
                flags: 0x2 as libc::c_int as uint8_t,
                sym: 11 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 56 as libc::c_int as uint8_t,
                flags: 0x3 as libc::c_int as uint8_t,
                sym: 11 as libc::c_int as uint8_t,
            };
            init
        },
    ],
    [
        {
            let mut init = decode_el {
                state: 3 as libc::c_int as uint8_t,
                flags: 0x2 as libc::c_int as uint8_t,
                sym: 12 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 6 as libc::c_int as uint8_t,
                flags: 0x2 as libc::c_int as uint8_t,
                sym: 12 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 10 as libc::c_int as uint8_t,
                flags: 0x2 as libc::c_int as uint8_t,
                sym: 12 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 15 as libc::c_int as uint8_t,
                flags: 0x2 as libc::c_int as uint8_t,
                sym: 12 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 24 as libc::c_int as uint8_t,
                flags: 0x2 as libc::c_int as uint8_t,
                sym: 12 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 31 as libc::c_int as uint8_t,
                flags: 0x2 as libc::c_int as uint8_t,
                sym: 12 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 41 as libc::c_int as uint8_t,
                flags: 0x2 as libc::c_int as uint8_t,
                sym: 12 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 56 as libc::c_int as uint8_t,
                flags: 0x3 as libc::c_int as uint8_t,
                sym: 12 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 3 as libc::c_int as uint8_t,
                flags: 0x2 as libc::c_int as uint8_t,
                sym: 14 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 6 as libc::c_int as uint8_t,
                flags: 0x2 as libc::c_int as uint8_t,
                sym: 14 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 10 as libc::c_int as uint8_t,
                flags: 0x2 as libc::c_int as uint8_t,
                sym: 14 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 15 as libc::c_int as uint8_t,
                flags: 0x2 as libc::c_int as uint8_t,
                sym: 14 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 24 as libc::c_int as uint8_t,
                flags: 0x2 as libc::c_int as uint8_t,
                sym: 14 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 31 as libc::c_int as uint8_t,
                flags: 0x2 as libc::c_int as uint8_t,
                sym: 14 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 41 as libc::c_int as uint8_t,
                flags: 0x2 as libc::c_int as uint8_t,
                sym: 14 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 56 as libc::c_int as uint8_t,
                flags: 0x3 as libc::c_int as uint8_t,
                sym: 14 as libc::c_int as uint8_t,
            };
            init
        },
    ],
    [
        {
            let mut init = decode_el {
                state: 2 as libc::c_int as uint8_t,
                flags: 0x2 as libc::c_int as uint8_t,
                sym: 15 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 9 as libc::c_int as uint8_t,
                flags: 0x2 as libc::c_int as uint8_t,
                sym: 15 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 23 as libc::c_int as uint8_t,
                flags: 0x2 as libc::c_int as uint8_t,
                sym: 15 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 40 as libc::c_int as uint8_t,
                flags: 0x3 as libc::c_int as uint8_t,
                sym: 15 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 2 as libc::c_int as uint8_t,
                flags: 0x2 as libc::c_int as uint8_t,
                sym: 16 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 9 as libc::c_int as uint8_t,
                flags: 0x2 as libc::c_int as uint8_t,
                sym: 16 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 23 as libc::c_int as uint8_t,
                flags: 0x2 as libc::c_int as uint8_t,
                sym: 16 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 40 as libc::c_int as uint8_t,
                flags: 0x3 as libc::c_int as uint8_t,
                sym: 16 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 2 as libc::c_int as uint8_t,
                flags: 0x2 as libc::c_int as uint8_t,
                sym: 17 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 9 as libc::c_int as uint8_t,
                flags: 0x2 as libc::c_int as uint8_t,
                sym: 17 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 23 as libc::c_int as uint8_t,
                flags: 0x2 as libc::c_int as uint8_t,
                sym: 17 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 40 as libc::c_int as uint8_t,
                flags: 0x3 as libc::c_int as uint8_t,
                sym: 17 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 2 as libc::c_int as uint8_t,
                flags: 0x2 as libc::c_int as uint8_t,
                sym: 18 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 9 as libc::c_int as uint8_t,
                flags: 0x2 as libc::c_int as uint8_t,
                sym: 18 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 23 as libc::c_int as uint8_t,
                flags: 0x2 as libc::c_int as uint8_t,
                sym: 18 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 40 as libc::c_int as uint8_t,
                flags: 0x3 as libc::c_int as uint8_t,
                sym: 18 as libc::c_int as uint8_t,
            };
            init
        },
    ],
    [
        {
            let mut init = decode_el {
                state: 3 as libc::c_int as uint8_t,
                flags: 0x2 as libc::c_int as uint8_t,
                sym: 15 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 6 as libc::c_int as uint8_t,
                flags: 0x2 as libc::c_int as uint8_t,
                sym: 15 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 10 as libc::c_int as uint8_t,
                flags: 0x2 as libc::c_int as uint8_t,
                sym: 15 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 15 as libc::c_int as uint8_t,
                flags: 0x2 as libc::c_int as uint8_t,
                sym: 15 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 24 as libc::c_int as uint8_t,
                flags: 0x2 as libc::c_int as uint8_t,
                sym: 15 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 31 as libc::c_int as uint8_t,
                flags: 0x2 as libc::c_int as uint8_t,
                sym: 15 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 41 as libc::c_int as uint8_t,
                flags: 0x2 as libc::c_int as uint8_t,
                sym: 15 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 56 as libc::c_int as uint8_t,
                flags: 0x3 as libc::c_int as uint8_t,
                sym: 15 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 3 as libc::c_int as uint8_t,
                flags: 0x2 as libc::c_int as uint8_t,
                sym: 16 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 6 as libc::c_int as uint8_t,
                flags: 0x2 as libc::c_int as uint8_t,
                sym: 16 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 10 as libc::c_int as uint8_t,
                flags: 0x2 as libc::c_int as uint8_t,
                sym: 16 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 15 as libc::c_int as uint8_t,
                flags: 0x2 as libc::c_int as uint8_t,
                sym: 16 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 24 as libc::c_int as uint8_t,
                flags: 0x2 as libc::c_int as uint8_t,
                sym: 16 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 31 as libc::c_int as uint8_t,
                flags: 0x2 as libc::c_int as uint8_t,
                sym: 16 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 41 as libc::c_int as uint8_t,
                flags: 0x2 as libc::c_int as uint8_t,
                sym: 16 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 56 as libc::c_int as uint8_t,
                flags: 0x3 as libc::c_int as uint8_t,
                sym: 16 as libc::c_int as uint8_t,
            };
            init
        },
    ],
    [
        {
            let mut init = decode_el {
                state: 3 as libc::c_int as uint8_t,
                flags: 0x2 as libc::c_int as uint8_t,
                sym: 17 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 6 as libc::c_int as uint8_t,
                flags: 0x2 as libc::c_int as uint8_t,
                sym: 17 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 10 as libc::c_int as uint8_t,
                flags: 0x2 as libc::c_int as uint8_t,
                sym: 17 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 15 as libc::c_int as uint8_t,
                flags: 0x2 as libc::c_int as uint8_t,
                sym: 17 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 24 as libc::c_int as uint8_t,
                flags: 0x2 as libc::c_int as uint8_t,
                sym: 17 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 31 as libc::c_int as uint8_t,
                flags: 0x2 as libc::c_int as uint8_t,
                sym: 17 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 41 as libc::c_int as uint8_t,
                flags: 0x2 as libc::c_int as uint8_t,
                sym: 17 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 56 as libc::c_int as uint8_t,
                flags: 0x3 as libc::c_int as uint8_t,
                sym: 17 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 3 as libc::c_int as uint8_t,
                flags: 0x2 as libc::c_int as uint8_t,
                sym: 18 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 6 as libc::c_int as uint8_t,
                flags: 0x2 as libc::c_int as uint8_t,
                sym: 18 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 10 as libc::c_int as uint8_t,
                flags: 0x2 as libc::c_int as uint8_t,
                sym: 18 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 15 as libc::c_int as uint8_t,
                flags: 0x2 as libc::c_int as uint8_t,
                sym: 18 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 24 as libc::c_int as uint8_t,
                flags: 0x2 as libc::c_int as uint8_t,
                sym: 18 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 31 as libc::c_int as uint8_t,
                flags: 0x2 as libc::c_int as uint8_t,
                sym: 18 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 41 as libc::c_int as uint8_t,
                flags: 0x2 as libc::c_int as uint8_t,
                sym: 18 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 56 as libc::c_int as uint8_t,
                flags: 0x3 as libc::c_int as uint8_t,
                sym: 18 as libc::c_int as uint8_t,
            };
            init
        },
    ],
    [
        {
            let mut init = decode_el {
                state: 0 as libc::c_int as uint8_t,
                flags: 0x3 as libc::c_int as uint8_t,
                sym: 19 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 0 as libc::c_int as uint8_t,
                flags: 0x3 as libc::c_int as uint8_t,
                sym: 20 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 0 as libc::c_int as uint8_t,
                flags: 0x3 as libc::c_int as uint8_t,
                sym: 21 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 0 as libc::c_int as uint8_t,
                flags: 0x3 as libc::c_int as uint8_t,
                sym: 23 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 0 as libc::c_int as uint8_t,
                flags: 0x3 as libc::c_int as uint8_t,
                sym: 24 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 0 as libc::c_int as uint8_t,
                flags: 0x3 as libc::c_int as uint8_t,
                sym: 25 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 0 as libc::c_int as uint8_t,
                flags: 0x3 as libc::c_int as uint8_t,
                sym: 26 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 0 as libc::c_int as uint8_t,
                flags: 0x3 as libc::c_int as uint8_t,
                sym: 27 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 0 as libc::c_int as uint8_t,
                flags: 0x3 as libc::c_int as uint8_t,
                sym: 28 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 0 as libc::c_int as uint8_t,
                flags: 0x3 as libc::c_int as uint8_t,
                sym: 29 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 0 as libc::c_int as uint8_t,
                flags: 0x3 as libc::c_int as uint8_t,
                sym: 30 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 0 as libc::c_int as uint8_t,
                flags: 0x3 as libc::c_int as uint8_t,
                sym: 31 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 0 as libc::c_int as uint8_t,
                flags: 0x3 as libc::c_int as uint8_t,
                sym: 127 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 0 as libc::c_int as uint8_t,
                flags: 0x3 as libc::c_int as uint8_t,
                sym: 220 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 0 as libc::c_int as uint8_t,
                flags: 0x3 as libc::c_int as uint8_t,
                sym: 249 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 253 as libc::c_int as uint8_t,
                flags: 0 as libc::c_int as uint8_t,
                sym: 0 as libc::c_int as uint8_t,
            };
            init
        },
    ],
    [
        {
            let mut init = decode_el {
                state: 1 as libc::c_int as uint8_t,
                flags: 0x2 as libc::c_int as uint8_t,
                sym: 19 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 22 as libc::c_int as uint8_t,
                flags: 0x3 as libc::c_int as uint8_t,
                sym: 19 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 1 as libc::c_int as uint8_t,
                flags: 0x2 as libc::c_int as uint8_t,
                sym: 20 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 22 as libc::c_int as uint8_t,
                flags: 0x3 as libc::c_int as uint8_t,
                sym: 20 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 1 as libc::c_int as uint8_t,
                flags: 0x2 as libc::c_int as uint8_t,
                sym: 21 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 22 as libc::c_int as uint8_t,
                flags: 0x3 as libc::c_int as uint8_t,
                sym: 21 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 1 as libc::c_int as uint8_t,
                flags: 0x2 as libc::c_int as uint8_t,
                sym: 23 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 22 as libc::c_int as uint8_t,
                flags: 0x3 as libc::c_int as uint8_t,
                sym: 23 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 1 as libc::c_int as uint8_t,
                flags: 0x2 as libc::c_int as uint8_t,
                sym: 24 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 22 as libc::c_int as uint8_t,
                flags: 0x3 as libc::c_int as uint8_t,
                sym: 24 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 1 as libc::c_int as uint8_t,
                flags: 0x2 as libc::c_int as uint8_t,
                sym: 25 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 22 as libc::c_int as uint8_t,
                flags: 0x3 as libc::c_int as uint8_t,
                sym: 25 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 1 as libc::c_int as uint8_t,
                flags: 0x2 as libc::c_int as uint8_t,
                sym: 26 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 22 as libc::c_int as uint8_t,
                flags: 0x3 as libc::c_int as uint8_t,
                sym: 26 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 1 as libc::c_int as uint8_t,
                flags: 0x2 as libc::c_int as uint8_t,
                sym: 27 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 22 as libc::c_int as uint8_t,
                flags: 0x3 as libc::c_int as uint8_t,
                sym: 27 as libc::c_int as uint8_t,
            };
            init
        },
    ],
    [
        {
            let mut init = decode_el {
                state: 2 as libc::c_int as uint8_t,
                flags: 0x2 as libc::c_int as uint8_t,
                sym: 19 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 9 as libc::c_int as uint8_t,
                flags: 0x2 as libc::c_int as uint8_t,
                sym: 19 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 23 as libc::c_int as uint8_t,
                flags: 0x2 as libc::c_int as uint8_t,
                sym: 19 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 40 as libc::c_int as uint8_t,
                flags: 0x3 as libc::c_int as uint8_t,
                sym: 19 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 2 as libc::c_int as uint8_t,
                flags: 0x2 as libc::c_int as uint8_t,
                sym: 20 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 9 as libc::c_int as uint8_t,
                flags: 0x2 as libc::c_int as uint8_t,
                sym: 20 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 23 as libc::c_int as uint8_t,
                flags: 0x2 as libc::c_int as uint8_t,
                sym: 20 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 40 as libc::c_int as uint8_t,
                flags: 0x3 as libc::c_int as uint8_t,
                sym: 20 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 2 as libc::c_int as uint8_t,
                flags: 0x2 as libc::c_int as uint8_t,
                sym: 21 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 9 as libc::c_int as uint8_t,
                flags: 0x2 as libc::c_int as uint8_t,
                sym: 21 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 23 as libc::c_int as uint8_t,
                flags: 0x2 as libc::c_int as uint8_t,
                sym: 21 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 40 as libc::c_int as uint8_t,
                flags: 0x3 as libc::c_int as uint8_t,
                sym: 21 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 2 as libc::c_int as uint8_t,
                flags: 0x2 as libc::c_int as uint8_t,
                sym: 23 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 9 as libc::c_int as uint8_t,
                flags: 0x2 as libc::c_int as uint8_t,
                sym: 23 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 23 as libc::c_int as uint8_t,
                flags: 0x2 as libc::c_int as uint8_t,
                sym: 23 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 40 as libc::c_int as uint8_t,
                flags: 0x3 as libc::c_int as uint8_t,
                sym: 23 as libc::c_int as uint8_t,
            };
            init
        },
    ],
    [
        {
            let mut init = decode_el {
                state: 3 as libc::c_int as uint8_t,
                flags: 0x2 as libc::c_int as uint8_t,
                sym: 19 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 6 as libc::c_int as uint8_t,
                flags: 0x2 as libc::c_int as uint8_t,
                sym: 19 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 10 as libc::c_int as uint8_t,
                flags: 0x2 as libc::c_int as uint8_t,
                sym: 19 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 15 as libc::c_int as uint8_t,
                flags: 0x2 as libc::c_int as uint8_t,
                sym: 19 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 24 as libc::c_int as uint8_t,
                flags: 0x2 as libc::c_int as uint8_t,
                sym: 19 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 31 as libc::c_int as uint8_t,
                flags: 0x2 as libc::c_int as uint8_t,
                sym: 19 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 41 as libc::c_int as uint8_t,
                flags: 0x2 as libc::c_int as uint8_t,
                sym: 19 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 56 as libc::c_int as uint8_t,
                flags: 0x3 as libc::c_int as uint8_t,
                sym: 19 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 3 as libc::c_int as uint8_t,
                flags: 0x2 as libc::c_int as uint8_t,
                sym: 20 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 6 as libc::c_int as uint8_t,
                flags: 0x2 as libc::c_int as uint8_t,
                sym: 20 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 10 as libc::c_int as uint8_t,
                flags: 0x2 as libc::c_int as uint8_t,
                sym: 20 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 15 as libc::c_int as uint8_t,
                flags: 0x2 as libc::c_int as uint8_t,
                sym: 20 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 24 as libc::c_int as uint8_t,
                flags: 0x2 as libc::c_int as uint8_t,
                sym: 20 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 31 as libc::c_int as uint8_t,
                flags: 0x2 as libc::c_int as uint8_t,
                sym: 20 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 41 as libc::c_int as uint8_t,
                flags: 0x2 as libc::c_int as uint8_t,
                sym: 20 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 56 as libc::c_int as uint8_t,
                flags: 0x3 as libc::c_int as uint8_t,
                sym: 20 as libc::c_int as uint8_t,
            };
            init
        },
    ],
    [
        {
            let mut init = decode_el {
                state: 3 as libc::c_int as uint8_t,
                flags: 0x2 as libc::c_int as uint8_t,
                sym: 21 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 6 as libc::c_int as uint8_t,
                flags: 0x2 as libc::c_int as uint8_t,
                sym: 21 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 10 as libc::c_int as uint8_t,
                flags: 0x2 as libc::c_int as uint8_t,
                sym: 21 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 15 as libc::c_int as uint8_t,
                flags: 0x2 as libc::c_int as uint8_t,
                sym: 21 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 24 as libc::c_int as uint8_t,
                flags: 0x2 as libc::c_int as uint8_t,
                sym: 21 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 31 as libc::c_int as uint8_t,
                flags: 0x2 as libc::c_int as uint8_t,
                sym: 21 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 41 as libc::c_int as uint8_t,
                flags: 0x2 as libc::c_int as uint8_t,
                sym: 21 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 56 as libc::c_int as uint8_t,
                flags: 0x3 as libc::c_int as uint8_t,
                sym: 21 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 3 as libc::c_int as uint8_t,
                flags: 0x2 as libc::c_int as uint8_t,
                sym: 23 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 6 as libc::c_int as uint8_t,
                flags: 0x2 as libc::c_int as uint8_t,
                sym: 23 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 10 as libc::c_int as uint8_t,
                flags: 0x2 as libc::c_int as uint8_t,
                sym: 23 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 15 as libc::c_int as uint8_t,
                flags: 0x2 as libc::c_int as uint8_t,
                sym: 23 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 24 as libc::c_int as uint8_t,
                flags: 0x2 as libc::c_int as uint8_t,
                sym: 23 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 31 as libc::c_int as uint8_t,
                flags: 0x2 as libc::c_int as uint8_t,
                sym: 23 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 41 as libc::c_int as uint8_t,
                flags: 0x2 as libc::c_int as uint8_t,
                sym: 23 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 56 as libc::c_int as uint8_t,
                flags: 0x3 as libc::c_int as uint8_t,
                sym: 23 as libc::c_int as uint8_t,
            };
            init
        },
    ],
    [
        {
            let mut init = decode_el {
                state: 2 as libc::c_int as uint8_t,
                flags: 0x2 as libc::c_int as uint8_t,
                sym: 24 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 9 as libc::c_int as uint8_t,
                flags: 0x2 as libc::c_int as uint8_t,
                sym: 24 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 23 as libc::c_int as uint8_t,
                flags: 0x2 as libc::c_int as uint8_t,
                sym: 24 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 40 as libc::c_int as uint8_t,
                flags: 0x3 as libc::c_int as uint8_t,
                sym: 24 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 2 as libc::c_int as uint8_t,
                flags: 0x2 as libc::c_int as uint8_t,
                sym: 25 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 9 as libc::c_int as uint8_t,
                flags: 0x2 as libc::c_int as uint8_t,
                sym: 25 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 23 as libc::c_int as uint8_t,
                flags: 0x2 as libc::c_int as uint8_t,
                sym: 25 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 40 as libc::c_int as uint8_t,
                flags: 0x3 as libc::c_int as uint8_t,
                sym: 25 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 2 as libc::c_int as uint8_t,
                flags: 0x2 as libc::c_int as uint8_t,
                sym: 26 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 9 as libc::c_int as uint8_t,
                flags: 0x2 as libc::c_int as uint8_t,
                sym: 26 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 23 as libc::c_int as uint8_t,
                flags: 0x2 as libc::c_int as uint8_t,
                sym: 26 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 40 as libc::c_int as uint8_t,
                flags: 0x3 as libc::c_int as uint8_t,
                sym: 26 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 2 as libc::c_int as uint8_t,
                flags: 0x2 as libc::c_int as uint8_t,
                sym: 27 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 9 as libc::c_int as uint8_t,
                flags: 0x2 as libc::c_int as uint8_t,
                sym: 27 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 23 as libc::c_int as uint8_t,
                flags: 0x2 as libc::c_int as uint8_t,
                sym: 27 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 40 as libc::c_int as uint8_t,
                flags: 0x3 as libc::c_int as uint8_t,
                sym: 27 as libc::c_int as uint8_t,
            };
            init
        },
    ],
    [
        {
            let mut init = decode_el {
                state: 3 as libc::c_int as uint8_t,
                flags: 0x2 as libc::c_int as uint8_t,
                sym: 24 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 6 as libc::c_int as uint8_t,
                flags: 0x2 as libc::c_int as uint8_t,
                sym: 24 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 10 as libc::c_int as uint8_t,
                flags: 0x2 as libc::c_int as uint8_t,
                sym: 24 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 15 as libc::c_int as uint8_t,
                flags: 0x2 as libc::c_int as uint8_t,
                sym: 24 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 24 as libc::c_int as uint8_t,
                flags: 0x2 as libc::c_int as uint8_t,
                sym: 24 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 31 as libc::c_int as uint8_t,
                flags: 0x2 as libc::c_int as uint8_t,
                sym: 24 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 41 as libc::c_int as uint8_t,
                flags: 0x2 as libc::c_int as uint8_t,
                sym: 24 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 56 as libc::c_int as uint8_t,
                flags: 0x3 as libc::c_int as uint8_t,
                sym: 24 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 3 as libc::c_int as uint8_t,
                flags: 0x2 as libc::c_int as uint8_t,
                sym: 25 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 6 as libc::c_int as uint8_t,
                flags: 0x2 as libc::c_int as uint8_t,
                sym: 25 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 10 as libc::c_int as uint8_t,
                flags: 0x2 as libc::c_int as uint8_t,
                sym: 25 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 15 as libc::c_int as uint8_t,
                flags: 0x2 as libc::c_int as uint8_t,
                sym: 25 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 24 as libc::c_int as uint8_t,
                flags: 0x2 as libc::c_int as uint8_t,
                sym: 25 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 31 as libc::c_int as uint8_t,
                flags: 0x2 as libc::c_int as uint8_t,
                sym: 25 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 41 as libc::c_int as uint8_t,
                flags: 0x2 as libc::c_int as uint8_t,
                sym: 25 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 56 as libc::c_int as uint8_t,
                flags: 0x3 as libc::c_int as uint8_t,
                sym: 25 as libc::c_int as uint8_t,
            };
            init
        },
    ],
    [
        {
            let mut init = decode_el {
                state: 3 as libc::c_int as uint8_t,
                flags: 0x2 as libc::c_int as uint8_t,
                sym: 26 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 6 as libc::c_int as uint8_t,
                flags: 0x2 as libc::c_int as uint8_t,
                sym: 26 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 10 as libc::c_int as uint8_t,
                flags: 0x2 as libc::c_int as uint8_t,
                sym: 26 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 15 as libc::c_int as uint8_t,
                flags: 0x2 as libc::c_int as uint8_t,
                sym: 26 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 24 as libc::c_int as uint8_t,
                flags: 0x2 as libc::c_int as uint8_t,
                sym: 26 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 31 as libc::c_int as uint8_t,
                flags: 0x2 as libc::c_int as uint8_t,
                sym: 26 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 41 as libc::c_int as uint8_t,
                flags: 0x2 as libc::c_int as uint8_t,
                sym: 26 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 56 as libc::c_int as uint8_t,
                flags: 0x3 as libc::c_int as uint8_t,
                sym: 26 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 3 as libc::c_int as uint8_t,
                flags: 0x2 as libc::c_int as uint8_t,
                sym: 27 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 6 as libc::c_int as uint8_t,
                flags: 0x2 as libc::c_int as uint8_t,
                sym: 27 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 10 as libc::c_int as uint8_t,
                flags: 0x2 as libc::c_int as uint8_t,
                sym: 27 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 15 as libc::c_int as uint8_t,
                flags: 0x2 as libc::c_int as uint8_t,
                sym: 27 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 24 as libc::c_int as uint8_t,
                flags: 0x2 as libc::c_int as uint8_t,
                sym: 27 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 31 as libc::c_int as uint8_t,
                flags: 0x2 as libc::c_int as uint8_t,
                sym: 27 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 41 as libc::c_int as uint8_t,
                flags: 0x2 as libc::c_int as uint8_t,
                sym: 27 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 56 as libc::c_int as uint8_t,
                flags: 0x3 as libc::c_int as uint8_t,
                sym: 27 as libc::c_int as uint8_t,
            };
            init
        },
    ],
    [
        {
            let mut init = decode_el {
                state: 1 as libc::c_int as uint8_t,
                flags: 0x2 as libc::c_int as uint8_t,
                sym: 28 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 22 as libc::c_int as uint8_t,
                flags: 0x3 as libc::c_int as uint8_t,
                sym: 28 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 1 as libc::c_int as uint8_t,
                flags: 0x2 as libc::c_int as uint8_t,
                sym: 29 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 22 as libc::c_int as uint8_t,
                flags: 0x3 as libc::c_int as uint8_t,
                sym: 29 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 1 as libc::c_int as uint8_t,
                flags: 0x2 as libc::c_int as uint8_t,
                sym: 30 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 22 as libc::c_int as uint8_t,
                flags: 0x3 as libc::c_int as uint8_t,
                sym: 30 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 1 as libc::c_int as uint8_t,
                flags: 0x2 as libc::c_int as uint8_t,
                sym: 31 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 22 as libc::c_int as uint8_t,
                flags: 0x3 as libc::c_int as uint8_t,
                sym: 31 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 1 as libc::c_int as uint8_t,
                flags: 0x2 as libc::c_int as uint8_t,
                sym: 127 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 22 as libc::c_int as uint8_t,
                flags: 0x3 as libc::c_int as uint8_t,
                sym: 127 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 1 as libc::c_int as uint8_t,
                flags: 0x2 as libc::c_int as uint8_t,
                sym: 220 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 22 as libc::c_int as uint8_t,
                flags: 0x3 as libc::c_int as uint8_t,
                sym: 220 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 1 as libc::c_int as uint8_t,
                flags: 0x2 as libc::c_int as uint8_t,
                sym: 249 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 22 as libc::c_int as uint8_t,
                flags: 0x3 as libc::c_int as uint8_t,
                sym: 249 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 254 as libc::c_int as uint8_t,
                flags: 0 as libc::c_int as uint8_t,
                sym: 0 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 255 as libc::c_int as uint8_t,
                flags: 0 as libc::c_int as uint8_t,
                sym: 0 as libc::c_int as uint8_t,
            };
            init
        },
    ],
    [
        {
            let mut init = decode_el {
                state: 2 as libc::c_int as uint8_t,
                flags: 0x2 as libc::c_int as uint8_t,
                sym: 28 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 9 as libc::c_int as uint8_t,
                flags: 0x2 as libc::c_int as uint8_t,
                sym: 28 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 23 as libc::c_int as uint8_t,
                flags: 0x2 as libc::c_int as uint8_t,
                sym: 28 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 40 as libc::c_int as uint8_t,
                flags: 0x3 as libc::c_int as uint8_t,
                sym: 28 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 2 as libc::c_int as uint8_t,
                flags: 0x2 as libc::c_int as uint8_t,
                sym: 29 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 9 as libc::c_int as uint8_t,
                flags: 0x2 as libc::c_int as uint8_t,
                sym: 29 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 23 as libc::c_int as uint8_t,
                flags: 0x2 as libc::c_int as uint8_t,
                sym: 29 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 40 as libc::c_int as uint8_t,
                flags: 0x3 as libc::c_int as uint8_t,
                sym: 29 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 2 as libc::c_int as uint8_t,
                flags: 0x2 as libc::c_int as uint8_t,
                sym: 30 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 9 as libc::c_int as uint8_t,
                flags: 0x2 as libc::c_int as uint8_t,
                sym: 30 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 23 as libc::c_int as uint8_t,
                flags: 0x2 as libc::c_int as uint8_t,
                sym: 30 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 40 as libc::c_int as uint8_t,
                flags: 0x3 as libc::c_int as uint8_t,
                sym: 30 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 2 as libc::c_int as uint8_t,
                flags: 0x2 as libc::c_int as uint8_t,
                sym: 31 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 9 as libc::c_int as uint8_t,
                flags: 0x2 as libc::c_int as uint8_t,
                sym: 31 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 23 as libc::c_int as uint8_t,
                flags: 0x2 as libc::c_int as uint8_t,
                sym: 31 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 40 as libc::c_int as uint8_t,
                flags: 0x3 as libc::c_int as uint8_t,
                sym: 31 as libc::c_int as uint8_t,
            };
            init
        },
    ],
    [
        {
            let mut init = decode_el {
                state: 3 as libc::c_int as uint8_t,
                flags: 0x2 as libc::c_int as uint8_t,
                sym: 28 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 6 as libc::c_int as uint8_t,
                flags: 0x2 as libc::c_int as uint8_t,
                sym: 28 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 10 as libc::c_int as uint8_t,
                flags: 0x2 as libc::c_int as uint8_t,
                sym: 28 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 15 as libc::c_int as uint8_t,
                flags: 0x2 as libc::c_int as uint8_t,
                sym: 28 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 24 as libc::c_int as uint8_t,
                flags: 0x2 as libc::c_int as uint8_t,
                sym: 28 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 31 as libc::c_int as uint8_t,
                flags: 0x2 as libc::c_int as uint8_t,
                sym: 28 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 41 as libc::c_int as uint8_t,
                flags: 0x2 as libc::c_int as uint8_t,
                sym: 28 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 56 as libc::c_int as uint8_t,
                flags: 0x3 as libc::c_int as uint8_t,
                sym: 28 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 3 as libc::c_int as uint8_t,
                flags: 0x2 as libc::c_int as uint8_t,
                sym: 29 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 6 as libc::c_int as uint8_t,
                flags: 0x2 as libc::c_int as uint8_t,
                sym: 29 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 10 as libc::c_int as uint8_t,
                flags: 0x2 as libc::c_int as uint8_t,
                sym: 29 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 15 as libc::c_int as uint8_t,
                flags: 0x2 as libc::c_int as uint8_t,
                sym: 29 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 24 as libc::c_int as uint8_t,
                flags: 0x2 as libc::c_int as uint8_t,
                sym: 29 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 31 as libc::c_int as uint8_t,
                flags: 0x2 as libc::c_int as uint8_t,
                sym: 29 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 41 as libc::c_int as uint8_t,
                flags: 0x2 as libc::c_int as uint8_t,
                sym: 29 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 56 as libc::c_int as uint8_t,
                flags: 0x3 as libc::c_int as uint8_t,
                sym: 29 as libc::c_int as uint8_t,
            };
            init
        },
    ],
    [
        {
            let mut init = decode_el {
                state: 3 as libc::c_int as uint8_t,
                flags: 0x2 as libc::c_int as uint8_t,
                sym: 30 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 6 as libc::c_int as uint8_t,
                flags: 0x2 as libc::c_int as uint8_t,
                sym: 30 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 10 as libc::c_int as uint8_t,
                flags: 0x2 as libc::c_int as uint8_t,
                sym: 30 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 15 as libc::c_int as uint8_t,
                flags: 0x2 as libc::c_int as uint8_t,
                sym: 30 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 24 as libc::c_int as uint8_t,
                flags: 0x2 as libc::c_int as uint8_t,
                sym: 30 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 31 as libc::c_int as uint8_t,
                flags: 0x2 as libc::c_int as uint8_t,
                sym: 30 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 41 as libc::c_int as uint8_t,
                flags: 0x2 as libc::c_int as uint8_t,
                sym: 30 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 56 as libc::c_int as uint8_t,
                flags: 0x3 as libc::c_int as uint8_t,
                sym: 30 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 3 as libc::c_int as uint8_t,
                flags: 0x2 as libc::c_int as uint8_t,
                sym: 31 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 6 as libc::c_int as uint8_t,
                flags: 0x2 as libc::c_int as uint8_t,
                sym: 31 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 10 as libc::c_int as uint8_t,
                flags: 0x2 as libc::c_int as uint8_t,
                sym: 31 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 15 as libc::c_int as uint8_t,
                flags: 0x2 as libc::c_int as uint8_t,
                sym: 31 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 24 as libc::c_int as uint8_t,
                flags: 0x2 as libc::c_int as uint8_t,
                sym: 31 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 31 as libc::c_int as uint8_t,
                flags: 0x2 as libc::c_int as uint8_t,
                sym: 31 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 41 as libc::c_int as uint8_t,
                flags: 0x2 as libc::c_int as uint8_t,
                sym: 31 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 56 as libc::c_int as uint8_t,
                flags: 0x3 as libc::c_int as uint8_t,
                sym: 31 as libc::c_int as uint8_t,
            };
            init
        },
    ],
    [
        {
            let mut init = decode_el {
                state: 2 as libc::c_int as uint8_t,
                flags: 0x2 as libc::c_int as uint8_t,
                sym: 127 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 9 as libc::c_int as uint8_t,
                flags: 0x2 as libc::c_int as uint8_t,
                sym: 127 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 23 as libc::c_int as uint8_t,
                flags: 0x2 as libc::c_int as uint8_t,
                sym: 127 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 40 as libc::c_int as uint8_t,
                flags: 0x3 as libc::c_int as uint8_t,
                sym: 127 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 2 as libc::c_int as uint8_t,
                flags: 0x2 as libc::c_int as uint8_t,
                sym: 220 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 9 as libc::c_int as uint8_t,
                flags: 0x2 as libc::c_int as uint8_t,
                sym: 220 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 23 as libc::c_int as uint8_t,
                flags: 0x2 as libc::c_int as uint8_t,
                sym: 220 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 40 as libc::c_int as uint8_t,
                flags: 0x3 as libc::c_int as uint8_t,
                sym: 220 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 2 as libc::c_int as uint8_t,
                flags: 0x2 as libc::c_int as uint8_t,
                sym: 249 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 9 as libc::c_int as uint8_t,
                flags: 0x2 as libc::c_int as uint8_t,
                sym: 249 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 23 as libc::c_int as uint8_t,
                flags: 0x2 as libc::c_int as uint8_t,
                sym: 249 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 40 as libc::c_int as uint8_t,
                flags: 0x3 as libc::c_int as uint8_t,
                sym: 249 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 0 as libc::c_int as uint8_t,
                flags: 0x3 as libc::c_int as uint8_t,
                sym: 10 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 0 as libc::c_int as uint8_t,
                flags: 0x3 as libc::c_int as uint8_t,
                sym: 13 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 0 as libc::c_int as uint8_t,
                flags: 0x3 as libc::c_int as uint8_t,
                sym: 22 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 0 as libc::c_int as uint8_t,
                flags: 0x4 as libc::c_int as uint8_t,
                sym: 0 as libc::c_int as uint8_t,
            };
            init
        },
    ],
    [
        {
            let mut init = decode_el {
                state: 3 as libc::c_int as uint8_t,
                flags: 0x2 as libc::c_int as uint8_t,
                sym: 127 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 6 as libc::c_int as uint8_t,
                flags: 0x2 as libc::c_int as uint8_t,
                sym: 127 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 10 as libc::c_int as uint8_t,
                flags: 0x2 as libc::c_int as uint8_t,
                sym: 127 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 15 as libc::c_int as uint8_t,
                flags: 0x2 as libc::c_int as uint8_t,
                sym: 127 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 24 as libc::c_int as uint8_t,
                flags: 0x2 as libc::c_int as uint8_t,
                sym: 127 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 31 as libc::c_int as uint8_t,
                flags: 0x2 as libc::c_int as uint8_t,
                sym: 127 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 41 as libc::c_int as uint8_t,
                flags: 0x2 as libc::c_int as uint8_t,
                sym: 127 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 56 as libc::c_int as uint8_t,
                flags: 0x3 as libc::c_int as uint8_t,
                sym: 127 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 3 as libc::c_int as uint8_t,
                flags: 0x2 as libc::c_int as uint8_t,
                sym: 220 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 6 as libc::c_int as uint8_t,
                flags: 0x2 as libc::c_int as uint8_t,
                sym: 220 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 10 as libc::c_int as uint8_t,
                flags: 0x2 as libc::c_int as uint8_t,
                sym: 220 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 15 as libc::c_int as uint8_t,
                flags: 0x2 as libc::c_int as uint8_t,
                sym: 220 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 24 as libc::c_int as uint8_t,
                flags: 0x2 as libc::c_int as uint8_t,
                sym: 220 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 31 as libc::c_int as uint8_t,
                flags: 0x2 as libc::c_int as uint8_t,
                sym: 220 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 41 as libc::c_int as uint8_t,
                flags: 0x2 as libc::c_int as uint8_t,
                sym: 220 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 56 as libc::c_int as uint8_t,
                flags: 0x3 as libc::c_int as uint8_t,
                sym: 220 as libc::c_int as uint8_t,
            };
            init
        },
    ],
    [
        {
            let mut init = decode_el {
                state: 3 as libc::c_int as uint8_t,
                flags: 0x2 as libc::c_int as uint8_t,
                sym: 249 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 6 as libc::c_int as uint8_t,
                flags: 0x2 as libc::c_int as uint8_t,
                sym: 249 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 10 as libc::c_int as uint8_t,
                flags: 0x2 as libc::c_int as uint8_t,
                sym: 249 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 15 as libc::c_int as uint8_t,
                flags: 0x2 as libc::c_int as uint8_t,
                sym: 249 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 24 as libc::c_int as uint8_t,
                flags: 0x2 as libc::c_int as uint8_t,
                sym: 249 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 31 as libc::c_int as uint8_t,
                flags: 0x2 as libc::c_int as uint8_t,
                sym: 249 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 41 as libc::c_int as uint8_t,
                flags: 0x2 as libc::c_int as uint8_t,
                sym: 249 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 56 as libc::c_int as uint8_t,
                flags: 0x3 as libc::c_int as uint8_t,
                sym: 249 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 1 as libc::c_int as uint8_t,
                flags: 0x2 as libc::c_int as uint8_t,
                sym: 10 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 22 as libc::c_int as uint8_t,
                flags: 0x3 as libc::c_int as uint8_t,
                sym: 10 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 1 as libc::c_int as uint8_t,
                flags: 0x2 as libc::c_int as uint8_t,
                sym: 13 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 22 as libc::c_int as uint8_t,
                flags: 0x3 as libc::c_int as uint8_t,
                sym: 13 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 1 as libc::c_int as uint8_t,
                flags: 0x2 as libc::c_int as uint8_t,
                sym: 22 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 22 as libc::c_int as uint8_t,
                flags: 0x3 as libc::c_int as uint8_t,
                sym: 22 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 0 as libc::c_int as uint8_t,
                flags: 0x4 as libc::c_int as uint8_t,
                sym: 0 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 0 as libc::c_int as uint8_t,
                flags: 0x4 as libc::c_int as uint8_t,
                sym: 0 as libc::c_int as uint8_t,
            };
            init
        },
    ],
    [
        {
            let mut init = decode_el {
                state: 2 as libc::c_int as uint8_t,
                flags: 0x2 as libc::c_int as uint8_t,
                sym: 10 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 9 as libc::c_int as uint8_t,
                flags: 0x2 as libc::c_int as uint8_t,
                sym: 10 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 23 as libc::c_int as uint8_t,
                flags: 0x2 as libc::c_int as uint8_t,
                sym: 10 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 40 as libc::c_int as uint8_t,
                flags: 0x3 as libc::c_int as uint8_t,
                sym: 10 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 2 as libc::c_int as uint8_t,
                flags: 0x2 as libc::c_int as uint8_t,
                sym: 13 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 9 as libc::c_int as uint8_t,
                flags: 0x2 as libc::c_int as uint8_t,
                sym: 13 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 23 as libc::c_int as uint8_t,
                flags: 0x2 as libc::c_int as uint8_t,
                sym: 13 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 40 as libc::c_int as uint8_t,
                flags: 0x3 as libc::c_int as uint8_t,
                sym: 13 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 2 as libc::c_int as uint8_t,
                flags: 0x2 as libc::c_int as uint8_t,
                sym: 22 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 9 as libc::c_int as uint8_t,
                flags: 0x2 as libc::c_int as uint8_t,
                sym: 22 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 23 as libc::c_int as uint8_t,
                flags: 0x2 as libc::c_int as uint8_t,
                sym: 22 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 40 as libc::c_int as uint8_t,
                flags: 0x3 as libc::c_int as uint8_t,
                sym: 22 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 0 as libc::c_int as uint8_t,
                flags: 0x4 as libc::c_int as uint8_t,
                sym: 0 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 0 as libc::c_int as uint8_t,
                flags: 0x4 as libc::c_int as uint8_t,
                sym: 0 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 0 as libc::c_int as uint8_t,
                flags: 0x4 as libc::c_int as uint8_t,
                sym: 0 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 0 as libc::c_int as uint8_t,
                flags: 0x4 as libc::c_int as uint8_t,
                sym: 0 as libc::c_int as uint8_t,
            };
            init
        },
    ],
    [
        {
            let mut init = decode_el {
                state: 3 as libc::c_int as uint8_t,
                flags: 0x2 as libc::c_int as uint8_t,
                sym: 10 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 6 as libc::c_int as uint8_t,
                flags: 0x2 as libc::c_int as uint8_t,
                sym: 10 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 10 as libc::c_int as uint8_t,
                flags: 0x2 as libc::c_int as uint8_t,
                sym: 10 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 15 as libc::c_int as uint8_t,
                flags: 0x2 as libc::c_int as uint8_t,
                sym: 10 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 24 as libc::c_int as uint8_t,
                flags: 0x2 as libc::c_int as uint8_t,
                sym: 10 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 31 as libc::c_int as uint8_t,
                flags: 0x2 as libc::c_int as uint8_t,
                sym: 10 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 41 as libc::c_int as uint8_t,
                flags: 0x2 as libc::c_int as uint8_t,
                sym: 10 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 56 as libc::c_int as uint8_t,
                flags: 0x3 as libc::c_int as uint8_t,
                sym: 10 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 3 as libc::c_int as uint8_t,
                flags: 0x2 as libc::c_int as uint8_t,
                sym: 13 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 6 as libc::c_int as uint8_t,
                flags: 0x2 as libc::c_int as uint8_t,
                sym: 13 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 10 as libc::c_int as uint8_t,
                flags: 0x2 as libc::c_int as uint8_t,
                sym: 13 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 15 as libc::c_int as uint8_t,
                flags: 0x2 as libc::c_int as uint8_t,
                sym: 13 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 24 as libc::c_int as uint8_t,
                flags: 0x2 as libc::c_int as uint8_t,
                sym: 13 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 31 as libc::c_int as uint8_t,
                flags: 0x2 as libc::c_int as uint8_t,
                sym: 13 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 41 as libc::c_int as uint8_t,
                flags: 0x2 as libc::c_int as uint8_t,
                sym: 13 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 56 as libc::c_int as uint8_t,
                flags: 0x3 as libc::c_int as uint8_t,
                sym: 13 as libc::c_int as uint8_t,
            };
            init
        },
    ],
    [
        {
            let mut init = decode_el {
                state: 3 as libc::c_int as uint8_t,
                flags: 0x2 as libc::c_int as uint8_t,
                sym: 22 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 6 as libc::c_int as uint8_t,
                flags: 0x2 as libc::c_int as uint8_t,
                sym: 22 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 10 as libc::c_int as uint8_t,
                flags: 0x2 as libc::c_int as uint8_t,
                sym: 22 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 15 as libc::c_int as uint8_t,
                flags: 0x2 as libc::c_int as uint8_t,
                sym: 22 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 24 as libc::c_int as uint8_t,
                flags: 0x2 as libc::c_int as uint8_t,
                sym: 22 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 31 as libc::c_int as uint8_t,
                flags: 0x2 as libc::c_int as uint8_t,
                sym: 22 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 41 as libc::c_int as uint8_t,
                flags: 0x2 as libc::c_int as uint8_t,
                sym: 22 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 56 as libc::c_int as uint8_t,
                flags: 0x3 as libc::c_int as uint8_t,
                sym: 22 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 0 as libc::c_int as uint8_t,
                flags: 0x4 as libc::c_int as uint8_t,
                sym: 0 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 0 as libc::c_int as uint8_t,
                flags: 0x4 as libc::c_int as uint8_t,
                sym: 0 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 0 as libc::c_int as uint8_t,
                flags: 0x4 as libc::c_int as uint8_t,
                sym: 0 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 0 as libc::c_int as uint8_t,
                flags: 0x4 as libc::c_int as uint8_t,
                sym: 0 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 0 as libc::c_int as uint8_t,
                flags: 0x4 as libc::c_int as uint8_t,
                sym: 0 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 0 as libc::c_int as uint8_t,
                flags: 0x4 as libc::c_int as uint8_t,
                sym: 0 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 0 as libc::c_int as uint8_t,
                flags: 0x4 as libc::c_int as uint8_t,
                sym: 0 as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = decode_el {
                state: 0 as libc::c_int as uint8_t,
                flags: 0x4 as libc::c_int as uint8_t,
                sym: 0 as libc::c_int as uint8_t,
            };
            init
        },
    ],
];
#[no_mangle]
#[cold]
pub unsafe extern "C" fn fdevent_reset(mut ev: *mut fdevents) -> libc::c_int {
    let mut rc: libc::c_int = if ((*ev).reset).is_some() {
        ((*ev).reset).expect("non-null function pointer")(ev)
    } else {
        0 as libc::c_int
    };
    if -(1 as libc::c_int) == rc {
        log_error(
            (*ev).errh,
            b"/home/kkysen/work/rust/lighttpd/src/fdevent_impl.c\0" as *const u8
                as *const libc::c_char,
            292 as libc::c_int as libc::c_uint,
            b"event-handler failed: %s; try to set server.event-handler = \"poll\" or \"select\"\0"
                as *const u8 as *const libc::c_char,
            if !((*ev).event_handler).is_null() {
                (*ev).event_handler
            } else {
                b"\0" as *const u8 as *const libc::c_char
            },
        );
    }
    return rc;
}
#[no_mangle]
#[cold]
pub unsafe extern "C" fn fdevent_config(
    mut event_handler_name: *mut *const libc::c_char,
    mut errh: *mut log_error_st,
) -> libc::c_int {
    static mut event_handlers: [ev_map; 4] = [
        {
            let mut init = ev_map {
                et: FDEVENT_HANDLER_LINUX_SYSEPOLL,
                name: b"linux-sysepoll\0" as *const u8 as *const libc::c_char,
            };
            init
        },
        {
            let mut init = ev_map {
                et: FDEVENT_HANDLER_LINUX_SYSEPOLL,
                name: b"epoll\0" as *const u8 as *const libc::c_char,
            };
            init
        },
        {
            let mut init = ev_map {
                et: FDEVENT_HANDLER_POLL,
                name: b"poll\0" as *const u8 as *const libc::c_char,
            };
            init
        },
        {
            let mut init = ev_map {
                et: FDEVENT_HANDLER_UNSET,
                name: 0 as *const libc::c_char,
            };
            init
        },
    ];
    let mut event_handler: *const libc::c_char = *event_handler_name;
    let mut et: fdevent_handler_t = FDEVENT_HANDLER_UNSET;
    if !event_handler.is_null()
        && 0 as libc::c_int
            == strcmp(
                event_handler,
                b"libev\0" as *const u8 as *const libc::c_char,
            )
    {
        event_handler = 0 as *const libc::c_char;
    }
    if !event_handler.is_null()
        && 0 as libc::c_int
            == strcmp(
                event_handler,
                b"select\0" as *const u8 as *const libc::c_char,
            )
    {
        event_handler = b"poll\0" as *const u8 as *const libc::c_char;
    }
    if event_handler.is_null() {
        et = event_handlers[0 as libc::c_int as usize].et;
        *event_handler_name = event_handlers[0 as libc::c_int as usize].name;
        if FDEVENT_HANDLER_UNSET as libc::c_int as libc::c_uint == et as libc::c_uint {
            log_error(
                errh,
                b"/home/kkysen/work/rust/lighttpd/src/fdevent_impl.c\0" as *const u8
                    as *const libc::c_char,
                105 as libc::c_int as libc::c_uint,
                b"sorry, there is no event handler for this system\0" as *const u8
                    as *const libc::c_char,
            );
            return -(1 as libc::c_int);
        }
    } else {
        let mut i: uint32_t = 0 as libc::c_int as uint32_t;
        while !(event_handlers[i as usize].name).is_null() {
            if 0 as libc::c_int == strcmp(event_handlers[i as usize].name, event_handler) {
                et = event_handlers[i as usize].et;
                break;
            } else {
                i = i.wrapping_add(1);
            }
        }
        if FDEVENT_HANDLER_UNSET as libc::c_int as libc::c_uint == et as libc::c_uint {
            log_error(
                errh,
                b"/home/kkysen/work/rust/lighttpd/src/fdevent_impl.c\0" as *const u8
                    as *const libc::c_char,
                124 as libc::c_int as libc::c_uint,
                b"the selected event-handler in unknown or not supported: %s\0" as *const u8
                    as *const libc::c_char,
                event_handler,
            );
            return -(1 as libc::c_int);
        }
    }
    return et as libc::c_int;
}
#[no_mangle]
#[cold]
pub unsafe extern "C" fn fdevent_show_event_handlers() -> *const libc::c_char {
    return b"\nEvent Handlers:\n\n\t- select (generic)\n\t+ poll (Unix)\n\t+ epoll (Linux)\n\t- /dev/poll (Solaris)\n\t- eventports (Solaris)\n\t- kqueue (FreeBSD)\n\t- libev (generic)\n\0"
        as *const u8 as *const libc::c_char;
}
#[no_mangle]
#[cold]
pub unsafe extern "C" fn fdevent_init(
    mut event_handler: *const libc::c_char,
    mut max_fds: *mut libc::c_int,
    mut cur_fds: *mut libc::c_int,
    mut errh: *mut log_error_st,
) -> *mut fdevents {
    let mut ev: *mut fdevents = 0 as *mut fdevents;
    let mut maxfds: uint32_t = if 0 as libc::c_int != *max_fds {
        *max_fds as uint32_t
    } else {
        4096 as libc::c_int as libc::c_uint
    };
    let mut type_0: libc::c_int = fdevent_config(&mut event_handler, errh);
    if type_0 <= 0 as libc::c_int {
        return 0 as *mut fdevents;
    }
    fdevent_socket_nb_cloexec_init();
    *max_fds = maxfds as libc::c_int;
    maxfds = maxfds.wrapping_add(1);
    ev = calloc(
        1 as libc::c_int as libc::c_ulong,
        ::core::mem::size_of::<fdevents>() as libc::c_ulong,
    ) as *mut fdevents;
    if ev.is_null() {
        ck_assert_failed(
            b"/home/kkysen/work/rust/lighttpd/src/fdevent_impl.c\0" as *const u8
                as *const libc::c_char,
            204 as libc::c_int as libc::c_uint,
            b"((void*)0) != ev\0" as *const u8 as *const libc::c_char,
        );
    }
    (*ev).errh = errh;
    (*ev).cur_fds = cur_fds;
    (*ev).event_handler = event_handler;
    (*ev).fdarray = calloc(
        maxfds as libc::c_ulong,
        ::core::mem::size_of::<*mut fdnode>() as libc::c_ulong,
    ) as *mut *mut fdnode;
    if ((*ev).fdarray).is_null() {
        log_error(
            (*ev).errh,
            b"/home/kkysen/work/rust/lighttpd/src/fdevent_impl.c\0" as *const u8
                as *const libc::c_char,
            210 as libc::c_int as libc::c_uint,
            b"server.max-fds too large? (%u)\0" as *const u8 as *const libc::c_char,
            maxfds.wrapping_sub(1 as libc::c_int as libc::c_uint),
        );
        free(ev as *mut libc::c_void);
        return 0 as *mut fdevents;
    }
    (*ev).maxfds = maxfds;
    match type_0 {
        2 => {
            if 0 as libc::c_int == fdevent_poll_init(ev) {
                return ev;
            }
        }
        3 => {
            if 0 as libc::c_int == fdevent_linux_sysepoll_init(ev) {
                return ev;
            }
        }
        _ => {}
    }
    free((*ev).fdarray as *mut libc::c_void);
    free(ev as *mut libc::c_void);
    log_error(
        errh,
        b"/home/kkysen/work/rust/lighttpd/src/fdevent_impl.c\0" as *const u8 as *const libc::c_char,
        261 as libc::c_int as libc::c_uint,
        b"event-handler failed: %s; try to set server.event-handler = \"poll\" or \"select\"\0"
            as *const u8 as *const libc::c_char,
        event_handler,
    );
    return 0 as *mut fdevents;
}
#[cold]
unsafe extern "C" fn fdevent_linux_sysepoll_init(mut ev: *mut fdevents) -> libc::c_int {
    if !(EPOLLIN as libc::c_int == 0x1 as libc::c_int) {
        ck_assert_failed(
            b"/home/kkysen/work/rust/lighttpd/src/fdevent_impl.c\0" as *const u8
                as *const libc::c_char,
            401 as libc::c_int as libc::c_uint,
            b"EPOLLIN == 0x0001\0" as *const u8 as *const libc::c_char,
        );
    }
    if !(EPOLLPRI as libc::c_int == 0x2 as libc::c_int) {
        ck_assert_failed(
            b"/home/kkysen/work/rust/lighttpd/src/fdevent_impl.c\0" as *const u8
                as *const libc::c_char,
            402 as libc::c_int as libc::c_uint,
            b"EPOLLPRI == 0x0002\0" as *const u8 as *const libc::c_char,
        );
    }
    if !(EPOLLOUT as libc::c_int == 0x4 as libc::c_int) {
        ck_assert_failed(
            b"/home/kkysen/work/rust/lighttpd/src/fdevent_impl.c\0" as *const u8
                as *const libc::c_char,
            403 as libc::c_int as libc::c_uint,
            b"EPOLLOUT == 0x0004\0" as *const u8 as *const libc::c_char,
        );
    }
    if !(EPOLLERR as libc::c_int == 0x8 as libc::c_int) {
        ck_assert_failed(
            b"/home/kkysen/work/rust/lighttpd/src/fdevent_impl.c\0" as *const u8
                as *const libc::c_char,
            404 as libc::c_int as libc::c_uint,
            b"EPOLLERR == 0x0008\0" as *const u8 as *const libc::c_char,
        );
    }
    if !(EPOLLHUP as libc::c_int == 0x10 as libc::c_int) {
        ck_assert_failed(
            b"/home/kkysen/work/rust/lighttpd/src/fdevent_impl.c\0" as *const u8
                as *const libc::c_char,
            405 as libc::c_int as libc::c_uint,
            b"EPOLLHUP == 0x0010\0" as *const u8 as *const libc::c_char,
        );
    }
    if !(EPOLLRDHUP as libc::c_int == 0x2000 as libc::c_int) {
        ck_assert_failed(
            b"/home/kkysen/work/rust/lighttpd/src/fdevent_impl.c\0" as *const u8
                as *const libc::c_char,
            407 as libc::c_int as libc::c_uint,
            b"EPOLLRDHUP == 0x2000\0" as *const u8 as *const libc::c_char,
        );
    }
    (*ev).type_0 = FDEVENT_HANDLER_LINUX_SYSEPOLL;
    (*ev).event_set = Some(
        fdevent_linux_sysepoll_event_set
            as unsafe extern "C" fn(*mut fdevents, *mut fdnode, libc::c_int) -> libc::c_int,
    );
    (*ev).event_del = Some(
        fdevent_linux_sysepoll_event_del
            as unsafe extern "C" fn(*mut fdevents, *mut fdnode) -> libc::c_int,
    );
    (*ev).poll = Some(
        fdevent_linux_sysepoll_poll
            as unsafe extern "C" fn(*mut fdevents, libc::c_int) -> libc::c_int,
    );
    (*ev).free = Some(fdevent_linux_sysepoll_free as unsafe extern "C" fn(*mut fdevents) -> ());
    (*ev).epoll_fd = epoll_create1(EPOLL_CLOEXEC as libc::c_int);
    if -(1 as libc::c_int) == (*ev).epoll_fd {
        return -(1 as libc::c_int);
    }
    (*ev).epoll_events = malloc(
        ((*ev).maxfds as libc::c_ulong)
            .wrapping_mul(::core::mem::size_of::<epoll_event>() as libc::c_ulong),
    ) as *mut epoll_event;
    if ((*ev).epoll_events).is_null() {
        ck_assert_failed(
            b"/home/kkysen/work/rust/lighttpd/src/fdevent_impl.c\0" as *const u8
                as *const libc::c_char,
            424 as libc::c_int as libc::c_uint,
            b"((void*)0) != ev->epoll_events\0" as *const u8 as *const libc::c_char,
        );
    }
    return 0 as libc::c_int;
}
#[cold]
unsafe extern "C" fn fdevent_linux_sysepoll_free(mut ev: *mut fdevents) {
    close((*ev).epoll_fd);
    free((*ev).epoll_events as *mut libc::c_void);
}
unsafe extern "C" fn fdevent_linux_sysepoll_poll(
    ev: *mut fdevents,
    mut timeout_ms: libc::c_int,
) -> libc::c_int {
    let epoll_events: *mut epoll_event = (*ev).epoll_events;
    let mut n: libc::c_int = epoll_wait(
        (*ev).epoll_fd,
        epoll_events,
        (*ev).maxfds as libc::c_int,
        timeout_ms,
    );
    let mut i: libc::c_int = 0 as libc::c_int;
    while i < n {
        let fdn: *mut fdnode = (*epoll_events.offset(i as isize)).data.ptr as *mut fdnode;
        let mut revents: libc::c_int = (*epoll_events.offset(i as isize)).events as libc::c_int;
        if ((*fdn).handler).is_some() {
            (Some(((*fdn).handler).expect("non-null function pointer")))
                .expect("non-null function pointer")((*fdn).ctx, revents);
        }
        i += 1;
    }
    return n;
}
unsafe extern "C" fn fdevent_linux_sysepoll_event_del(
    mut ev: *mut fdevents,
    mut fdn: *mut fdnode,
) -> libc::c_int {
    return epoll_ctl(
        (*ev).epoll_fd,
        2 as libc::c_int,
        (*fdn).fd,
        0 as *mut epoll_event,
    );
}
unsafe extern "C" fn fdevent_linux_sysepoll_event_set(
    mut ev: *mut fdevents,
    mut fdn: *mut fdnode,
    mut events: libc::c_int,
) -> libc::c_int {
    let mut op: libc::c_int = if -(1 as libc::c_int) == (*fdn).fde_ndx {
        1 as libc::c_int
    } else {
        3 as libc::c_int
    };
    (*fdn).fde_ndx = (*fdn).fd;
    let mut fd: libc::c_int = (*fdn).fde_ndx;
    let mut ep: epoll_event = epoll_event {
        events: 0,
        data: epoll_data {
            ptr: 0 as *mut libc::c_void,
        },
    };
    ep.events = (events | EPOLLERR as libc::c_int | EPOLLHUP as libc::c_int) as uint32_t;
    ep.data.ptr = fdn as *mut libc::c_void;
    return epoll_ctl((*ev).epoll_fd, op, fd, &mut ep);
}
#[cold]
unsafe extern "C" fn fdevent_poll_init(mut ev: *mut fdevents) -> libc::c_int {
    if !(0x1 as libc::c_int == 0x1 as libc::c_int) {
        ck_assert_failed(
            b"/home/kkysen/work/rust/lighttpd/src/fdevent_impl.c\0" as *const u8
                as *const libc::c_char,
            991 as libc::c_int as libc::c_uint,
            b"0x001 == 0x0001\0" as *const u8 as *const libc::c_char,
        );
    }
    if !(0x2 as libc::c_int == 0x2 as libc::c_int) {
        ck_assert_failed(
            b"/home/kkysen/work/rust/lighttpd/src/fdevent_impl.c\0" as *const u8
                as *const libc::c_char,
            992 as libc::c_int as libc::c_uint,
            b"0x002 == 0x0002\0" as *const u8 as *const libc::c_char,
        );
    }
    if !(0x4 as libc::c_int == 0x4 as libc::c_int) {
        ck_assert_failed(
            b"/home/kkysen/work/rust/lighttpd/src/fdevent_impl.c\0" as *const u8
                as *const libc::c_char,
            993 as libc::c_int as libc::c_uint,
            b"0x004 == 0x0004\0" as *const u8 as *const libc::c_char,
        );
    }
    if !(0x8 as libc::c_int == 0x8 as libc::c_int) {
        ck_assert_failed(
            b"/home/kkysen/work/rust/lighttpd/src/fdevent_impl.c\0" as *const u8
                as *const libc::c_char,
            994 as libc::c_int as libc::c_uint,
            b"0x008 == 0x0008\0" as *const u8 as *const libc::c_char,
        );
    }
    if !(0x10 as libc::c_int == 0x10 as libc::c_int) {
        ck_assert_failed(
            b"/home/kkysen/work/rust/lighttpd/src/fdevent_impl.c\0" as *const u8
                as *const libc::c_char,
            995 as libc::c_int as libc::c_uint,
            b"0x010 == 0x0010\0" as *const u8 as *const libc::c_char,
        );
    }
    if !(0x20 as libc::c_int == 0x20 as libc::c_int) {
        ck_assert_failed(
            b"/home/kkysen/work/rust/lighttpd/src/fdevent_impl.c\0" as *const u8
                as *const libc::c_char,
            996 as libc::c_int as libc::c_uint,
            b"0x020 == 0x0020\0" as *const u8 as *const libc::c_char,
        );
    }
    if !(0x2000 as libc::c_int == 0x2000 as libc::c_int) {
        ck_assert_failed(
            b"/home/kkysen/work/rust/lighttpd/src/fdevent_impl.c\0" as *const u8
                as *const libc::c_char,
            998 as libc::c_int as libc::c_uint,
            b"0x2000 == 0x2000\0" as *const u8 as *const libc::c_char,
        );
    }
    (*ev).type_0 = FDEVENT_HANDLER_POLL;
    (*ev).event_set = Some(
        fdevent_poll_event_set
            as unsafe extern "C" fn(*mut fdevents, *mut fdnode, libc::c_int) -> libc::c_int,
    );
    (*ev).event_del = Some(
        fdevent_poll_event_del as unsafe extern "C" fn(*mut fdevents, *mut fdnode) -> libc::c_int,
    );
    (*ev).poll =
        Some(fdevent_poll_poll as unsafe extern "C" fn(*mut fdevents, libc::c_int) -> libc::c_int);
    (*ev).free = Some(fdevent_poll_free as unsafe extern "C" fn(*mut fdevents) -> ());
    return 0 as libc::c_int;
}
#[cold]
unsafe extern "C" fn fdevent_poll_free(mut ev: *mut fdevents) {
    free((*ev).pollfds as *mut libc::c_void);
    if !((*ev).unused.ptr).is_null() {
        free((*ev).unused.ptr as *mut libc::c_void);
    }
}
unsafe extern "C" fn fdevent_poll_poll(
    mut ev: *mut fdevents,
    mut timeout_ms: libc::c_int,
) -> libc::c_int {
    let pfds: *mut pollfd = (*ev).pollfds;
    let fdarray: *mut *mut fdnode = (*ev).fdarray;
    let n: libc::c_int = poll(pfds, (*ev).used as nfds_t, timeout_ms);
    let mut i: libc::c_int = 0 as libc::c_int;
    let mut m: libc::c_int = 0 as libc::c_int;
    while m < n {
        if !(0 as libc::c_int == (*pfds.offset(i as isize)).revents as libc::c_int) {
            let mut fdn: *mut fdnode = *fdarray.offset((*pfds.offset(i as isize)).fd as isize);
            if 0 as libc::c_int as libc::c_ulong
                == fdn as uintptr_t & 0x3 as libc::c_int as libc::c_ulong
            {
                (Some(((*fdn).handler).expect("non-null function pointer")))
                    .expect("non-null function pointer")(
                    (*fdn).ctx,
                    (*pfds.offset(i as isize)).revents as libc::c_int,
                );
            }
            m += 1;
        }
        i += 1;
    }
    return n;
}
unsafe extern "C" fn fdevent_sched_run(ev: *mut fdevents) {
    let mut fdn: *mut fdnode = (*ev).pendclose;
    while !fdn.is_null() {
        let mut fd: libc::c_int = 0;
        let mut rc: libc::c_int = 0;
        fdn = (fdn as uintptr_t & !(0x3 as libc::c_int) as libc::c_ulong) as *mut fdnode;
        fd = (*fdn).fd;
        rc = close(fd);
        if 0 as libc::c_int != rc {
            log_perror(
                (*ev).errh,
                b"/home/kkysen/work/rust/lighttpd/src/fdevent_impl.c\0" as *const u8
                    as *const libc::c_char,
                323 as libc::c_int as libc::c_uint,
                b"close failed %d\0" as *const u8 as *const libc::c_char,
                fd,
            );
        } else {
            *(*ev).cur_fds -= 1;
        }
        let fdn_tmp: *mut fdnode = fdn;
        fdn = (*fdn).ctx as *mut fdnode;
        free(fdn_tmp as *mut libc::c_void);
        let ref mut fresh59 = *((*ev).fdarray).offset(fd as isize);
        *fresh59 = 0 as *mut fdnode;
    }
    (*ev).pendclose = 0 as *mut fdnode;
}
unsafe extern "C" fn fdevent_poll_event_del(
    mut ev: *mut fdevents,
    mut fdn: *mut fdnode,
) -> libc::c_int {
    let mut fd: libc::c_int = (*fdn).fd;
    let mut k: libc::c_int = (*fdn).fde_ndx;
    if k as uint32_t >= (*ev).used || (*((*ev).pollfds).offset(k as isize)).fd != fd {
        *__errno_location() = 22 as libc::c_int;
        return -(1 as libc::c_int);
    }
    (*((*ev).pollfds).offset(k as isize)).fd = -(1 as libc::c_int);
    if (*ev).unused.size == (*ev).unused.used {
        (*ev).unused.size = ((*ev).unused.size as libc::c_uint)
            .wrapping_add(16 as libc::c_int as libc::c_uint) as uint32_t
            as uint32_t;
        (*ev).unused.ptr = realloc(
            (*ev).unused.ptr as *mut libc::c_void,
            (::core::mem::size_of::<libc::c_int>() as libc::c_ulong)
                .wrapping_mul((*ev).unused.size as libc::c_ulong),
        ) as *mut libc::c_int;
        if ((*ev).unused.ptr).is_null() {
            ck_assert_failed(
                b"/home/kkysen/work/rust/lighttpd/src/fdevent_impl.c\0" as *const u8
                    as *const libc::c_char,
                918 as libc::c_int as libc::c_uint,
                b"((void*)0) != ev->unused.ptr\0" as *const u8 as *const libc::c_char,
            );
        }
    }
    let fresh60 = (*ev).unused.used;
    (*ev).unused.used = ((*ev).unused.used).wrapping_add(1);
    *((*ev).unused.ptr).offset(fresh60 as isize) = k;
    return 0 as libc::c_int;
}
unsafe extern "C" fn fdevent_poll_event_set(
    mut ev: *mut fdevents,
    mut fdn: *mut fdnode,
    mut events: libc::c_int,
) -> libc::c_int {
    let mut fd: libc::c_int = (*fdn).fd;
    let mut k: libc::c_int = (*fdn).fde_ndx;
    if k >= 0 as libc::c_int {
        if k as uint32_t >= (*ev).used || (*((*ev).pollfds).offset(k as isize)).fd != fd {
            *__errno_location() = 22 as libc::c_int;
            return -(1 as libc::c_int);
        }
        (*((*ev).pollfds).offset(k as isize)).events = events as libc::c_short;
        return 0 as libc::c_int;
    }
    if (*ev).unused.used > 0 as libc::c_int as libc::c_uint {
        (*ev).unused.used = ((*ev).unused.used).wrapping_sub(1);
        k = *((*ev).unused.ptr).offset((*ev).unused.used as isize);
    } else {
        if (*ev).size == (*ev).used {
            (*ev).size = ((*ev).size as libc::c_uint)
                .wrapping_add(16 as libc::c_int as libc::c_uint)
                as uint32_t as uint32_t;
            (*ev).pollfds = realloc(
                (*ev).pollfds as *mut libc::c_void,
                (::core::mem::size_of::<pollfd>() as libc::c_ulong)
                    .wrapping_mul((*ev).size as libc::c_ulong),
            ) as *mut pollfd;
            if ((*ev).pollfds).is_null() {
                ck_assert_failed(
                    b"/home/kkysen/work/rust/lighttpd/src/fdevent_impl.c\0" as *const u8
                        as *const libc::c_char,
                    950 as libc::c_int as libc::c_uint,
                    b"((void*)0) != ev->pollfds\0" as *const u8 as *const libc::c_char,
                );
            }
        }
        let fresh61 = (*ev).used;
        (*ev).used = ((*ev).used).wrapping_add(1);
        k = fresh61 as libc::c_int;
    }
    (*fdn).fde_ndx = k;
    (*((*ev).pollfds).offset(k as isize)).fd = fd;
    (*((*ev).pollfds).offset(k as isize)).events = events as libc::c_short;
    return 0 as libc::c_int;
}
#[no_mangle]
#[cold]
pub unsafe extern "C" fn fdevent_free(mut ev: *mut fdevents) {
    if ev.is_null() {
        return;
    }
    if ((*ev).free).is_some() {
        ((*ev).free).expect("non-null function pointer")(ev);
    }
    let mut i: uint32_t = 0 as libc::c_int as uint32_t;
    while i < (*ev).maxfds {
        if !(*((*ev).fdarray).offset(i as isize)).is_null() {
            free(
                (*((*ev).fdarray).offset(i as isize) as uintptr_t
                    & !(0x3 as libc::c_int) as libc::c_ulong) as *mut fdnode
                    as *mut libc::c_void,
            );
        }
        i = i.wrapping_add(1);
    }
    free((*ev).fdarray as *mut libc::c_void);
    free(ev as *mut libc::c_void);
}
#[no_mangle]
pub unsafe extern "C" fn fdevent_poll(ev: *mut fdevents, timeout_ms: libc::c_int) -> libc::c_int {
    let n: libc::c_int = ((*ev).poll).expect("non-null function pointer")(
        ev,
        if !((*ev).pendclose).is_null() {
            0 as libc::c_int
        } else {
            timeout_ms
        },
    );
    if n >= 0 as libc::c_int {
        fdevent_sched_run(ev);
    } else if *__errno_location() != 4 as libc::c_int {
        log_perror(
            (*ev).errh,
            b"/home/kkysen/work/rust/lighttpd/src/fdevent_impl.c\0" as *const u8
                as *const libc::c_char,
            346 as libc::c_int as libc::c_uint,
            b"fdevent_poll failed\0" as *const u8 as *const libc::c_char,
        );
    }
    return n;
}
#[inline(never)]
unsafe extern "C" fn http_range_coalesce(ranges: *mut off_t, mut n: libc::c_int) -> libc::c_int {
    let mut i: libc::c_int = 0 as libc::c_int;
    while (i + 2 as libc::c_int) < n {
        let b: off_t = *ranges.offset(i as isize);
        let e: off_t = *ranges.offset((i + 1 as libc::c_int) as isize);
        let mut j: libc::c_int = i + 2 as libc::c_int;
        while j < n {
            if if b <= *ranges.offset(j as isize) {
                (e < *ranges.offset(j as isize) - 80 as libc::c_int as libc::c_long) as libc::c_int
            } else {
                (*ranges.offset((j + 1 as libc::c_int) as isize)
                    < b - 80 as libc::c_int as libc::c_long) as libc::c_int
            } != 0
            {
                j += 2 as libc::c_int;
            } else {
                *ranges.offset(i as isize) = if b <= *ranges.offset(j as isize) {
                    b
                } else {
                    *ranges.offset(j as isize)
                };
                *ranges.offset((i + 1 as libc::c_int) as isize) =
                    if e >= *ranges.offset((j + 1 as libc::c_int) as isize) {
                        e
                    } else {
                        *ranges.offset((j + 1 as libc::c_int) as isize)
                    };
                memmove(
                    ranges.offset(j as isize) as *mut libc::c_void,
                    ranges.offset(j as isize).offset(2 as libc::c_int as isize)
                        as *const libc::c_void,
                    ((n - j - 2 as libc::c_int) as libc::c_ulong)
                        .wrapping_mul(::core::mem::size_of::<off_t>() as libc::c_ulong),
                );
                n -= 2 as libc::c_int;
                i = -(2 as libc::c_int);
                break;
            }
        }
        i += 2 as libc::c_int;
    }
    return n;
}
unsafe extern "C" fn http_range_parse_next(
    mut s: *const libc::c_char,
    len: off_t,
    ranges: *mut off_t,
) -> *const libc::c_char {
    let mut e: *mut libc::c_char = 0 as *mut libc::c_char;
    let mut n: off_t = strtoll(s, &mut e, 10 as libc::c_int) as off_t;
    *ranges.offset(1 as libc::c_int as isize) = -(1 as libc::c_int) as off_t;
    if n >= 0 as libc::c_int as libc::c_long {
        if n as libc::c_longlong != 9223372036854775807 as libc::c_longlong
            && n < len
            && s != e as *const libc::c_char
        {
            *ranges.offset(0 as libc::c_int as isize) = n;
            while *e as libc::c_int == ' ' as i32 || *e as libc::c_int == '\t' as i32 {
                e = e.offset(1);
            }
            if *e as libc::c_int == '-' as i32 {
                s = e.offset(1 as libc::c_int as isize);
                n = strtoll(s, &mut e, 10 as libc::c_int) as off_t;
                if s == e as *const libc::c_char
                    || n == 0 as libc::c_int as libc::c_long
                        && *e.offset(-(1 as libc::c_int) as isize) as libc::c_int != '0' as i32
                {
                    *ranges.offset(1 as libc::c_int as isize) =
                        len - 1 as libc::c_int as libc::c_long;
                } else if *ranges.offset(0 as libc::c_int as isize) <= n
                    && n as libc::c_longlong != 9223372036854775807 as libc::c_longlong
                {
                    *ranges.offset(1 as libc::c_int as isize) = if n < len {
                        n
                    } else {
                        len - 1 as libc::c_int as libc::c_long
                    };
                }
            }
        }
    } else if n as libc::c_longlong
        != -(9223372036854775807 as libc::c_longlong) - 1 as libc::c_longlong
    {
        *ranges.offset(0 as libc::c_int as isize) = if len > -n {
            len + n
        } else {
            0 as libc::c_int as libc::c_long
        };
        *ranges.offset(1 as libc::c_int as isize) = len - 1 as libc::c_int as libc::c_long;
    }
    while *e as libc::c_int == ' ' as i32 || *e as libc::c_int == '\t' as i32 {
        e = e.offset(1);
    }
    return e;
}
unsafe extern "C" fn http_range_parse(
    mut s: *const libc::c_char,
    content_length: off_t,
    mut ranges: *mut off_t,
) -> libc::c_int {
    let mut n: libc::c_int = 0 as libc::c_int;
    loop {
        s = http_range_parse_next(s, content_length, ranges.offset(n as isize));
        if (*s as libc::c_int == '\0' as i32 || *s as libc::c_int == ',' as i32)
            && *ranges.offset((n + 1 as libc::c_int) as isize)
                != -(1 as libc::c_int) as libc::c_long
        {
            n += 2 as libc::c_int;
        } else {
            while *s as libc::c_int != '\0' as i32 && *s as libc::c_int != ',' as i32 {
                s = s.offset(1);
            }
        }
        let fresh62 = s;
        s = s.offset(1);
        if !(*fresh62 as libc::c_int != '\0' as i32 && n < 10 as libc::c_int * 2 as libc::c_int) {
            break;
        }
    }
    if n <= 2 as libc::c_int {
        return n;
    }
    return http_range_coalesce(ranges, n);
}
unsafe extern "C" fn http_range_single(r: *mut request_st, mut ranges: *const off_t) {
    let cq: *mut chunkqueue = &mut (*r).write_queue;
    let complete_length: off_t = chunkqueue_length(cq);
    let mut len: uint32_t = (::core::mem::size_of::<[libc::c_char; 7]>() as libc::c_ulong)
        .wrapping_sub(1 as libc::c_int as libc::c_ulong) as uint32_t;
    let mut cr: [libc::c_char; 72] = *::core::mem::transmute::<
        &[u8; 72],
        &mut [libc::c_char; 72],
    >(
        b"bytes \0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0",
    );
    len = (len as libc::c_uint).wrapping_add(li_itostrn(
        cr.as_mut_ptr().offset(len as isize),
        (::core::mem::size_of::<[libc::c_char; 72]>() as libc::c_ulong)
            .wrapping_sub(len as libc::c_ulong),
        *ranges.offset(0 as libc::c_int as isize),
    ) as uint32_t) as uint32_t as uint32_t;
    let fresh63 = len;
    len = len.wrapping_add(1);
    cr[fresh63 as usize] = '-' as i32 as libc::c_char;
    len = (len as libc::c_uint).wrapping_add(li_itostrn(
        cr.as_mut_ptr().offset(len as isize),
        (::core::mem::size_of::<[libc::c_char; 72]>() as libc::c_ulong)
            .wrapping_sub(len as libc::c_ulong),
        *ranges.offset(1 as libc::c_int as isize),
    ) as uint32_t) as uint32_t as uint32_t;
    let fresh64 = len;
    len = len.wrapping_add(1);
    cr[fresh64 as usize] = '/' as i32 as libc::c_char;
    len = (len as libc::c_uint).wrapping_add(li_itostrn(
        cr.as_mut_ptr().offset(len as isize),
        (::core::mem::size_of::<[libc::c_char; 72]>() as libc::c_ulong)
            .wrapping_sub(len as libc::c_ulong),
        complete_length,
    ) as uint32_t) as uint32_t as uint32_t;
    http_header_response_set(
        r,
        HTTP_HEADER_CONTENT_RANGE,
        b"Content-Range\0" as *const u8 as *const libc::c_char,
        (::core::mem::size_of::<[libc::c_char; 14]>() as libc::c_ulong as uint32_t)
            .wrapping_sub(1 as libc::c_int as libc::c_uint),
        cr.as_mut_ptr(),
        len,
    );
    if (*cq).first == (*cq).last {
        if *ranges.offset(0 as libc::c_int as isize) != 0 {
            chunkqueue_mark_written(cq, *ranges.offset(0 as libc::c_int as isize));
            (*cq).bytes_out -= *ranges.offset(0 as libc::c_int as isize);
            (*cq).bytes_in -= *ranges.offset(0 as libc::c_int as isize);
        }
        (*cq).bytes_in -= complete_length
            - (*ranges.offset(1 as libc::c_int as isize) + 1 as libc::c_int as libc::c_long);
        let c: *mut chunk = (*cq).first;
        if (*c).type_0 as libc::c_uint == FILE_CHUNK as libc::c_int as libc::c_uint {
            (*c).file.length = (*c).offset + *ranges.offset(1 as libc::c_int as isize)
                - *ranges.offset(0 as libc::c_int as isize)
                + 1 as libc::c_int as libc::c_long;
        } else {
            (*(*c).mem).used = ((*c).offset + *ranges.offset(1 as libc::c_int as isize)
                - *ranges.offset(0 as libc::c_int as isize)
                + 1 as libc::c_int as libc::c_long
                + 1 as libc::c_int as libc::c_long) as uint32_t;
        }
    } else {
        let mut tq: chunkqueue = chunkqueue {
            first: 0 as *mut chunk,
            last: 0 as *mut chunk,
            bytes_in: 0,
            bytes_out: 0,
            tempdirs: 0 as *const array,
            upload_temp_file_size: 0,
            tempdir_idx: 0,
        };
        memset(
            &mut tq as *mut chunkqueue as *mut libc::c_void,
            0 as libc::c_int,
            ::core::mem::size_of::<chunkqueue>() as libc::c_ulong,
        );
        chunkqueue_steal(&mut tq, cq, complete_length);
        (*cq).bytes_out -= complete_length;
        (*cq).bytes_in -= complete_length;
        chunkqueue_mark_written(&mut tq, *ranges.offset(0 as libc::c_int as isize));
        chunkqueue_steal(
            cq,
            &mut tq,
            *ranges.offset(1 as libc::c_int as isize) - *ranges.offset(0 as libc::c_int as isize)
                + 1 as libc::c_int as libc::c_long,
        );
        chunkqueue_reset(&mut tq);
    };
}
#[cold]
unsafe extern "C" fn http_range_multi(
    r: *mut request_st,
    mut ranges: *const off_t,
    n: libc::c_int,
) {
    static mut boundary_prefix: [libc::c_char; 18] = unsafe {
        *::core::mem::transmute::<&[u8; 18], &[libc::c_char; 18]>(b"\r\n--fkj49sn38dcn3\0")
    };
    static mut boundary_end: [libc::c_char; 22] = unsafe {
        *::core::mem::transmute::<&[u8; 22], &[libc::c_char; 22]>(b"\r\n--fkj49sn38dcn3--\r\n\0")
    };
    static mut multipart_type: [libc::c_char; 45] = unsafe {
        *::core::mem::transmute::<&[u8; 45], &[libc::c_char; 45]>(
            b"multipart/byteranges; boundary=fkj49sn38dcn3\0",
        )
    };
    let tb: *mut buffer = (*r).tmp_buf;
    buffer_copy_string_len(
        tb,
        boundary_prefix.as_ptr(),
        (::core::mem::size_of::<[libc::c_char; 18]>() as libc::c_ulong as uint32_t)
            .wrapping_sub(1 as libc::c_int as libc::c_uint) as size_t,
    );
    let content_type: *const buffer = http_header_response_get(
        r,
        HTTP_HEADER_CONTENT_TYPE,
        b"Content-Type\0" as *const u8 as *const libc::c_char,
        (::core::mem::size_of::<[libc::c_char; 13]>() as libc::c_ulong as uint32_t)
            .wrapping_sub(1 as libc::c_int as libc::c_uint),
    );
    if !content_type.is_null() {
        buffer_append_str2(
            tb,
            b"\r\nContent-Type: \0" as *const u8 as *const libc::c_char,
            (::core::mem::size_of::<[libc::c_char; 17]>() as libc::c_ulong as uint32_t)
                .wrapping_sub(1 as libc::c_int as libc::c_uint) as size_t,
            (*content_type).ptr,
            buffer_clen(content_type) as size_t,
        );
    }
    buffer_append_string_len(
        tb,
        b"\r\nContent-Range: bytes \0" as *const u8 as *const libc::c_char,
        (::core::mem::size_of::<[libc::c_char; 24]>() as libc::c_ulong as uint32_t)
            .wrapping_sub(1 as libc::c_int as libc::c_uint) as size_t,
    );
    let prefix_len: uint32_t = buffer_clen(tb);
    http_header_response_set(
        r,
        HTTP_HEADER_CONTENT_TYPE,
        b"Content-Type\0" as *const u8 as *const libc::c_char,
        (::core::mem::size_of::<[libc::c_char; 13]>() as libc::c_ulong as uint32_t)
            .wrapping_sub(1 as libc::c_int as libc::c_uint),
        multipart_type.as_ptr(),
        (::core::mem::size_of::<[libc::c_char; 45]>() as libc::c_ulong as uint32_t)
            .wrapping_sub(1 as libc::c_int as libc::c_uint),
    );
    let cq: *mut chunkqueue = &mut (*r).write_queue;
    let complete_length: off_t = chunkqueue_length(cq);
    let c: *mut chunk = if (*cq).first == (*cq).last
        && (*(*cq).first).type_0 as libc::c_uint == MEM_CHUNK as libc::c_int as libc::c_uint
    {
        (*cq).first
    } else {
        0 as *mut chunk
    };
    let mut i: libc::c_int = 0 as libc::c_int;
    while i < n {
        buffer_truncate(tb, prefix_len);
        buffer_append_int(tb, *ranges.offset(i as isize));
        buffer_append_string_len(
            tb,
            b"-\0" as *const u8 as *const libc::c_char,
            (::core::mem::size_of::<[libc::c_char; 2]>() as libc::c_ulong as uint32_t)
                .wrapping_sub(1 as libc::c_int as libc::c_uint) as size_t,
        );
        buffer_append_int(tb, *ranges.offset((i + 1 as libc::c_int) as isize));
        buffer_append_string_len(
            tb,
            b"/\0" as *const u8 as *const libc::c_char,
            (::core::mem::size_of::<[libc::c_char; 2]>() as libc::c_ulong as uint32_t)
                .wrapping_sub(1 as libc::c_int as libc::c_uint) as size_t,
        );
        buffer_append_int(tb, complete_length);
        buffer_append_string_len(
            tb,
            b"\r\n\r\n\0" as *const u8 as *const libc::c_char,
            (::core::mem::size_of::<[libc::c_char; 5]>() as libc::c_ulong as uint32_t)
                .wrapping_sub(1 as libc::c_int as libc::c_uint) as size_t,
        );
        if !c.is_null() {
            chunkqueue_append_mem(cq, (*tb).ptr, buffer_clen(tb) as size_t);
        } else {
            chunkqueue_append_mem_min(cq, (*tb).ptr, buffer_clen(tb) as size_t);
        }
        chunkqueue_append_cq_range(
            cq,
            cq,
            *ranges.offset(i as isize),
            *ranges.offset((i + 1 as libc::c_int) as isize) - *ranges.offset(i as isize)
                + 1 as libc::c_int as libc::c_long,
        );
        i += 2 as libc::c_int;
    }
    chunkqueue_append_mem_min(
        cq,
        boundary_end.as_ptr(),
        (::core::mem::size_of::<[libc::c_char; 22]>() as libc::c_ulong as uint32_t)
            .wrapping_sub(1 as libc::c_int as libc::c_uint) as size_t,
    );
    chunkqueue_mark_written(cq, complete_length + 2 as libc::c_int as libc::c_long);
    (*cq).bytes_out -= complete_length + 2 as libc::c_int as libc::c_long;
    (*cq).bytes_in -= complete_length + 2 as libc::c_int as libc::c_long;
}
#[cold]
unsafe extern "C" fn http_range_not_satisfiable(
    r: *mut request_st,
    content_length: off_t,
) -> libc::c_int {
    let mut len: uint32_t = (::core::mem::size_of::<[libc::c_char; 9]>() as libc::c_ulong)
        .wrapping_sub(1 as libc::c_int as libc::c_ulong) as uint32_t;
    let mut cr: [libc::c_char; 32] = *::core::mem::transmute::<&[u8; 32], &mut [libc::c_char; 32]>(
        b"bytes */\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0",
    );
    len = (len as libc::c_uint).wrapping_add(li_itostrn(
        cr.as_mut_ptr().offset(len as isize),
        (::core::mem::size_of::<[libc::c_char; 32]>() as libc::c_ulong)
            .wrapping_sub(len as libc::c_ulong),
        content_length,
    ) as uint32_t) as uint32_t as uint32_t;
    http_header_response_set(
        r,
        HTTP_HEADER_CONTENT_RANGE,
        b"Content-Range\0" as *const u8 as *const libc::c_char,
        (::core::mem::size_of::<[libc::c_char; 14]>() as libc::c_ulong as uint32_t)
            .wrapping_sub(1 as libc::c_int as libc::c_uint),
        cr.as_mut_ptr(),
        len,
    );
    (*r).handler_module = 0 as *const plugin;
    (*r).http_status = 416 as libc::c_int;
    return (*r).http_status;
}
#[inline(never)]
unsafe extern "C" fn http_range_process(
    r: *mut request_st,
    http_range: *const buffer,
) -> libc::c_int {
    let content_length: off_t = chunkqueue_length(&mut (*r).write_queue);
    if 0 as libc::c_int as libc::c_long == content_length {
        return (*r).http_status;
    }
    if (buffer_clen(http_range) as libc::c_ulong)
        < (::core::mem::size_of::<[libc::c_char; 7]>() as libc::c_ulong)
            .wrapping_sub(1 as libc::c_int as libc::c_ulong)
        || buffer_eq_icase_ssn(
            (*http_range).ptr,
            b"bytes=\0" as *const u8 as *const libc::c_char,
            (::core::mem::size_of::<[libc::c_char; 7]>() as libc::c_ulong)
                .wrapping_sub(1 as libc::c_int as libc::c_ulong),
        ) == 0
    {
        return (*r).http_status;
    }
    let mut ranges: [off_t; 20] = [0; 20];
    let n: libc::c_int = http_range_parse(
        ((*http_range).ptr)
            .offset(::core::mem::size_of::<[libc::c_char; 7]>() as libc::c_ulong as isize)
            .offset(-(1 as libc::c_int as isize)),
        content_length,
        ranges.as_mut_ptr(),
    );
    if 2 as libc::c_int == n {
        http_range_single(r, ranges.as_mut_ptr() as *const off_t);
    } else if 0 as libc::c_int == n {
        return http_range_not_satisfiable(r, content_length);
    } else {
        http_range_multi(r, ranges.as_mut_ptr() as *const off_t, n);
    }
    buffer_append_int(
        http_header_response_set_ptr(
            r,
            HTTP_HEADER_CONTENT_LENGTH,
            b"Content-Length\0" as *const u8 as *const libc::c_char,
            (::core::mem::size_of::<[libc::c_char; 15]>() as libc::c_ulong as uint32_t)
                .wrapping_sub(1 as libc::c_int as libc::c_uint),
        ),
        chunkqueue_length(&mut (*r).write_queue),
    );
    (*r).http_status = 206 as libc::c_int;
    return (*r).http_status;
}
#[no_mangle]
pub unsafe extern "C" fn http_range_rfc7233(r: *mut request_st) -> libc::c_int {
    let http_status_0: libc::c_int = (*r).http_status;
    if (*r).resp_body_finished == 0 {
        return http_status_0;
    }
    if 200 as libc::c_int != http_status_0 {
        return http_status_0;
    }
    if !((*r).http_method as libc::c_int <= HTTP_METHOD_HEAD as libc::c_int) {
        return http_status_0;
    }
    if ((*r).http_version as libc::c_int) < HTTP_VERSION_1_1 as libc::c_int {
        return http_status_0;
    }
    if (*r).resp_htags
        & ((1 as libc::c_ulong) << HTTP_HEADER_TRANSFER_ENCODING as libc::c_int
            | (1 as libc::c_ulong) << HTTP_HEADER_CONTENT_ENCODING as libc::c_int)
        != 0
    {
        return http_status_0;
    }
    if (*r).resp_htags & (1 as libc::c_ulong) << HTTP_HEADER_ACCEPT_RANGES as libc::c_int == 0 {
        http_header_response_set(
            r,
            HTTP_HEADER_ACCEPT_RANGES,
            b"Accept-Ranges\0" as *const u8 as *const libc::c_char,
            (::core::mem::size_of::<[libc::c_char; 14]>() as libc::c_ulong as uint32_t)
                .wrapping_sub(1 as libc::c_int as libc::c_uint),
            b"bytes\0" as *const u8 as *const libc::c_char,
            (::core::mem::size_of::<[libc::c_char; 6]>() as libc::c_ulong as uint32_t)
                .wrapping_sub(1 as libc::c_int as libc::c_uint),
        );
    } else {
        let accept_ranges: *const buffer = http_header_response_get(
            r,
            HTTP_HEADER_ACCEPT_RANGES,
            b"Accept-Ranges\0" as *const u8 as *const libc::c_char,
            (::core::mem::size_of::<[libc::c_char; 14]>() as libc::c_ulong as uint32_t)
                .wrapping_sub(1 as libc::c_int as libc::c_uint),
        );
        if buffer_eq_slen(
            accept_ranges,
            b"none\0" as *const u8 as *const libc::c_char,
            (::core::mem::size_of::<[libc::c_char; 5]>() as libc::c_ulong as uint32_t)
                .wrapping_sub(1 as libc::c_int as libc::c_uint) as size_t,
        ) != 0
        {
            return http_status_0;
        }
    }
    if (*r).http_method as libc::c_int != HTTP_METHOD_GET as libc::c_int {
        return http_status_0;
    }
    let http_range: *const buffer = http_header_request_get(
        r,
        HTTP_HEADER_RANGE,
        b"Range\0" as *const u8 as *const libc::c_char,
        (::core::mem::size_of::<[libc::c_char; 6]>() as libc::c_ulong as uint32_t)
            .wrapping_sub(1 as libc::c_int as libc::c_uint),
    );
    if http_range.is_null() {
        return http_status_0;
    }
    if (*r).rqst_htags & (1 as libc::c_ulong) << HTTP_HEADER_IF_RANGE as libc::c_int != 0 {
        let if_range: *const buffer = http_header_request_get(
            r,
            HTTP_HEADER_IF_RANGE,
            b"If-Range\0" as *const u8 as *const libc::c_char,
            (::core::mem::size_of::<[libc::c_char; 9]>() as libc::c_ulong as uint32_t)
                .wrapping_sub(1 as libc::c_int as libc::c_uint),
        );
        let cmp: *const buffer =
            if *((*if_range).ptr).offset(0 as libc::c_int as isize) as libc::c_int == '"' as i32 {
                http_header_response_get(
                    r,
                    HTTP_HEADER_ETAG,
                    b"ETag\0" as *const u8 as *const libc::c_char,
                    (::core::mem::size_of::<[libc::c_char; 5]>() as libc::c_ulong as uint32_t)
                        .wrapping_sub(1 as libc::c_int as libc::c_uint),
                )
            } else {
                http_header_response_get(
                    r,
                    HTTP_HEADER_LAST_MODIFIED,
                    b"Last-Modified\0" as *const u8 as *const libc::c_char,
                    (::core::mem::size_of::<[libc::c_char; 14]>() as libc::c_ulong as uint32_t)
                        .wrapping_sub(1 as libc::c_int as libc::c_uint),
                )
            };
        if cmp.is_null() || buffer_is_equal(if_range, cmp) == 0 {
            return http_status_0;
        }
    }
    return http_range_process(r, http_range);
}
#[no_mangle]
pub unsafe extern "C" fn network_accept_tcp_nagle_disable(fd: libc::c_int) {
    static mut noinherit_tcpnodelay: libc::c_int = -(1 as libc::c_int);
    let mut opt: libc::c_int = 0;
    if noinherit_tcpnodelay == 0 {
        return;
    }
    if noinherit_tcpnodelay < 0 as libc::c_int {
        let mut optlen: socklen_t =
            ::core::mem::size_of::<libc::c_int>() as libc::c_ulong as socklen_t;
        if 0 as libc::c_int
            == getsockopt(
                fd,
                IPPROTO_TCP as libc::c_int,
                1 as libc::c_int,
                &mut opt as *mut libc::c_int as *mut libc::c_void,
                &mut optlen,
            )
        {
            noinherit_tcpnodelay = (opt == 0) as libc::c_int;
            if opt != 0 {
                return;
            }
        }
    }
    opt = 1 as libc::c_int;
    setsockopt(
        fd,
        IPPROTO_TCP as libc::c_int,
        1 as libc::c_int,
        &mut opt as *mut libc::c_int as *const libc::c_void,
        ::core::mem::size_of::<libc::c_int>() as libc::c_ulong as socklen_t,
    );
}
unsafe extern "C" fn network_server_handle_fdevent(
    mut context: *mut libc::c_void,
    mut revents: libc::c_int,
) -> handler_t {
    let srv_socket: *const server_socket = context as *mut server_socket;
    let srv: *mut server = (*srv_socket).srv;
    if 0 as libc::c_int == revents & 0x1 as libc::c_int {
        log_error(
            (*srv).errh,
            b"/home/kkysen/work/rust/lighttpd/src/network.c\0" as *const u8 as *const libc::c_char,
            51 as libc::c_int as libc::c_uint,
            b"strange event for server socket %d %d\0" as *const u8 as *const libc::c_char,
            (*srv_socket).fd,
            revents,
        );
        return HANDLER_ERROR;
    }
    let mut loops: libc::c_int = (*srv).lim_conns as libc::c_int;
    if loops > 100 as libc::c_int {
        loops = 100 as libc::c_int;
    } else if loops <= 0 as libc::c_int {
        return HANDLER_GO_ON;
    }
    let nagle_disable: libc::c_int =
        (sock_addr_get_family(&(*srv_socket).addr) != 1 as libc::c_int) as libc::c_int;
    let mut addr: sock_addr = sock_addr {
        ipv6: sockaddr_in6 {
            sin6_family: 0,
            sin6_port: 0,
            sin6_flowinfo: 0,
            sin6_addr: in6_addr {
                __in6_u: C2RustUnnamed_0 {
                    __u6_addr8: [0; 16],
                },
            },
            sin6_scope_id: 0,
        },
    };
    let mut addrlen: size_t = 0;
    loop {
        addrlen = ::core::mem::size_of::<sock_addr>() as libc::c_ulong;
        let mut fd: libc::c_int = fdevent_accept_listenfd(
            (*srv_socket).fd,
            &mut addr as *mut sock_addr as *mut sockaddr,
            &mut addrlen,
        );
        if -(1 as libc::c_int) == fd {
            break;
        }
        if nagle_disable != 0 {
            network_accept_tcp_nagle_disable(fd);
        }
        let mut con: *mut connection = connection_accepted(srv, srv_socket, &mut addr, fd);
        if con.is_null() as libc::c_int as libc::c_long != 0 {
            return HANDLER_GO_ON;
        }
        connection_state_machine(con);
        loops -= 1;
        if !(loops != 0) {
            break;
        }
    }
    if loops != 0 {
        match *__errno_location() {
            11 | 4 | 103 | 24 => {}
            _ => {
                log_perror(
                    (*srv).errh,
                    b"/home/kkysen/work/rust/lighttpd/src/network.c\0" as *const u8
                        as *const libc::c_char,
                    94 as libc::c_int as libc::c_uint,
                    b"accept()\0" as *const u8 as *const libc::c_char,
                );
            }
        }
    }
    return HANDLER_GO_ON;
}
unsafe extern "C" fn network_host_normalize_addr_str(
    mut host: *mut buffer,
    mut addr: *mut sock_addr,
) {
    buffer_clear(host);
    sock_addr_stringify_append_buffer(host, addr);
}
unsafe extern "C" fn network_host_parse_addr(
    mut srv: *mut server,
    mut addr: *mut sock_addr,
    mut addr_len: *mut socklen_t,
    mut host: *mut buffer,
    mut use_ipv6: libc::c_int,
) -> libc::c_int {
    let mut h: *mut libc::c_char = 0 as *mut libc::c_char;
    let mut colon: *mut libc::c_char = 0 as *mut libc::c_char;
    let mut chost: *const libc::c_char = 0 as *const libc::c_char;
    let mut family: sa_family_t = (if use_ipv6 != 0 {
        10 as libc::c_int
    } else {
        2 as libc::c_int
    }) as sa_family_t;
    let mut port: libc::c_uint = (*srv).srvconf.port as libc::c_uint;
    if buffer_is_blank(host) != 0 {
        log_error(
            (*srv).errh,
            b"/home/kkysen/work/rust/lighttpd/src/network.c\0" as *const u8 as *const libc::c_char,
            113 as libc::c_int as libc::c_uint,
            b"value of $SERVER[\"socket\"] must not be empty\0" as *const u8 as *const libc::c_char,
        );
        return -(1 as libc::c_int);
    }
    h = (*host).ptr;
    if *h.offset(0 as libc::c_int as isize) as libc::c_int == '/' as i32 {
        return if 1 as libc::c_int
            == sock_addr_from_str_hints(
                addr,
                addr_len,
                h,
                1 as libc::c_int,
                0 as libc::c_int as libc::c_ushort,
                (*srv).errh,
            ) {
            0 as libc::c_int
        } else {
            -(1 as libc::c_int)
        };
    }
    let tb: *mut buffer = (*srv).tmp_buf;
    buffer_copy_buffer(tb, host);
    h = (*tb).ptr;
    if *h.offset(0 as libc::c_int as isize) as libc::c_int == '[' as i32 {
        family = 10 as libc::c_int as sa_family_t;
        h = strchr(h, ']' as i32);
        if !h.is_null() {
            let fresh65 = h;
            h = h.offset(1);
            *fresh65 = '\0' as i32 as libc::c_char;
            if *h as libc::c_int == ':' as i32 {
                colon = h;
            }
        }
        h = ((*tb).ptr).offset(1 as libc::c_int as isize);
    } else {
        colon = strrchr(h, ':' as i32);
    }
    if !colon.is_null() {
        let fresh66 = colon;
        colon = colon.offset(1);
        *fresh66 = '\0' as i32 as libc::c_char;
        port = strtol(colon, 0 as *mut *mut libc::c_char, 10 as libc::c_int) as libc::c_uint;
        if port == 0 as libc::c_int as libc::c_uint || port > 65535 as libc::c_int as libc::c_uint {
            log_error(
                (*srv).errh,
                b"/home/kkysen/work/rust/lighttpd/src/network.c\0" as *const u8
                    as *const libc::c_char,
                148 as libc::c_int as libc::c_uint,
                b"port not set or out of range: %u\0" as *const u8 as *const libc::c_char,
                port,
            );
            return -(1 as libc::c_int);
        }
    }
    if *h.offset(0 as libc::c_int as isize) as libc::c_int == '*' as i32
        && *h.offset(1 as libc::c_int as isize) as libc::c_int == '\0' as i32
    {
        family = 2 as libc::c_int as sa_family_t;
        h = h.offset(1);
    }
    chost = if *h as libc::c_int != 0 {
        h as *const libc::c_char
    } else if family as libc::c_int == 2 as libc::c_int {
        b"0.0.0.0\0" as *const u8 as *const libc::c_char
    } else {
        b"::\0" as *const u8 as *const libc::c_char
    };
    if 1 as libc::c_int
        != sock_addr_from_str_hints(
            addr,
            addr_len,
            chost,
            family as libc::c_int,
            port as libc::c_ushort,
            (*srv).errh,
        )
    {
        return -(1 as libc::c_int);
    }
    return 0 as libc::c_int;
}
unsafe extern "C" fn network_srv_sockets_append(
    mut srv: *mut server,
    mut srv_socket: *mut server_socket,
) {
    if (*srv).srv_sockets.used == (*srv).srv_sockets.size {
        (*srv).srv_sockets.size = ((*srv).srv_sockets.size as libc::c_uint)
            .wrapping_add(4 as libc::c_int as libc::c_uint)
            as uint32_t as uint32_t;
        (*srv).srv_sockets.ptr = realloc(
            (*srv).srv_sockets.ptr as *mut libc::c_void,
            ((*srv).srv_sockets.size as libc::c_ulong)
                .wrapping_mul(::core::mem::size_of::<*mut server_socket>() as libc::c_ulong),
        ) as *mut *mut server_socket;
        if ((*srv).srv_sockets.ptr).is_null() {
            ck_assert_failed(
                b"/home/kkysen/work/rust/lighttpd/src/network.c\0" as *const u8
                    as *const libc::c_char,
                169 as libc::c_int as libc::c_uint,
                b"((void*)0) != srv->srv_sockets.ptr\0" as *const u8 as *const libc::c_char,
            );
        }
    }
    let fresh67 = (*srv).srv_sockets.used;
    (*srv).srv_sockets.used = ((*srv).srv_sockets.used).wrapping_add(1);
    let ref mut fresh68 = *((*srv).srv_sockets.ptr).offset(fresh67 as isize);
    *fresh68 = srv_socket;
}
unsafe extern "C" fn network_merge_config_cpv(
    pconf: *mut network_socket_config,
    cpv: *const config_plugin_value_t,
) {
    match (*cpv).k_id {
        0 => {
            (*pconf).ssl_enabled =
                (0 as libc::c_int as libc::c_uint != (*cpv).v.u) as libc::c_int as libc::c_uchar;
        }
        1 => {
            (*pconf).listen_backlog = (*cpv).v.u as libc::c_int;
        }
        2 => {
            (*pconf).socket_perms = (*cpv).v.b;
        }
        3 => {
            (*pconf).bsd_accept_filter = (*cpv).v.b;
        }
        4 => {
            (*pconf).defer_accept =
                (0 as libc::c_int as libc::c_uint != (*cpv).v.u) as libc::c_int as libc::c_uchar;
        }
        5 => {
            (*pconf).use_ipv6 =
                (0 as libc::c_int as libc::c_uint != (*cpv).v.u) as libc::c_int as libc::c_uchar;
        }
        6 => {
            (*pconf).set_v6only =
                (0 as libc::c_int as libc::c_uint != (*cpv).v.u) as libc::c_int as libc::c_uchar;
        }
        7 => {
            (*pconf).v4mapped =
                (0 as libc::c_int as libc::c_uint != (*cpv).v.u) as libc::c_int as int8_t;
        }
        _ => return,
    };
}
unsafe extern "C" fn network_merge_config(
    pconf: *mut network_socket_config,
    mut cpv: *const config_plugin_value_t,
) {
    loop {
        network_merge_config_cpv(pconf, cpv);
        cpv = cpv.offset(1);
        if !((*cpv).k_id != -(1 as libc::c_int)) {
            break;
        }
    }
}
unsafe extern "C" fn network_srv_token_colon(b: *const buffer) -> uint8_t {
    let mut colon: *const libc::c_char = 0 as *const libc::c_char;
    let p: *const libc::c_char = (*b).ptr;
    if *p as libc::c_int == '[' as i32 {
        colon = strstr(p, b"]:\0" as *const u8 as *const libc::c_char);
        if !colon.is_null() {
            colon = colon.offset(1);
        }
    } else if *p as libc::c_int != '/' as i32 {
        colon = strchr(p, ':' as i32);
    }
    return (if !colon.is_null() {
        colon.offset_from(p) as libc::c_long as uint8_t as libc::c_int
    } else {
        buffer_clen(b) as uint8_t as libc::c_int
    }) as uint8_t;
}
unsafe extern "C" fn network_server_init(
    mut srv: *mut server,
    mut s: *mut network_socket_config,
    mut host_token: *mut buffer,
    mut sidx: size_t,
    mut stdin_fd: libc::c_int,
) -> libc::c_int {
    let mut srv_socket: *mut server_socket = 0 as *mut server_socket;
    let mut host: *const libc::c_char = 0 as *const libc::c_char;
    let mut addr_len: socklen_t = ::core::mem::size_of::<sock_addr>() as libc::c_ulong as socklen_t;
    let mut addr: sock_addr = sock_addr {
        ipv6: sockaddr_in6 {
            sin6_family: 0,
            sin6_port: 0,
            sin6_flowinfo: 0,
            sin6_addr: in6_addr {
                __in6_u: C2RustUnnamed_0 {
                    __u6_addr8: [0; 16],
                },
            },
            sin6_scope_id: 0,
        },
    };
    let mut family: libc::c_int = 0 as libc::c_int;
    let mut set_v6only: libc::c_int = 0 as libc::c_int;
    if buffer_is_blank(host_token) != 0 {
        log_error(
            (*srv).errh,
            b"/home/kkysen/work/rust/lighttpd/src/network.c\0" as *const u8 as *const libc::c_char,
            253 as libc::c_int as libc::c_uint,
            b"value of $SERVER[\"socket\"] must not be empty\0" as *const u8 as *const libc::c_char,
        );
        return -(1 as libc::c_int);
    }
    let mut i: uint32_t = 0 as libc::c_int as uint32_t;
    while i < (*srv).srv_sockets.used {
        if buffer_is_equal(
            (**((*srv).srv_sockets.ptr).offset(i as isize)).srv_token,
            host_token,
        ) != 0
        {
            return 0 as libc::c_int;
        }
        i = i.wrapping_add(1);
    }
    host = (*host_token).ptr;
    if (*s).use_ipv6 as libc::c_int != 0
        && (*host as libc::c_int == '\0' as i32 || *host as libc::c_int == ':' as i32)
        || *host.offset(0 as libc::c_int as isize) as libc::c_int == '[' as i32
            && *host.offset(1 as libc::c_int as isize) as libc::c_int == ']' as i32
    {
        log_error(
            (*srv).errh,
            b"/home/kkysen/work/rust/lighttpd/src/network.c\0" as *const u8
                as *const libc::c_char,
            269 as libc::c_int as libc::c_uint,
            b"warning: please use server.use-ipv6 only for hostnames, not without server.bind / empty address; your config will break if the kernel default for IPV6_V6ONLY changes\0"
                as *const u8 as *const libc::c_char,
        );
    }
    if *host as libc::c_int == '[' as i32 {
        (*s).use_ipv6 = 1 as libc::c_int as libc::c_uchar;
    }
    memset(
        &mut addr as *mut sock_addr as *mut libc::c_void,
        0 as libc::c_int,
        ::core::mem::size_of::<sock_addr>() as libc::c_ulong,
    );
    if -(1 as libc::c_int) != stdin_fd {
        if -(1 as libc::c_int)
            == getsockname(
                stdin_fd,
                __SOCKADDR_ARG {
                    __sockaddr__: &mut addr as *mut sock_addr as *mut sockaddr,
                },
                &mut addr_len,
            )
        {
            log_perror(
                (*srv).errh,
                b"/home/kkysen/work/rust/lighttpd/src/network.c\0" as *const u8
                    as *const libc::c_char,
                279 as libc::c_int as libc::c_uint,
                b"getsockname()\0" as *const u8 as *const libc::c_char,
            );
            return -(1 as libc::c_int);
        }
    } else if 0 as libc::c_int
        != network_host_parse_addr(
            srv,
            &mut addr,
            &mut addr_len,
            host_token,
            (*s).use_ipv6 as libc::c_int,
        )
    {
        return -(1 as libc::c_int);
    }
    family = sock_addr_get_family(&mut addr);
    if *host as libc::c_int != '\0' as i32 && 10 as libc::c_int == family {
        if (*s).set_v6only != 0 {
            set_v6only = 1 as libc::c_int;
        } else {
            log_error(
                (*srv).errh,
                b"/home/kkysen/work/rust/lighttpd/src/network.c\0" as *const u8
                    as *const libc::c_char,
                293 as libc::c_int as libc::c_uint,
                b"warning: server.set-v6only will be removed soon, update your config to have different sockets for ipv4 and ipv6\0"
                    as *const u8 as *const libc::c_char,
            );
        }
    }
    if 10 as libc::c_int == family && -(1 as libc::c_int) != (*s).v4mapped as libc::c_int {
        set_v6only = if (*s).v4mapped as libc::c_int != 0 {
            -(1 as libc::c_int)
        } else {
            1 as libc::c_int
        };
    }
    network_host_normalize_addr_str(host_token, &mut addr);
    host = (*host_token).ptr;
    if (*srv).srvconf.preflight_check != 0 {
        return 0 as libc::c_int;
    }
    let mut i_0: uint32_t = 0 as libc::c_int as uint32_t;
    while i_0 < (*srv).srv_sockets.used {
        if 0 as libc::c_int
            == memcmp(
                &mut (**((*srv).srv_sockets.ptr).offset(i_0 as isize)).addr as *mut sock_addr
                    as *const libc::c_void,
                &mut addr as *mut sock_addr as *const libc::c_void,
                ::core::mem::size_of::<sock_addr>() as libc::c_ulong,
            )
        {
            return 0 as libc::c_int;
        }
        i_0 = i_0.wrapping_add(1);
    }
    srv_socket = calloc(
        1 as libc::c_int as libc::c_ulong,
        ::core::mem::size_of::<server_socket>() as libc::c_ulong,
    ) as *mut server_socket;
    if srv_socket.is_null() {
        ck_assert_failed(
            b"/home/kkysen/work/rust/lighttpd/src/network.c\0" as *const u8 as *const libc::c_char,
            318 as libc::c_int as libc::c_uint,
            b"((void*)0) != srv_socket\0" as *const u8 as *const libc::c_char,
        );
    }
    memcpy(
        &mut (*srv_socket).addr as *mut sock_addr as *mut libc::c_void,
        &mut addr as *mut sock_addr as *const libc::c_void,
        addr_len as libc::c_ulong,
    );
    (*srv_socket).fd = -(1 as libc::c_int);
    (*srv_socket).sidx = sidx as libc::c_ushort;
    (*srv_socket).is_ssl = (*s).ssl_enabled;
    (*srv_socket).srv = srv;
    (*srv_socket).srv_token = buffer_init();
    buffer_copy_buffer((*srv_socket).srv_token, host_token);
    (*srv_socket).srv_token_colon = network_srv_token_colon((*srv_socket).srv_token);
    network_srv_sockets_append(srv, srv_socket);
    if (*srv).sockets_disabled != 0 {
        return 0 as libc::c_int;
    }
    if (*srv).srvconf.systemd_socket_activation != 0 {
        let mut i_1: uint32_t = 0 as libc::c_int as uint32_t;
        while i_1 < (*srv).srv_sockets_inherited.used {
            if 0 as libc::c_int
                != memcmp(
                    &mut (**((*srv).srv_sockets_inherited.ptr).offset(i_1 as isize)).addr
                        as *mut sock_addr as *const libc::c_void,
                    &mut (*srv_socket).addr as *mut sock_addr as *const libc::c_void,
                    addr_len as libc::c_ulong,
                )
            {
                i_1 = i_1.wrapping_add(1);
            } else {
                if !(0 as libc::c_uint) as libc::c_ushort as libc::c_int
                    == (**((*srv).srv_sockets_inherited.ptr).offset(i_1 as isize)).sidx
                        as libc::c_int
                {
                    (**((*srv).srv_sockets_inherited.ptr).offset(i_1 as isize)).sidx =
                        sidx as libc::c_ushort;
                }
                stdin_fd = (**((*srv).srv_sockets_inherited.ptr).offset(i_1 as isize)).fd;
                break;
            }
        }
    }
    if -(1 as libc::c_int) != stdin_fd {
        (*srv_socket).fd = stdin_fd;
        if -(1 as libc::c_int) == fdevent_fcntl_set_nb_cloexec(stdin_fd) {
            log_perror(
                (*srv).errh,
                b"/home/kkysen/work/rust/lighttpd/src/network.c\0" as *const u8
                    as *const libc::c_char,
                348 as libc::c_int as libc::c_uint,
                b"fcntl\0" as *const u8 as *const libc::c_char,
            );
            return -(1 as libc::c_int);
        }
    } else if 1 as libc::c_int == family {
        if host.is_null() {
            ck_assert_failed(
                b"/home/kkysen/work/rust/lighttpd/src/network.c\0" as *const u8
                    as *const libc::c_char,
                355 as libc::c_int as libc::c_uint,
                b"host\0" as *const u8 as *const libc::c_char,
            );
        }
        (*srv_socket).fd = fdevent_socket_cloexec(
            1 as libc::c_int,
            SOCK_STREAM as libc::c_int,
            0 as libc::c_int,
        );
        if -(1 as libc::c_int) == (*srv_socket).fd {
            log_perror(
                (*srv).errh,
                b"/home/kkysen/work/rust/lighttpd/src/network.c\0" as *const u8
                    as *const libc::c_char,
                357 as libc::c_int as libc::c_uint,
                b"socket\0" as *const u8 as *const libc::c_char,
            );
            return -(1 as libc::c_int);
        }
        if 0 as libc::c_int
            == connect(
                (*srv_socket).fd,
                __CONST_SOCKADDR_ARG {
                    __sockaddr__: &mut (*srv_socket).addr as *mut sock_addr as *mut sockaddr,
                },
                addr_len,
            )
        {
            log_error(
                (*srv).errh,
                b"/home/kkysen/work/rust/lighttpd/src/network.c\0" as *const u8
                    as *const libc::c_char,
                361 as libc::c_int as libc::c_uint,
                b"server socket is still in use: %s\0" as *const u8 as *const libc::c_char,
                host,
            );
            return -(1 as libc::c_int);
        }
        match *__errno_location() {
            111 => {
                unlink(host);
            }
            2 => {}
            _ => {
                log_perror(
                    (*srv).errh,
                    b"/home/kkysen/work/rust/lighttpd/src/network.c\0" as *const u8
                        as *const libc::c_char,
                    374 as libc::c_int as libc::c_uint,
                    b"testing socket failed: %s\0" as *const u8 as *const libc::c_char,
                    host,
                );
                return -(1 as libc::c_int);
            }
        }
        if -(1 as libc::c_int) == fdevent_fcntl_set_nb((*srv_socket).fd) {
            log_perror(
                (*srv).errh,
                b"/home/kkysen/work/rust/lighttpd/src/network.c\0" as *const u8
                    as *const libc::c_char,
                380 as libc::c_int as libc::c_uint,
                b"fcntl\0" as *const u8 as *const libc::c_char,
            );
            return -(1 as libc::c_int);
        }
    } else {
        (*srv_socket).fd = fdevent_socket_nb_cloexec(
            family,
            SOCK_STREAM as libc::c_int,
            IPPROTO_TCP as libc::c_int,
        );
        if -(1 as libc::c_int) == (*srv_socket).fd {
            log_perror(
                (*srv).errh,
                b"/home/kkysen/work/rust/lighttpd/src/network.c\0" as *const u8
                    as *const libc::c_char,
                387 as libc::c_int as libc::c_uint,
                b"socket\0" as *const u8 as *const libc::c_char,
            );
            return -(1 as libc::c_int);
        }
        if set_v6only != 0 {
            let mut val: libc::c_int = (set_v6only > 0 as libc::c_int) as libc::c_int;
            if -(1 as libc::c_int)
                == setsockopt(
                    (*srv_socket).fd,
                    IPPROTO_IPV6 as libc::c_int,
                    26 as libc::c_int,
                    &mut val as *mut libc::c_int as *const libc::c_void,
                    ::core::mem::size_of::<libc::c_int>() as libc::c_ulong as socklen_t,
                )
            {
                log_perror(
                    (*srv).errh,
                    b"/home/kkysen/work/rust/lighttpd/src/network.c\0" as *const u8
                        as *const libc::c_char,
                    395 as libc::c_int as libc::c_uint,
                    b"setsockopt(IPV6_V6ONLY)\0" as *const u8 as *const libc::c_char,
                );
                return -(1 as libc::c_int);
            }
        }
    }
    (*srv).cur_fds = (*srv_socket).fd;
    if fdevent_set_so_reuseaddr((*srv_socket).fd, 1 as libc::c_int) < 0 as libc::c_int {
        log_perror(
            (*srv).errh,
            b"/home/kkysen/work/rust/lighttpd/src/network.c\0" as *const u8 as *const libc::c_char,
            406 as libc::c_int as libc::c_uint,
            b"setsockopt(SO_REUSEADDR)\0" as *const u8 as *const libc::c_char,
        );
        return -(1 as libc::c_int);
    }
    if family != 1 as libc::c_int {
        if fdevent_set_tcp_nodelay((*srv_socket).fd, 1 as libc::c_int) < 0 as libc::c_int {
            log_perror(
                (*srv).errh,
                b"/home/kkysen/work/rust/lighttpd/src/network.c\0" as *const u8
                    as *const libc::c_char,
                412 as libc::c_int as libc::c_uint,
                b"setsockopt(TCP_NODELAY)\0" as *const u8 as *const libc::c_char,
            );
            return -(1 as libc::c_int);
        }
    }
    if !(-(1 as libc::c_int) != stdin_fd) {
        if 0 as libc::c_int
            != bind(
                (*srv_socket).fd,
                __CONST_SOCKADDR_ARG {
                    __sockaddr__: &mut (*srv_socket).addr as *mut sock_addr as *mut sockaddr,
                },
                addr_len,
            )
        {
            log_perror(
                (*srv).errh,
                b"/home/kkysen/work/rust/lighttpd/src/network.c\0" as *const u8
                    as *const libc::c_char,
                419 as libc::c_int as libc::c_uint,
                b"can't bind to socket: %s\0" as *const u8 as *const libc::c_char,
                host,
            );
            return -(1 as libc::c_int);
        }
    }
    if !(-(1 as libc::c_int) != stdin_fd) {
        if 1 as libc::c_int == family && !((*s).socket_perms).is_null() {
            let mut m: mode_t = 0 as libc::c_int as mode_t;
            let mut str: *mut libc::c_char = (*(*s).socket_perms).ptr;
            while *str != 0 {
                m <<= 3 as libc::c_int;
                m |= (*str as libc::c_int - '0' as i32) as libc::c_uint;
                str = str.offset(1);
            }
            if 0 as libc::c_int as libc::c_uint != m && -(1 as libc::c_int) == chmod(host, m) {
                log_perror(
                    (*srv).errh,
                    b"/home/kkysen/work/rust/lighttpd/src/network.c\0" as *const u8
                        as *const libc::c_char,
                    432 as libc::c_int as libc::c_uint,
                    b"chmod(\"%s\", %s)\0" as *const u8 as *const libc::c_char,
                    host,
                    (*(*s).socket_perms).ptr,
                );
                return -(1 as libc::c_int);
            }
        }
    }
    if !(-(1 as libc::c_int) != stdin_fd) {
        if -(1 as libc::c_int) == listen((*srv_socket).fd, (*s).listen_backlog) {
            log_perror(
                (*srv).errh,
                b"/home/kkysen/work/rust/lighttpd/src/network.c\0" as *const u8
                    as *const libc::c_char,
                440 as libc::c_int as libc::c_uint,
                b"listen\0" as *const u8 as *const libc::c_char,
            );
            return -(1 as libc::c_int);
        }
    }
    if !((*s).ssl_enabled != 0) {
        if (*s).defer_accept != 0 {
            let mut v: libc::c_int = (*s).defer_accept as libc::c_int;
            if -(1 as libc::c_int)
                == setsockopt(
                    (*srv_socket).fd,
                    IPPROTO_TCP as libc::c_int,
                    9 as libc::c_int,
                    &mut v as *mut libc::c_int as *const libc::c_void,
                    ::core::mem::size_of::<libc::c_int>() as libc::c_ulong as socklen_t,
                )
            {
                log_perror(
                    (*srv).errh,
                    b"/home/kkysen/work/rust/lighttpd/src/network.c\0" as *const u8
                        as *const libc::c_char,
                    450 as libc::c_int as libc::c_uint,
                    b"can't set TCP_DEFER_ACCEPT\0" as *const u8 as *const libc::c_char,
                );
            }
        }
    }
    return 0 as libc::c_int;
}
#[no_mangle]
#[cold]
pub unsafe extern "C" fn network_close(mut srv: *mut server) -> libc::c_int {
    let mut i: uint32_t = 0 as libc::c_int as uint32_t;
    while i < (*srv).srv_sockets.used {
        let mut srv_socket: *mut server_socket = *((*srv).srv_sockets.ptr).offset(i as isize);
        if (*srv_socket).fd != -(1 as libc::c_int) {
            network_unregister_sock(srv, srv_socket);
            close((*srv_socket).fd);
        }
        buffer_free((*srv_socket).srv_token);
        free(srv_socket as *mut libc::c_void);
        i = i.wrapping_add(1);
    }
    free((*srv).srv_sockets.ptr as *mut libc::c_void);
    (*srv).srv_sockets.ptr = 0 as *mut *mut server_socket;
    (*srv).srv_sockets.used = 0 as libc::c_int as uint32_t;
    (*srv).srv_sockets.size = 0 as libc::c_int as uint32_t;
    let mut i_0: uint32_t = 0 as libc::c_int as uint32_t;
    while i_0 < (*srv).srv_sockets_inherited.used {
        let mut srv_socket_0: *mut server_socket =
            *((*srv).srv_sockets_inherited.ptr).offset(i_0 as isize);
        if (*srv_socket_0).fd != -(1 as libc::c_int)
            && (*srv_socket_0).sidx as libc::c_int
                != !(0 as libc::c_uint) as libc::c_ushort as libc::c_int
        {
            close((*srv_socket_0).fd);
        }
        buffer_free((*srv_socket_0).srv_token);
        free(srv_socket_0 as *mut libc::c_void);
        i_0 = i_0.wrapping_add(1);
    }
    free((*srv).srv_sockets_inherited.ptr as *mut libc::c_void);
    (*srv).srv_sockets_inherited.ptr = 0 as *mut *mut server_socket;
    (*srv).srv_sockets_inherited.used = 0 as libc::c_int as uint32_t;
    (*srv).srv_sockets_inherited.size = 0 as libc::c_int as uint32_t;
    return 0 as libc::c_int;
}
#[no_mangle]
#[cold]
pub unsafe extern "C" fn network_socket_activation_to_env(srv: *mut server) {
    let mut fd: libc::c_int = 3 as libc::c_int;
    let mut n: uint32_t = 0 as libc::c_int as uint32_t;
    let mut i: uint32_t = 0;
    while n < (*srv).srv_sockets.used {
        let mut srv_socket: *mut server_socket = *((*srv).srv_sockets.ptr).offset(n as isize);
        if !((*srv_socket).fd < fd) {
            if (*srv_socket).fd == fd {
                fdevent_clrfd_cloexec(fd);
                fd += 1;
            } else {
                i = n.wrapping_add(1 as libc::c_int as libc::c_uint);
                while i < (*srv).srv_sockets.used {
                    if fd == (**((*srv).srv_sockets.ptr).offset(i as isize)).fd {
                        break;
                    }
                    i = i.wrapping_add(1);
                }
                if i < (*srv).srv_sockets.used {
                    fdevent_clrfd_cloexec(fd);
                    fd += 1;
                    n = n.wrapping_sub(1);
                } else if !(fd != dup2((*srv_socket).fd, fd)) {
                    fd += 1;
                }
            }
        }
        n = n.wrapping_add(1);
    }
    fd -= 3 as libc::c_int;
    if 0 as libc::c_int == fd {
        return;
    }
    let tb: *mut buffer = (*srv).tmp_buf;
    buffer_clear(tb);
    buffer_append_int(tb, fd as intmax_t);
    setenv(
        b"LISTEN_FDS\0" as *const u8 as *const libc::c_char,
        (*tb).ptr,
        1 as libc::c_int,
    );
    buffer_clear(tb);
    buffer_append_int(tb, (*srv).pid as intmax_t);
    setenv(
        b"LISTEN_PID\0" as *const u8 as *const libc::c_char,
        (*tb).ptr,
        1 as libc::c_int,
    );
}
unsafe extern "C" fn network_socket_activation_nfds(
    mut srv: *mut server,
    mut s: *mut network_socket_config,
    mut nfds: libc::c_int,
) -> libc::c_int {
    let mut host: *mut buffer = buffer_init();
    let mut addr_len: socklen_t = 0;
    let mut addr: sock_addr = sock_addr {
        ipv6: sockaddr_in6 {
            sin6_family: 0,
            sin6_port: 0,
            sin6_flowinfo: 0,
            sin6_addr: in6_addr {
                __in6_u: C2RustUnnamed_0 {
                    __u6_addr8: [0; 16],
                },
            },
            sin6_scope_id: 0,
        },
    };
    let mut rc: libc::c_int = 0 as libc::c_int;
    nfds += 3 as libc::c_int;
    let mut fd: libc::c_int = 3 as libc::c_int;
    while fd < nfds {
        addr_len = ::core::mem::size_of::<sock_addr>() as libc::c_ulong as socklen_t;
        rc = getsockname(
            fd,
            __SOCKADDR_ARG {
                __sockaddr__: &mut addr as *mut sock_addr as *mut sockaddr,
            },
            &mut addr_len,
        );
        if -(1 as libc::c_int) == rc {
            log_perror(
                (*srv).errh,
                b"/home/kkysen/work/rust/lighttpd/src/network.c\0" as *const u8
                    as *const libc::c_char,
                564 as libc::c_int as libc::c_uint,
                b"socket activation getsockname()\0" as *const u8 as *const libc::c_char,
            );
            break;
        } else {
            network_host_normalize_addr_str(host, &mut addr);
            rc = network_server_init(srv, s, host, 0 as libc::c_int as size_t, fd);
            if 0 as libc::c_int != rc {
                break;
            }
            (**((*srv).srv_sockets.ptr).offset(
                ((*srv).srv_sockets.used).wrapping_sub(1 as libc::c_int as libc::c_uint) as isize,
            ))
            .sidx = !(0 as libc::c_uint) as libc::c_ushort;
            fd += 1;
        }
    }
    buffer_free(host);
    memcpy(
        &mut (*srv).srv_sockets_inherited as *mut server_socket_array as *mut libc::c_void,
        &mut (*srv).srv_sockets as *mut server_socket_array as *const libc::c_void,
        ::core::mem::size_of::<server_socket_array>() as libc::c_ulong,
    );
    memset(
        &mut (*srv).srv_sockets as *mut server_socket_array as *mut libc::c_void,
        0 as libc::c_int,
        ::core::mem::size_of::<server_socket_array>() as libc::c_ulong,
    );
    return rc;
}
unsafe extern "C" fn network_socket_activation_from_env(
    mut srv: *mut server,
    mut s: *mut network_socket_config,
) -> libc::c_int {
    let mut listen_pid: *mut libc::c_char =
        getenv(b"LISTEN_PID\0" as *const u8 as *const libc::c_char);
    let mut listen_fds: *mut libc::c_char =
        getenv(b"LISTEN_FDS\0" as *const u8 as *const libc::c_char);
    let mut lpid: pid_t = if !listen_pid.is_null() {
        strtoul(listen_pid, 0 as *mut *mut libc::c_char, 10 as libc::c_int) as pid_t
    } else {
        0 as libc::c_int
    };
    let mut nfds: libc::c_int = if !listen_fds.is_null() {
        atoi(listen_fds)
    } else {
        0 as libc::c_int
    };
    let mut rc: libc::c_int = if nfds > 0 as libc::c_int
        && nfds < 5000 as libc::c_int
        && (lpid == getpid()
            || 0 as libc::c_int
                == strncmp(
                    listen_pid,
                    b"parent:\0" as *const u8 as *const libc::c_char,
                    7 as libc::c_int as libc::c_ulong,
                )
                && getppid()
                    == strtoul(
                        listen_pid.offset(7 as libc::c_int as isize),
                        0 as *mut *mut libc::c_char,
                        10 as libc::c_int,
                    ) as pid_t)
    {
        network_socket_activation_nfds(srv, s, nfds)
    } else {
        0 as libc::c_int
    };
    unsetenv(b"LISTEN_PID\0" as *const u8 as *const libc::c_char);
    unsetenv(b"LISTEN_FDS\0" as *const u8 as *const libc::c_char);
    unsetenv(b"LISTEN_FDNAMES\0" as *const u8 as *const libc::c_char);
    return rc;
}
static mut cpk: [config_plugin_keys_t; 9] = [config_plugin_keys_t {
    k: 0 as *const libc::c_char,
    klen: 0,
    ktype: 0,
    scope: 0,
}; 9];
#[no_mangle]
#[cold]
pub unsafe extern "C" fn network_init(
    mut srv: *mut server,
    mut stdin_fd: libc::c_int,
) -> libc::c_int {
    if 0 as libc::c_int != network_write_init(srv) {
        return -(1 as libc::c_int);
    }
    let mut np: network_plugin_data = network_plugin_data {
        id: 0,
        nconfig: 0,
        cvlist: 0 as *mut config_plugin_value_t,
        self_0: 0 as *mut plugin,
        defaults: network_socket_config {
            listen_backlog: 0,
            ssl_enabled: 0,
            use_ipv6: 0,
            set_v6only: 0,
            defer_accept: 0,
            v4mapped: 0,
            socket_perms: 0 as *const buffer,
            bsd_accept_filter: 0 as *const buffer,
        },
        conf: network_socket_config {
            listen_backlog: 0,
            ssl_enabled: 0,
            use_ipv6: 0,
            set_v6only: 0,
            defer_accept: 0,
            v4mapped: 0,
            socket_perms: 0 as *const buffer,
            bsd_accept_filter: 0 as *const buffer,
        },
    };
    memset(
        &mut np as *mut network_plugin_data as *mut libc::c_void,
        0 as libc::c_int,
        ::core::mem::size_of::<network_plugin_data>() as libc::c_ulong,
    );
    let mut p: *mut network_plugin_data = &mut np;
    if config_plugin_values_init(
        srv,
        p as *mut libc::c_void,
        cpk.as_ptr(),
        b"network\0" as *const u8 as *const libc::c_char,
    ) == 0
    {
        return HANDLER_ERROR as libc::c_int;
    }
    (*p).defaults.listen_backlog = 1024 as libc::c_int;
    (*p).defaults.defer_accept = 0 as libc::c_int as libc::c_uchar;
    (*p).defaults.use_ipv6 = 0 as libc::c_int as libc::c_uchar;
    (*p).defaults.set_v6only = 1 as libc::c_int as libc::c_uchar;
    (*p).defaults.v4mapped = -(1 as libc::c_int) as int8_t;
    if (*p).nconfig > 0 as libc::c_int && (*(*p).cvlist).v.u2[1 as libc::c_int as usize] != 0 {
        let mut cpv: *const config_plugin_value_t =
            ((*p).cvlist).offset((*(*p).cvlist).v.u2[0 as libc::c_int as usize] as isize);
        if -(1 as libc::c_int) != (*cpv).k_id {
            network_merge_config(&mut (*p).defaults, cpv);
        }
    }
    let mut rc: libc::c_int = 0 as libc::c_int;
    let mut current_block_53: u64;
    if (*srv).srvconf.systemd_socket_activation != 0 {
        let mut i: uint32_t = 0 as libc::c_int as uint32_t;
        while i < (*srv).srv_sockets_inherited.used {
            (**((*srv).srv_sockets_inherited.ptr).offset(i as isize)).sidx =
                !(0 as libc::c_uint) as libc::c_ushort;
            i = i.wrapping_add(1);
        }
        rc = network_socket_activation_from_env(srv, &mut (*p).defaults);
        if 0 as libc::c_int != rc {
            current_block_53 = 13660591889533726445;
        } else {
            if 0 as libc::c_int as libc::c_uint == (*srv).srv_sockets_inherited.used {
                (*srv).srvconf.systemd_socket_activation = 0 as libc::c_int as libc::c_uchar;
            }
            current_block_53 = 5601891728916014340;
        }
    } else {
        current_block_53 = 5601891728916014340;
    }
    match current_block_53 {
        5601891728916014340 => {
            if -(1 as libc::c_int) != stdin_fd {
                let mut b: *mut buffer = buffer_init();
                buffer_copy_buffer(b, (*srv).srvconf.bindhost);
                rc = if 0 as libc::c_int as libc::c_uint == (*srv).srv_sockets.used {
                    network_server_init(
                        srv,
                        &mut (*p).defaults,
                        b,
                        0 as libc::c_int as size_t,
                        stdin_fd,
                    )
                } else {
                    close(stdin_fd)
                };
                buffer_free(b);
                if 0 as libc::c_int != rc {
                    current_block_53 = 13660591889533726445;
                } else {
                    current_block_53 = 18386322304582297246;
                }
            } else {
                current_block_53 = 18386322304582297246;
            }
            match current_block_53 {
                13660591889533726445 => {}
                _ => {
                    let mut i_0: uint32_t = 1 as libc::c_int as uint32_t;
                    while i_0 < (*(*srv).config_context).used {
                        let mut cfginfo: config_cond_info = config_cond_info {
                            comp: COMP_UNSET,
                            cond: CONFIG_COND_UNSET,
                            string: 0 as *const buffer,
                            comp_key: 0 as *const libc::c_char,
                        };
                        config_get_config_cond_info(&mut cfginfo, i_0);
                        if !(COMP_SERVER_SOCKET as libc::c_int as libc::c_uint
                            != cfginfo.comp as libc::c_uint)
                        {
                            let mut host_token: *mut buffer = 0 as *mut buffer;
                            let ref mut fresh69 =
                                *(&mut host_token as *mut *mut buffer as *mut *const buffer);
                            *fresh69 = cfginfo.string;
                            memcpy(
                                &mut (*p).conf as *mut network_socket_config as *mut libc::c_void,
                                &mut (*p).defaults as *mut network_socket_config
                                    as *const libc::c_void,
                                ::core::mem::size_of::<network_socket_config>() as libc::c_ulong,
                            );
                            let mut j: libc::c_int =
                                ((*((*p).cvlist).offset(0 as libc::c_int as isize)).v.u2
                                    [1 as libc::c_int as usize]
                                    == 0) as libc::c_int;
                            while j < (*p).nconfig {
                                if i_0 as libc::c_int != (*((*p).cvlist).offset(j as isize)).k_id {
                                    j += 1;
                                } else {
                                    let mut cpv_0: *const config_plugin_value_t = ((*p).cvlist)
                                        .offset(
                                            (*((*p).cvlist).offset(j as isize)).v.u2
                                                [0 as libc::c_int as usize]
                                                as isize,
                                        );
                                    network_merge_config(&mut (*p).conf, cpv_0);
                                    break;
                                }
                            }
                            if cfginfo.cond as libc::c_uint
                                == CONFIG_COND_EQ as libc::c_int as libc::c_uint
                            {
                                rc = network_server_init(
                                    srv,
                                    &mut (*p).conf,
                                    host_token,
                                    i_0 as size_t,
                                    -(1 as libc::c_int),
                                );
                                if 0 as libc::c_int != rc {
                                    break;
                                }
                            } else if cfginfo.cond as libc::c_uint
                                == CONFIG_COND_NE as libc::c_int as libc::c_uint
                            {
                                let mut addr_len: socklen_t = ::core::mem::size_of::<sock_addr>()
                                    as libc::c_ulong
                                    as socklen_t;
                                let mut addr: sock_addr = sock_addr {
                                    ipv6: sockaddr_in6 {
                                        sin6_family: 0,
                                        sin6_port: 0,
                                        sin6_flowinfo: 0,
                                        sin6_addr: in6_addr {
                                            __in6_u: C2RustUnnamed_0 {
                                                __u6_addr8: [0; 16],
                                            },
                                        },
                                        sin6_scope_id: 0,
                                    },
                                };
                                rc = network_host_parse_addr(
                                    srv,
                                    &mut addr,
                                    &mut addr_len,
                                    host_token,
                                    (*p).conf.use_ipv6 as libc::c_int,
                                );
                                if 0 as libc::c_int != rc {
                                    break;
                                }
                                network_host_normalize_addr_str(host_token, &mut addr);
                            }
                        }
                        i_0 = i_0.wrapping_add(1);
                    }
                    if !(0 as libc::c_int != rc) {
                        if ((*srv).srvconf.systemd_socket_activation == 0
                            || !((*srv).srvconf.bindhost).is_null())
                            && -(1 as libc::c_int) == stdin_fd
                        {
                            let mut b_0: *mut buffer = buffer_init();
                            if !((*srv).srvconf.bindhost).is_null() {
                                buffer_copy_buffer(b_0, (*srv).srvconf.bindhost);
                            }
                            if ((*b_0).ptr).is_null()
                                || *((*b_0).ptr).offset(0 as libc::c_int as isize) as libc::c_int
                                    != '/' as i32
                            {
                                buffer_append_string_len(
                                    b_0,
                                    b":\0" as *const u8 as *const libc::c_char,
                                    (::core::mem::size_of::<[libc::c_char; 2]>() as libc::c_ulong
                                        as uint32_t)
                                        .wrapping_sub(1 as libc::c_int as libc::c_uint)
                                        as size_t,
                                );
                                buffer_append_int(b_0, (*srv).srvconf.port as intmax_t);
                            }
                            rc = network_server_init(
                                srv,
                                &mut (*p).defaults,
                                b_0,
                                0 as libc::c_int as size_t,
                                -(1 as libc::c_int),
                            );
                            buffer_free(b_0);
                            if 0 as libc::c_int != rc {
                                current_block_53 = 13660591889533726445;
                            } else {
                                current_block_53 = 1724319918354933278;
                            }
                        } else {
                            current_block_53 = 1724319918354933278;
                        }
                        match current_block_53 {
                            13660591889533726445 => {}
                            _ => {
                                if (*srv).srvconf.systemd_socket_activation != 0 {
                                    let mut srv_socket: *mut server_socket =
                                        0 as *mut server_socket;
                                    let mut i_1: uint32_t = 0 as libc::c_int as uint32_t;
                                    while i_1 < (*srv).srv_sockets_inherited.used {
                                        if !(!(0 as libc::c_uint) as libc::c_ushort as libc::c_int
                                            != (**((*srv).srv_sockets_inherited.ptr)
                                                .offset(i_1 as isize))
                                            .sidx
                                                as libc::c_int)
                                        {
                                            (**((*srv).srv_sockets_inherited.ptr)
                                                .offset(i_1 as isize))
                                            .sidx = 0 as libc::c_int as libc::c_ushort;
                                            srv_socket = calloc(
                                                1 as libc::c_int as libc::c_ulong,
                                                ::core::mem::size_of::<server_socket>()
                                                    as libc::c_ulong,
                                            )
                                                as *mut server_socket;
                                            if srv_socket.is_null() {
                                                ck_assert_failed(
                                                    b"/home/kkysen/work/rust/lighttpd/src/network.c\0"
                                                        as *const u8 as *const libc::c_char,
                                                    764 as libc::c_int as libc::c_uint,
                                                    b"((void*)0) != srv_socket\0" as *const u8
                                                        as *const libc::c_char,
                                                );
                                            }
                                            memcpy(
                                                srv_socket as *mut libc::c_void,
                                                *((*srv).srv_sockets_inherited.ptr)
                                                    .offset(i_1 as isize)
                                                    as *const libc::c_void,
                                                ::core::mem::size_of::<server_socket>()
                                                    as libc::c_ulong,
                                            );
                                            let srv_token: *const buffer = (*srv_socket).srv_token;
                                            (*srv_socket).srv_token = buffer_init();
                                            buffer_copy_buffer((*srv_socket).srv_token, srv_token);
                                            (*srv_socket).srv_token_colon =
                                                network_srv_token_colon((*srv_socket).srv_token);
                                            network_srv_sockets_append(srv, srv_socket);
                                        }
                                        i_1 = i_1.wrapping_add(1);
                                    }
                                }
                            }
                        }
                    }
                }
            }
        }
        _ => {}
    }
    free((*p).cvlist as *mut libc::c_void);
    return rc;
}
#[no_mangle]
#[cold]
pub unsafe extern "C" fn network_unregister_sock(
    mut srv: *mut server,
    mut srv_socket: *mut server_socket,
) {
    let mut fdn: *mut fdnode = (*srv_socket).fdn;
    if fdn.is_null() {
        return;
    }
    fdevent_fdnode_event_del((*srv).ev, fdn);
    fdevent_unregister((*srv).ev, (*fdn).fd);
    (*srv_socket).fdn = 0 as *mut fdnode;
}
#[no_mangle]
#[cold]
pub unsafe extern "C" fn network_register_fdevents(mut srv: *mut server) -> libc::c_int {
    if -(1 as libc::c_int) == fdevent_reset((*srv).ev) {
        return -(1 as libc::c_int);
    }
    if (*srv).sockets_disabled != 0 {
        return 0 as libc::c_int;
    }
    let mut i: uint32_t = 0 as libc::c_int as uint32_t;
    while i < (*srv).srv_sockets.used {
        let mut srv_socket: *mut server_socket = *((*srv).srv_sockets.ptr).offset(i as isize);
        (*srv_socket).fdn = fdevent_register(
            (*srv).ev,
            (*srv_socket).fd,
            Some(
                network_server_handle_fdevent
                    as unsafe extern "C" fn(*mut libc::c_void, libc::c_int) -> handler_t,
            ),
            srv_socket as *mut libc::c_void,
        );
        fdevent_fdnode_event_set((*srv).ev, (*srv_socket).fdn, 0x1 as libc::c_int);
        i = i.wrapping_add(1);
    }
    return 0 as libc::c_int;
}
unsafe extern "C" fn network_write_accounting(
    fd: libc::c_int,
    cq: *mut chunkqueue,
    p_max_bytes: *mut off_t,
    errh: *mut log_error_st,
    wr: ssize_t,
    toSend: off_t,
) -> libc::c_int {
    if wr >= 0 as libc::c_int as libc::c_long {
        *p_max_bytes -= wr;
        let rc: libc::c_int = if wr == toSend && *p_max_bytes > 0 as libc::c_int as libc::c_long {
            0 as libc::c_int
        } else {
            -(3 as libc::c_int)
        };
        chunkqueue_mark_written(cq, wr);
        return rc;
    } else {
        return network_write_error(fd, errh);
    };
}
#[cold]
unsafe extern "C" fn network_remove_finished_chunks(
    cq: *mut chunkqueue,
    len: off_t,
) -> libc::c_int {
    if !(len >= 0 as libc::c_int as libc::c_long) {
        ck_assert_failed(
            b"/home/kkysen/work/rust/lighttpd/src/network_write.c\0" as *const u8
                as *const libc::c_char,
            104 as libc::c_int as libc::c_uint,
            b"len >= 0\0" as *const u8 as *const libc::c_char,
        );
    }
    chunkqueue_remove_finished_chunks(cq);
    return 0 as libc::c_int;
}
#[inline]
unsafe extern "C" fn network_write_data_len(
    mut fd: libc::c_int,
    mut data: *const libc::c_char,
    mut len: off_t,
) -> ssize_t {
    return write(fd, data as *const libc::c_void, len as size_t);
}
#[cold]
unsafe extern "C" fn network_write_error(
    mut fd: libc::c_int,
    mut errh: *mut log_error_st,
) -> libc::c_int {
    match *__errno_location() {
        11 | 4 => return -(3 as libc::c_int),
        32 | 104 => return -(2 as libc::c_int),
        _ => {
            log_perror(
                errh,
                b"/home/kkysen/work/rust/lighttpd/src/network_write.c\0" as *const u8
                    as *const libc::c_char,
                96 as libc::c_int as libc::c_uint,
                b"write failed: %d\0" as *const u8 as *const libc::c_char,
                fd,
            );
            return -(1 as libc::c_int);
        }
    };
}
unsafe extern "C" fn network_write_file_chunk_no_mmap(
    fd: libc::c_int,
    cq: *mut chunkqueue,
    p_max_bytes: *mut off_t,
    errh: *mut log_error_st,
) -> libc::c_int {
    let c: *mut chunk = (*cq).first;
    let mut offset: off_t = 0;
    let mut toSend: off_t = 0;
    let mut buf: [libc::c_char; 16384] = [0; 16384];
    offset = (*c).offset;
    toSend = (*c).file.length - (*c).offset;
    if toSend > *p_max_bytes {
        toSend = *p_max_bytes;
    }
    if toSend <= 0 as libc::c_int as libc::c_long {
        return network_remove_finished_chunks(cq, toSend);
    }
    if (*c).file.fd < 0 as libc::c_int && 0 as libc::c_int != chunkqueue_open_file_chunk(cq, errh) {
        return -(1 as libc::c_int);
    }
    if toSend > ::core::mem::size_of::<[libc::c_char; 16384]>() as libc::c_ulong as off_t {
        toSend = ::core::mem::size_of::<[libc::c_char; 16384]>() as libc::c_ulong as off_t;
    }
    toSend = pread(
        (*c).file.fd,
        buf.as_mut_ptr() as *mut libc::c_void,
        toSend as size_t,
        offset,
    );
    if toSend <= 0 as libc::c_int as libc::c_long {
        log_perror(
            errh,
            b"/home/kkysen/work/rust/lighttpd/src/network_write.c\0" as *const u8
                as *const libc::c_char,
            176 as libc::c_int as libc::c_uint,
            b"read\0" as *const u8 as *const libc::c_char,
        );
        return -(1 as libc::c_int);
    }
    let mut wr: ssize_t = network_write_data_len(fd, buf.as_mut_ptr(), toSend);
    return network_write_accounting(fd, cq, p_max_bytes, errh, wr, toSend);
}
unsafe extern "C" fn network_writev_mem_chunks(
    fd: libc::c_int,
    cq: *mut chunkqueue,
    p_max_bytes: *mut off_t,
    errh: *mut log_error_st,
) -> libc::c_int {
    let mut num_chunks: size_t = 0 as libc::c_int as size_t;
    let mut toSend: off_t = 0 as libc::c_int as off_t;
    let mut chunks_0: [iovec; 32] = [iovec {
        iov_base: 0 as *mut libc::c_void,
        iov_len: 0,
    }; 32];
    let mut c: *const chunk = (*cq).first;
    while !c.is_null() && MEM_CHUNK as libc::c_int as libc::c_uint == (*c).type_0 as libc::c_uint {
        let c_len: off_t = buffer_clen((*c).mem) as off_t - (*c).offset;
        if c_len > 0 as libc::c_int as libc::c_long {
            toSend += c_len;
            chunks_0[num_chunks as usize].iov_base =
                ((*(*c).mem).ptr).offset((*c).offset as isize) as *mut libc::c_void;
            chunks_0[num_chunks as usize].iov_len = c_len as size_t;
            num_chunks = num_chunks.wrapping_add(1);
            if num_chunks == 32 as libc::c_int as libc::c_ulong || toSend >= *p_max_bytes {
                break;
            }
        } else if c_len < 0 as libc::c_int as libc::c_long {
            return network_remove_finished_chunks(cq, c_len);
        }
        c = (*c).next;
    }
    if 0 as libc::c_int as libc::c_ulong == num_chunks {
        return network_remove_finished_chunks(cq, 0 as libc::c_int as off_t);
    }
    let mut wr: ssize_t = writev(fd, chunks_0.as_mut_ptr(), num_chunks as libc::c_int);
    return network_write_accounting(fd, cq, p_max_bytes, errh, wr, toSend);
}
unsafe extern "C" fn network_write_file_chunk_sendfile(
    fd: libc::c_int,
    cq: *mut chunkqueue,
    p_max_bytes: *mut off_t,
    errh: *mut log_error_st,
) -> libc::c_int {
    let c: *mut chunk = (*cq).first;
    let mut wr: ssize_t = 0;
    let mut offset: off_t = 0;
    let mut toSend: off_t = 0;
    let mut written: off_t = 0 as libc::c_int as off_t;
    offset = (*c).offset;
    toSend = (*c).file.length - (*c).offset;
    if toSend > *p_max_bytes {
        toSend = *p_max_bytes;
    }
    if toSend <= 0 as libc::c_int as libc::c_long {
        return network_remove_finished_chunks(cq, toSend);
    }
    if (*c).file.fd < 0 as libc::c_int && 0 as libc::c_int != chunkqueue_open_file_chunk(cq, errh) {
        return -(1 as libc::c_int);
    }
    wr = sendfile(fd, (*c).file.fd, &mut offset, toSend as size_t);
    if wr > 0 as libc::c_int as libc::c_long {
        written = wr;
    }
    if -(1 as libc::c_int) as libc::c_long == wr {
        match *__errno_location() {
            11 | 4 => {}
            32 | 104 | 107 => return -(2 as libc::c_int),
            22 | 38 | 95 | 94 | 97 => {
                return network_write_file_chunk_no_mmap(fd, cq, p_max_bytes, errh);
            }
            _ => {
                log_perror(
                    errh,
                    b"/home/kkysen/work/rust/lighttpd/src/network_write.c\0" as *const u8
                        as *const libc::c_char,
                    479 as libc::c_int as libc::c_uint,
                    b"sendfile(): fd: %d\0" as *const u8 as *const libc::c_char,
                    fd,
                );
                return -(1 as libc::c_int);
            }
        }
    }
    if written > 0 as libc::c_int as libc::c_long {
        chunkqueue_mark_written(cq, written);
        *p_max_bytes -= written;
        if (*p_max_bytes <= 0 as libc::c_int as libc::c_long) as libc::c_int as libc::c_long != 0 {
            return -(3 as libc::c_int);
        }
    } else if 0 as libc::c_int as libc::c_long == wr {
        log_error(
            errh,
            b"/home/kkysen/work/rust/lighttpd/src/network_write.c\0" as *const u8
                as *const libc::c_char,
            490 as libc::c_int as libc::c_uint,
            b"sendfile(): fd: %d file truncated\0" as *const u8 as *const libc::c_char,
            fd,
        );
        return -(1 as libc::c_int);
    }
    return if wr >= 0 as libc::c_int as libc::c_long && written == toSend {
        0 as libc::c_int
    } else {
        -(3 as libc::c_int)
    };
}
unsafe extern "C" fn network_write_chunkqueue_writev(
    fd: libc::c_int,
    cq: *mut chunkqueue,
    mut max_bytes: off_t,
    errh: *mut log_error_st,
) -> libc::c_int {
    while !((*cq).first).is_null() {
        let mut rc: libc::c_int = -(1 as libc::c_int);
        match (*(*cq).first).type_0 as libc::c_uint {
            0 => {
                rc = network_writev_mem_chunks(fd, cq, &mut max_bytes, errh);
            }
            1 => {
                rc = network_write_file_chunk_no_mmap(fd, cq, &mut max_bytes, errh);
            }
            _ => {}
        }
        if (0 as libc::c_int != rc) as libc::c_int as libc::c_long != 0 {
            return if -(3 as libc::c_int) == rc {
                0 as libc::c_int
            } else {
                rc
            };
        }
    }
    return 0 as libc::c_int;
}
unsafe extern "C" fn network_write_chunkqueue_sendfile(
    fd: libc::c_int,
    cq: *mut chunkqueue,
    mut max_bytes: off_t,
    errh: *mut log_error_st,
) -> libc::c_int {
    while !((*cq).first).is_null() {
        let mut rc: libc::c_int = -(1 as libc::c_int);
        match (*(*cq).first).type_0 as libc::c_uint {
            0 => {
                rc = network_writev_mem_chunks(fd, cq, &mut max_bytes, errh);
            }
            1 => {
                rc = network_write_file_chunk_sendfile(fd, cq, &mut max_bytes, errh);
            }
            _ => {}
        }
        if (0 as libc::c_int != rc) as libc::c_int as libc::c_long != 0 {
            return if -(3 as libc::c_int) == rc {
                0 as libc::c_int
            } else {
                rc
            };
        }
    }
    return 0 as libc::c_int;
}
#[no_mangle]
#[cold]
pub unsafe extern "C" fn network_write_init(mut srv: *mut server) -> libc::c_int {
    let mut backend: network_backend_t = NETWORK_BACKEND_UNSET;
    let mut network_backends: [nb_map; 7] = [
        {
            let mut init = nb_map {
                nb: NETWORK_BACKEND_SENDFILE,
                name: b"sendfile\0" as *const u8 as *const libc::c_char,
            };
            init
        },
        {
            let mut init = nb_map {
                nb: NETWORK_BACKEND_SENDFILE,
                name: b"linux-sendfile\0" as *const u8 as *const libc::c_char,
            };
            init
        },
        {
            let mut init = nb_map {
                nb: NETWORK_BACKEND_SENDFILE,
                name: b"freebsd-sendfile\0" as *const u8 as *const libc::c_char,
            };
            init
        },
        {
            let mut init = nb_map {
                nb: NETWORK_BACKEND_SENDFILE,
                name: b"solaris-sendfilev\0" as *const u8 as *const libc::c_char,
            };
            init
        },
        {
            let mut init = nb_map {
                nb: NETWORK_BACKEND_WRITEV,
                name: b"writev\0" as *const u8 as *const libc::c_char,
            };
            init
        },
        {
            let mut init = nb_map {
                nb: NETWORK_BACKEND_WRITE,
                name: b"write\0" as *const u8 as *const libc::c_char,
            };
            init
        },
        {
            let mut init = nb_map {
                nb: NETWORK_BACKEND_UNSET,
                name: 0 as *const libc::c_char,
            };
            init
        },
    ];
    backend = network_backends[0 as libc::c_int as usize].nb;
    if !((*srv).srvconf.network_backend).is_null() {
        let mut name: *const libc::c_char = 0 as *const libc::c_char;
        let mut confname: *const libc::c_char = (*(*srv).srvconf.network_backend).ptr;
        let mut i: size_t = 0 as libc::c_int as size_t;
        loop {
            name = network_backends[i as usize].name;
            if name.is_null() {
                break;
            }
            if 0 as libc::c_int == strcmp(confname, name) {
                backend = network_backends[i as usize].nb;
                break;
            } else {
                i = i.wrapping_add(1);
            }
        }
        if name.is_null() {
            log_error(
                (*srv).errh,
                b"/home/kkysen/work/rust/lighttpd/src/network_write.c\0" as *const u8
                    as *const libc::c_char,
                604 as libc::c_int as libc::c_uint,
                b"server.network-backend has an unknown value: %s\0" as *const u8
                    as *const libc::c_char,
                confname,
            );
            return -(1 as libc::c_int);
        }
    }
    match backend as libc::c_uint {
        3 => {
            (*srv).network_backend_write = Some(
                network_write_chunkqueue_sendfile
                    as unsafe extern "C" fn(
                        libc::c_int,
                        *mut chunkqueue,
                        off_t,
                        *mut log_error_st,
                    ) -> libc::c_int,
            );
        }
        2 | 1 => {
            (*srv).network_backend_write = Some(
                network_write_chunkqueue_writev
                    as unsafe extern "C" fn(
                        libc::c_int,
                        *mut chunkqueue,
                        off_t,
                        *mut log_error_st,
                    ) -> libc::c_int,
            );
        }
        _ => return -(1 as libc::c_int),
    }
    return 0 as libc::c_int;
}
#[no_mangle]
#[cold]
pub unsafe extern "C" fn network_write_show_handlers() -> *const libc::c_char {
    return b"\nNetwork handler:\n\n\t+ linux-sendfile\n\t- freebsd-sendfile\n\t- darwin-sendfile\n\t- solaris-sendfilev\n\t+ writev\n\t+ write\n\t- mmap support\n\0"
        as *const u8 as *const libc::c_char;
}
#[inline]
unsafe extern "C" fn vector_config_weak_init(mut v: *mut vector_config_weak) {
    (*v).data = 0 as *mut *mut data_config;
    (*v).size = 0 as libc::c_int as size_t;
    (*v).used = (*v).size;
}
#[inline]
unsafe extern "C" fn vector_config_weak_clear(mut v: *mut vector_config_weak) {
    if (::core::mem::transmute::<
        *mut libc::c_void,
        Option<unsafe extern "C" fn(*mut data_config) -> ()>,
    >(0 as *mut libc::c_void))
    .is_some()
    {
        let mut i: size_t = 0 as libc::c_int as size_t;
        while i < (*v).used {
            (::core::mem::transmute::<
                *mut libc::c_void,
                Option<unsafe extern "C" fn(*mut data_config) -> ()>,
            >(0 as *mut libc::c_void))
            .expect("non-null function pointer")(*((*v).data).offset(i as isize));
            i = i.wrapping_add(1);
        }
    }
    vector_free((*v).data as *mut libc::c_void);
    vector_config_weak_init(v);
}
#[inline]
unsafe extern "C" fn vector_config_weak_push(
    mut v: *mut vector_config_weak,
    mut e: *mut data_config,
) {
    vector_config_weak_reserve(v, 1 as libc::c_int as size_t);
    let fresh70 = (*v).used;
    (*v).used = ((*v).used).wrapping_add(1);
    let ref mut fresh71 = *((*v).data).offset(fresh70 as isize);
    *fresh71 = e;
}
#[inline]
unsafe extern "C" fn vector_config_weak_reserve(mut v: *mut vector_config_weak, mut p: size_t) {
    if ((*v).size).wrapping_sub((*v).used) < p {
        if !((*v).used < (18446744073709551615 as libc::c_ulong).wrapping_sub(p)) {
            ck_assert_failed(
                b"/home/kkysen/work/rust/lighttpd/src/configfile.h\0" as *const u8
                    as *const libc::c_char,
                23 as libc::c_int as libc::c_uint,
                b"v->used < SIZE_MAX - p\0" as *const u8 as *const libc::c_char,
            );
        }
        (*v).size = vector_align_size(((*v).used).wrapping_add(p));
        (*v).data = vector_realloc(
            (*v).data as *mut libc::c_void,
            ::core::mem::size_of::<*mut data_config>() as libc::c_ulong,
            (*v).size,
            (*v).used,
        ) as *mut *mut data_config;
    }
}
#[inline]
unsafe extern "C" fn vector_config_weak_pop(mut v: *mut vector_config_weak) -> *mut data_config {
    if !((*v).used > 0 as libc::c_int as libc::c_ulong) {
        ck_assert_failed(
            b"/home/kkysen/work/rust/lighttpd/src/configfile.h\0" as *const u8
                as *const libc::c_char,
            23 as libc::c_int as libc::c_uint,
            b"v->used > 0\0" as *const u8 as *const libc::c_char,
        );
    }
    (*v).used = ((*v).used).wrapping_sub(1);
    return *((*v).data).offset((*v).used as isize);
}
#[inline]
unsafe extern "C" fn vector_align_size(mut s: size_t) -> size_t {
    let mut a: size_t = s.wrapping_add(15 as libc::c_int as libc::c_ulong) & !(15 as libc::c_ulong);
    return if a < s { s } else { a };
}
#[no_mangle]
#[cold]
pub unsafe extern "C" fn data_config_pcre_compile(
    dc: *mut data_config,
    pcre_jit: libc::c_int,
    errh: *mut log_error_st,
) -> libc::c_int {
    let mut errcode: libc::c_int = 0;
    let mut erroff: size_t = 0;
    let mut errbuf: [PCRE2_UCHAR8; 1024] = [0; 1024];
    (*dc).code = pcre2_compile_8(
        (*dc).string.ptr as PCRE2_SPTR8,
        buffer_clen(&mut (*dc).string) as size_t,
        0x80000 as libc::c_uint,
        &mut errcode,
        &mut erroff,
        0 as *mut pcre2_compile_context_8,
    ) as *mut libc::c_void;
    if ((*dc).code).is_null() {
        pcre2_get_error_message_8(
            errcode,
            errbuf.as_mut_ptr(),
            ::core::mem::size_of::<[PCRE2_UCHAR8; 1024]>() as libc::c_ulong,
        );
        log_error(
            errh,
            b"/home/kkysen/work/rust/lighttpd/src/data_config.c\0" as *const u8
                as *const libc::c_char,
            94 as libc::c_int as libc::c_uint,
            b"pcre2_compile: %s at offset %zu, regex: %s\0" as *const u8 as *const libc::c_char,
            errbuf.as_mut_ptr() as *mut libc::c_char,
            erroff,
            (*dc).string.ptr,
        );
        return 0 as libc::c_int;
    }
    if pcre_jit != 0 {
        errcode = pcre2_jit_compile_8((*dc).code as *mut pcre2_code_8, 0x1 as libc::c_uint);
        if 0 as libc::c_int != errcode && errcode != -(45 as libc::c_int) {
            pcre2_get_error_message_8(
                errcode,
                errbuf.as_mut_ptr(),
                ::core::mem::size_of::<[PCRE2_UCHAR8; 1024]>() as libc::c_ulong,
            );
            log_error(
                errh,
                b"/home/kkysen/work/rust/lighttpd/src/data_config.c\0" as *const u8
                    as *const libc::c_char,
                104 as libc::c_int as libc::c_uint,
                b"pcre2_jit_compile: %s, regex: %s\0" as *const u8 as *const libc::c_char,
                errbuf.as_mut_ptr() as *mut libc::c_char,
                (*dc).string.ptr,
            );
        }
    }
    let mut captures: uint32_t = 0;
    errcode = pcre2_pattern_info_8(
        (*dc).code as *const pcre2_code_8,
        4 as libc::c_int as uint32_t,
        &mut captures as *mut uint32_t as *mut libc::c_void,
    );
    if 0 as libc::c_int != errcode {
        pcre2_get_error_message_8(
            errcode,
            errbuf.as_mut_ptr(),
            ::core::mem::size_of::<[PCRE2_UCHAR8; 1024]>() as libc::c_ulong,
        );
        log_error(
            errh,
            b"/home/kkysen/work/rust/lighttpd/src/data_config.c\0" as *const u8
                as *const libc::c_char,
            115 as libc::c_int as libc::c_uint,
            b"pcre2_pattern_info: %s, regex: %s\0" as *const u8 as *const libc::c_char,
            errbuf.as_mut_ptr() as *mut libc::c_char,
            (*dc).string.ptr,
        );
        return 0 as libc::c_int;
    } else {
        if captures > 9 as libc::c_int as libc::c_uint {
            log_error(
                errh,
                b"/home/kkysen/work/rust/lighttpd/src/data_config.c\0" as *const u8
                    as *const libc::c_char,
                120 as libc::c_int as libc::c_uint,
                b"Too many captures in regex, use (?:...) instead of (...): %s\0" as *const u8
                    as *const libc::c_char,
                (*dc).string.ptr,
            );
            return 0 as libc::c_int;
        }
    }
    return 1 as libc::c_int;
}
#[no_mangle]
#[cold]
pub unsafe extern "C" fn data_config_init() -> *mut data_config {
    static mut config_fn: data_methods = unsafe {
        {
            let mut init = data_methods {
                copy: Some(
                    data_config_copy as unsafe extern "C" fn(*const data_unset) -> *mut data_unset,
                ),
                free: Some(data_config_free as unsafe extern "C" fn(*mut data_unset) -> ()),
                insert_dup: None,
            };
            init
        }
    };
    let mut ds: *mut data_config = 0 as *mut data_config;
    ds = calloc(
        1 as libc::c_int as libc::c_ulong,
        ::core::mem::size_of::<data_config>() as libc::c_ulong,
    ) as *mut data_config;
    if ds.is_null() {
        ck_assert_failed(
            b"/home/kkysen/work/rust/lighttpd/src/data_config.c\0" as *const u8
                as *const libc::c_char,
            68 as libc::c_int as libc::c_uint,
            b"ds\0" as *const u8 as *const libc::c_char,
        );
    }
    (*ds).comp_key = b"\0" as *const u8 as *const libc::c_char;
    (*ds).value = array_init(4 as libc::c_int as uint32_t);
    vector_config_weak_init(&mut (*ds).children);
    (*ds).type_0 = TYPE_CONFIG;
    (*ds).fn_0 = &config_fn;
    return ds;
}
#[cold]
unsafe extern "C" fn data_config_free(mut d: *mut data_unset) {
    let mut ds: *mut data_config = d as *mut data_config;
    free((*ds).key.ptr as *mut libc::c_void);
    free((*ds).comp_tag.ptr as *mut libc::c_void);
    array_free((*ds).value);
    vector_config_weak_clear(&mut (*ds).children);
    free((*ds).string.ptr as *mut libc::c_void);
    if !((*ds).code).is_null() {
        pcre2_code_free_8((*ds).code as *mut pcre2_code_8);
    }
    free(d as *mut libc::c_void);
}
#[cold]
unsafe extern "C" fn data_config_copy(mut s: *const data_unset) -> *mut data_unset {
    let mut src: *mut data_config = s as *mut data_config;
    let mut ds: *mut data_config = data_config_init();
    (*ds).comp = (*src).comp;
    if buffer_is_unset(&mut (*src).key) == 0 {
        buffer_copy_buffer(&mut (*ds).key, &mut (*src).key);
        (*ds).comp_key = ((*ds).key.ptr)
            .offset(((*src).comp_key).offset_from((*src).key.ptr) as libc::c_long as isize);
    }
    buffer_copy_buffer(&mut (*ds).comp_tag, &mut (*src).comp_tag);
    array_copy_array((*ds).value, (*src).value);
    return ds as *mut data_unset;
}
#[no_mangle]
pub unsafe extern "C" fn vector_free(mut data: *mut libc::c_void) {
    free(data);
}
#[no_mangle]
pub unsafe extern "C" fn vector_malloc(mut sz: size_t) -> *mut libc::c_void {
    return malloc(sz);
}
#[no_mangle]
pub unsafe extern "C" fn vector_realloc(
    mut data: *mut libc::c_void,
    mut elem_size: size_t,
    mut size: size_t,
    mut used: size_t,
) -> *mut libc::c_void {
    let total_size: size_t = elem_size.wrapping_mul(size);
    let used_size: size_t = elem_size.wrapping_mul(used);
    if !(size <= (18446744073709551615 as libc::c_ulong).wrapping_div(elem_size)) {
        ck_assert_failed(
            b"/home/kkysen/work/rust/lighttpd/src/vector.c\0" as *const u8 as *const libc::c_char,
            15 as libc::c_int as libc::c_uint,
            b"size <= SIZE_MAX / elem_size\0" as *const u8 as *const libc::c_char,
        );
    }
    data = realloc(data, total_size);
    if data.is_null() {
        ck_assert_failed(
            b"/home/kkysen/work/rust/lighttpd/src/vector.c\0" as *const u8 as *const libc::c_char,
            17 as libc::c_int as libc::c_uint,
            b"NULL != data\0" as *const u8 as *const libc::c_char,
        );
    }
    memset(
        (data as *mut libc::c_char).offset(used_size as isize) as *mut libc::c_void,
        0 as libc::c_int,
        total_size.wrapping_sub(used_size),
    );
    return data;
}
unsafe extern "C" fn config_parse(
    mut srv: *mut server,
    mut context: *mut config_t,
    mut source: *const libc::c_char,
    mut input: *const libc::c_char,
    mut isize: size_t,
) -> libc::c_int {
    let mut pParser: *mut libc::c_void = 0 as *mut libc::c_void;
    let mut token: *mut buffer = 0 as *mut buffer;
    let mut lasttoken: *mut buffer = 0 as *mut buffer;
    let mut token_id: libc::c_int = 0 as libc::c_int;
    let mut ret: libc::c_int = 0;
    let mut t: tokenizer_t = tokenizer_t {
        source: 0 as *const libc::c_char,
        input: 0 as *const libc::c_char,
        offset: 0,
        size: 0,
        line_pos: 0,
        line: 0,
        in_key: 0,
        in_brace: 0,
        in_cond: 0,
        simulate_eol: 0,
    };
    t.source = source;
    t.input = input;
    t.size = isize;
    t.offset = 0 as libc::c_int as size_t;
    t.line = 1 as libc::c_int;
    t.line_pos = 1 as libc::c_int;
    t.in_key = 1 as libc::c_int;
    t.in_brace = 0 as libc::c_int;
    t.in_cond = 0 as libc::c_int;
    t.simulate_eol = 0 as libc::c_int;
    pParser = configparserAlloc(Some(
        malloc as unsafe extern "C" fn(libc::c_ulong) -> *mut libc::c_void,
    ));
    if pParser.is_null() {
        ck_assert_failed(
            b"/home/kkysen/work/rust/lighttpd/src/configfile.c\0" as *const u8
                as *const libc::c_char,
            2128 as libc::c_int as libc::c_uint,
            b"pParser\0" as *const u8 as *const libc::c_char,
        );
    }
    lasttoken = buffer_init();
    token = buffer_init();
    loop {
        ret = config_tokenizer(srv, &mut t, &mut token_id, token);
        if !(1 as libc::c_int == ret && (*context).ok != 0) {
            break;
        }
        buffer_copy_buffer(lasttoken, token);
        configparser(pParser, token_id, token, context);
        token = buffer_init();
    }
    buffer_free(token);
    if ret != -(1 as libc::c_int) && (*context).ok != 0 {
        token = buffer_init();
        buffer_copy_string(token, b"(EOL)\0" as *const u8 as *const libc::c_char);
        configparser(pParser, 1 as libc::c_int, token, context);
        if (*context).ok != 0 {
            configparser(pParser, 0 as libc::c_int, 0 as *mut buffer, context);
        }
    }
    configparserFree(
        pParser,
        Some(free as unsafe extern "C" fn(*mut libc::c_void) -> ()),
    );
    if ret == -(1 as libc::c_int) {
        log_error(
            (*srv).errh,
            b"/home/kkysen/work/rust/lighttpd/src/configfile.c\0" as *const u8
                as *const libc::c_char,
            2150 as libc::c_int as libc::c_uint,
            b"configfile parser failed at: %s\0" as *const u8 as *const libc::c_char,
            (*lasttoken).ptr,
        );
    } else if (*context).ok == 0 as libc::c_int {
        log_error(
            (*srv).errh,
            b"/home/kkysen/work/rust/lighttpd/src/configfile.c\0" as *const u8
                as *const libc::c_char,
            2153 as libc::c_int as libc::c_uint,
            b"source: %s line: %d pos: %d parser failed somehow near here: %s\0" as *const u8
                as *const libc::c_char,
            t.source,
            t.line,
            t.line_pos,
            (*lasttoken).ptr,
        );
        ret = -(1 as libc::c_int);
    }
    buffer_free(lasttoken);
    return if ret == -(1 as libc::c_int) {
        -(1 as libc::c_int)
    } else {
        0 as libc::c_int
    };
}
#[no_mangle]
#[cold]
pub unsafe extern "C" fn config_init(mut srv: *mut server) {
    (*srv).config_context = array_init(16 as libc::c_int as uint32_t);
    (*srv).srvconf.config_touched = array_init(128 as libc::c_int as uint32_t);
    (*srv).srvconf.port = 0 as libc::c_int as libc::c_ushort;
    (*srv).srvconf.dont_daemonize = 0 as libc::c_int as libc::c_uchar;
    (*srv).srvconf.preflight_check = 0 as libc::c_int as libc::c_uchar;
    (*srv).srvconf.compat_module_load = 1 as libc::c_int as libc::c_uchar;
    (*srv).srvconf.systemd_socket_activation = 0 as libc::c_int as libc::c_uchar;
    (*srv).srvconf.high_precision_timestamps = 0 as libc::c_int as libc::c_uchar;
    (*srv).srvconf.max_request_field_size = 8192 as libc::c_int as uint32_t;
    (*srv).srvconf.http_header_strict = 1 as libc::c_int as libc::c_uchar;
    (*srv).srvconf.http_host_strict = 1 as libc::c_int as libc::c_uchar;
    (*srv).srvconf.http_host_normalize = 0 as libc::c_int as libc::c_uchar;
    (*srv).srvconf.http_url_normalize = (HTTP_PARSEOPT_URL_NORMALIZE as libc::c_int
        | HTTP_PARSEOPT_URL_NORMALIZE_UNRESERVED as libc::c_int
        | HTTP_PARSEOPT_URL_NORMALIZE_CTRLS_REJECT as libc::c_int
        | HTTP_PARSEOPT_URL_NORMALIZE_PATH_2F_DECODE as libc::c_int
        | HTTP_PARSEOPT_URL_NORMALIZE_PATH_DOTSEG_REMOVE as libc::c_int)
        as libc::c_ushort;
    (*srv).srvconf.modules = array_init(16 as libc::c_int as uint32_t);
    (*srv).srvconf.modules_dir = b"/usr/local/lib/lighttpd\0" as *const u8 as *const libc::c_char;
    (*srv).srvconf.upload_tempdirs = array_init(2 as libc::c_int as uint32_t);
}
#[no_mangle]
#[cold]
pub unsafe extern "C" fn config_print(mut srv: *mut server) {
    buffer_clear((*srv).tmp_buf);
    let mut dc: *mut data_unset =
        *((*(*srv).config_context).data).offset(0 as libc::c_int as isize);
    config_print_by_type(dc, (*srv).tmp_buf, 0 as libc::c_int);
}
#[cold]
unsafe extern "C" fn config_print_by_type(
    du: *const data_unset,
    b: *mut buffer,
    mut depth: libc::c_int,
) {
    match (*du).type_0 as libc::c_uint {
        0 => {
            config_print_string(du, b);
        }
        2 => {
            buffer_append_int(b, (*(du as *mut data_integer)).value as intmax_t);
        }
        1 => {
            config_print_array(&mut (*(du as *mut data_array)).value, b, depth);
        }
        3 => {
            config_print_config(du, b, depth);
        }
        _ => {}
    };
}
unsafe extern "C" fn config_print_config(
    mut d: *const data_unset,
    b: *mut buffer,
    mut depth: libc::c_int,
) {
    let mut dc: *mut data_config = d as *mut data_config;
    let mut a: *mut array = (*dc).value;
    if 0 as libc::c_int == (*dc).context_ndx {
        buffer_append_string(b, b"config {\n\0" as *const u8 as *const libc::c_char);
    } else {
        if (*dc).cond as libc::c_uint != CONFIG_COND_ELSE as libc::c_int as libc::c_uint {
            buffer_append_string(b, (*dc).comp_key);
            buffer_append_string(b, b" \0" as *const u8 as *const libc::c_char);
        }
        buffer_append_string(b, b"{\n\0" as *const u8 as *const libc::c_char);
        config_print_indent(b, depth + 1 as libc::c_int);
        buffer_append_string(b, b"# block \0" as *const u8 as *const libc::c_char);
        buffer_append_int(b, (*dc).context_ndx as intmax_t);
        buffer_append_string(b, b"\n\0" as *const u8 as *const libc::c_char);
    }
    depth += 1;
    let maxlen: uint32_t = config_print_array_max_klen(a);
    let mut i: uint32_t = 0 as libc::c_int as uint32_t;
    while i < (*a).used {
        config_print_indent(b, depth);
        let mut du: *mut data_unset = *((*a).data).offset(i as isize);
        buffer_append_buffer(b, &mut (*du).key);
        let mut indent: libc::c_int =
            maxlen.wrapping_sub(buffer_clen(&mut (*du).key)) as libc::c_int;
        if indent > 0 as libc::c_int {
            memset(
                buffer_extend(b, indent as size_t) as *mut libc::c_void,
                ' ' as i32,
                indent as libc::c_ulong,
            );
        }
        buffer_append_string(b, b" = \0" as *const u8 as *const libc::c_char);
        config_print_by_type(du, b, depth);
        buffer_append_string(b, b"\n\0" as *const u8 as *const libc::c_char);
        i = i.wrapping_add(1);
    }
    buffer_append_string(b, b"\n\0" as *const u8 as *const libc::c_char);
    let mut i_0: uint32_t = 0 as libc::c_int as uint32_t;
    while (i_0 as libc::c_ulong) < (*dc).children.used {
        let mut dcc: *mut data_config = *((*dc).children.data).offset(i_0 as isize);
        if ((*dcc).prev).is_null() {
            buffer_append_string(b, b"\n\0" as *const u8 as *const libc::c_char);
            config_print_indent(b, depth);
            config_print_by_type(dcc as *mut data_unset, b, depth);
            buffer_append_string(b, b"\n\0" as *const u8 as *const libc::c_char);
        }
        i_0 = i_0.wrapping_add(1);
    }
    depth -= 1;
    config_print_indent(b, depth);
    buffer_append_string(b, b"}\0" as *const u8 as *const libc::c_char);
    if 0 as libc::c_int != (*dc).context_ndx {
        buffer_append_string(b, b" # end of \0" as *const u8 as *const libc::c_char);
        buffer_append_string(
            b,
            if (*dc).cond as libc::c_uint != CONFIG_COND_ELSE as libc::c_int as libc::c_uint {
                (*dc).comp_key
            } else {
                b"else\0" as *const u8 as *const libc::c_char
            },
        );
    }
    if !((*dc).next).is_null() {
        buffer_append_string(b, b"\n\0" as *const u8 as *const libc::c_char);
        config_print_indent(b, depth);
        buffer_append_string(b, b"else \0" as *const u8 as *const libc::c_char);
        config_print_by_type((*dc).next as *mut data_unset, b, depth);
    }
}
unsafe extern "C" fn config_print_indent(mut b: *mut buffer, mut depth: libc::c_int) {
    depth <<= 2 as libc::c_int;
    memset(
        buffer_extend(b, depth as size_t) as *mut libc::c_void,
        ' ' as i32,
        depth as libc::c_ulong,
    );
}
unsafe extern "C" fn config_print_array_max_klen(a: *const array) -> uint32_t {
    let mut maxlen: uint32_t = 0 as libc::c_int as uint32_t;
    let mut i: uint32_t = 0 as libc::c_int as uint32_t;
    while i < (*a).used {
        let mut len: uint32_t = buffer_clen(&mut (**((*a).data).offset(i as isize)).key);
        if maxlen < len {
            maxlen = len;
        }
        i = i.wrapping_add(1);
    }
    return maxlen;
}
unsafe extern "C" fn config_print_array(a: *const array, b: *mut buffer, mut depth: libc::c_int) {
    if (*a).used <= 5 as libc::c_int as libc::c_uint
        && ((*a).used == 0
            || buffer_is_unset(&mut (**((*a).data).offset(0 as libc::c_int as isize)).key) != 0)
    {
        let mut oneline: libc::c_int = 1 as libc::c_int;
        let mut i: uint32_t = 0 as libc::c_int as uint32_t;
        while i < (*a).used {
            let mut du: *mut data_unset = *((*a).data).offset(i as isize);
            if (*du).type_0 as libc::c_uint != TYPE_STRING as libc::c_int as libc::c_uint
                && (*du).type_0 as libc::c_uint != TYPE_INTEGER as libc::c_int as libc::c_uint
            {
                oneline = 0 as libc::c_int;
                break;
            } else {
                i = i.wrapping_add(1);
            }
        }
        if oneline != 0 {
            buffer_append_string(b, b"(\0" as *const u8 as *const libc::c_char);
            let mut i_0: uint32_t = 0 as libc::c_int as uint32_t;
            while i_0 < (*a).used {
                if i_0 != 0 as libc::c_int as libc::c_uint {
                    buffer_append_string(b, b", \0" as *const u8 as *const libc::c_char);
                }
                config_print_by_type(
                    *((*a).data).offset(i_0 as isize),
                    b,
                    depth + 1 as libc::c_int,
                );
                i_0 = i_0.wrapping_add(1);
            }
            buffer_append_string(b, b")\0" as *const u8 as *const libc::c_char);
            return;
        }
    }
    let maxlen: uint32_t = config_print_array_max_klen(a);
    buffer_append_string(b, b"(\n\0" as *const u8 as *const libc::c_char);
    let mut i_1: uint32_t = 0 as libc::c_int as uint32_t;
    while i_1 < (*a).used {
        config_print_indent(b, depth + 1 as libc::c_int);
        let mut du_0: *mut data_unset = *((*a).data).offset(i_1 as isize);
        if buffer_is_unset(&mut (*du_0).key) == 0 {
            buffer_append_str3(
                b,
                b"\"\0" as *const u8 as *const libc::c_char,
                (::core::mem::size_of::<[libc::c_char; 2]>() as libc::c_ulong as uint32_t)
                    .wrapping_sub(1 as libc::c_int as libc::c_uint) as size_t,
                (*du_0).key.ptr,
                buffer_clen(&mut (*du_0).key) as size_t,
                b"\"\0" as *const u8 as *const libc::c_char,
                (::core::mem::size_of::<[libc::c_char; 2]>() as libc::c_ulong as uint32_t)
                    .wrapping_sub(1 as libc::c_int as libc::c_uint) as size_t,
            );
            let mut indent: libc::c_int =
                maxlen.wrapping_sub(buffer_clen(&mut (*du_0).key)) as libc::c_int;
            if indent > 0 as libc::c_int {
                memset(
                    buffer_extend(b, indent as size_t) as *mut libc::c_void,
                    ' ' as i32,
                    indent as libc::c_ulong,
                );
            }
            buffer_append_string(b, b" => \0" as *const u8 as *const libc::c_char);
        }
        config_print_by_type(du_0, b, depth + 1 as libc::c_int);
        buffer_append_string(b, b",\n\0" as *const u8 as *const libc::c_char);
        i_1 = i_1.wrapping_add(1);
    }
    config_print_indent(b, depth);
    buffer_append_string(b, b")\0" as *const u8 as *const libc::c_char);
}
unsafe extern "C" fn config_print_string(mut du: *const data_unset, b: *mut buffer) {
    let vb: *const buffer = &mut (*(du as *mut data_string)).value;
    let mut dst: *mut libc::c_char = buffer_string_prepare_append(
        b,
        (buffer_clen(vb)).wrapping_mul(2 as libc::c_int as libc::c_uint) as size_t,
    );
    let mut n: uint32_t = 0 as libc::c_int as uint32_t;
    let fresh72 = n;
    n = n.wrapping_add(1);
    *dst.offset(fresh72 as isize) = '"' as i32 as libc::c_char;
    if !((*vb).ptr).is_null() {
        let mut p: *const libc::c_char = (*vb).ptr;
        while *p != 0 {
            if *p as libc::c_int == '"' as i32 {
                let fresh73 = n;
                n = n.wrapping_add(1);
                *dst.offset(fresh73 as isize) = '\\' as i32 as libc::c_char;
            }
            let fresh74 = n;
            n = n.wrapping_add(1);
            *dst.offset(fresh74 as isize) = *p;
            p = p.offset(1);
        }
    }
    let fresh75 = n;
    n = n.wrapping_add(1);
    *dst.offset(fresh75 as isize) = '"' as i32 as libc::c_char;
    buffer_commit(b, n as size_t);
}
static mut cpk_0: [config_plugin_keys_t; 35] = [config_plugin_keys_t {
    k: 0 as *const libc::c_char,
    klen: 0,
    ktype: 0,
    scope: 0,
}; 35];
unsafe extern "C" fn config_insert(mut srv: *mut server) -> libc::c_int {
    let mut rc: libc::c_int = 0 as libc::c_int;
    let p: *mut config_data_base = calloc(
        1 as libc::c_int as libc::c_ulong,
        ::core::mem::size_of::<config_data_base>() as libc::c_ulong,
    ) as *mut config_data_base;
    if p.is_null() {
        ck_assert_failed(
            b"/home/kkysen/work/rust/lighttpd/src/configfile.c\0" as *const u8
                as *const libc::c_char,
            1035 as libc::c_int as libc::c_uint,
            b"p\0" as *const u8 as *const libc::c_char,
        );
    }
    (*srv).config_data_base = p as *mut libc::c_void;
    if config_plugin_values_init(
        srv,
        p as *mut libc::c_void,
        cpk_0.as_ptr(),
        b"base\0" as *const u8 as *const libc::c_char,
    ) == 0
    {
        return HANDLER_ERROR as libc::c_int;
    }
    let mut i: libc::c_int = ((*((*p).cvlist).offset(0 as libc::c_int as isize)).v.u2
        [1 as libc::c_int as usize]
        == 0) as libc::c_int;
    while i < (*p).nconfig {
        let mut cpv: *mut config_plugin_value_t = ((*p).cvlist)
            .offset((*((*p).cvlist).offset(i as isize)).v.u2[0 as libc::c_int as usize] as isize);
        while -(1 as libc::c_int) != (*cpv).k_id {
            match (*cpv).k_id {
                1 => {
                    if buffer_is_blank((*cpv).v.b) != 0 {
                        (*cpv).v.b = 0 as *const buffer;
                    }
                }
                2 => {
                    if buffer_is_blank((*cpv).v.b) == 0 {
                        let mut b: *mut buffer = 0 as *mut buffer;
                        let ref mut fresh76 = *(&mut b as *mut *mut buffer as *mut *const buffer);
                        *fresh76 = (*cpv).v.b;
                        let mut t: *mut libc::c_char = strchr((*b).ptr, '\n' as i32);
                        while !t.is_null() {
                            if !(*t.offset(1 as libc::c_int as isize) as libc::c_int == ' ' as i32
                                || *t.offset(1 as libc::c_int as isize) as libc::c_int
                                    == '\t' as i32)
                            {
                                let mut off: off_t = t.offset_from((*b).ptr) as libc::c_long;
                                let mut len: size_t = buffer_clen(b) as size_t;
                                buffer_string_prepare_append(b, 1 as libc::c_int as size_t);
                                t = ((*b).ptr).offset(off as isize);
                                memmove(
                                    t.offset(2 as libc::c_int as isize) as *mut libc::c_void,
                                    t.offset(1 as libc::c_int as isize) as *const libc::c_void,
                                    len.wrapping_sub(off as libc::c_ulong)
                                        .wrapping_sub(1 as libc::c_int as libc::c_ulong),
                                );
                                *t.offset(1 as libc::c_int as isize) = ' ' as i32 as libc::c_char;
                                buffer_commit(b, 1 as libc::c_int as size_t);
                            }
                            t = strchr(t.offset(2 as libc::c_int as isize), '\n' as i32);
                        }
                        let mut t_0: *mut libc::c_char = (*b).ptr;
                        while *t_0 as libc::c_int == ' ' as i32
                            || *t_0 as libc::c_int == '\t' as i32
                            || *t_0 as libc::c_int == '\r' as i32
                            || *t_0 as libc::c_int == '\n' as i32
                        {
                            t_0 = t_0.offset(1);
                        }
                        if *t_0 as libc::c_int == '\0' as i32 {
                            buffer_truncate(b, 0 as libc::c_int as uint32_t);
                        }
                    } else if 0 as libc::c_int != i {
                        (*cpv).v.b = 0 as *const buffer;
                    }
                }
                8 | 9 | 10 => {
                    if buffer_is_blank((*cpv).v.b) != 0 {
                        (*cpv).v.b = 0 as *const buffer;
                    }
                }
                16 => {
                    if (*cpv).v.shrt as libc::c_int & (1 as libc::c_int) << 1 as libc::c_int != 0 {
                        (*cpv).v.shrt = ((*cpv).v.shrt as libc::c_int
                            | (1 as libc::c_int) << 0 as libc::c_int)
                            as libc::c_ushort;
                    }
                }
                17 => {
                    if (*cpv).v.shrt as libc::c_int & (1 as libc::c_int) << 1 as libc::c_int != 0 {
                        (*cpv).v.shrt = ((*cpv).v.shrt as libc::c_int
                            | (1 as libc::c_int) << 0 as libc::c_int)
                            as libc::c_ushort;
                    }
                }
                18 => {
                    let cnt: *mut off_t = malloc(
                        (2 as libc::c_int as libc::c_ulong)
                            .wrapping_mul(::core::mem::size_of::<off_t>() as libc::c_ulong),
                    ) as *mut off_t;
                    if cnt.is_null() {
                        ck_assert_failed(
                            b"/home/kkysen/work/rust/lighttpd/src/configfile.c\0" as *const u8
                                as *const libc::c_char,
                            1114 as libc::c_int as libc::c_uint,
                            b"cnt\0" as *const u8 as *const libc::c_char,
                        );
                    }
                    *cnt.offset(0 as libc::c_int as isize) = 0 as libc::c_int as off_t;
                    *cnt.offset(1 as libc::c_int as isize) =
                        ((*cpv).v.shrt as off_t) << 10 as libc::c_int;
                    (*cpv).v.v = cnt as *mut libc::c_void;
                    (*cpv).vtype = T_CONFIG_LOCAL;
                }
                0 | 3 | 4 | 5 | 6 | 7 | 11 | 12 | 13 | 14 | 15 | 19 | 20 | 21 | 22 | 23 | 24
                | 25 | 26 | 27 | 28 | 29 | 30 | 31 | 32 | 33 | _ => {}
            }
            cpv = cpv.offset(1);
        }
        i += 1;
    }
    (*p).defaults.errh = (*srv).errh;
    (*p).defaults.max_keep_alive_requests = 100 as libc::c_int as libc::c_ushort;
    (*p).defaults.max_keep_alive_idle = 5 as libc::c_int as libc::c_ushort;
    (*p).defaults.max_read_idle = 60 as libc::c_int as libc::c_ushort;
    (*p).defaults.max_write_idle = 360 as libc::c_int as libc::c_ushort;
    (*p).defaults.follow_symlink = 1 as libc::c_int as libc::c_uchar;
    (*p).defaults.allow_http11 = 1 as libc::c_int as libc::c_uchar;
    (*p).defaults.etag_flags = (ETAG_USE_INODE as libc::c_int
        | ETAG_USE_MTIME as libc::c_int
        | ETAG_USE_SIZE as libc::c_int) as libc::c_uchar;
    (*p).defaults.range_requests = 1 as libc::c_int as libc::c_uchar;
    (*p).defaults.force_lowercase_filenames = 2 as libc::c_int as libc::c_uchar;
    (*p).defaults.http_parseopts =
        ((if (*srv).srvconf.http_header_strict as libc::c_int != 0 {
            HTTP_PARSEOPT_HEADER_STRICT as libc::c_int
        } else {
            0 as libc::c_int
        }) | (if (*srv).srvconf.http_host_strict as libc::c_int != 0 {
            HTTP_PARSEOPT_HOST_STRICT as libc::c_int | HTTP_PARSEOPT_HOST_NORMALIZE as libc::c_int
        } else {
            0 as libc::c_int
        }) | (if (*srv).srvconf.http_host_normalize as libc::c_int != 0 {
            HTTP_PARSEOPT_HOST_NORMALIZE as libc::c_int
        } else {
            0 as libc::c_int
        }) | (if (*srv).srvconf.http_method_get_body as libc::c_int != 0 {
            HTTP_PARSEOPT_METHOD_GET_BODY as libc::c_int
        } else {
            0 as libc::c_int
        })) as libc::c_uint;
    (*p).defaults.http_parseopts |= (*srv).srvconf.http_url_normalize as libc::c_uint;
    (*p).defaults.mimetypes = &mut (*srv).srvconf.empty_array;
    (*p).defaults.h2proto = (*srv).srvconf.h2proto;
    if (*p).nconfig > 0 as libc::c_int && (*(*p).cvlist).v.u2[1 as libc::c_int as usize] != 0 {
        let mut cpv_0: *const config_plugin_value_t =
            ((*p).cvlist).offset((*(*p).cvlist).v.u2[0 as libc::c_int as usize] as isize);
        if -(1 as libc::c_int) != (*cpv_0).k_id {
            config_merge_config(&mut (*p).defaults, cpv_0);
        }
    }
    (*p).defaults.max_request_field_size = (*srv).srvconf.max_request_field_size;
    (*p).defaults.log_request_header_on_error = (*srv).srvconf.log_request_header_on_error;
    if (*p).defaults.log_request_handling as libc::c_int != 0
        || (*p).defaults.log_request_header as libc::c_int != 0
    {
        (*p).defaults.log_request_header_on_error = 1 as libc::c_int as libc::c_uchar;
    }
    request_config_set_defaults(&mut (*p).defaults);
    return rc;
}
static mut cpk_1: [config_plugin_keys_t; 34] = [config_plugin_keys_t {
    k: 0 as *const libc::c_char,
    klen: 0,
    ktype: 0,
    scope: 0,
}; 34];
unsafe extern "C" fn config_insert_srvconf(mut srv: *mut server) -> libc::c_int {
    (*srv).srvconf.h2proto = 2 as libc::c_int as libc::c_uchar;
    let mut rc: libc::c_int = 0 as libc::c_int;
    let mut srvplug: plugin_data_base = plugin_data_base {
        id: 0,
        nconfig: 0,
        cvlist: 0 as *mut config_plugin_value_t,
        self_0: 0 as *mut plugin,
    };
    memset(
        &mut srvplug as *mut plugin_data_base as *mut libc::c_void,
        0 as libc::c_int,
        ::core::mem::size_of::<plugin_data_base>() as libc::c_ulong,
    );
    let p: *mut plugin_data_base = &mut srvplug;
    if config_plugin_values_init(
        srv,
        p as *mut libc::c_void,
        cpk_1.as_ptr(),
        b"global\0" as *const u8 as *const libc::c_char,
    ) == 0
    {
        return HANDLER_ERROR as libc::c_int;
    }
    let mut ssl_enabled: libc::c_int = 0 as libc::c_int;
    if (*((*p).cvlist).offset(0 as libc::c_int as isize)).v.u2[1 as libc::c_int as usize] != 0 {
        let mut cpv: *mut config_plugin_value_t = ((*p).cvlist).offset(
            (*((*p).cvlist).offset(0 as libc::c_int as isize)).v.u2[0 as libc::c_int as usize]
                as isize,
        );
        while -(1 as libc::c_int) != (*cpv).k_id {
            match (*cpv).k_id {
                0 => {
                    array_copy_array((*srv).srvconf.modules, (*cpv).v.a);
                }
                1 => {
                    (*srv).srvconf.compat_module_load =
                        (*cpv).v.u as libc::c_ushort as libc::c_uchar;
                }
                2 => {
                    (*srv).srvconf.systemd_socket_activation =
                        (*cpv).v.u as libc::c_ushort as libc::c_uchar;
                }
                3 => {
                    (*srv).srvconf.port = (*cpv).v.shrt;
                }
                4 => {
                    if buffer_is_blank((*cpv).v.b) == 0 {
                        (*srv).srvconf.bindhost = (*cpv).v.b;
                    }
                }
                5 => {
                    if buffer_is_blank((*cpv).v.b) == 0 {
                        (*srv).srvconf.network_backend = (*cpv).v.b;
                    }
                }
                6 => {
                    if buffer_is_blank((*cpv).v.b) == 0 {
                        (*srv).srvconf.changeroot = (*cpv).v.b;
                    }
                }
                7 => {
                    if buffer_is_blank((*cpv).v.b) == 0 {
                        (*srv).srvconf.username = (*cpv).v.b;
                    }
                }
                8 => {
                    if buffer_is_blank((*cpv).v.b) == 0 {
                        (*srv).srvconf.groupname = (*cpv).v.b;
                    }
                }
                11 => {
                    (*srv).srvconf.errorlog_use_syslog =
                        (*cpv).v.u as libc::c_ushort as libc::c_uchar;
                }
                12 => {
                    if buffer_is_blank((*cpv).v.b) == 0 {
                        (*srv).srvconf.syslog_facility = (*cpv).v.b;
                    }
                }
                13 => {
                    (*srv).srvconf.enable_cores = (*cpv).v.u as libc::c_ushort as libc::c_uchar;
                }
                14 => {
                    (*srv).srvconf.event_handler = (*(*cpv).v.b).ptr;
                }
                15 => {
                    if buffer_is_blank((*cpv).v.b) == 0 {
                        let ref mut fresh77 = *(&mut (*srv).srvconf.pid_file as *mut *mut buffer
                            as *mut *const buffer);
                        *fresh77 = (*cpv).v.b;
                    }
                }
                16 => {
                    (*srv).srvconf.max_worker = (*cpv).v.u as libc::c_ushort;
                }
                17 => {
                    (*srv).srvconf.max_fds = (*cpv).v.u as libc::c_ushort;
                }
                18 => {
                    (*srv).srvconf.max_conns = (*cpv).v.u as libc::c_ushort;
                }
                19 => {
                    (*srv).srvconf.max_request_field_size = (*cpv).v.u;
                }
                20 => {
                    chunkqueue_set_chunk_size((*cpv).v.u as size_t);
                }
                21 => {
                    (*srv).srvconf.upload_temp_file_size = (*cpv).v.u;
                }
                22 => {
                    array_copy_array((*srv).srvconf.upload_tempdirs, (*cpv).v.a);
                }
                23 => {
                    if config_http_parseopts(srv, (*cpv).v.a) == 0 {
                        rc = HANDLER_ERROR as libc::c_int;
                    }
                }
                24 => {
                    (*srv).srvconf.http_header_strict =
                        (0 as libc::c_int as libc::c_uint != (*cpv).v.u) as libc::c_int
                            as libc::c_uchar;
                }
                25 => {
                    (*srv).srvconf.http_host_strict =
                        (0 as libc::c_int as libc::c_uint != (*cpv).v.u) as libc::c_int
                            as libc::c_uchar;
                }
                26 => {
                    (*srv).srvconf.http_host_normalize =
                        (0 as libc::c_int as libc::c_uint != (*cpv).v.u) as libc::c_int
                            as libc::c_uchar;
                }
                28 => {
                    if 0 as libc::c_int != stat_cache_choose_engine((*cpv).v.b, (*srv).errh) {
                        rc = HANDLER_ERROR as libc::c_int;
                    }
                }
                29 => {
                    stat_cache_xattrname((*(*cpv).v.b).ptr);
                }
                30 => {
                    ssl_enabled = (0 as libc::c_int as libc::c_uint != (*cpv).v.u) as libc::c_int;
                    if ssl_enabled != 0 {
                        log_error(
                            (*srv).errh,
                            b"/home/kkysen/work/rust/lighttpd/src/configfile.c\0" as *const u8
                                as *const libc::c_char,
                            871 as libc::c_int as libc::c_uint,
                            b"ssl support is missing; recompile with e.g. --with-openssl\0"
                                as *const u8 as *const libc::c_char,
                        );
                        rc = HANDLER_ERROR as libc::c_int;
                    }
                }
                31 => {
                    (*srv).srvconf.log_request_header_on_error =
                        (0 as libc::c_int as libc::c_uint != (*cpv).v.u) as libc::c_int
                            as libc::c_uchar;
                }
                32 => {
                    (*srv).srvconf.feature_flags = (*cpv).v.a;
                    (*srv).srvconf.h2proto = config_plugin_value_tobool(
                        array_get_element_klen(
                            (*cpv).v.a,
                            b"server.h2proto\0" as *const u8 as *const libc::c_char,
                            (::core::mem::size_of::<[libc::c_char; 15]>() as libc::c_ulong
                                as uint32_t)
                                .wrapping_sub(1 as libc::c_int as libc::c_uint),
                        ),
                        1 as libc::c_int,
                    ) as libc::c_uchar;
                    if (*srv).srvconf.h2proto != 0 {
                        (*srv).srvconf.h2proto = ((*srv).srvconf.h2proto as libc::c_int
                            + config_plugin_value_tobool(
                                array_get_element_klen(
                                    (*cpv).v.a,
                                    b"server.h2c\0" as *const u8 as *const libc::c_char,
                                    (::core::mem::size_of::<[libc::c_char; 11]>() as libc::c_ulong
                                        as uint32_t)
                                        .wrapping_sub(1 as libc::c_int as libc::c_uint),
                                ),
                                1 as libc::c_int,
                            )) as libc::c_uchar;
                    }
                    (*srv).srvconf.absolute_dir_redirect = config_plugin_value_tobool(
                        array_get_element_klen(
                            (*cpv).v.a,
                            b"server.absolute-dir-redirect\0" as *const u8 as *const libc::c_char,
                            (::core::mem::size_of::<[libc::c_char; 29]>() as libc::c_ulong
                                as uint32_t)
                                .wrapping_sub(1 as libc::c_int as libc::c_uint),
                        ),
                        0 as libc::c_int,
                    ) as libc::c_uchar;
                }
                9 | 10 | 27 | _ => {}
            }
            cpv = cpv.offset(1);
        }
    }
    if 0 as libc::c_int == (*srv).srvconf.port as libc::c_int {
        (*srv).srvconf.port = (if ssl_enabled != 0 {
            443 as libc::c_int
        } else {
            80 as libc::c_int
        }) as libc::c_ushort;
    }
    config_check_module_duplicates(srv);
    if (*srv).srvconf.compat_module_load != 0 {
        config_compat_module_load(srv);
    }
    config_deprecate_module_compress(srv);
    if (*srv).srvconf.http_url_normalize != 0 {
        config_burl_normalize_cond(srv);
    }
    if config_pcre_keyvalue(srv) == 0 {
        rc = HANDLER_ERROR as libc::c_int;
    }
    free(srvplug.cvlist as *mut libc::c_void);
    return rc;
}
unsafe extern "C" fn config_pcre_keyvalue(srv: *mut server) -> libc::c_int {
    let pcre_jit: libc::c_int = config_feature_bool(
        srv,
        b"server.pcre_jit\0" as *const u8 as *const libc::c_char,
        1 as libc::c_int,
    );
    let mut i: uint32_t = 0 as libc::c_int as uint32_t;
    while i < (*(*srv).config_context).used {
        let dc: *mut data_config =
            *((*(*srv).config_context).data).offset(i as isize) as *mut data_config;
        if !((*dc).cond as libc::c_uint != CONFIG_COND_NOMATCH as libc::c_int as libc::c_uint
            && (*dc).cond as libc::c_uint != CONFIG_COND_MATCH as libc::c_int as libc::c_uint)
        {
            if data_config_pcre_compile(dc, pcre_jit, (*srv).errh) == 0 {
                return 0 as libc::c_int;
            }
        }
        i = i.wrapping_add(1);
    }
    return 1 as libc::c_int;
}
unsafe extern "C" fn config_burl_normalize_cond(srv: *mut server) {
    let tb: *mut buffer = (*srv).tmp_buf;
    let mut i: uint32_t = 0 as libc::c_int as uint32_t;
    while i < (*(*srv).config_context).used {
        let config: *mut data_config =
            *((*(*srv).config_context).data).offset(i as isize) as *mut data_config;
        if !(COMP_HTTP_QUERY_STRING as libc::c_int as libc::c_uint
            != (*config).comp as libc::c_uint)
        {
            match (*config).cond as libc::c_uint {
                3 | 1 => {
                    pcre_keyvalue_burl_normalize_key(&mut (*config).string, tb);
                }
                4 | 2 => {
                    pcre_keyvalue_burl_normalize_key(&mut (*config).string, tb);
                }
                _ => {}
            }
        }
        i = i.wrapping_add(1);
    }
}
unsafe extern "C" fn config_deprecate_module_compress(mut srv: *mut server) {
    let mut mod_compress_idx: libc::c_int = -(1 as libc::c_int);
    let mut mod_deflate_idx: libc::c_int = -(1 as libc::c_int);
    let mut i: uint32_t = 0 as libc::c_int as uint32_t;
    while i < (*(*srv).srvconf.modules).used {
        let mut m: *mut buffer = &mut (*(*((*(*srv).srvconf.modules).data).offset(i as isize)
            as *mut data_string))
            .value;
        if buffer_eq_slen(
            m,
            b"mod_compress\0" as *const u8 as *const libc::c_char,
            (::core::mem::size_of::<[libc::c_char; 13]>() as libc::c_ulong as uint32_t)
                .wrapping_sub(1 as libc::c_int as libc::c_uint) as size_t,
        ) != 0
        {
            mod_compress_idx = i as libc::c_int;
        } else if buffer_eq_slen(
            m,
            b"mod_deflate\0" as *const u8 as *const libc::c_char,
            (::core::mem::size_of::<[libc::c_char; 12]>() as libc::c_ulong as uint32_t)
                .wrapping_sub(1 as libc::c_int as libc::c_uint) as size_t,
        ) != 0
        {
            mod_deflate_idx = i as libc::c_int;
        }
        i = i.wrapping_add(1);
    }
    if mod_compress_idx < 0 as libc::c_int {
        return;
    }
    let mut has_compress_directive: libc::c_int = 0 as libc::c_int;
    let mut i_0: uint32_t = 0 as libc::c_int as uint32_t;
    while i_0 < (*(*srv).config_context).used {
        let mut config: *const data_config =
            *((*(*srv).config_context).data).offset(i_0 as isize) as *const data_config;
        let mut j: uint32_t = 0 as libc::c_int as uint32_t;
        while j < (*(*config).value).used {
            let mut k: *mut buffer = &mut (**((*(*config).value).data).offset(j as isize)).key;
            if 0 as libc::c_int
                == strncmp(
                    (*k).ptr,
                    b"compress.\0" as *const u8 as *const libc::c_char,
                    (::core::mem::size_of::<[libc::c_char; 10]>() as libc::c_ulong)
                        .wrapping_sub(1 as libc::c_int as libc::c_ulong),
                )
            {
                has_compress_directive = 1 as libc::c_int;
                break;
            } else {
                j = j.wrapping_add(1);
            }
        }
        if has_compress_directive != 0 {
            log_error(
                (*srv).errh,
                b"/home/kkysen/work/rust/lighttpd/src/configfile.c\0" as *const u8
                    as *const libc::c_char,
                514 as libc::c_int as libc::c_uint,
                b"Warning: \"mod_compress\" is DEPRECATED and has been replaced with \"mod_deflate\".  A future release of lighttpd 1.4.x will not contain mod_compress and lighttpd may fail to start up\0"
                    as *const u8 as *const libc::c_char,
            );
            break;
        } else {
            i_0 = i_0.wrapping_add(1);
        }
    }
    if mod_deflate_idx >= 0 as libc::c_int || has_compress_directive == 0 {
        let mut a: *mut array = array_init(
            ((*(*srv).srvconf.modules).used).wrapping_sub(1 as libc::c_int as libc::c_uint),
        );
        let mut i_1: uint32_t = 0 as libc::c_int as uint32_t;
        while i_1 < (*(*srv).srvconf.modules).used {
            let mut m_0: *mut buffer = &mut (*(*((*(*srv).srvconf.modules).data)
                .offset(i_1 as isize)
                as *mut data_string))
                .value;
            if !(buffer_eq_slen(
                m_0,
                b"mod_compress\0" as *const u8 as *const libc::c_char,
                (::core::mem::size_of::<[libc::c_char; 13]>() as libc::c_ulong as uint32_t)
                    .wrapping_sub(1 as libc::c_int as libc::c_uint) as size_t,
            ) != 0)
            {
                array_insert_value(a, (*m_0).ptr, buffer_clen(m_0));
            }
            i_1 = i_1.wrapping_add(1);
        }
        array_free((*srv).srvconf.modules);
        (*srv).srvconf.modules = a;
    } else {
        let mut m_1: *mut buffer = &mut (*(*((*(*srv).srvconf.modules).data)
            .offset(mod_compress_idx as isize)
            as *mut data_string))
            .value;
        buffer_copy_string_len(
            m_1,
            b"mod_deflate\0" as *const u8 as *const libc::c_char,
            (::core::mem::size_of::<[libc::c_char; 12]>() as libc::c_ulong as uint32_t)
                .wrapping_sub(1 as libc::c_int as libc::c_uint) as size_t,
        );
    };
}
unsafe extern "C" fn config_compat_module_load(mut srv: *mut server) {
    let mut prepend_mod_indexfile: libc::c_int = 1 as libc::c_int;
    let mut append_mod_dirlisting: libc::c_int = 1 as libc::c_int;
    let mut append_mod_staticfile: libc::c_int = 1 as libc::c_int;
    let mut append_mod_authn_file: libc::c_int = 1 as libc::c_int;
    let mut append_mod_authn_ldap: libc::c_int = 1 as libc::c_int;
    let mut append_mod_openssl: libc::c_int = 1 as libc::c_int;
    let mut contains_mod_auth: libc::c_int = 0 as libc::c_int;
    let mut prepend_mod_auth: libc::c_int = 0 as libc::c_int;
    let mut prepend_mod_vhostdb: libc::c_int = 0 as libc::c_int;
    let mut dyn_name: *const libc::c_char = 0 as *const libc::c_char;
    let mut i: uint32_t = 0 as libc::c_int as uint32_t;
    while i < (*(*srv).srvconf.modules).used {
        let mut m: *mut buffer = &mut (*(*((*(*srv).srvconf.modules).data).offset(i as isize)
            as *mut data_string))
            .value;
        if buffer_eq_slen(
            m,
            b"mod_indexfile\0" as *const u8 as *const libc::c_char,
            (::core::mem::size_of::<[libc::c_char; 14]>() as libc::c_ulong as uint32_t)
                .wrapping_sub(1 as libc::c_int as libc::c_uint) as size_t,
        ) != 0
        {
            prepend_mod_indexfile = 0 as libc::c_int;
        } else if buffer_eq_slen(
            m,
            b"mod_staticfile\0" as *const u8 as *const libc::c_char,
            (::core::mem::size_of::<[libc::c_char; 15]>() as libc::c_ulong as uint32_t)
                .wrapping_sub(1 as libc::c_int as libc::c_uint) as size_t,
        ) != 0
        {
            append_mod_staticfile = 0 as libc::c_int;
        } else if buffer_eq_slen(
            m,
            b"mod_dirlisting\0" as *const u8 as *const libc::c_char,
            (::core::mem::size_of::<[libc::c_char; 15]>() as libc::c_ulong as uint32_t)
                .wrapping_sub(1 as libc::c_int as libc::c_uint) as size_t,
        ) != 0
        {
            append_mod_dirlisting = 0 as libc::c_int;
        } else if buffer_eq_slen(
            m,
            b"mod_gnutls\0" as *const u8 as *const libc::c_char,
            (::core::mem::size_of::<[libc::c_char; 11]>() as libc::c_ulong as uint32_t)
                .wrapping_sub(1 as libc::c_int as libc::c_uint) as size_t,
        ) != 0
        {
            append_mod_openssl = 0 as libc::c_int;
        } else if buffer_eq_slen(
            m,
            b"mod_mbedtls\0" as *const u8 as *const libc::c_char,
            (::core::mem::size_of::<[libc::c_char; 12]>() as libc::c_ulong as uint32_t)
                .wrapping_sub(1 as libc::c_int as libc::c_uint) as size_t,
        ) != 0
        {
            append_mod_openssl = 0 as libc::c_int;
        } else if buffer_eq_slen(
            m,
            b"mod_nss\0" as *const u8 as *const libc::c_char,
            (::core::mem::size_of::<[libc::c_char; 8]>() as libc::c_ulong as uint32_t)
                .wrapping_sub(1 as libc::c_int as libc::c_uint) as size_t,
        ) != 0
        {
            append_mod_openssl = 0 as libc::c_int;
        } else if buffer_eq_slen(
            m,
            b"mod_openssl\0" as *const u8 as *const libc::c_char,
            (::core::mem::size_of::<[libc::c_char; 12]>() as libc::c_ulong as uint32_t)
                .wrapping_sub(1 as libc::c_int as libc::c_uint) as size_t,
        ) != 0
        {
            append_mod_openssl = 0 as libc::c_int;
        } else if buffer_eq_slen(
            m,
            b"mod_wolfssl\0" as *const u8 as *const libc::c_char,
            (::core::mem::size_of::<[libc::c_char; 12]>() as libc::c_ulong as uint32_t)
                .wrapping_sub(1 as libc::c_int as libc::c_uint) as size_t,
        ) != 0
        {
            append_mod_openssl = 0 as libc::c_int;
        } else if 0 as libc::c_int
            == strncmp(
                (*m).ptr,
                b"mod_auth\0" as *const u8 as *const libc::c_char,
                (::core::mem::size_of::<[libc::c_char; 9]>() as libc::c_ulong)
                    .wrapping_sub(1 as libc::c_int as libc::c_ulong),
            )
        {
            if buffer_eq_slen(
                m,
                b"mod_auth\0" as *const u8 as *const libc::c_char,
                (::core::mem::size_of::<[libc::c_char; 9]>() as libc::c_ulong as uint32_t)
                    .wrapping_sub(1 as libc::c_int as libc::c_uint) as size_t,
            ) != 0
            {
                if contains_mod_auth == 0 {
                    contains_mod_auth = 1 as libc::c_int;
                    if !dyn_name.is_null() {
                        log_error(
                            (*srv).errh,
                            b"/home/kkysen/work/rust/lighttpd/src/configfile.c\0"
                                as *const u8 as *const libc::c_char,
                            397 as libc::c_int as libc::c_uint,
                            b"Warning: mod_auth should be listed in server.modules before dynamic backends such as %s\0"
                                as *const u8 as *const libc::c_char,
                            dyn_name,
                        );
                    }
                }
            } else if contains_mod_auth == 0 {
                prepend_mod_auth = 1 as libc::c_int;
            }
            if buffer_eq_slen(
                m,
                b"mod_authn_file\0" as *const u8 as *const libc::c_char,
                (::core::mem::size_of::<[libc::c_char; 15]>() as libc::c_ulong as uint32_t)
                    .wrapping_sub(1 as libc::c_int as libc::c_uint) as size_t,
            ) != 0
            {
                append_mod_authn_file = 0 as libc::c_int;
            } else if buffer_eq_slen(
                m,
                b"mod_authn_ldap\0" as *const u8 as *const libc::c_char,
                (::core::mem::size_of::<[libc::c_char; 15]>() as libc::c_ulong as uint32_t)
                    .wrapping_sub(1 as libc::c_int as libc::c_uint) as size_t,
            ) != 0
            {
                append_mod_authn_ldap = 0 as libc::c_int;
            }
        } else if 0 as libc::c_int
            == strncmp(
                (*m).ptr,
                b"mod_vhostdb\0" as *const u8 as *const libc::c_char,
                (::core::mem::size_of::<[libc::c_char; 12]>() as libc::c_ulong)
                    .wrapping_sub(1 as libc::c_int as libc::c_ulong),
            )
        {
            if buffer_eq_slen(
                m,
                b"mod_vhostdb\0" as *const u8 as *const libc::c_char,
                (::core::mem::size_of::<[libc::c_char; 12]>() as libc::c_ulong as uint32_t)
                    .wrapping_sub(1 as libc::c_int as libc::c_uint) as size_t,
            ) != 0
            {
                prepend_mod_vhostdb |= 2 as libc::c_int;
            } else if prepend_mod_vhostdb & 2 as libc::c_int == 0 {
                prepend_mod_vhostdb |= 1 as libc::c_int;
            }
        } else if 0 as libc::c_int
            == strncmp(
                (*m).ptr,
                b"mod_ajp13\0" as *const u8 as *const libc::c_char,
                (::core::mem::size_of::<[libc::c_char; 10]>() as libc::c_ulong)
                    .wrapping_sub(1 as libc::c_int as libc::c_ulong),
            )
            || 0 as libc::c_int
                == strncmp(
                    (*m).ptr,
                    b"mod_cgi\0" as *const u8 as *const libc::c_char,
                    (::core::mem::size_of::<[libc::c_char; 8]>() as libc::c_ulong)
                        .wrapping_sub(1 as libc::c_int as libc::c_ulong),
                )
            || 0 as libc::c_int
                == strncmp(
                    (*m).ptr,
                    b"mod_fastcgi\0" as *const u8 as *const libc::c_char,
                    (::core::mem::size_of::<[libc::c_char; 12]>() as libc::c_ulong)
                        .wrapping_sub(1 as libc::c_int as libc::c_ulong),
                )
            || 0 as libc::c_int
                == strncmp(
                    (*m).ptr,
                    b"mod_proxy\0" as *const u8 as *const libc::c_char,
                    (::core::mem::size_of::<[libc::c_char; 10]>() as libc::c_ulong)
                        .wrapping_sub(1 as libc::c_int as libc::c_ulong),
                )
            || 0 as libc::c_int
                == strncmp(
                    (*m).ptr,
                    b"mod_scgi\0" as *const u8 as *const libc::c_char,
                    (::core::mem::size_of::<[libc::c_char; 9]>() as libc::c_ulong)
                        .wrapping_sub(1 as libc::c_int as libc::c_ulong),
                )
            || 0 as libc::c_int
                == strncmp(
                    (*m).ptr,
                    b"mod_sockproxy\0" as *const u8 as *const libc::c_char,
                    (::core::mem::size_of::<[libc::c_char; 14]>() as libc::c_ulong)
                        .wrapping_sub(1 as libc::c_int as libc::c_ulong),
                )
            || 0 as libc::c_int
                == strncmp(
                    (*m).ptr,
                    b"mod_wstunnel\0" as *const u8 as *const libc::c_char,
                    (::core::mem::size_of::<[libc::c_char; 13]>() as libc::c_ulong)
                        .wrapping_sub(1 as libc::c_int as libc::c_ulong),
                )
        {
            if dyn_name.is_null() {
                dyn_name = (*m).ptr;
            }
        }
        i = i.wrapping_add(1);
    }
    if prepend_mod_indexfile != 0 {
        config_compat_module_prepend(
            srv,
            b"mod_indexfile\0" as *const u8 as *const libc::c_char,
            (::core::mem::size_of::<[libc::c_char; 14]>() as libc::c_ulong as uint32_t)
                .wrapping_sub(1 as libc::c_int as libc::c_uint),
        );
    }
    if append_mod_dirlisting != 0 {
        array_insert_value(
            (*srv).srvconf.modules,
            b"mod_dirlisting\0" as *const u8 as *const libc::c_char,
            (::core::mem::size_of::<[libc::c_char; 15]>() as libc::c_ulong as uint32_t)
                .wrapping_sub(1 as libc::c_int as libc::c_uint),
        );
    }
    if append_mod_staticfile != 0 {
        array_insert_value(
            (*srv).srvconf.modules,
            b"mod_staticfile\0" as *const u8 as *const libc::c_char,
            (::core::mem::size_of::<[libc::c_char; 15]>() as libc::c_ulong as uint32_t)
                .wrapping_sub(1 as libc::c_int as libc::c_uint),
        );
    }
    append_mod_openssl != 0;
    if contains_mod_auth != 0 {
        if append_mod_authn_file != 0 {
            let mut v: *const libc::c_char = 0 as *const libc::c_char;
            v = config_has_opt_and_value(
                srv,
                b"auth.backend\0" as *const u8 as *const libc::c_char,
                (::core::mem::size_of::<[libc::c_char; 13]>() as libc::c_ulong as uint32_t)
                    .wrapping_sub(1 as libc::c_int as libc::c_uint),
                b"htdigest\0" as *const u8 as *const libc::c_char,
                (::core::mem::size_of::<[libc::c_char; 9]>() as libc::c_ulong as uint32_t)
                    .wrapping_sub(1 as libc::c_int as libc::c_uint),
            );
            if !v.is_null()
                || {
                    v = config_has_opt_and_value(
                        srv,
                        b"auth.backend\0" as *const u8 as *const libc::c_char,
                        (::core::mem::size_of::<[libc::c_char; 13]>() as libc::c_ulong as uint32_t)
                            .wrapping_sub(1 as libc::c_int as libc::c_uint),
                        b"htpasswd\0" as *const u8 as *const libc::c_char,
                        (::core::mem::size_of::<[libc::c_char; 9]>() as libc::c_ulong as uint32_t)
                            .wrapping_sub(1 as libc::c_int as libc::c_uint),
                    );
                    !v.is_null()
                }
                || {
                    v = config_has_opt_and_value(
                        srv,
                        b"auth.backend\0" as *const u8 as *const libc::c_char,
                        (::core::mem::size_of::<[libc::c_char; 13]>() as libc::c_ulong as uint32_t)
                            .wrapping_sub(1 as libc::c_int as libc::c_uint),
                        b"plain\0" as *const u8 as *const libc::c_char,
                        (::core::mem::size_of::<[libc::c_char; 6]>() as libc::c_ulong as uint32_t)
                            .wrapping_sub(1 as libc::c_int as libc::c_uint),
                    );
                    !v.is_null()
                }
            {
                config_warn_authn_module(
                    srv,
                    b"file\0" as *const u8 as *const libc::c_char,
                    (::core::mem::size_of::<[libc::c_char; 5]>() as libc::c_ulong as uint32_t)
                        .wrapping_sub(1 as libc::c_int as libc::c_uint),
                    v,
                );
            }
        }
        append_mod_authn_ldap != 0;
    }
    if prepend_mod_auth != 0 {
        config_compat_module_prepend(
            srv,
            b"mod_auth\0" as *const u8 as *const libc::c_char,
            (::core::mem::size_of::<[libc::c_char; 9]>() as libc::c_ulong as uint32_t)
                .wrapping_sub(1 as libc::c_int as libc::c_uint),
        );
    }
    if prepend_mod_vhostdb & 1 as libc::c_int != 0 {
        config_compat_module_prepend(
            srv,
            b"mod_vhostdb\0" as *const u8 as *const libc::c_char,
            (::core::mem::size_of::<[libc::c_char; 12]>() as libc::c_ulong as uint32_t)
                .wrapping_sub(1 as libc::c_int as libc::c_uint),
        );
    }
}
unsafe extern "C" fn config_compat_module_prepend(
    mut srv: *mut server,
    mut module: *const libc::c_char,
    mut len: uint32_t,
) {
    let mut modules: *mut array =
        array_init(((*(*srv).srvconf.modules).used).wrapping_add(4 as libc::c_int as libc::c_uint));
    array_insert_value(modules, module, len);
    let mut i: uint32_t = 0 as libc::c_int as uint32_t;
    while i < (*(*srv).srvconf.modules).used {
        let mut ds: *mut data_string =
            *((*(*srv).srvconf.modules).data).offset(i as isize) as *mut data_string;
        array_insert_value(modules, (*ds).value.ptr, buffer_clen(&mut (*ds).value));
        i = i.wrapping_add(1);
    }
    array_free((*srv).srvconf.modules);
    (*srv).srvconf.modules = modules;
}
unsafe extern "C" fn config_warn_authn_module(
    mut srv: *mut server,
    mut module: *const libc::c_char,
    mut len: uint32_t,
    mut v: *const libc::c_char,
) {
    let tb: *mut buffer = (*srv).tmp_buf;
    buffer_copy_string_len(
        tb,
        b"mod_authn_\0" as *const u8 as *const libc::c_char,
        (::core::mem::size_of::<[libc::c_char; 11]>() as libc::c_ulong as uint32_t)
            .wrapping_sub(1 as libc::c_int as libc::c_uint) as size_t,
    );
    buffer_append_string_len(tb, module, len as size_t);
    array_insert_value((*srv).srvconf.modules, (*tb).ptr, buffer_clen(tb));
    log_error(
        (*srv).errh,
        b"/home/kkysen/work/rust/lighttpd/src/configfile.c\0" as *const u8
            as *const libc::c_char,
        353 as libc::c_int as libc::c_uint,
        b"Warning: please add \"mod_authn_%s\" to server.modules list in lighttpd.conf.  A future release of lighttpd 1.4.x will not automatically load mod_authn_%s and lighttpd will fail to start up since your lighttpd.conf uses auth.backend = \"%s\".\0"
            as *const u8 as *const libc::c_char,
        module,
        module,
        v,
    );
}
unsafe extern "C" fn config_has_opt_and_value(
    srv: *const server,
    opt: *const libc::c_char,
    olen: uint32_t,
    v: *const libc::c_char,
    vlen: uint32_t,
) -> *const libc::c_char {
    let mut i: uint32_t = 0 as libc::c_int as uint32_t;
    while i < (*(*srv).config_context).used {
        let config: *const data_config =
            *((*(*srv).config_context).data).offset(i as isize) as *const data_config;
        let ds: *const data_string =
            array_get_element_klen((*config).value, opt, olen) as *mut data_string;
        if !ds.is_null()
            && (*ds).type_0 as libc::c_uint == TYPE_STRING as libc::c_int as libc::c_uint
            && buffer_eq_slen(&(*ds).value, v, vlen as size_t) != 0
        {
            return v;
        }
        i = i.wrapping_add(1);
    }
    return 0 as *const libc::c_char;
}
unsafe extern "C" fn config_check_module_duplicates(mut srv: *mut server) {
    let mut dups: libc::c_int = 0 as libc::c_int;
    let data: *mut *mut data_string = (*(*srv).srvconf.modules).data as *mut *mut data_string;
    let used: uint32_t = (*(*srv).srvconf.modules).used;
    let mut i: uint32_t = 0 as libc::c_int as uint32_t;
    while i < used {
        let m: *const buffer = &mut (**data.offset(i as isize)).value;
        let mut j: uint32_t = i.wrapping_add(1 as libc::c_int as libc::c_uint);
        while j < used {
            if buffer_is_equal(m, &mut (**data.offset(j as isize)).value) != 0 {
                dups += 1;
                break;
            } else {
                j = j.wrapping_add(1);
            }
        }
        i = i.wrapping_add(1);
    }
    if dups == 0 {
        return;
    }
    let modules: *mut array = array_init(used.wrapping_sub(dups as libc::c_uint));
    let mut i_0: uint32_t = 0 as libc::c_int as uint32_t;
    while i_0 < used {
        let m_0: *const buffer = &mut (**data.offset(i_0 as isize)).value;
        let mut j_0: uint32_t = 0;
        j_0 = 0 as libc::c_int as uint32_t;
        while j_0 < (*modules).used {
            let mut n: *mut buffer =
                &mut (*(*((*modules).data).offset(j_0 as isize) as *mut data_string)).value;
            if buffer_is_equal(m_0, n) != 0 {
                break;
            }
            j_0 = j_0.wrapping_add(1);
        }
        if j_0 == (*modules).used {
            array_insert_value(modules, (*m_0).ptr, buffer_clen(m_0));
        }
        i_0 = i_0.wrapping_add(1);
    }
    array_free((*srv).srvconf.modules);
    (*srv).srvconf.modules = modules;
}
unsafe extern "C" fn config_http_parseopts(
    mut srv: *mut server,
    mut a: *const array,
) -> libc::c_int {
    let mut opts: libc::c_ushort = (*srv).srvconf.http_url_normalize;
    let mut decode_2f: libc::c_ushort = 1 as libc::c_int as libc::c_ushort;
    let mut rc: libc::c_int = 1 as libc::c_int;
    let mut current_block_25: u64;
    let mut i: size_t = 0 as libc::c_int as size_t;
    while i < (*a).used as libc::c_ulong {
        let ds: *const data_string = *((*a).data).offset(i as isize) as *const data_string;
        let mut k: *const buffer = &(*ds).key;
        let mut opt: libc::c_ushort = 0;
        let mut val: libc::c_int =
            config_plugin_value_tobool(ds as *mut data_unset, 2 as libc::c_int);
        if 2 as libc::c_int == val {
            log_error(
                (*srv).errh,
                b"/home/kkysen/work/rust/lighttpd/src/configfile.c\0" as *const u8
                    as *const libc::c_char,
                551 as libc::c_int as libc::c_uint,
                b"unrecognized value for server.http-parseopts: %s => %s (expect \"[enable|disable]\")\0"
                    as *const u8 as *const libc::c_char,
                (*k).ptr,
                (*ds).value.ptr,
            );
            rc = 0 as libc::c_int;
        }
        if buffer_eq_slen(
            k,
            b"url-normalize\0" as *const u8 as *const libc::c_char,
            (::core::mem::size_of::<[libc::c_char; 14]>() as libc::c_ulong as uint32_t)
                .wrapping_sub(1 as libc::c_int as libc::c_uint) as size_t,
        ) != 0
        {
            opt = HTTP_PARSEOPT_URL_NORMALIZE as libc::c_int as libc::c_ushort;
            current_block_25 = 1118134448028020070;
        } else if buffer_eq_slen(
            k,
            b"url-normalize-unreserved\0" as *const u8 as *const libc::c_char,
            (::core::mem::size_of::<[libc::c_char; 25]>() as libc::c_ulong as uint32_t)
                .wrapping_sub(1 as libc::c_int as libc::c_uint) as size_t,
        ) != 0
        {
            opt = HTTP_PARSEOPT_URL_NORMALIZE_UNRESERVED as libc::c_int as libc::c_ushort;
            current_block_25 = 1118134448028020070;
        } else if buffer_eq_slen(
            k,
            b"url-normalize-required\0" as *const u8 as *const libc::c_char,
            (::core::mem::size_of::<[libc::c_char; 23]>() as libc::c_ulong as uint32_t)
                .wrapping_sub(1 as libc::c_int as libc::c_uint) as size_t,
        ) != 0
        {
            opt = HTTP_PARSEOPT_URL_NORMALIZE_REQUIRED as libc::c_int as libc::c_ushort;
            current_block_25 = 1118134448028020070;
        } else if buffer_eq_slen(
            k,
            b"url-ctrls-reject\0" as *const u8 as *const libc::c_char,
            (::core::mem::size_of::<[libc::c_char; 17]>() as libc::c_ulong as uint32_t)
                .wrapping_sub(1 as libc::c_int as libc::c_uint) as size_t,
        ) != 0
        {
            opt = HTTP_PARSEOPT_URL_NORMALIZE_CTRLS_REJECT as libc::c_int as libc::c_ushort;
            current_block_25 = 1118134448028020070;
        } else if buffer_eq_slen(
            k,
            b"url-path-backslash-trans\0" as *const u8 as *const libc::c_char,
            (::core::mem::size_of::<[libc::c_char; 25]>() as libc::c_ulong as uint32_t)
                .wrapping_sub(1 as libc::c_int as libc::c_uint) as size_t,
        ) != 0
        {
            opt = HTTP_PARSEOPT_URL_NORMALIZE_PATH_BACKSLASH_TRANS as libc::c_int as libc::c_ushort;
            current_block_25 = 1118134448028020070;
        } else if buffer_eq_slen(
            k,
            b"url-path-2f-decode\0" as *const u8 as *const libc::c_char,
            (::core::mem::size_of::<[libc::c_char; 19]>() as libc::c_ulong as uint32_t)
                .wrapping_sub(1 as libc::c_int as libc::c_uint) as size_t,
        ) != 0
        {
            opt = HTTP_PARSEOPT_URL_NORMALIZE_PATH_2F_DECODE as libc::c_int as libc::c_ushort;
            current_block_25 = 1118134448028020070;
        } else if buffer_eq_slen(
            k,
            b"url-path-2f-reject\0" as *const u8 as *const libc::c_char,
            (::core::mem::size_of::<[libc::c_char; 19]>() as libc::c_ulong as uint32_t)
                .wrapping_sub(1 as libc::c_int as libc::c_uint) as size_t,
        ) != 0
        {
            opt = HTTP_PARSEOPT_URL_NORMALIZE_PATH_2F_REJECT as libc::c_int as libc::c_ushort;
            current_block_25 = 1118134448028020070;
        } else if buffer_eq_slen(
            k,
            b"url-path-dotseg-remove\0" as *const u8 as *const libc::c_char,
            (::core::mem::size_of::<[libc::c_char; 23]>() as libc::c_ulong as uint32_t)
                .wrapping_sub(1 as libc::c_int as libc::c_uint) as size_t,
        ) != 0
        {
            opt = HTTP_PARSEOPT_URL_NORMALIZE_PATH_DOTSEG_REMOVE as libc::c_int as libc::c_ushort;
            current_block_25 = 1118134448028020070;
        } else if buffer_eq_slen(
            k,
            b"url-path-dotseg-reject\0" as *const u8 as *const libc::c_char,
            (::core::mem::size_of::<[libc::c_char; 23]>() as libc::c_ulong as uint32_t)
                .wrapping_sub(1 as libc::c_int as libc::c_uint) as size_t,
        ) != 0
        {
            opt = HTTP_PARSEOPT_URL_NORMALIZE_PATH_DOTSEG_REJECT as libc::c_int as libc::c_ushort;
            current_block_25 = 1118134448028020070;
        } else if buffer_eq_slen(
            k,
            b"url-query-20-plus\0" as *const u8 as *const libc::c_char,
            (::core::mem::size_of::<[libc::c_char; 18]>() as libc::c_ulong as uint32_t)
                .wrapping_sub(1 as libc::c_int as libc::c_uint) as size_t,
        ) != 0
        {
            opt = HTTP_PARSEOPT_URL_NORMALIZE_QUERY_20_PLUS as libc::c_int as libc::c_ushort;
            current_block_25 = 1118134448028020070;
        } else {
            if buffer_eq_slen(
                k,
                b"header-strict\0" as *const u8 as *const libc::c_char,
                (::core::mem::size_of::<[libc::c_char; 14]>() as libc::c_ulong as uint32_t)
                    .wrapping_sub(1 as libc::c_int as libc::c_uint) as size_t,
            ) != 0
            {
                (*srv).srvconf.http_header_strict = val as libc::c_uchar;
            } else if buffer_eq_slen(
                k,
                b"host-strict\0" as *const u8 as *const libc::c_char,
                (::core::mem::size_of::<[libc::c_char; 12]>() as libc::c_ulong as uint32_t)
                    .wrapping_sub(1 as libc::c_int as libc::c_uint) as size_t,
            ) != 0
            {
                (*srv).srvconf.http_host_strict = val as libc::c_uchar;
            } else if buffer_eq_slen(
                k,
                b"host-normalize\0" as *const u8 as *const libc::c_char,
                (::core::mem::size_of::<[libc::c_char; 15]>() as libc::c_ulong as uint32_t)
                    .wrapping_sub(1 as libc::c_int as libc::c_uint) as size_t,
            ) != 0
            {
                (*srv).srvconf.http_host_normalize = val as libc::c_uchar;
            } else if buffer_eq_slen(
                k,
                b"method-get-body\0" as *const u8 as *const libc::c_char,
                (::core::mem::size_of::<[libc::c_char; 16]>() as libc::c_ulong as uint32_t)
                    .wrapping_sub(1 as libc::c_int as libc::c_uint) as size_t,
            ) != 0
            {
                (*srv).srvconf.http_method_get_body = val as libc::c_uchar;
            } else {
                log_error(
                    (*srv).errh,
                    b"/home/kkysen/work/rust/lighttpd/src/configfile.c\0" as *const u8
                        as *const libc::c_char,
                    593 as libc::c_int as libc::c_uint,
                    b"unrecognized key for server.http-parseopts: %s\0" as *const u8
                        as *const libc::c_char,
                    (*k).ptr,
                );
                rc = 0 as libc::c_int;
            }
            current_block_25 = 6239978542346980191;
        }
        match current_block_25 {
            1118134448028020070 => {
                if val != 0 {
                    opts = (opts as libc::c_int | opt as libc::c_int) as libc::c_ushort;
                } else {
                    opts = (opts as libc::c_int & !(opt as libc::c_int)) as libc::c_ushort;
                    if opt as libc::c_int == HTTP_PARSEOPT_URL_NORMALIZE as libc::c_int {
                        opts = 0 as libc::c_int as libc::c_ushort;
                        break;
                    } else if opt as libc::c_int
                        == HTTP_PARSEOPT_URL_NORMALIZE_PATH_2F_DECODE as libc::c_int
                    {
                        decode_2f = 0 as libc::c_int as libc::c_ushort;
                    }
                }
            }
            _ => {}
        }
        i = i.wrapping_add(1);
    }
    if opts as libc::c_int != 0 as libc::c_int {
        opts = (opts as libc::c_int | HTTP_PARSEOPT_URL_NORMALIZE as libc::c_int) as libc::c_ushort;
        if opts as libc::c_int
            & (HTTP_PARSEOPT_URL_NORMALIZE_PATH_2F_DECODE as libc::c_int
                | HTTP_PARSEOPT_URL_NORMALIZE_PATH_2F_REJECT as libc::c_int)
            == HTTP_PARSEOPT_URL_NORMALIZE_PATH_2F_DECODE as libc::c_int
                | HTTP_PARSEOPT_URL_NORMALIZE_PATH_2F_REJECT as libc::c_int
        {
            log_error(
                (*srv).errh,
                b"/home/kkysen/work/rust/lighttpd/src/configfile.c\0" as *const u8
                    as *const libc::c_char,
                617 as libc::c_int as libc::c_uint,
                b"conflicting options in server.http-parseopts:url-path-2f-decode, url-path-2f-reject\0"
                    as *const u8 as *const libc::c_char,
            );
            rc = 0 as libc::c_int;
        }
        if opts as libc::c_int
            & (HTTP_PARSEOPT_URL_NORMALIZE_PATH_DOTSEG_REMOVE as libc::c_int
                | HTTP_PARSEOPT_URL_NORMALIZE_PATH_DOTSEG_REJECT as libc::c_int)
            == HTTP_PARSEOPT_URL_NORMALIZE_PATH_DOTSEG_REMOVE as libc::c_int
                | HTTP_PARSEOPT_URL_NORMALIZE_PATH_DOTSEG_REJECT as libc::c_int
        {
            log_error(
                (*srv).errh,
                b"/home/kkysen/work/rust/lighttpd/src/configfile.c\0" as *const u8
                    as *const libc::c_char,
                626 as libc::c_int as libc::c_uint,
                b"conflicting options in server.http-parseopts:url-path-dotseg-remove, url-path-dotseg-reject\0"
                    as *const u8 as *const libc::c_char,
            );
            rc = 0 as libc::c_int;
        }
        if opts as libc::c_int
            & (HTTP_PARSEOPT_URL_NORMALIZE_UNRESERVED as libc::c_int
                | HTTP_PARSEOPT_URL_NORMALIZE_REQUIRED as libc::c_int)
            == 0
        {
            opts = (opts as libc::c_int | HTTP_PARSEOPT_URL_NORMALIZE_UNRESERVED as libc::c_int)
                as libc::c_ushort;
            if decode_2f as libc::c_int != 0
                && opts as libc::c_int & HTTP_PARSEOPT_URL_NORMALIZE_PATH_2F_REJECT as libc::c_int
                    == 0
            {
                opts = (opts as libc::c_int
                    | HTTP_PARSEOPT_URL_NORMALIZE_PATH_2F_DECODE as libc::c_int)
                    as libc::c_ushort;
            }
        }
    }
    (*srv).srvconf.http_url_normalize = opts;
    return rc;
}
unsafe extern "C" fn config_tokenizer(
    mut srv: *mut server,
    mut t: *mut tokenizer_t,
    mut token_id: *mut libc::c_int,
    mut token: *mut buffer,
) -> libc::c_int {
    let mut tid: libc::c_int = 0 as libc::c_int;
    let mut i: size_t = 0;
    if (*t).simulate_eol != 0 {
        (*t).simulate_eol = 0 as libc::c_int;
        (*t).in_key = 1 as libc::c_int;
        tid = 1 as libc::c_int;
        buffer_copy_string_len(
            token,
            b"(EOL)\0" as *const u8 as *const libc::c_char,
            (::core::mem::size_of::<[libc::c_char; 6]>() as libc::c_ulong as uint32_t)
                .wrapping_sub(1 as libc::c_int as libc::c_uint) as size_t,
        );
    }
    while tid == 0 as libc::c_int
        && (*t).offset < (*t).size
        && *((*t).input).offset((*t).offset as isize) as libc::c_int != 0
    {
        let mut c: libc::c_char = *((*t).input).offset((*t).offset as isize);
        let mut start: *const libc::c_char = 0 as *const libc::c_char;
        match c as libc::c_int {
            61 => {
                if (*t).in_brace != 0 {
                    if *((*t).input).offset(
                        ((*t).offset).wrapping_add(1 as libc::c_int as libc::c_ulong) as isize,
                    ) as libc::c_int
                        == '>' as i32
                    {
                        (*t).offset = ((*t).offset as libc::c_ulong)
                            .wrapping_add(2 as libc::c_int as libc::c_ulong)
                            as size_t as size_t;
                        buffer_copy_string_len(
                            token,
                            b"=>\0" as *const u8 as *const libc::c_char,
                            (::core::mem::size_of::<[libc::c_char; 3]>() as libc::c_ulong
                                as uint32_t)
                                .wrapping_sub(1 as libc::c_int as libc::c_uint)
                                as size_t,
                        );
                        tid = 12 as libc::c_int;
                    } else {
                        return config_tokenizer_err(
                            srv,
                            b"/home/kkysen/work/rust/lighttpd/src/configfile.c\0" as *const u8
                                as *const libc::c_char,
                            1775 as libc::c_int as libc::c_uint,
                            t,
                            b"use => for assignments in arrays\0" as *const u8
                                as *const libc::c_char,
                        );
                    }
                } else if (*t).in_cond != 0 {
                    if *((*t).input).offset(
                        ((*t).offset).wrapping_add(1 as libc::c_int as libc::c_ulong) as isize,
                    ) as libc::c_int
                        == '=' as i32
                    {
                        (*t).offset = ((*t).offset as libc::c_ulong)
                            .wrapping_add(2 as libc::c_int as libc::c_ulong)
                            as size_t as size_t;
                        buffer_copy_string_len(
                            token,
                            b"==\0" as *const u8 as *const libc::c_char,
                            (::core::mem::size_of::<[libc::c_char; 3]>() as libc::c_ulong
                                as uint32_t)
                                .wrapping_sub(1 as libc::c_int as libc::c_uint)
                                as size_t,
                        );
                        tid = 21 as libc::c_int;
                    } else if *((*t).input).offset(
                        ((*t).offset).wrapping_add(1 as libc::c_int as libc::c_ulong) as isize,
                    ) as libc::c_int
                        == '~' as i32
                    {
                        (*t).offset = ((*t).offset as libc::c_ulong)
                            .wrapping_add(2 as libc::c_int as libc::c_ulong)
                            as size_t as size_t;
                        buffer_copy_string_len(
                            token,
                            b"=~\0" as *const u8 as *const libc::c_char,
                            (::core::mem::size_of::<[libc::c_char; 3]>() as libc::c_ulong
                                as uint32_t)
                                .wrapping_sub(1 as libc::c_int as libc::c_uint)
                                as size_t,
                        );
                        tid = 22 as libc::c_int;
                    } else {
                        return config_tokenizer_err(
                            srv,
                            b"/home/kkysen/work/rust/lighttpd/src/configfile.c\0" as *const u8
                                as *const libc::c_char,
                            1792 as libc::c_int as libc::c_uint,
                            t,
                            b"only =~ and == are allowed in the condition\0" as *const u8
                                as *const libc::c_char,
                        );
                    }
                    (*t).in_key = 1 as libc::c_int;
                    (*t).in_cond = 0 as libc::c_int;
                } else if (*t).in_key != 0 {
                    tid = 2 as libc::c_int;
                    buffer_copy_string_len(
                        token,
                        ((*t).input).offset((*t).offset as isize),
                        1 as libc::c_int as size_t,
                    );
                    (*t).offset = ((*t).offset).wrapping_add(1);
                    (*t).line_pos += 1;
                } else {
                    return config_tokenizer_err(
                        srv,
                        b"/home/kkysen/work/rust/lighttpd/src/configfile.c\0" as *const u8
                            as *const libc::c_char,
                        1805 as libc::c_int as libc::c_uint,
                        t,
                        b"unexpected equal-sign: =\0" as *const u8 as *const libc::c_char,
                    );
                }
            }
            33 => {
                if (*t).in_cond != 0 {
                    if *((*t).input).offset(
                        ((*t).offset).wrapping_add(1 as libc::c_int as libc::c_ulong) as isize,
                    ) as libc::c_int
                        == '=' as i32
                    {
                        (*t).offset = ((*t).offset as libc::c_ulong)
                            .wrapping_add(2 as libc::c_int as libc::c_ulong)
                            as size_t as size_t;
                        buffer_copy_string_len(
                            token,
                            b"!=\0" as *const u8 as *const libc::c_char,
                            (::core::mem::size_of::<[libc::c_char; 3]>() as libc::c_ulong
                                as uint32_t)
                                .wrapping_sub(1 as libc::c_int as libc::c_uint)
                                as size_t,
                        );
                        tid = 23 as libc::c_int;
                    } else if *((*t).input).offset(
                        ((*t).offset).wrapping_add(1 as libc::c_int as libc::c_ulong) as isize,
                    ) as libc::c_int
                        == '~' as i32
                    {
                        (*t).offset = ((*t).offset as libc::c_ulong)
                            .wrapping_add(2 as libc::c_int as libc::c_ulong)
                            as size_t as size_t;
                        buffer_copy_string_len(
                            token,
                            b"!~\0" as *const u8 as *const libc::c_char,
                            (::core::mem::size_of::<[libc::c_char; 3]>() as libc::c_ulong
                                as uint32_t)
                                .wrapping_sub(1 as libc::c_int as libc::c_uint)
                                as size_t,
                        );
                        tid = 24 as libc::c_int;
                    } else {
                        return config_tokenizer_err(
                            srv,
                            b"/home/kkysen/work/rust/lighttpd/src/configfile.c\0" as *const u8
                                as *const libc::c_char,
                            1825 as libc::c_int as libc::c_uint,
                            t,
                            b"only !~ and != are allowed in the condition\0" as *const u8
                                as *const libc::c_char,
                        );
                    }
                    (*t).in_key = 1 as libc::c_int;
                    (*t).in_cond = 0 as libc::c_int;
                } else {
                    return config_tokenizer_err(
                        srv,
                        b"/home/kkysen/work/rust/lighttpd/src/configfile.c\0" as *const u8
                            as *const libc::c_char,
                        1831 as libc::c_int as libc::c_uint,
                        t,
                        b"unexpected exclamation-marks: !\0" as *const u8 as *const libc::c_char,
                    );
                }
            }
            9 | 32 => {
                (*t).offset = ((*t).offset).wrapping_add(1);
                (*t).line_pos += 1;
            }
            10 | 13 => {
                if (*t).in_brace == 0 as libc::c_int {
                    let mut done: libc::c_int = 0 as libc::c_int;
                    while done == 0 && (*t).offset < (*t).size {
                        match *((*t).input).offset((*t).offset as isize) as libc::c_int {
                            13 | 10 => {
                                config_skip_newline(t);
                                (*t).line_pos = 1 as libc::c_int;
                                (*t).line += 1;
                            }
                            35 => {
                                (*t).line_pos += config_skip_comment(t);
                            }
                            9 | 32 => {
                                (*t).offset = ((*t).offset).wrapping_add(1);
                                (*t).line_pos += 1;
                            }
                            _ => {
                                done = 1 as libc::c_int;
                            }
                        }
                    }
                    (*t).in_key = 1 as libc::c_int;
                    tid = 1 as libc::c_int;
                    buffer_copy_string_len(
                        token,
                        b"(EOL)\0" as *const u8 as *const libc::c_char,
                        (::core::mem::size_of::<[libc::c_char; 6]>() as libc::c_ulong as uint32_t)
                            .wrapping_sub(1 as libc::c_int as libc::c_uint)
                            as size_t,
                    );
                } else {
                    config_skip_newline(t);
                    (*t).line_pos = 1 as libc::c_int;
                    (*t).line += 1;
                }
            }
            44 => {
                if (*t).in_brace > 0 as libc::c_int {
                    tid = 11 as libc::c_int;
                    buffer_copy_string_len(
                        token,
                        b"(COMMA)\0" as *const u8 as *const libc::c_char,
                        (::core::mem::size_of::<[libc::c_char; 8]>() as libc::c_ulong as uint32_t)
                            .wrapping_sub(1 as libc::c_int as libc::c_uint)
                            as size_t,
                    );
                }
                (*t).offset = ((*t).offset).wrapping_add(1);
                (*t).line_pos += 1;
            }
            34 => {
                start = ((*t).input)
                    .offset((*t).offset as isize)
                    .offset(1 as libc::c_int as isize);
                buffer_copy_string_len(
                    token,
                    b"\0" as *const u8 as *const libc::c_char,
                    (::core::mem::size_of::<[libc::c_char; 1]>() as libc::c_ulong as uint32_t)
                        .wrapping_sub(1 as libc::c_int as libc::c_uint)
                        as size_t,
                );
                i = 1 as libc::c_int as size_t;
                while *((*t).input).offset(((*t).offset).wrapping_add(i) as isize) != 0 {
                    if *((*t).input).offset(((*t).offset).wrapping_add(i) as isize) as libc::c_int
                        == '\\' as i32
                        && *((*t).input).offset(
                            ((*t).offset)
                                .wrapping_add(i)
                                .wrapping_add(1 as libc::c_int as libc::c_ulong)
                                as isize,
                        ) as libc::c_int
                            == '"' as i32
                    {
                        buffer_append_string_len(
                            token,
                            start,
                            ((*t).input)
                                .offset((*t).offset as isize)
                                .offset(i as isize)
                                .offset_from(start) as libc::c_long
                                as size_t,
                        );
                        start = ((*t).input)
                            .offset((*t).offset as isize)
                            .offset(i as isize)
                            .offset(1 as libc::c_int as isize);
                        i = i.wrapping_add(1);
                    } else if *((*t).input).offset(((*t).offset).wrapping_add(i) as isize)
                        as libc::c_int
                        == '"' as i32
                    {
                        tid = 7 as libc::c_int;
                        buffer_append_string_len(
                            token,
                            start,
                            ((*t).input)
                                .offset((*t).offset as isize)
                                .offset(i as isize)
                                .offset_from(start) as libc::c_long
                                as size_t,
                        );
                        break;
                    }
                    i = i.wrapping_add(1);
                }
                if *((*t).input).offset(((*t).offset).wrapping_add(i) as isize) as libc::c_int
                    == '\0' as i32
                {
                    return config_tokenizer_err(
                        srv,
                        b"/home/kkysen/work/rust/lighttpd/src/configfile.c\0" as *const u8
                            as *const libc::c_char,
                        1916 as libc::c_int as libc::c_uint,
                        t,
                        b"missing closing quote\0" as *const u8 as *const libc::c_char,
                    );
                }
                (*t).offset = ((*t).offset as libc::c_ulong)
                    .wrapping_add(i.wrapping_add(1 as libc::c_int as libc::c_ulong))
                    as size_t as size_t;
                (*t).line_pos = ((*t).line_pos as libc::c_ulong)
                    .wrapping_add(i.wrapping_add(1 as libc::c_int as libc::c_ulong))
                    as libc::c_int as libc::c_int;
            }
            40 => {
                (*t).offset = ((*t).offset).wrapping_add(1);
                (*t).in_brace += 1;
                tid = 9 as libc::c_int;
                buffer_copy_string_len(
                    token,
                    b"(\0" as *const u8 as *const libc::c_char,
                    (::core::mem::size_of::<[libc::c_char; 2]>() as libc::c_ulong as uint32_t)
                        .wrapping_sub(1 as libc::c_int as libc::c_uint)
                        as size_t,
                );
            }
            41 => {
                (*t).offset = ((*t).offset).wrapping_add(1);
                (*t).in_brace -= 1;
                tid = 10 as libc::c_int;
                buffer_copy_string_len(
                    token,
                    b")\0" as *const u8 as *const libc::c_char,
                    (::core::mem::size_of::<[libc::c_char; 2]>() as libc::c_ulong as uint32_t)
                        .wrapping_sub(1 as libc::c_int as libc::c_uint)
                        as size_t,
                );
            }
            36 => {
                (*t).offset = ((*t).offset).wrapping_add(1);
                tid = 17 as libc::c_int;
                (*t).in_cond = 1 as libc::c_int;
                (*t).in_key = 0 as libc::c_int;
                buffer_copy_string_len(
                    token,
                    b"$\0" as *const u8 as *const libc::c_char,
                    (::core::mem::size_of::<[libc::c_char; 2]>() as libc::c_ulong as uint32_t)
                        .wrapping_sub(1 as libc::c_int as libc::c_uint)
                        as size_t,
                );
            }
            43 => {
                if *((*t).input)
                    .offset(((*t).offset).wrapping_add(1 as libc::c_int as libc::c_ulong) as isize)
                    as libc::c_int
                    == '=' as i32
                {
                    (*t).offset = ((*t).offset as libc::c_ulong)
                        .wrapping_add(2 as libc::c_int as libc::c_ulong)
                        as size_t as size_t;
                    buffer_copy_string_len(
                        token,
                        b"+=\0" as *const u8 as *const libc::c_char,
                        (::core::mem::size_of::<[libc::c_char; 3]>() as libc::c_ulong as uint32_t)
                            .wrapping_sub(1 as libc::c_int as libc::c_uint)
                            as size_t,
                    );
                    tid = 4 as libc::c_int;
                } else {
                    (*t).offset = ((*t).offset).wrapping_add(1);
                    tid = 6 as libc::c_int;
                    buffer_copy_string_len(
                        token,
                        b"+\0" as *const u8 as *const libc::c_char,
                        (::core::mem::size_of::<[libc::c_char; 2]>() as libc::c_ulong as uint32_t)
                            .wrapping_sub(1 as libc::c_int as libc::c_uint)
                            as size_t,
                    );
                }
            }
            58 => {
                if *((*t).input)
                    .offset(((*t).offset).wrapping_add(1 as libc::c_int as libc::c_ulong) as isize)
                    as libc::c_int
                    == '=' as i32
                {
                    (*t).offset = ((*t).offset as libc::c_ulong)
                        .wrapping_add(2 as libc::c_int as libc::c_ulong)
                        as size_t as size_t;
                    tid = 3 as libc::c_int;
                    buffer_copy_string_len(
                        token,
                        b":=\0" as *const u8 as *const libc::c_char,
                        (::core::mem::size_of::<[libc::c_char; 3]>() as libc::c_ulong as uint32_t)
                            .wrapping_sub(1 as libc::c_int as libc::c_uint)
                            as size_t,
                    );
                } else {
                    return config_tokenizer_err(
                        srv,
                        b"/home/kkysen/work/rust/lighttpd/src/configfile.c\0" as *const u8
                            as *const libc::c_char,
                        1969 as libc::c_int as libc::c_uint,
                        t,
                        b"unexpected character ':'\0" as *const u8 as *const libc::c_char,
                    );
                }
            }
            123 => {
                (*t).offset = ((*t).offset).wrapping_add(1);
                tid = 14 as libc::c_int;
                buffer_copy_string_len(
                    token,
                    b"{\0" as *const u8 as *const libc::c_char,
                    (::core::mem::size_of::<[libc::c_char; 2]>() as libc::c_ulong as uint32_t)
                        .wrapping_sub(1 as libc::c_int as libc::c_uint)
                        as size_t,
                );
            }
            125 => {
                (*t).offset = ((*t).offset).wrapping_add(1);
                tid = 15 as libc::c_int;
                buffer_copy_string_len(
                    token,
                    b"}\0" as *const u8 as *const libc::c_char,
                    (::core::mem::size_of::<[libc::c_char; 2]>() as libc::c_ulong as uint32_t)
                        .wrapping_sub(1 as libc::c_int as libc::c_uint)
                        as size_t,
                );
                while (*t).offset < (*t).size {
                    c = *((*t).input).offset((*t).offset as isize);
                    if c as libc::c_int == '\r' as i32 || c as libc::c_int == '\n' as i32 {
                        break;
                    }
                    if c as libc::c_int == '#' as i32 {
                        (*t).line_pos += config_skip_comment(t);
                        break;
                    } else if c as libc::c_int != ' ' as i32 && c as libc::c_int != '\t' as i32 {
                        (*t).simulate_eol = 1 as libc::c_int;
                        break;
                    } else {
                        (*t).offset = ((*t).offset).wrapping_add(1);
                        (*t).line_pos += 1;
                    }
                }
            }
            91 => {
                (*t).offset = ((*t).offset).wrapping_add(1);
                tid = 19 as libc::c_int;
                buffer_copy_string_len(
                    token,
                    b"[\0" as *const u8 as *const libc::c_char,
                    (::core::mem::size_of::<[libc::c_char; 2]>() as libc::c_ulong as uint32_t)
                        .wrapping_sub(1 as libc::c_int as libc::c_uint)
                        as size_t,
                );
            }
            93 => {
                (*t).offset = ((*t).offset).wrapping_add(1);
                tid = 20 as libc::c_int;
                buffer_copy_string_len(
                    token,
                    b"]\0" as *const u8 as *const libc::c_char,
                    (::core::mem::size_of::<[libc::c_char; 2]>() as libc::c_ulong as uint32_t)
                        .wrapping_sub(1 as libc::c_int as libc::c_uint)
                        as size_t,
                );
            }
            35 => {
                (*t).line_pos += config_skip_comment(t);
            }
            _ => {
                if (*t).in_cond != 0 {
                    i = 0 as libc::c_int as size_t;
                    while *((*t).input).offset(((*t).offset).wrapping_add(i) as isize)
                        as libc::c_int
                        != 0
                        && (*(*__ctype_b_loc()).offset(
                            *((*t).input).offset(((*t).offset).wrapping_add(i) as isize)
                                as libc::c_uchar as libc::c_int
                                as isize,
                        ) as libc::c_int
                            & _ISalpha as libc::c_int as libc::c_ushort as libc::c_int
                            != 0
                            || *((*t).input).offset(((*t).offset).wrapping_add(i) as isize)
                                as libc::c_int
                                == '_' as i32)
                    {
                        i = i.wrapping_add(1);
                    }
                    if i != 0
                        && *((*t).input).offset(((*t).offset).wrapping_add(i) as isize)
                            as libc::c_int
                            != 0
                    {
                        tid = 18 as libc::c_int;
                        buffer_copy_string_len(token, ((*t).input).offset((*t).offset as isize), i);
                        (*t).offset =
                            ((*t).offset as libc::c_ulong).wrapping_add(i) as size_t as size_t;
                        (*t).line_pos = ((*t).line_pos as libc::c_ulong).wrapping_add(i)
                            as libc::c_int as libc::c_int;
                    } else {
                        return config_tokenizer_err(
                            srv,
                            b"/home/kkysen/work/rust/lighttpd/src/configfile.c\0" as *const u8
                                as *const libc::c_char,
                            2041 as libc::c_int as libc::c_uint,
                            t,
                            b"invalid character in condition\0" as *const u8 as *const libc::c_char,
                        );
                    }
                } else if *(*__ctype_b_loc()).offset(c as libc::c_uchar as libc::c_int as isize)
                    as libc::c_int
                    & _ISdigit as libc::c_int as libc::c_ushort as libc::c_int
                    != 0
                {
                    i = 0 as libc::c_int as size_t;
                    while *((*t).input).offset(((*t).offset).wrapping_add(i) as isize)
                        as libc::c_int
                        != 0
                        && *(*__ctype_b_loc()).offset(
                            *((*t).input).offset(((*t).offset).wrapping_add(i) as isize)
                                as libc::c_uchar as libc::c_int
                                as isize,
                        ) as libc::c_int
                            & _ISdigit as libc::c_int as libc::c_ushort as libc::c_int
                            != 0
                    {
                        i = i.wrapping_add(1);
                    }
                    if i != 0 {
                        tid = 8 as libc::c_int;
                        buffer_copy_string_len(token, ((*t).input).offset((*t).offset as isize), i);
                        (*t).offset =
                            ((*t).offset as libc::c_ulong).wrapping_add(i) as size_t as size_t;
                        (*t).line_pos = ((*t).line_pos as libc::c_ulong).wrapping_add(i)
                            as libc::c_int as libc::c_int;
                    }
                } else {
                    i = 0 as libc::c_int as size_t;
                    while *((*t).input).offset(((*t).offset).wrapping_add(i) as isize)
                        as libc::c_int
                        != 0
                        && (*(*__ctype_b_loc()).offset(
                            *((*t).input).offset(((*t).offset).wrapping_add(i) as isize)
                                as libc::c_uchar as libc::c_int
                                as isize,
                        ) as libc::c_int
                            & _ISalnum as libc::c_int as libc::c_ushort as libc::c_int
                            != 0
                            || *((*t).input).offset(((*t).offset).wrapping_add(i) as isize)
                                as libc::c_int
                                == '.' as i32
                            || *((*t).input).offset(((*t).offset).wrapping_add(i) as isize)
                                as libc::c_int
                                == '_' as i32
                            || *((*t).input).offset(((*t).offset).wrapping_add(i) as isize)
                                as libc::c_int
                                == '-' as i32)
                    {
                        i = i.wrapping_add(1);
                    }
                    if i != 0
                        && *((*t).input).offset(((*t).offset).wrapping_add(i) as isize)
                            as libc::c_int
                            != 0
                    {
                        buffer_copy_string_len(token, ((*t).input).offset((*t).offset as isize), i);
                        if strcmp(
                            (*token).ptr,
                            b"include\0" as *const u8 as *const libc::c_char,
                        ) == 0 as libc::c_int
                        {
                            tid = 25 as libc::c_int;
                        } else if strcmp(
                            (*token).ptr,
                            b"include_shell\0" as *const u8 as *const libc::c_char,
                        ) == 0 as libc::c_int
                        {
                            tid = 26 as libc::c_int;
                        } else if strcmp(
                            (*token).ptr,
                            b"global\0" as *const u8 as *const libc::c_char,
                        ) == 0 as libc::c_int
                        {
                            tid = 13 as libc::c_int;
                        } else if strcmp(
                            (*token).ptr,
                            b"else\0" as *const u8 as *const libc::c_char,
                        ) == 0 as libc::c_int
                        {
                            tid = 16 as libc::c_int;
                        } else {
                            tid = 5 as libc::c_int;
                        }
                        (*t).offset =
                            ((*t).offset as libc::c_ulong).wrapping_add(i) as size_t as size_t;
                        (*t).line_pos = ((*t).line_pos as libc::c_ulong).wrapping_add(i)
                            as libc::c_int as libc::c_int;
                    } else if 0 as libc::c_int as libc::c_ulong == i
                        && *((*t).input as *mut uint8_t).offset(
                            ((*t).offset).wrapping_add(0 as libc::c_int as libc::c_ulong) as isize,
                        ) as libc::c_int
                            == 0xc2 as libc::c_int
                        && *((*t).input as *mut uint8_t).offset(
                            ((*t).offset).wrapping_add(1 as libc::c_int as libc::c_ulong) as isize,
                        ) as libc::c_int
                            == 0xa0 as libc::c_int
                    {
                        (*t).offset = ((*t).offset as libc::c_ulong)
                            .wrapping_add(2 as libc::c_int as libc::c_ulong)
                            as size_t as size_t;
                        (*t).line_pos += 2 as libc::c_int;
                    } else {
                        return config_tokenizer_err(
                            srv,
                            b"/home/kkysen/work/rust/lighttpd/src/configfile.c\0" as *const u8
                                as *const libc::c_char,
                            2091 as libc::c_int as libc::c_uint,
                            t,
                            b"invalid character in variable name\0" as *const u8
                                as *const libc::c_char,
                        );
                    }
                }
            }
        }
    }
    if tid != 0 {
        *token_id = tid;
        return 1 as libc::c_int;
    } else {
        if (*t).offset < (*t).size {
            log_error(
                (*srv).errh,
                b"/home/kkysen/work/rust/lighttpd/src/configfile.c\0" as *const u8
                    as *const libc::c_char,
                2103 as libc::c_int as libc::c_uint,
                b"%d, %s\0" as *const u8 as *const libc::c_char,
                tid,
                (*token).ptr,
            );
        }
    }
    return 0 as libc::c_int;
}
#[cold]
unsafe extern "C" fn config_tokenizer_err(
    mut srv: *mut server,
    mut file: *const libc::c_char,
    mut line: libc::c_uint,
    mut t: *mut tokenizer_t,
    mut msg: *const libc::c_char,
) -> libc::c_int {
    log_error(
        (*srv).errh,
        file,
        line,
        b"source: %s line: %d pos: %d %s\0" as *const u8 as *const libc::c_char,
        (*t).source,
        (*t).line,
        (*t).line_pos,
        msg,
    );
    return -(1 as libc::c_int);
}
unsafe extern "C" fn config_merge_config_cpv(
    pconf: *mut request_config,
    cpv: *const config_plugin_value_t,
) {
    match (*cpv).k_id {
        0 => {
            (*pconf).document_root = (*cpv).v.b;
        }
        1 => {
            (*pconf).server_name = (*cpv).v.b;
        }
        2 => {
            (*pconf).server_tag = (*cpv).v.b;
        }
        3 => {
            (*pconf).max_request_size = (*cpv).v.u;
        }
        4 => {
            (*pconf).max_keep_alive_requests = (*cpv).v.shrt;
        }
        5 => {
            (*pconf).max_keep_alive_idle = (*cpv).v.shrt;
        }
        6 => {
            (*pconf).max_read_idle = (*cpv).v.shrt;
        }
        7 => {
            (*pconf).max_write_idle = (*cpv).v.shrt;
        }
        8 => {
            (*pconf).errorfile_prefix = (*cpv).v.b;
        }
        9 => {
            (*pconf).error_handler = (*cpv).v.b;
        }
        10 => {
            (*pconf).error_handler_404 = (*cpv).v.b;
        }
        11 => {
            (*pconf).error_intercept =
                (0 as libc::c_int as libc::c_uint != (*cpv).v.u) as libc::c_int as libc::c_uchar;
        }
        12 => {
            (*pconf).force_lowercase_filenames =
                (0 as libc::c_int as libc::c_uint != (*cpv).v.u) as libc::c_int as libc::c_uchar;
        }
        13 => {
            (*pconf).follow_symlink =
                (0 as libc::c_int as libc::c_uint != (*cpv).v.u) as libc::c_int as libc::c_uchar;
        }
        14 => {
            (*pconf).allow_http11 =
                (0 as libc::c_int as libc::c_uint != (*cpv).v.u) as libc::c_int as libc::c_uchar;
        }
        15 => {
            (*pconf).range_requests =
                (0 as libc::c_int as libc::c_uint != (*cpv).v.u) as libc::c_int as libc::c_uchar;
        }
        16 => {
            (*pconf).stream_request_body = (*cpv).v.shrt;
        }
        17 => {
            (*pconf).stream_response_body = (*cpv).v.shrt;
        }
        18 => {
            (*pconf).global_bytes_per_second =
                *((*cpv).v.v as *mut off_t).offset(1 as libc::c_int as isize) as libc::c_uint;
            (*pconf).global_bytes_per_second_cnt_ptr = (*cpv).v.v as *mut off_t;
        }
        19 => {
            (*pconf).bytes_per_second = ((*cpv).v.shrt as libc::c_uint) << 10 as libc::c_int;
        }
        20 => {
            (*pconf).mimetypes = (*cpv).v.a;
        }
        21 => {
            (*pconf).use_xattr =
                (0 as libc::c_int as libc::c_uint != (*cpv).v.u) as libc::c_int as libc::c_uchar;
        }
        22 => {
            if (*cpv).v.u != 0 {
                (*pconf).etag_flags = ((*pconf).etag_flags as libc::c_int
                    | ETAG_USE_INODE as libc::c_int)
                    as libc::c_uchar;
            } else {
                (*pconf).etag_flags = ((*pconf).etag_flags as libc::c_int
                    & !(ETAG_USE_INODE as libc::c_int))
                    as libc::c_uchar;
            };
        }
        23 => {
            if (*cpv).v.u != 0 {
                (*pconf).etag_flags = ((*pconf).etag_flags as libc::c_int
                    | ETAG_USE_MTIME as libc::c_int)
                    as libc::c_uchar;
            } else {
                (*pconf).etag_flags = ((*pconf).etag_flags as libc::c_int
                    & !(ETAG_USE_MTIME as libc::c_int))
                    as libc::c_uchar;
            };
        }
        24 => {
            if (*cpv).v.u != 0 {
                (*pconf).etag_flags = ((*pconf).etag_flags as libc::c_int
                    | ETAG_USE_SIZE as libc::c_int)
                    as libc::c_uchar;
            } else {
                (*pconf).etag_flags = ((*pconf).etag_flags as libc::c_int
                    & !(ETAG_USE_SIZE as libc::c_int))
                    as libc::c_uchar;
            };
        }
        25 => {
            (*pconf).log_condition_handling =
                (0 as libc::c_int as libc::c_uint != (*cpv).v.u) as libc::c_int as libc::c_uchar;
        }
        26 => {
            (*pconf).log_file_not_found =
                (0 as libc::c_int as libc::c_uint != (*cpv).v.u) as libc::c_int as libc::c_uchar;
        }
        27 => {
            (*pconf).log_request_handling =
                (0 as libc::c_int as libc::c_uint != (*cpv).v.u) as libc::c_int as libc::c_uchar;
        }
        28 => {
            (*pconf).log_request_header =
                (0 as libc::c_int as libc::c_uint != (*cpv).v.u) as libc::c_int as libc::c_uchar;
        }
        29 => {
            (*pconf).log_response_header =
                (0 as libc::c_int as libc::c_uint != (*cpv).v.u) as libc::c_int as libc::c_uchar;
        }
        30 => {
            (*pconf).log_timeouts =
                (0 as libc::c_int as libc::c_uint != (*cpv).v.u) as libc::c_int as libc::c_uchar;
        }
        31 => {
            (*pconf).log_state_handling =
                (0 as libc::c_int as libc::c_uint != (*cpv).v.u) as libc::c_int as libc::c_uchar;
        }
        32 => {
            if (*cpv).vtype as libc::c_uint == T_CONFIG_LOCAL as libc::c_int as libc::c_uint {
                (*pconf).errh = (*cpv).v.v as *mut fdlog_st;
            }
        }
        33 => {
            if (*cpv).vtype as libc::c_uint == T_CONFIG_LOCAL as libc::c_int as libc::c_uint {
                (*pconf).serrh = (*cpv).v.v as *mut fdlog_st;
            }
        }
        _ => return,
    };
}
unsafe extern "C" fn config_skip_comment(mut t: *mut tokenizer_t) -> libc::c_int {
    let mut i: libc::c_int = 0;
    if !(*((*t).input).offset((*t).offset as isize) as libc::c_int == '#' as i32) {
        ck_assert_failed(
            b"/home/kkysen/work/rust/lighttpd/src/configfile.c\0" as *const u8
                as *const libc::c_char,
            1735 as libc::c_int as libc::c_uint,
            b"t->input[t->offset] == '#'\0" as *const u8 as *const libc::c_char,
        );
    }
    i = 1 as libc::c_int;
    while *((*t).input).offset(((*t).offset).wrapping_add(i as libc::c_ulong) as isize)
        as libc::c_int
        != 0
        && (*((*t).input).offset(((*t).offset).wrapping_add(i as libc::c_ulong) as isize)
            as libc::c_int
            != '\n' as i32
            && *((*t).input).offset(((*t).offset).wrapping_add(i as libc::c_ulong) as isize)
                as libc::c_int
                != '\r' as i32)
    {
        i += 1;
    }
    (*t).offset =
        ((*t).offset as libc::c_ulong).wrapping_add(i as libc::c_ulong) as size_t as size_t;
    return i;
}
#[no_mangle]
pub unsafe extern "C" fn config_patch_config(r: *mut request_st) {
    let p: *mut config_data_base = (*(*r).con).config_data_base as *mut config_data_base;
    let mut i: libc::c_int = 1 as libc::c_int;
    let mut used: libc::c_int = (*p).nconfig;
    while i < used {
        if config_check_cond(
            r,
            (*((*p).cvlist).offset(i as isize)).k_id as uint32_t as libc::c_int,
        ) != 0
        {
            config_merge_config(
                &mut (*r).conf,
                ((*p).cvlist).offset(
                    (*((*p).cvlist).offset(i as isize)).v.u2[0 as libc::c_int as usize] as isize,
                ),
            );
        }
        i += 1;
    }
}
unsafe extern "C" fn config_merge_config(
    pconf: *mut request_config,
    mut cpv: *const config_plugin_value_t,
) {
    loop {
        config_merge_config_cpv(pconf, cpv);
        cpv = cpv.offset(1);
        if !((*cpv).k_id != -(1 as libc::c_int)) {
            break;
        }
    }
}
unsafe extern "C" fn config_skip_newline(mut t: *mut tokenizer_t) -> libc::c_int {
    let mut skipped: libc::c_int = 1 as libc::c_int;
    if !(*((*t).input).offset((*t).offset as isize) as libc::c_int == '\r' as i32
        || *((*t).input).offset((*t).offset as isize) as libc::c_int == '\n' as i32)
    {
        ck_assert_failed(
            b"/home/kkysen/work/rust/lighttpd/src/configfile.c\0" as *const u8
                as *const libc::c_char,
            1724 as libc::c_int as libc::c_uint,
            b"t->input[t->offset] == '\\r' || t->input[t->offset] == '\\n'\0" as *const u8
                as *const libc::c_char,
        );
    }
    if *((*t).input).offset((*t).offset as isize) as libc::c_int == '\r' as i32
        && *((*t).input)
            .offset(((*t).offset).wrapping_add(1 as libc::c_int as libc::c_ulong) as isize)
            as libc::c_int
            == '\n' as i32
    {
        skipped += 1;
        (*t).offset = ((*t).offset).wrapping_add(1);
    }
    (*t).offset = ((*t).offset).wrapping_add(1);
    return skipped;
}
#[no_mangle]
#[cold]
pub unsafe extern "C" fn config_finalize(
    mut srv: *mut server,
    mut default_server_tag_0: *const buffer,
) -> libc::c_int {
    let p: *mut config_data_base = (*srv).config_data_base as *mut config_data_base;
    (*p).defaults.high_precision_timestamps = (*srv).srvconf.high_precision_timestamps;
    if ((*p).defaults.server_tag).is_null() {
        (*p).defaults.server_tag = default_server_tag_0;
    } else if buffer_is_blank((*p).defaults.server_tag) != 0 {
        (*p).defaults.server_tag = 0 as *const buffer;
    }
    let mut i: uint32_t = 0 as libc::c_int as uint32_t;
    while i < (*(*srv).config_context).used {
        let mut config: *mut array =
            (*(*((*(*srv).config_context).data).offset(i as isize) as *mut data_config)).value;
        let mut j: uint32_t = 0 as libc::c_int as uint32_t;
        while !config.is_null() && j < (*config).used {
            let k: *const buffer = &mut (**((*config).data).offset(j as isize)).key;
            if !(strncmp(
                (*k).ptr,
                b"var.\0" as *const u8 as *const libc::c_char,
                (::core::mem::size_of::<[libc::c_char; 5]>() as libc::c_ulong)
                    .wrapping_sub(1 as libc::c_int as libc::c_ulong),
            ) == 0 as libc::c_int)
            {
                if (array_get_element_klen((*srv).srvconf.config_touched, (*k).ptr, buffer_clen(k)))
                    .is_null()
                {
                    log_error(
                        (*srv).errh,
                        b"/home/kkysen/work/rust/lighttpd/src/configfile.c\0" as *const u8
                            as *const libc::c_char,
                        1213 as libc::c_int as libc::c_uint,
                        b"WARNING: unknown config-key: %s (ignored)\0" as *const u8
                            as *const libc::c_char,
                        (*k).ptr,
                    );
                }
            }
            j = j.wrapping_add(1);
        }
        i = i.wrapping_add(1);
    }
    array_free((*srv).srvconf.config_touched);
    (*srv).srvconf.config_touched = 0 as *mut array;
    if (*srv).srvconf.config_unsupported as libc::c_int != 0
        || (*srv).srvconf.config_deprecated as libc::c_int != 0
    {
        if (*srv).srvconf.config_unsupported != 0 {
            log_error(
                (*srv).errh,
                b"/home/kkysen/work/rust/lighttpd/src/configfile.c\0" as *const u8
                    as *const libc::c_char,
                1223 as libc::c_int as libc::c_uint,
                b"Configuration contains unsupported keys. Going down.\0" as *const u8
                    as *const libc::c_char,
            );
        }
        if (*srv).srvconf.config_deprecated != 0 {
            log_error(
                (*srv).errh,
                b"/home/kkysen/work/rust/lighttpd/src/configfile.c\0" as *const u8
                    as *const libc::c_char,
                1226 as libc::c_int as libc::c_uint,
                b"Configuration contains deprecated keys. Going down.\0" as *const u8
                    as *const libc::c_char,
            );
        }
        return 0 as libc::c_int;
    }
    let mut i_0: uint32_t = 1 as libc::c_int as uint32_t;
    while i_0 < (*(*srv).config_context).used {
        let dc: *mut data_config =
            *((*(*srv).config_context).data).offset(i_0 as isize) as *mut data_config;
        if ((*dc).cond as libc::c_uint == CONFIG_COND_MATCH as libc::c_int as libc::c_uint
            || (*dc).cond as libc::c_uint == CONFIG_COND_NOMATCH as libc::c_int as libc::c_uint)
            && 0 as libc::c_int == (*dc).capture_idx
        {
            if (0 as *mut libc::c_void == (*srv).match_data) as libc::c_int as libc::c_long != 0 {
                let mut ovec_max: uint32_t = 10 as libc::c_int as uint32_t;
                (*srv).match_data =
                    pcre2_match_data_create_8(ovec_max, 0 as *mut pcre2_general_context_8)
                        as *mut libc::c_void;
                if ((*srv).match_data).is_null() {
                    ck_assert_failed(
                        b"/home/kkysen/work/rust/lighttpd/src/configfile.c\0" as *const u8
                            as *const libc::c_char,
                        1261 as libc::c_int as libc::c_uint,
                        b"srv->match_data\0" as *const u8 as *const libc::c_char,
                    );
                }
            }
            (*dc).match_data = (*srv).match_data as *mut pcre2_real_match_data_8;
        }
        i_0 = i_0.wrapping_add(1);
    }
    return 1 as libc::c_int;
}
#[no_mangle]
#[cold]
pub unsafe extern "C" fn config_free(mut srv: *mut server) {
    config_free_config((*srv).config_data_base);
    array_free((*srv).config_context);
    array_free((*srv).srvconf.config_touched);
    array_free((*srv).srvconf.modules);
    array_free((*srv).srvconf.upload_tempdirs);
    if ((*srv).match_data).is_null() {
        pcre2_match_data_free_8((*srv).match_data as *mut pcre2_match_data_8);
    }
}
unsafe extern "C" fn config_free_config(p_d: *mut libc::c_void) {
    let p: *mut plugin_data_base = p_d as *mut plugin_data_base;
    if p.is_null() {
        return;
    }
    if ((*p).cvlist).is_null() {
        free(p as *mut libc::c_void);
        return;
    }
    let mut i: libc::c_int = ((*((*p).cvlist).offset(0 as libc::c_int as isize)).v.u2
        [1 as libc::c_int as usize]
        == 0) as libc::c_int;
    let mut used: libc::c_int = (*p).nconfig;
    while i < used {
        let mut cpv: *mut config_plugin_value_t = ((*p).cvlist)
            .offset((*((*p).cvlist).offset(i as isize)).v.u2[0 as libc::c_int as usize] as isize);
        while -(1 as libc::c_int) != (*cpv).k_id {
            match (*cpv).k_id {
                18 => {
                    if (*cpv).vtype as libc::c_uint == T_CONFIG_LOCAL as libc::c_int as libc::c_uint
                    {
                        free((*cpv).v.v);
                    }
                }
                _ => {}
            }
            cpv = cpv.offset(1);
        }
        i += 1;
    }
    free((*p).cvlist as *mut libc::c_void);
    free(p as *mut libc::c_void);
}
#[no_mangle]
#[cold]
pub unsafe extern "C" fn config_log_error_open(mut srv: *mut server) -> libc::c_int {
    let p: *mut config_data_base = (*srv).config_data_base as *mut config_data_base;
    let mut serrh: *mut log_error_st = 0 as *mut log_error_st;
    let mut i: libc::c_int = ((*((*p).cvlist).offset(0 as libc::c_int as isize)).v.u2
        [1 as libc::c_int as usize]
        == 0) as libc::c_int;
    while i < (*p).nconfig {
        let mut cpv: *mut config_plugin_value_t = ((*p).cvlist)
            .offset((*((*p).cvlist).offset(i as isize)).v.u2[0 as libc::c_int as usize] as isize);
        let mut current_block_15: u64;
        while -(1 as libc::c_int) != (*cpv).k_id {
            let mut fn_0: *const libc::c_char = 0 as *const libc::c_char;
            let mut errh: *mut log_error_st = 0 as *mut log_error_st;
            match (*cpv).k_id {
                32 => {
                    if 0 as libc::c_int == i {
                        if (*srv).srvconf.errorlog_use_syslog != 0 {
                            current_block_15 = 16658872821858055392;
                        } else {
                            errh = (*srv).errh;
                            current_block_15 = 16112922285257937552;
                        }
                    } else {
                        current_block_15 = 16112922285257937552;
                    }
                }
                33 => {
                    current_block_15 = 16112922285257937552;
                }
                _ => {
                    current_block_15 = 1856101646708284338;
                }
            }
            match current_block_15 {
                16112922285257937552 => {
                    if buffer_is_blank((*cpv).v.b) == 0 {
                        fn_0 = (*(*cpv).v.b).ptr;
                    }
                    current_block_15 = 1856101646708284338;
                }
                _ => {}
            }
            match current_block_15 {
                1856101646708284338 => {
                    if !fn_0.is_null() {
                        let fdlog: *mut fdlog_st = fdlog_open(fn_0);
                        if fdlog.is_null() {
                            log_perror(
                                (*srv).errh,
                                b"/home/kkysen/work/rust/lighttpd/src/configfile.c\0" as *const u8
                                    as *const libc::c_char,
                                1608 as libc::c_int as libc::c_uint,
                                b"opening errorlog '%s' failed\0" as *const u8
                                    as *const libc::c_char,
                                fn_0,
                            );
                            return -(1 as libc::c_int);
                        }
                        if !errh.is_null() {
                            (*srv).errh = fdlog;
                            (*p).defaults.errh = (*srv).errh;
                            log_set_global_errh((*srv).errh, 0 as libc::c_int);
                        }
                        errh = fdlog;
                        (*cpv).v.v = errh as *mut libc::c_void;
                        (*cpv).vtype = T_CONFIG_LOCAL;
                        if 0 as libc::c_int == i && errh != (*srv).errh {
                            serrh = errh;
                        }
                    }
                }
                _ => {}
            }
            cpv = cpv.offset(1);
        }
        i += 1;
    }
    if config_feature_bool(
        srv,
        b"server.errorlog-high-precision\0" as *const u8 as *const libc::c_char,
        0 as libc::c_int,
    ) != 0
    {
        log_set_global_errh((*srv).errh, 1 as libc::c_int);
    }
    if (*srv).srvconf.errorlog_use_syslog != 0 {
        config_log_error_open_syslog(srv, (*srv).errh, (*srv).srvconf.syslog_facility);
    } else if (*(*srv).errh).mode as libc::c_uint == FDLOG_FD as libc::c_int as libc::c_uint
        && (*srv).srvconf.dont_daemonize == 0
    {
        (*(*srv).errh).fd = -(1 as libc::c_int);
    }
    let mut errfd: libc::c_int = 0;
    if !serrh.is_null() {
        if (*(*srv).errh).mode as libc::c_uint == FDLOG_FD as libc::c_int as libc::c_uint {
            (*(*srv).errh).fd = dup(2 as libc::c_int);
            fdevent_setfd_cloexec((*(*srv).errh).fd);
        }
        errfd = (*serrh).fd;
        if *(*serrh).fn_0 as libc::c_int == '|' as i32 {
            fdlog_pipe_serrh(errfd);
        }
    } else if (*srv).srvconf.dont_daemonize == 0 {
        errfd = fdevent_open_devnull();
        if -(1 as libc::c_int) == errfd {
            log_perror(
                (*srv).errh,
                b"/home/kkysen/work/rust/lighttpd/src/configfile.c\0" as *const u8
                    as *const libc::c_char,
                1659 as libc::c_int as libc::c_uint,
                b"opening /dev/null failed\0" as *const u8 as *const libc::c_char,
            );
            return -(1 as libc::c_int);
        }
    } else {
        errfd = -(1 as libc::c_int);
    }
    if 0 as libc::c_int
        != fdevent_set_stdin_stdout_stderr(-(1 as libc::c_int), -(1 as libc::c_int), errfd)
    {
        log_perror(
            (*srv).errh,
            b"/home/kkysen/work/rust/lighttpd/src/configfile.c\0" as *const u8
                as *const libc::c_char,
            1669 as libc::c_int as libc::c_uint,
            b"setting stderr failed\0" as *const u8 as *const libc::c_char,
        );
        if -(1 as libc::c_int) != errfd && serrh.is_null() {
            close(errfd);
        }
        return -(1 as libc::c_int);
    }
    if -(1 as libc::c_int) != errfd && serrh.is_null() {
        close(errfd);
    }
    if !serrh.is_null() {
        close(errfd);
        (*serrh).fd = 2 as libc::c_int;
    }
    return 0 as libc::c_int;
}
unsafe extern "C" fn config_log_error_open_syslog(
    mut srv: *mut server,
    mut errh: *mut log_error_st,
    mut syslog_facility: *const buffer,
) {
    (*errh).mode = FDLOG_SYSLOG;
    (*errh).fd = -(1 as libc::c_int);
    let mut facility: libc::c_int = -(1 as libc::c_int);
    if !syslog_facility.is_null() {
        static mut facility_names: [facility_name_st; 21] = [
            {
                let mut init = facility_name_st {
                    name: b"auth\0" as *const u8 as *const libc::c_char,
                    val: (4 as libc::c_int) << 3 as libc::c_int,
                };
                init
            },
            {
                let mut init = facility_name_st {
                    name: b"authpriv\0" as *const u8 as *const libc::c_char,
                    val: (10 as libc::c_int) << 3 as libc::c_int,
                };
                init
            },
            {
                let mut init = facility_name_st {
                    name: b"cron\0" as *const u8 as *const libc::c_char,
                    val: (9 as libc::c_int) << 3 as libc::c_int,
                };
                init
            },
            {
                let mut init = facility_name_st {
                    name: b"daemon\0" as *const u8 as *const libc::c_char,
                    val: (3 as libc::c_int) << 3 as libc::c_int,
                };
                init
            },
            {
                let mut init = facility_name_st {
                    name: b"ftp\0" as *const u8 as *const libc::c_char,
                    val: (11 as libc::c_int) << 3 as libc::c_int,
                };
                init
            },
            {
                let mut init = facility_name_st {
                    name: b"kern\0" as *const u8 as *const libc::c_char,
                    val: (0 as libc::c_int) << 3 as libc::c_int,
                };
                init
            },
            {
                let mut init = facility_name_st {
                    name: b"lpr\0" as *const u8 as *const libc::c_char,
                    val: (6 as libc::c_int) << 3 as libc::c_int,
                };
                init
            },
            {
                let mut init = facility_name_st {
                    name: b"mail\0" as *const u8 as *const libc::c_char,
                    val: (2 as libc::c_int) << 3 as libc::c_int,
                };
                init
            },
            {
                let mut init = facility_name_st {
                    name: b"news\0" as *const u8 as *const libc::c_char,
                    val: (7 as libc::c_int) << 3 as libc::c_int,
                };
                init
            },
            {
                let mut init = facility_name_st {
                    name: b"security\0" as *const u8 as *const libc::c_char,
                    val: (4 as libc::c_int) << 3 as libc::c_int,
                };
                init
            },
            {
                let mut init = facility_name_st {
                    name: b"syslog\0" as *const u8 as *const libc::c_char,
                    val: (5 as libc::c_int) << 3 as libc::c_int,
                };
                init
            },
            {
                let mut init = facility_name_st {
                    name: b"user\0" as *const u8 as *const libc::c_char,
                    val: (1 as libc::c_int) << 3 as libc::c_int,
                };
                init
            },
            {
                let mut init = facility_name_st {
                    name: b"uucp\0" as *const u8 as *const libc::c_char,
                    val: (8 as libc::c_int) << 3 as libc::c_int,
                };
                init
            },
            {
                let mut init = facility_name_st {
                    name: b"local0\0" as *const u8 as *const libc::c_char,
                    val: (16 as libc::c_int) << 3 as libc::c_int,
                };
                init
            },
            {
                let mut init = facility_name_st {
                    name: b"local1\0" as *const u8 as *const libc::c_char,
                    val: (17 as libc::c_int) << 3 as libc::c_int,
                };
                init
            },
            {
                let mut init = facility_name_st {
                    name: b"local2\0" as *const u8 as *const libc::c_char,
                    val: (18 as libc::c_int) << 3 as libc::c_int,
                };
                init
            },
            {
                let mut init = facility_name_st {
                    name: b"local3\0" as *const u8 as *const libc::c_char,
                    val: (19 as libc::c_int) << 3 as libc::c_int,
                };
                init
            },
            {
                let mut init = facility_name_st {
                    name: b"local4\0" as *const u8 as *const libc::c_char,
                    val: (20 as libc::c_int) << 3 as libc::c_int,
                };
                init
            },
            {
                let mut init = facility_name_st {
                    name: b"local5\0" as *const u8 as *const libc::c_char,
                    val: (21 as libc::c_int) << 3 as libc::c_int,
                };
                init
            },
            {
                let mut init = facility_name_st {
                    name: b"local6\0" as *const u8 as *const libc::c_char,
                    val: (22 as libc::c_int) << 3 as libc::c_int,
                };
                init
            },
            {
                let mut init = facility_name_st {
                    name: b"local7\0" as *const u8 as *const libc::c_char,
                    val: (23 as libc::c_int) << 3 as libc::c_int,
                };
                init
            },
        ];
        let mut i: libc::c_uint = 0 as libc::c_int as libc::c_uint;
        while (i as libc::c_ulong)
            < (::core::mem::size_of::<[facility_name_st; 21]>() as libc::c_ulong)
                .wrapping_div(::core::mem::size_of::<facility_name_st>() as libc::c_ulong)
        {
            let mut f: *const facility_name_st = facility_names.as_ptr().offset(i as isize);
            if 0 as libc::c_int == strcmp((*syslog_facility).ptr, (*f).name) {
                facility = (*f).val;
                break;
            } else {
                i = i.wrapping_add(1);
            }
        }
        if -(1 as libc::c_int) == facility {
            log_error(
                (*srv).errh,
                b"/home/kkysen/work/rust/lighttpd/src/configfile.c\0" as *const u8
                    as *const libc::c_char,
                1559 as libc::c_int as libc::c_uint,
                b"unrecognized server.syslog-facility: \"%s\"; defaulting to \"daemon\" facility\0"
                    as *const u8 as *const libc::c_char,
                (*syslog_facility).ptr,
            );
        }
    }
    openlog(
        b"lighttpd\0" as *const u8 as *const libc::c_char,
        0x2 as libc::c_int | 0x1 as libc::c_int,
        if -(1 as libc::c_int) == facility {
            (3 as libc::c_int) << 3 as libc::c_int
        } else {
            facility
        },
    );
}
#[no_mangle]
#[cold]
pub unsafe extern "C" fn config_log_error_close(mut srv: *mut server) {
    let p: *mut config_data_base = (*srv).config_data_base as *mut config_data_base;
    if p.is_null() {
        return;
    }
    (*p).defaults.serrh = 0 as *mut fdlog_st;
    fdlog_closeall((*srv).errh);
    if (*(*srv).errh).mode as libc::c_uint == FDLOG_SYSLOG as libc::c_int as libc::c_uint {
        (*(*srv).errh).mode = FDLOG_FD;
        (*(*srv).errh).fd = 2 as libc::c_int;
        closelog();
    }
}
#[no_mangle]
pub unsafe extern "C" fn config_reset_config_bytes_sec(p_d: *mut libc::c_void) {
    let p: *mut plugin_data_base = p_d as *mut plugin_data_base;
    if ((*p).cvlist).is_null() {
        return;
    }
    let mut i: libc::c_int = ((*((*p).cvlist).offset(0 as libc::c_int as isize)).v.u2
        [1 as libc::c_int as usize]
        == 0) as libc::c_int;
    let mut used: libc::c_int = (*p).nconfig;
    while i < used {
        let mut cpv: *mut config_plugin_value_t = ((*p).cvlist)
            .offset((*((*p).cvlist).offset(i as isize)).v.u2[0 as libc::c_int as usize] as isize);
        while -(1 as libc::c_int) != (*cpv).k_id {
            match (*cpv).k_id {
                18 => {
                    if (*cpv).vtype as libc::c_uint == T_CONFIG_LOCAL as libc::c_int as libc::c_uint
                    {
                        *((*cpv).v.v as *mut off_t).offset(0 as libc::c_int as isize) =
                            0 as libc::c_int as off_t;
                    }
                }
                _ => {}
            }
            cpv = cpv.offset(1);
        }
        i += 1;
    }
}
#[cold]
unsafe extern "C" fn config_parse_stdin(
    mut srv: *mut server,
    mut context: *mut config_t,
) -> libc::c_int {
    let b: *mut buffer = chunk_buffer_acquire();
    let mut dlen: size_t = 0;
    let mut n: ssize_t = -(1 as libc::c_int) as ssize_t;
    loop {
        if n > 0 as libc::c_int as libc::c_long {
            buffer_commit(b, n as size_t);
        }
        let mut avail: size_t = buffer_string_space(b) as size_t;
        dlen = buffer_clen(b) as size_t;
        if (avail < 1024 as libc::c_int as libc::c_ulong) as libc::c_int as libc::c_long != 0 {
            if dlen
                >= (32 as libc::c_int * 1024 as libc::c_int * 1024 as libc::c_int) as libc::c_ulong
            {
                log_error(
                    (*srv).errh,
                    b"/home/kkysen/work/rust/lighttpd/src/configfile.c\0" as *const u8
                        as *const libc::c_char,
                    2176 as libc::c_int as libc::c_uint,
                    b"config read from stdin is way too large\0" as *const u8
                        as *const libc::c_char,
                );
                break;
            } else {
                avail = chunk_buffer_prepare_append(
                    b,
                    ((*b).size as libc::c_ulong).wrapping_add(avail),
                );
            }
        }
        n = read(
            0 as libc::c_int,
            ((*b).ptr).offset(dlen as isize) as *mut libc::c_void,
            avail,
        );
        if !(n > 0 as libc::c_int as libc::c_long
            || n == -(1 as libc::c_int) as libc::c_long && *__errno_location() == 4 as libc::c_int)
        {
            break;
        }
    }
    let mut rc: libc::c_int = -(1 as libc::c_int);
    if 0 as libc::c_int as libc::c_long == n {
        rc = if dlen != 0 {
            config_parse(
                srv,
                context,
                b"-\0" as *const u8 as *const libc::c_char,
                (*b).ptr,
                dlen,
            )
        } else {
            0 as libc::c_int
        };
    } else {
        log_perror(
            (*srv).errh,
            b"/home/kkysen/work/rust/lighttpd/src/configfile.c\0" as *const u8
                as *const libc::c_char,
            2188 as libc::c_int as libc::c_uint,
            b"config read from stdin\0" as *const u8 as *const libc::c_char,
        );
    }
    if dlen != 0 {
        ck_memzero((*b).ptr as *mut libc::c_void, dlen);
    }
    chunk_buffer_release(b);
    return rc;
}
unsafe extern "C" fn config_parse_file_stream(
    mut srv: *mut server,
    mut context: *mut config_t,
    mut fn_0: *const libc::c_char,
) -> libc::c_int {
    let mut dlen: off_t = (32 as libc::c_int * 1024 as libc::c_int * 1024 as libc::c_int) as off_t;
    let mut data: *mut libc::c_char = fdevent_load_file(
        fn_0,
        &mut dlen,
        0 as *mut log_error_st,
        Some(malloc as unsafe extern "C" fn(libc::c_ulong) -> *mut libc::c_void),
        Some(free as unsafe extern "C" fn(*mut libc::c_void) -> ()),
    );
    if data.is_null() {
        log_perror(
            (*srv).errh,
            b"/home/kkysen/work/rust/lighttpd/src/configfile.c\0" as *const u8
                as *const libc::c_char,
            2200 as libc::c_int as libc::c_uint,
            b"opening configfile %s failed\0" as *const u8 as *const libc::c_char,
            fn_0,
        );
        return -(1 as libc::c_int);
    }
    let mut rc: libc::c_int = 0 as libc::c_int;
    if dlen != 0 {
        rc = config_parse(srv, context, fn_0, data, dlen as size_t);
        ck_memzero(data as *mut libc::c_void, dlen as size_t);
    }
    free(data as *mut libc::c_void);
    return rc;
}
#[no_mangle]
#[cold]
pub unsafe extern "C" fn config_parse_file(
    mut srv: *mut server,
    mut context: *mut config_t,
    mut fn_0: *const libc::c_char,
) -> libc::c_int {
    let filename: *mut buffer = buffer_init();
    let fnlen: size_t = strlen(fn_0);
    let mut ret: libc::c_int = -(1 as libc::c_int);
    let mut flags: libc::c_int = (1 as libc::c_int) << 10 as libc::c_int;
    let mut gl: glob_t = glob_t {
        gl_pathc: 0,
        gl_pathv: 0 as *mut *mut libc::c_char,
        gl_offs: 0,
        gl_flags: 0,
        gl_closedir: None,
        gl_readdir: None,
        gl_opendir: None,
        gl_lstat: None,
        gl_stat: None,
    };
    if *fn_0.offset(0 as libc::c_int as isize) as libc::c_int == '/' as i32
        || *fn_0.offset(0 as libc::c_int as isize) as libc::c_int == '\\' as i32
        || *fn_0.offset(0 as libc::c_int as isize) as libc::c_int == '.' as i32
            && (*fn_0.offset(1 as libc::c_int as isize) as libc::c_int == '/' as i32
                || *fn_0.offset(1 as libc::c_int as isize) as libc::c_int == '\\' as i32)
        || *fn_0.offset(0 as libc::c_int as isize) as libc::c_int == '.' as i32
            && *fn_0.offset(1 as libc::c_int as isize) as libc::c_int == '.' as i32
            && (*fn_0.offset(2 as libc::c_int as isize) as libc::c_int == '/' as i32
                || *fn_0.offset(2 as libc::c_int as isize) as libc::c_int == '\\' as i32)
    {
        buffer_copy_string_len(filename, fn_0, fnlen);
    } else {
        buffer_copy_path_len2(
            filename,
            (*(*context).basedir).ptr,
            buffer_clen((*context).basedir) as size_t,
            fn_0,
            fnlen,
        );
    }
    match glob((*filename).ptr, flags, None, &mut gl) {
        0 => {
            let mut i: size_t = 0 as libc::c_int as size_t;
            while i < gl.gl_pathc {
                ret = config_parse_file_stream(srv, context, *(gl.gl_pathv).offset(i as isize));
                if 0 as libc::c_int != ret {
                    break;
                }
                i = i.wrapping_add(1);
            }
            globfree(&mut gl);
        }
        3 => {
            if *((*filename).ptr).offset(strcspn(
                (*filename).ptr,
                b"*?[]{}\0" as *const u8 as *const libc::c_char,
            ) as isize) as libc::c_int
                != '\0' as i32
            {
                ret = 0 as libc::c_int;
            } else {
                log_error(
                    (*srv).errh,
                    b"/home/kkysen/work/rust/lighttpd/src/configfile.c\0" as *const u8
                        as *const libc::c_char,
                    2247 as libc::c_int as libc::c_uint,
                    b"include file not found: %s\0" as *const u8 as *const libc::c_char,
                    (*filename).ptr,
                );
            }
        }
        2 | 1 => {
            log_perror(
                (*srv).errh,
                b"/home/kkysen/work/rust/lighttpd/src/configfile.c\0" as *const u8
                    as *const libc::c_char,
                2252 as libc::c_int as libc::c_uint,
                b"glob() %s failed\0" as *const u8 as *const libc::c_char,
                (*filename).ptr,
            );
        }
        _ => {}
    }
    buffer_free(filename);
    return ret;
}
#[no_mangle]
#[cold]
pub unsafe extern "C" fn config_parse_cmd(
    mut srv: *mut server,
    mut context: *mut config_t,
    mut cmd: *const libc::c_char,
) -> libc::c_int {
    let mut ret: libc::c_int = 0 as libc::c_int;
    let mut fds: [libc::c_int; 2] = [0; 2];
    let mut oldpwd: [libc::c_char; 4096] = [0; 4096];
    if (getcwd(
        oldpwd.as_mut_ptr(),
        ::core::mem::size_of::<[libc::c_char; 4096]>() as libc::c_ulong,
    ))
    .is_null()
    {
        log_perror(
            (*srv).errh,
            b"/home/kkysen/work/rust/lighttpd/src/configfile.c\0" as *const u8
                as *const libc::c_char,
            2282 as libc::c_int as libc::c_uint,
            b"getcwd()\0" as *const u8 as *const libc::c_char,
        );
        return -(1 as libc::c_int);
    }
    if buffer_is_blank((*context).basedir) == 0 {
        if 0 as libc::c_int != chdir((*(*context).basedir).ptr) {
            log_perror(
                (*srv).errh,
                b"/home/kkysen/work/rust/lighttpd/src/configfile.c\0" as *const u8
                    as *const libc::c_char,
                2288 as libc::c_int as libc::c_uint,
                b"cannot change directory to %s\0" as *const u8 as *const libc::c_char,
                (*(*context).basedir).ptr,
            );
            return -(1 as libc::c_int);
        }
    }
    if fdevent_pipe_cloexec(fds.as_mut_ptr(), 65536 as libc::c_int as libc::c_uint) != 0 {
        log_perror(
            (*srv).errh,
            b"/home/kkysen/work/rust/lighttpd/src/configfile.c\0" as *const u8
                as *const libc::c_char,
            2295 as libc::c_int as libc::c_uint,
            b"pipe()\0" as *const u8 as *const libc::c_char,
        );
        ret = -(1 as libc::c_int);
    } else {
        let mut shell: *mut libc::c_char = getenv(b"SHELL\0" as *const u8 as *const libc::c_char);
        let mut args: [*mut libc::c_char; 4] = [0 as *mut libc::c_char; 4];
        let mut pid: pid_t = 0;
        let ref mut fresh78 = *(&mut *args.as_mut_ptr().offset(0 as libc::c_int as isize)
            as *mut *mut libc::c_char as *mut *const libc::c_char);
        *fresh78 = if !shell.is_null() {
            shell as *const libc::c_char
        } else {
            b"/bin/sh\0" as *const u8 as *const libc::c_char
        };
        let ref mut fresh79 = *(&mut *args.as_mut_ptr().offset(1 as libc::c_int as isize)
            as *mut *mut libc::c_char as *mut *const libc::c_char);
        *fresh79 = b"-c\0" as *const u8 as *const libc::c_char;
        let ref mut fresh80 = *(&mut *args.as_mut_ptr().offset(2 as libc::c_int as isize)
            as *mut *mut libc::c_char as *mut *const libc::c_char);
        *fresh80 = cmd;
        args[3 as libc::c_int as usize] = 0 as *mut libc::c_char;
        pid = fdevent_fork_execve(
            args[0 as libc::c_int as usize],
            args.as_mut_ptr(),
            0 as *mut *mut libc::c_char,
            -(1 as libc::c_int),
            fds[1 as libc::c_int as usize],
            -(1 as libc::c_int),
            -(1 as libc::c_int),
        );
        if -(1 as libc::c_int) == pid {
            log_perror(
                (*srv).errh,
                b"/home/kkysen/work/rust/lighttpd/src/configfile.c\0" as *const u8
                    as *const libc::c_char,
                2309 as libc::c_int as libc::c_uint,
                b"fork/exec(%s)\0" as *const u8 as *const libc::c_char,
                cmd,
            );
            ret = -(1 as libc::c_int);
        } else {
            let mut rd: ssize_t = 0;
            let mut wstatus: libc::c_int = 0 as libc::c_int;
            let mut out: *mut buffer = buffer_init();
            close(fds[1 as libc::c_int as usize]);
            fds[1 as libc::c_int as usize] = -(1 as libc::c_int);
            loop {
                rd = read(
                    fds[0 as libc::c_int as usize],
                    buffer_string_prepare_append(out, 1023 as libc::c_int as size_t)
                        as *mut libc::c_void,
                    1023 as libc::c_int as size_t,
                );
                if rd >= 0 as libc::c_int as libc::c_long {
                    buffer_commit(out, rd as size_t);
                }
                if !(rd > 0 as libc::c_int as libc::c_long
                    || -(1 as libc::c_int) as libc::c_long == rd
                        && *__errno_location() == 4 as libc::c_int)
                {
                    break;
                }
            }
            if 0 as libc::c_int as libc::c_long != rd {
                log_perror(
                    (*srv).errh,
                    b"/home/kkysen/work/rust/lighttpd/src/configfile.c\0" as *const u8
                        as *const libc::c_char,
                    2323 as libc::c_int as libc::c_uint,
                    b"read \"%s\"\0" as *const u8 as *const libc::c_char,
                    cmd,
                );
                ret = -(1 as libc::c_int);
            }
            close(fds[0 as libc::c_int as usize]);
            fds[0 as libc::c_int as usize] = -(1 as libc::c_int);
            if pid != fdevent_waitpid(pid, &mut wstatus, 0 as libc::c_int) {
                log_perror(
                    (*srv).errh,
                    b"/home/kkysen/work/rust/lighttpd/src/configfile.c\0" as *const u8
                        as *const libc::c_char,
                    2329 as libc::c_int as libc::c_uint,
                    b"waitpid \"%s\"\0" as *const u8 as *const libc::c_char,
                    cmd,
                );
                ret = -(1 as libc::c_int);
            }
            if 0 as libc::c_int != wstatus {
                log_error(
                    (*srv).errh,
                    b"/home/kkysen/work/rust/lighttpd/src/configfile.c\0" as *const u8
                        as *const libc::c_char,
                    2333 as libc::c_int as libc::c_uint,
                    b"command \"%s\" exited non-zero: %d\0" as *const u8 as *const libc::c_char,
                    cmd,
                    (wstatus & 0xff00 as libc::c_int) >> 8 as libc::c_int,
                );
                ret = -(1 as libc::c_int);
            }
            if -(1 as libc::c_int) != ret {
                ret = config_parse(srv, context, cmd, (*out).ptr, buffer_clen(out) as size_t);
            }
            buffer_free(out);
        }
        if -(1 as libc::c_int) != fds[0 as libc::c_int as usize] {
            close(fds[0 as libc::c_int as usize]);
        }
        if -(1 as libc::c_int) != fds[1 as libc::c_int as usize] {
            close(fds[1 as libc::c_int as usize]);
        }
    }
    if 0 as libc::c_int != chdir(oldpwd.as_mut_ptr()) {
        log_perror(
            (*srv).errh,
            b"/home/kkysen/work/rust/lighttpd/src/configfile.c\0" as *const u8
                as *const libc::c_char,
            2349 as libc::c_int as libc::c_uint,
            b"cannot change directory to %s\0" as *const u8 as *const libc::c_char,
            oldpwd.as_mut_ptr(),
        );
        ret = -(1 as libc::c_int);
    }
    return ret;
}
unsafe extern "C" fn config_remoteip_normalize_ipv6(
    b: *mut buffer,
    tb: *mut buffer,
) -> libc::c_int {
    buffer_clear(tb);
    if *((*b).ptr).offset(0 as libc::c_int as isize) as libc::c_int != '[' as i32 {
        buffer_append_str3(
            tb,
            b"[\0" as *const u8 as *const libc::c_char,
            (::core::mem::size_of::<[libc::c_char; 2]>() as libc::c_ulong as uint32_t)
                .wrapping_sub(1 as libc::c_int as libc::c_uint) as size_t,
            (*b).ptr,
            buffer_clen(b) as size_t,
            b"]\0" as *const u8 as *const libc::c_char,
            (::core::mem::size_of::<[libc::c_char; 2]>() as libc::c_ulong as uint32_t)
                .wrapping_sub(1 as libc::c_int as libc::c_uint) as size_t,
        );
    } else {
        buffer_append_buffer(tb, b);
    }
    let mut rc: libc::c_int = http_request_host_normalize(tb, 0 as libc::c_int);
    if 0 as libc::c_int == rc {
        let mut blen: size_t = buffer_clen(tb) as size_t;
        if blen > 1 as libc::c_int as libc::c_ulong {
            buffer_copy_string_len(
                b,
                ((*tb).ptr).offset(1 as libc::c_int as isize),
                blen.wrapping_sub(2 as libc::c_int as libc::c_ulong),
            );
        }
    }
    return rc;
}
#[no_mangle]
#[cold]
pub unsafe extern "C" fn config_remoteip_normalize(b: *mut buffer, tb: *mut buffer) -> libc::c_int {
    if *((*b).ptr).offset(0 as libc::c_int as isize) as libc::c_int == '/' as i32 {
        return 1 as libc::c_int;
    }
    let slash: *const libc::c_char = strchr((*b).ptr, '/' as i32);
    let colon: *const libc::c_char = strchr((*b).ptr, ':' as i32);
    let mut nm_bits: libc::c_ulong = 0 as libc::c_int as libc::c_ulong;
    if !slash.is_null() {
        let mut nptr: *mut libc::c_char = 0 as *mut libc::c_char;
        nm_bits = strtoul(
            slash.offset(1 as libc::c_int as isize),
            &mut nptr,
            10 as libc::c_int,
        );
        if *nptr as libc::c_int != 0
            || 0 as libc::c_int as libc::c_ulong == nm_bits
            || nm_bits
                > (if !colon.is_null() {
                    128 as libc::c_int
                } else {
                    32 as libc::c_int
                }) as libc::c_ulong
        {
            return -(1 as libc::c_int);
        }
        buffer_truncate(
            b,
            slash.offset_from((*b).ptr) as libc::c_long as size_t as uint32_t,
        );
    }
    let mut family: libc::c_int = if !colon.is_null() {
        10 as libc::c_int
    } else {
        2 as libc::c_int
    };
    let mut rc: libc::c_int = if family == 2 as libc::c_int {
        http_request_host_normalize(b, 0 as libc::c_int)
    } else {
        config_remoteip_normalize_ipv6(b, tb)
    };
    let mut len: uint32_t = buffer_clen(b);
    if nm_bits != 0 {
        buffer_append_string_len(
            b,
            b"/\0" as *const u8 as *const libc::c_char,
            (::core::mem::size_of::<[libc::c_char; 2]>() as libc::c_ulong as uint32_t)
                .wrapping_sub(1 as libc::c_int as libc::c_uint) as size_t,
        );
        buffer_append_int(b, nm_bits as libc::c_int as intmax_t);
    }
    if 0 as libc::c_int != rc {
        return -(1 as libc::c_int);
    }
    let mut after: *mut libc::c_char = buffer_string_prepare_append(
        b,
        (1 as libc::c_int + 7 as libc::c_int + 28 as libc::c_int) as size_t,
    );
    after = after.offset(1);
    *(after as *mut libc::c_uchar) = nm_bits as libc::c_uchar;
    let addr: *mut sock_addr = ((after as uintptr_t)
        .wrapping_add(1 as libc::c_int as libc::c_ulong)
        .wrapping_add(7 as libc::c_int as libc::c_ulong)
        & !(7 as libc::c_int) as libc::c_ulong) as *mut sock_addr;
    if nm_bits != 0 {
        *((*b).ptr).offset(len as isize) = '\0' as i32 as libc::c_char;
    }
    rc = sock_addr_inet_pton(addr, (*b).ptr, family, 0 as libc::c_int as libc::c_ushort);
    if nm_bits != 0 {
        *((*b).ptr).offset(len as isize) = '/' as i32 as libc::c_char;
    }
    return (1 as libc::c_int == rc) as libc::c_int;
}
unsafe extern "C" fn context_init(mut srv: *mut server, mut context: *mut config_t) {
    (*context).srv = srv;
    (*context).ok = 1 as libc::c_int;
    vector_config_weak_init(&mut (*context).configs_stack);
    (*context).basedir = buffer_init();
}
unsafe extern "C" fn context_free(mut context: *mut config_t) {
    vector_config_weak_clear(&mut (*context).configs_stack);
    buffer_free((*context).basedir);
}
#[inline(never)]
unsafe extern "C" fn config_vars_init(mut a: *mut array) {
    let mut dcwd: [libc::c_char; 4096] = [0; 4096];
    if !(getcwd(
        dcwd.as_mut_ptr(),
        ::core::mem::size_of::<[libc::c_char; 4096]>() as libc::c_ulong,
    ))
    .is_null()
    {
        array_set_key_value(
            a,
            b"var.CWD\0" as *const u8 as *const libc::c_char,
            (::core::mem::size_of::<[libc::c_char; 8]>() as libc::c_ulong as uint32_t)
                .wrapping_sub(1 as libc::c_int as libc::c_uint),
            dcwd.as_mut_ptr(),
            strlen(dcwd.as_mut_ptr()) as uint32_t,
        );
    }
    *array_get_int_ptr(
        a,
        b"var.PID\0" as *const u8 as *const libc::c_char,
        (::core::mem::size_of::<[libc::c_char; 8]>() as libc::c_ulong as uint32_t)
            .wrapping_sub(1 as libc::c_int as libc::c_uint),
    ) = getpid();
}
#[no_mangle]
#[cold]
pub unsafe extern "C" fn config_read(
    mut srv: *mut server,
    mut fn_0: *const libc::c_char,
) -> libc::c_int {
    let mut context: config_t = config_t {
        srv: 0 as *mut server,
        ok: 0,
        all_configs: 0 as *mut array,
        configs_stack: vector_config_weak {
            data: 0 as *mut *mut data_config,
            used: 0,
            size: 0,
        },
        current: 0 as *mut data_config,
        basedir: 0 as *mut buffer,
    };
    let mut dc: *mut data_config = 0 as *mut data_config;
    let mut ret: libc::c_int = 0;
    let mut pos: *mut libc::c_char = 0 as *mut libc::c_char;
    context_init(srv, &mut context);
    context.all_configs = (*srv).config_context;
    pos = strrchr(fn_0, '/' as i32);
    if !pos.is_null() {
        buffer_copy_string_len(
            context.basedir,
            fn_0,
            (pos.offset_from(fn_0) as libc::c_long + 1 as libc::c_int as libc::c_long) as size_t,
        );
    }
    dc = data_config_init();
    buffer_copy_string_len(
        &mut (*dc).key,
        b"global\0" as *const u8 as *const libc::c_char,
        (::core::mem::size_of::<[libc::c_char; 7]>() as libc::c_ulong as uint32_t)
            .wrapping_sub(1 as libc::c_int as libc::c_uint) as size_t,
    );
    config_vars_init((*dc).value);
    if !((*context.all_configs).used == 0 as libc::c_int as libc::c_uint) {
        ck_assert_failed(
            b"/home/kkysen/work/rust/lighttpd/src/configfile.c\0" as *const u8
                as *const libc::c_char,
            2467 as libc::c_int as libc::c_uint,
            b"context.all_configs->used == 0\0" as *const u8 as *const libc::c_char,
        );
    }
    (*dc).context_ndx = (*context.all_configs).used as libc::c_int;
    array_insert_unique(context.all_configs, dc as *mut data_unset);
    context.current = dc;
    ret = if 0 as libc::c_int != strcmp(fn_0, b"-\0" as *const u8 as *const libc::c_char) {
        config_parse_file_stream(srv, &mut context, fn_0)
    } else {
        config_parse_stdin(srv, &mut context)
    };
    if 0 as libc::c_int == ret
        && context.ok != 0
        && 0 as libc::c_int as libc::c_ulong != context.configs_stack.used
    {
        ck_assert_failed(
            b"/home/kkysen/work/rust/lighttpd/src/configfile.c\0" as *const u8
                as *const libc::c_char,
            2477 as libc::c_int as libc::c_uint,
            b"!(0 == ret && context.ok && 0 != context.configs_stack.used)\0" as *const u8
                as *const libc::c_char,
        );
    }
    context_free(&mut context);
    if 0 as libc::c_int != ret {
        return ret;
    }
    let mut i: uint32_t = 0 as libc::c_int as uint32_t;
    while i < (*(*srv).config_context).used {
        dc = *((*(*srv).config_context).data).offset(i as isize) as *mut data_config;
        if !((*dc).context_ndx == i as libc::c_int) {
            let mut j: uint32_t = i;
            while j < (*(*srv).config_context).used {
                dc = *((*(*srv).config_context).data).offset(j as isize) as *mut data_config;
                if (*dc).context_ndx == i as libc::c_int {
                    let ref mut fresh81 = *((*(*srv).config_context).data).offset(j as isize);
                    *fresh81 = *((*(*srv).config_context).data).offset(i as isize);
                    let ref mut fresh82 = *((*(*srv).config_context).data).offset(i as isize);
                    *fresh82 = dc as *mut data_unset;
                    break;
                } else {
                    j = j.wrapping_add(1);
                }
            }
        }
        i = i.wrapping_add(1);
    }
    if 0 as libc::c_int != config_insert_srvconf(srv) {
        return -(1 as libc::c_int);
    }
    if 0 as libc::c_int != config_insert(srv) {
        return -(1 as libc::c_int);
    }
    return 0 as libc::c_int;
}
#[no_mangle]
#[cold]
pub unsafe extern "C" fn config_set_defaults(mut srv: *mut server) -> libc::c_int {
    let mut i: size_t = 0;
    let mut s: *mut request_config =
        &mut (*((*srv).config_data_base as *mut config_data_base)).defaults;
    let mut st1: stat = stat {
        st_dev: 0,
        st_ino: 0,
        st_nlink: 0,
        st_mode: 0,
        st_uid: 0,
        st_gid: 0,
        __pad0: 0,
        st_rdev: 0,
        st_size: 0,
        st_blksize: 0,
        st_blocks: 0,
        st_atim: timespec {
            tv_sec: 0,
            tv_nsec: 0,
        },
        st_mtim: timespec {
            tv_sec: 0,
            tv_nsec: 0,
        },
        st_ctim: timespec {
            tv_sec: 0,
            tv_nsec: 0,
        },
        __glibc_reserved: [0; 3],
    };
    let mut st2: stat = stat {
        st_dev: 0,
        st_ino: 0,
        st_nlink: 0,
        st_mode: 0,
        st_uid: 0,
        st_gid: 0,
        __pad0: 0,
        st_rdev: 0,
        st_size: 0,
        st_blksize: 0,
        st_blocks: 0,
        st_atim: timespec {
            tv_sec: 0,
            tv_nsec: 0,
        },
        st_mtim: timespec {
            tv_sec: 0,
            tv_nsec: 0,
        },
        st_ctim: timespec {
            tv_sec: 0,
            tv_nsec: 0,
        },
        __glibc_reserved: [0; 3],
    };
    if fdevent_config(&mut (*srv).srvconf.event_handler, (*srv).errh) <= 0 as libc::c_int {
        return -(1 as libc::c_int);
    }
    if !((*srv).srvconf.changeroot).is_null() {
        if -(1 as libc::c_int) == stat((*(*srv).srvconf.changeroot).ptr, &mut st1) {
            log_error(
                (*srv).errh,
                b"/home/kkysen/work/rust/lighttpd/src/configfile.c\0" as *const u8
                    as *const libc::c_char,
                2526 as libc::c_int as libc::c_uint,
                b"server.chroot doesn't exist: %s\0" as *const u8 as *const libc::c_char,
                (*(*srv).srvconf.changeroot).ptr,
            );
            return -(1 as libc::c_int);
        }
        if !(st1.st_mode & 0o170000 as libc::c_int as libc::c_uint
            == 0o40000 as libc::c_int as libc::c_uint)
        {
            log_error(
                (*srv).errh,
                b"/home/kkysen/work/rust/lighttpd/src/configfile.c\0" as *const u8
                    as *const libc::c_char,
                2532 as libc::c_int as libc::c_uint,
                b"server.chroot isn't a directory: %s\0" as *const u8 as *const libc::c_char,
                (*(*srv).srvconf.changeroot).ptr,
            );
            return -(1 as libc::c_int);
        }
    }
    if (*(*srv).srvconf.upload_tempdirs).used == 0 {
        let mut tmpdir: *const libc::c_char =
            getenv(b"TMPDIR\0" as *const u8 as *const libc::c_char);
        if tmpdir.is_null() {
            tmpdir = b"/var/tmp\0" as *const u8 as *const libc::c_char;
        }
        array_insert_value(
            (*srv).srvconf.upload_tempdirs,
            tmpdir,
            strlen(tmpdir) as uint32_t,
        );
    }
    if (*(*srv).srvconf.upload_tempdirs).used != 0 {
        let tb: *mut buffer = (*srv).tmp_buf;
        buffer_clear(tb);
        if !((*srv).srvconf.changeroot).is_null() {
            buffer_copy_buffer(tb, (*srv).srvconf.changeroot);
        }
        let len: size_t = buffer_clen(tb) as size_t;
        i = 0 as libc::c_int as size_t;
        while i < (*(*srv).srvconf.upload_tempdirs).used as libc::c_ulong {
            let ds: *const data_string =
                *((*(*srv).srvconf.upload_tempdirs).data).offset(i as isize) as *mut data_string;
            if len != 0 {
                buffer_truncate(tb, len as uint32_t);
                buffer_append_path_len(tb, (*ds).value.ptr, buffer_clen(&(*ds).value) as size_t);
            } else {
                buffer_copy_buffer(tb, &(*ds).value);
            }
            if -(1 as libc::c_int) == stat((*tb).ptr, &mut st1) {
                log_error(
                    (*srv).errh,
                    b"/home/kkysen/work/rust/lighttpd/src/configfile.c\0" as *const u8
                        as *const libc::c_char,
                    2562 as libc::c_int as libc::c_uint,
                    b"server.upload-dirs doesn't exist: %s\0" as *const u8 as *const libc::c_char,
                    (*tb).ptr,
                );
            } else if !(st1.st_mode & 0o170000 as libc::c_int as libc::c_uint
                == 0o40000 as libc::c_int as libc::c_uint)
            {
                log_error(
                    (*srv).errh,
                    b"/home/kkysen/work/rust/lighttpd/src/configfile.c\0" as *const u8
                        as *const libc::c_char,
                    2565 as libc::c_int as libc::c_uint,
                    b"server.upload-dirs isn't a directory: %s\0" as *const u8
                        as *const libc::c_char,
                    (*tb).ptr,
                );
            }
            i = i.wrapping_add(1);
        }
    }
    chunkqueue_set_tempdirs_default(
        (*srv).srvconf.upload_tempdirs,
        (*srv).srvconf.upload_temp_file_size as off_t,
    );
    if ((*s).document_root).is_null() || buffer_is_blank((*s).document_root) != 0 {
        log_error(
            (*srv).errh,
            b"/home/kkysen/work/rust/lighttpd/src/configfile.c\0" as *const u8
                as *const libc::c_char,
            2576 as libc::c_int as libc::c_uint,
            b"server.document-root is not set\0" as *const u8 as *const libc::c_char,
        );
        return -(1 as libc::c_int);
    }
    if 2 as libc::c_int == (*s).force_lowercase_filenames as libc::c_int {
        (*s).force_lowercase_filenames = 0 as libc::c_int as libc::c_uchar;
        let tb_0: *mut buffer = (*srv).tmp_buf;
        buffer_copy_string_len_lc(
            tb_0,
            (*(*s).document_root).ptr,
            buffer_clen((*s).document_root) as size_t,
        );
        if 0 as libc::c_int == stat((*tb_0).ptr, &mut st1) {
            let mut is_lower: libc::c_int = 0 as libc::c_int;
            is_lower = buffer_is_equal(tb_0, (*s).document_root);
            buffer_copy_buffer(tb_0, (*s).document_root);
            buffer_to_upper(tb_0);
            if is_lower != 0 && buffer_is_equal(tb_0, (*s).document_root) != 0 {
                (*s).force_lowercase_filenames = 0 as libc::c_int as libc::c_uchar;
            } else if 0 as libc::c_int == stat((*tb_0).ptr, &mut st2) {
                if st1.st_ino == st2.st_ino {
                    (*s).force_lowercase_filenames = 1 as libc::c_int as libc::c_uchar;
                }
            }
        }
    }
    return 0 as libc::c_int;
}
unsafe extern "C" fn configparser_get_data_config(
    mut a: *const array,
    mut k: *const libc::c_char,
    klen: size_t,
) -> *mut data_config {
    return array_get_data_unset(a, k, klen as uint32_t) as *mut data_config;
}
unsafe extern "C" fn configparser_push(
    mut ctx: *mut config_t,
    mut dc: *mut data_config,
    mut isnew: libc::c_int,
) {
    if isnew != 0 {
        (*dc).context_ndx = (*(*ctx).all_configs).used as libc::c_int;
        if !((*dc).context_ndx > (*(*ctx).current).context_ndx) {
            ck_assert_failed(
                b"/home/kkysen/work/rust/lighttpd/src/configparser.y\0" as *const u8
                    as *const libc::c_char,
                28 as libc::c_int as libc::c_uint,
                b"dc->context_ndx > ctx->current->context_ndx\0" as *const u8
                    as *const libc::c_char,
            );
        }
        array_insert_unique((*ctx).all_configs, dc as *mut data_unset);
        (*dc).parent = (*ctx).current;
        vector_config_weak_push(&mut (*(*dc).parent).children, dc);
    }
    if (*ctx).configs_stack.used > 0 as libc::c_int as libc::c_ulong
        && (*(*ctx).current).context_ndx == 0 as libc::c_int
    {
        fprintf(
            stderr,
            b"Cannot use conditionals inside a global { ... } block\n\0" as *const u8
                as *const libc::c_char,
        );
        exit(-(1 as libc::c_int));
    }
    vector_config_weak_push(&mut (*ctx).configs_stack, (*ctx).current);
    (*ctx).current = dc;
}
unsafe extern "C" fn configparser_pop(mut ctx: *mut config_t) -> *mut data_config {
    let mut old: *mut data_config = (*ctx).current;
    (*ctx).current = vector_config_weak_pop(&mut (*ctx).configs_stack);
    return old;
}
unsafe extern "C" fn configparser_get_variable(
    mut ctx: *mut config_t,
    mut key: *const buffer,
) -> *mut data_unset {
    let mut du: *const data_unset = 0 as *const data_unset;
    let mut dc: *mut data_config = 0 as *mut data_config;
    dc = (*ctx).current;
    while !dc.is_null() {
        du = array_get_element_klen((*dc).value, (*key).ptr, buffer_clen(key));
        if !du.is_null() {
            let mut du_copy: *mut data_unset =
                ((*(*du).fn_0).copy).expect("non-null function pointer")(du);
            buffer_clear(&mut (*du_copy).key);
            return du_copy;
        }
        dc = (*dc).parent;
    }
    return 0 as *mut data_unset;
}
unsafe extern "C" fn configparser_merge_data(
    mut op1: *mut data_unset,
    mut op2: *const data_unset,
) -> *mut data_unset {
    if (*op1).type_0 as libc::c_uint != (*op2).type_0 as libc::c_uint {
        if (*op1).type_0 as libc::c_uint == TYPE_STRING as libc::c_int as libc::c_uint
            && (*op2).type_0 as libc::c_uint == TYPE_INTEGER as libc::c_int as libc::c_uint
        {
            let mut ds: *mut data_string = op1 as *mut data_string;
            buffer_append_int(
                &mut (*ds).value,
                (*(op2 as *mut data_integer)).value as intmax_t,
            );
            return op1;
        } else if (*op1).type_0 as libc::c_uint == TYPE_INTEGER as libc::c_int as libc::c_uint
            && (*op2).type_0 as libc::c_uint == TYPE_STRING as libc::c_int as libc::c_uint
        {
            let mut ds_0: *mut data_string = array_data_string_init();
            buffer_append_int(
                &mut (*ds_0).value,
                (*(op1 as *mut data_integer)).value as intmax_t,
            );
            buffer_append_buffer(&mut (*ds_0).value, &mut (*(op2 as *mut data_string)).value);
            ((*(*op1).fn_0).free).expect("non-null function pointer")(op1);
            return ds_0 as *mut data_unset;
        } else {
            fprintf(
                stderr,
                b"data type mismatch, cannot merge\n\0" as *const u8 as *const libc::c_char,
            );
            ((*(*op1).fn_0).free).expect("non-null function pointer")(op1);
            return 0 as *mut data_unset;
        }
    }
    match (*op1).type_0 as libc::c_uint {
        0 => {
            buffer_append_buffer(
                &mut (*(op1 as *mut data_string)).value,
                &mut (*(op2 as *mut data_string)).value,
            );
        }
        2 => {
            (*(op1 as *mut data_integer)).value += (*(op2 as *mut data_integer)).value;
        }
        1 => {
            let mut dst: *mut array = &mut (*(op1 as *mut data_array)).value;
            let mut src: *mut array = &mut (*(op2 as *mut data_array)).value;
            let mut du: *const data_unset = 0 as *const data_unset;
            let mut ddu: *const data_unset = 0 as *const data_unset;
            let mut i: size_t = 0;
            let mut current_block_24: u64;
            i = 0 as libc::c_int as size_t;
            while i < (*src).used as libc::c_ulong {
                du = *((*src).data).offset(i as isize);
                if !du.is_null() {
                    if buffer_is_unset(&(*du).key) != 0 || {
                        ddu = array_get_element_klen(dst, (*du).key.ptr, buffer_clen(&(*du).key));
                        ddu.is_null()
                    } {
                        array_insert_unique(
                            dst,
                            ((*(*du).fn_0).copy).expect("non-null function pointer")(du),
                        );
                    } else {
                        fprintf(
                            stderr,
                            b"Duplicate array-key '%s'\n\0" as *const u8 as *const libc::c_char,
                            (*du).key.ptr,
                        );
                        if (*ddu).type_0 as libc::c_uint == (*du).type_0 as libc::c_uint {
                            if (*du).type_0 as libc::c_uint
                                == TYPE_STRING as libc::c_int as libc::c_uint
                                && buffer_is_equal(
                                    &mut (*(du as *mut data_string)).value,
                                    &mut (*(ddu as *mut data_string)).value,
                                ) != 0
                            {
                                current_block_24 = 5143058163439228106;
                            } else if (*du).type_0 as libc::c_uint
                                == TYPE_INTEGER as libc::c_int as libc::c_uint
                                && (*(du as *mut data_integer)).value
                                    == (*(ddu as *mut data_integer)).value
                            {
                                current_block_24 = 5143058163439228106;
                            } else {
                                current_block_24 = 9828876828309294594;
                            }
                        } else {
                            current_block_24 = 9828876828309294594;
                        }
                        match current_block_24 {
                            5143058163439228106 => {}
                            _ => {
                                ((*(*op1).fn_0).free).expect("non-null function pointer")(op1);
                                return 0 as *mut data_unset;
                            }
                        }
                    }
                }
                i = i.wrapping_add(1);
            }
        }
        _ => {
            if 0 as libc::c_int == 0 {
                ck_assert_failed(
                    b"/home/kkysen/work/rust/lighttpd/src/configparser.y\0" as *const u8
                        as *const libc::c_char,
                    131 as libc::c_int as libc::c_uint,
                    b"0\0" as *const u8 as *const libc::c_char,
                );
            }
        }
    }
    return op1;
}
static mut comps: [C2RustUnnamed_30; 13] = [C2RustUnnamed_30 {
    comp: COMP_UNSET,
    len: 0,
    comp_tag: 0 as *const libc::c_char,
}; 13];
unsafe extern "C" fn configparser_comp_key_id(
    obj_tag: *const buffer,
    comp_tag: *const buffer,
) -> comp_key_t {
    if buffer_eq_slen(
        obj_tag,
        b"REQUEST_HEADER\0" as *const u8 as *const libc::c_char,
        (::core::mem::size_of::<[libc::c_char; 15]>() as libc::c_ulong as uint32_t)
            .wrapping_sub(1 as libc::c_int as libc::c_uint) as size_t,
    ) != 0
    {
        return COMP_HTTP_REQUEST_HEADER;
    } else {
        if buffer_eq_slen(
            obj_tag,
            b"SERVER\0" as *const u8 as *const libc::c_char,
            (::core::mem::size_of::<[libc::c_char; 7]>() as libc::c_ulong as uint32_t)
                .wrapping_sub(1 as libc::c_int as libc::c_uint) as size_t,
        ) != 0
        {
            return (if buffer_eq_slen(
                comp_tag,
                b"socket\0" as *const u8 as *const libc::c_char,
                (::core::mem::size_of::<[libc::c_char; 7]>() as libc::c_ulong as uint32_t)
                    .wrapping_sub(1 as libc::c_int as libc::c_uint) as size_t,
            ) != 0
            {
                COMP_SERVER_SOCKET as libc::c_int
            } else {
                COMP_UNSET as libc::c_int
            }) as comp_key_t;
        } else {
            if buffer_eq_slen(
                obj_tag,
                b"HTTP\0" as *const u8 as *const libc::c_char,
                (::core::mem::size_of::<[libc::c_char; 5]>() as libc::c_ulong as uint32_t)
                    .wrapping_sub(1 as libc::c_int as libc::c_uint) as size_t,
            ) != 0
            {
                let mut i: uint32_t = 0 as libc::c_int as uint32_t;
                while (i as libc::c_ulong)
                    < (::core::mem::size_of::<[C2RustUnnamed_30; 13]>() as libc::c_ulong)
                        .wrapping_div(::core::mem::size_of::<C2RustUnnamed_30>() as libc::c_ulong)
                {
                    if buffer_eq_slen(
                        comp_tag,
                        comps[i as usize].comp_tag,
                        comps[i as usize].len as size_t,
                    ) != 0
                    {
                        return comps[i as usize].comp;
                    }
                    i = i.wrapping_add(1);
                }
            }
        }
    }
    return COMP_UNSET;
}
unsafe extern "C" fn configparser_parse_condition(
    ctx: *mut config_t,
    obj_tag: *const buffer,
    comp_tag: *const buffer,
    cond: config_cond_t,
    rvalue: *mut buffer,
) {
    let mut op: *const libc::c_char = 0 as *const libc::c_char;
    match cond as libc::c_uint {
        3 => {
            op = b"!=\0" as *const u8 as *const libc::c_char;
        }
        1 => {
            op = b"==\0" as *const u8 as *const libc::c_char;
        }
        4 => {
            op = b"!~\0" as *const u8 as *const libc::c_char;
        }
        2 => {
            op = b"=~\0" as *const u8 as *const libc::c_char;
        }
        _ => {
            if 0 as libc::c_int == 0 {
                ck_assert_failed(
                    b"/home/kkysen/work/rust/lighttpd/src/configparser.y\0" as *const u8
                        as *const libc::c_char,
                    189 as libc::c_int as libc::c_uint,
                    b"0\0" as *const u8 as *const libc::c_char,
                );
            }
            return;
        }
    }
    let comp_offset: uint32_t =
        (buffer_clen(&mut (*(*ctx).current).key)).wrapping_add(3 as libc::c_int as libc::c_uint);
    let tb: *mut buffer = (*(*ctx).srv).tmp_buf;
    buffer_clear(tb);
    let mut iov: [const_iovec; 11] = [
        {
            let mut init = const_iovec {
                iov_base: (*(*ctx).current).key.ptr as *const libc::c_void,
                iov_len: buffer_clen(&mut (*(*ctx).current).key) as size_t,
            };
            init
        },
        {
            let mut init = const_iovec {
                iov_base: b" / \0" as *const u8 as *const libc::c_char as *const libc::c_void,
                iov_len: (::core::mem::size_of::<[libc::c_char; 4]>() as libc::c_ulong as uint32_t)
                    .wrapping_sub(1 as libc::c_int as libc::c_uint)
                    as size_t,
            };
            init
        },
        {
            let mut init = const_iovec {
                iov_base: b"$\0" as *const u8 as *const libc::c_char as *const libc::c_void,
                iov_len: (::core::mem::size_of::<[libc::c_char; 2]>() as libc::c_ulong as uint32_t)
                    .wrapping_sub(1 as libc::c_int as libc::c_uint)
                    as size_t,
            };
            init
        },
        {
            let mut init = const_iovec {
                iov_base: (*obj_tag).ptr as *const libc::c_void,
                iov_len: buffer_clen(obj_tag) as size_t,
            };
            init
        },
        {
            let mut init = const_iovec {
                iov_base: b"[\"\0" as *const u8 as *const libc::c_char as *const libc::c_void,
                iov_len: (::core::mem::size_of::<[libc::c_char; 3]>() as libc::c_ulong as uint32_t)
                    .wrapping_sub(1 as libc::c_int as libc::c_uint)
                    as size_t,
            };
            init
        },
        {
            let mut init = const_iovec {
                iov_base: (*comp_tag).ptr as *const libc::c_void,
                iov_len: buffer_clen(comp_tag) as size_t,
            };
            init
        },
        {
            let mut init = const_iovec {
                iov_base: b"\"] \0" as *const u8 as *const libc::c_char as *const libc::c_void,
                iov_len: (::core::mem::size_of::<[libc::c_char; 4]>() as libc::c_ulong as uint32_t)
                    .wrapping_sub(1 as libc::c_int as libc::c_uint)
                    as size_t,
            };
            init
        },
        {
            let mut init = const_iovec {
                iov_base: op as *const libc::c_void,
                iov_len: 2 as libc::c_int as size_t,
            };
            init
        },
        {
            let mut init = const_iovec {
                iov_base: b" \"\0" as *const u8 as *const libc::c_char as *const libc::c_void,
                iov_len: (::core::mem::size_of::<[libc::c_char; 3]>() as libc::c_ulong as uint32_t)
                    .wrapping_sub(1 as libc::c_int as libc::c_uint)
                    as size_t,
            };
            init
        },
        {
            let mut init = const_iovec {
                iov_base: (*rvalue).ptr as *const libc::c_void,
                iov_len: buffer_clen(rvalue) as size_t,
            };
            init
        },
        {
            let mut init = const_iovec {
                iov_base: b"\"\0" as *const u8 as *const libc::c_char as *const libc::c_void,
                iov_len: (::core::mem::size_of::<[libc::c_char; 2]>() as libc::c_ulong as uint32_t)
                    .wrapping_sub(1 as libc::c_int as libc::c_uint)
                    as size_t,
            };
            init
        },
    ];
    buffer_append_iovec(
        tb,
        iov.as_mut_ptr(),
        (::core::mem::size_of::<[const_iovec; 11]>() as libc::c_ulong)
            .wrapping_div(::core::mem::size_of::<const_iovec>() as libc::c_ulong),
    );
    let mut dc: *mut data_config = 0 as *mut data_config;
    dc = configparser_get_data_config((*ctx).all_configs, (*tb).ptr, buffer_clen(tb) as size_t);
    if !dc.is_null() {
        configparser_push(ctx, dc, 0 as libc::c_int);
    } else {
        dc = data_config_init();
        (*dc).cond = cond;
        (*dc).comp = configparser_comp_key_id(obj_tag, comp_tag);
        buffer_copy_buffer(&mut (*dc).key, tb);
        buffer_copy_buffer(&mut (*dc).comp_tag, comp_tag);
        (*dc).comp_key = ((*dc).key.ptr).offset(comp_offset as isize);
        if COMP_UNSET as libc::c_int as libc::c_uint == (*dc).comp as libc::c_uint {
            fprintf(
                stderr,
                b"error comp_key %s\0" as *const u8 as *const libc::c_char,
                (*dc).comp_key,
            );
            (*ctx).ok = 0 as libc::c_int;
        } else if COMP_HTTP_LANGUAGE as libc::c_int as libc::c_uint == (*dc).comp as libc::c_uint {
            (*dc).comp = COMP_HTTP_REQUEST_HEADER;
            buffer_copy_string_len(
                &mut (*dc).comp_tag,
                b"Accept-Language\0" as *const u8 as *const libc::c_char,
                (::core::mem::size_of::<[libc::c_char; 16]>() as libc::c_ulong as uint32_t)
                    .wrapping_sub(1 as libc::c_int as libc::c_uint) as size_t,
            );
        } else if COMP_HTTP_USER_AGENT as libc::c_int as libc::c_uint == (*dc).comp as libc::c_uint
        {
            (*dc).comp = COMP_HTTP_REQUEST_HEADER;
            buffer_copy_string_len(
                &mut (*dc).comp_tag,
                b"User-Agent\0" as *const u8 as *const libc::c_char,
                (::core::mem::size_of::<[libc::c_char; 11]>() as libc::c_ulong as uint32_t)
                    .wrapping_sub(1 as libc::c_int as libc::c_uint) as size_t,
            );
        } else if COMP_HTTP_REMOTE_IP as libc::c_int as libc::c_uint == (*dc).comp as libc::c_uint
            && ((*dc).cond as libc::c_uint == CONFIG_COND_EQ as libc::c_int as libc::c_uint
                || (*dc).cond as libc::c_uint == CONFIG_COND_NE as libc::c_int as libc::c_uint)
        {
            if config_remoteip_normalize(rvalue, tb) == 0 {
                fprintf(
                    stderr,
                    b"invalid IP addr: %s\n\0" as *const u8 as *const libc::c_char,
                    (*rvalue).ptr,
                );
                (*ctx).ok = 0 as libc::c_int;
            }
        } else if COMP_SERVER_SOCKET as libc::c_int as libc::c_uint == (*dc).comp as libc::c_uint {
            if *((*rvalue).ptr).offset(0 as libc::c_int as isize) as libc::c_int != ':' as i32
                && !(*((*rvalue).ptr).offset(0 as libc::c_int as isize) as libc::c_int
                    == '[' as i32
                    && *((*rvalue).ptr).offset(1 as libc::c_int as isize) as libc::c_int
                        == ']' as i32)
            {
                if http_request_host_normalize(rvalue, 0 as libc::c_int) != 0 {
                    fprintf(
                        stderr,
                        b"invalid IP addr: %s\n\0" as *const u8 as *const libc::c_char,
                        (*rvalue).ptr,
                    );
                    (*ctx).ok = 0 as libc::c_int;
                }
            }
        } else if COMP_HTTP_HOST as libc::c_int as libc::c_uint == (*dc).comp as libc::c_uint {
            if (*dc).cond as libc::c_uint == CONFIG_COND_EQ as libc::c_int as libc::c_uint
                || (*dc).cond as libc::c_uint == CONFIG_COND_NE as libc::c_int as libc::c_uint
            {
                if http_request_host_normalize(rvalue, 0 as libc::c_int) != 0 {
                    fprintf(
                        stderr,
                        b"invalid IP addr: %s\n\0" as *const u8 as *const libc::c_char,
                        (*rvalue).ptr,
                    );
                    (*ctx).ok = 0 as libc::c_int;
                }
            }
        }
        if COMP_HTTP_REQUEST_HEADER as libc::c_int as libc::c_uint == (*dc).comp as libc::c_uint {
            (*dc).ext = http_header_hkey_get(
                (*dc).comp_tag.ptr,
                buffer_clen(&mut (*dc).comp_tag) as size_t,
            ) as libc::c_int;
        }
        buffer_move(&mut (*dc).string, rvalue);
        if (*ctx).ok != 0 {
            configparser_push(ctx, dc, 1 as libc::c_int);
        } else {
            ((*(*dc).fn_0).free).expect("non-null function pointer")(dc as *mut data_unset);
        }
    };
}
unsafe extern "C" fn configparser_parse_else_condition(ctx: *mut config_t) {
    let dc: *mut data_config = data_config_init();
    (*dc).cond = CONFIG_COND_ELSE;
    buffer_append_str2(
        &mut (*dc).key,
        (*(*ctx).current).key.ptr,
        buffer_clen(&mut (*(*ctx).current).key) as size_t,
        b" / else_tmp_token\0" as *const u8 as *const libc::c_char,
        (::core::mem::size_of::<[libc::c_char; 18]>() as libc::c_ulong as uint32_t)
            .wrapping_sub(1 as libc::c_int as libc::c_uint) as size_t,
    );
    configparser_push(ctx, dc, 1 as libc::c_int);
}
static mut yy_action: [libc::c_uchar; 138] = [
    2 as libc::c_int as libc::c_uchar,
    3 as libc::c_int as libc::c_uchar,
    4 as libc::c_int as libc::c_uchar,
    5 as libc::c_int as libc::c_uchar,
    14 as libc::c_int as libc::c_uchar,
    15 as libc::c_int as libc::c_uchar,
    70 as libc::c_int as libc::c_uchar,
    16 as libc::c_int as libc::c_uchar,
    7 as libc::c_int as libc::c_uchar,
    48 as libc::c_int as libc::c_uchar,
    96 as libc::c_int as libc::c_uchar,
    21 as libc::c_int as libc::c_uchar,
    21 as libc::c_int as libc::c_uchar,
    17 as libc::c_int as libc::c_uchar,
    24 as libc::c_int as libc::c_uchar,
    25 as libc::c_int as libc::c_uchar,
    27 as libc::c_int as libc::c_uchar,
    44 as libc::c_int as libc::c_uchar,
    11 as libc::c_int as libc::c_uchar,
    43 as libc::c_int as libc::c_uchar,
    8 as libc::c_int as libc::c_uchar,
    16 as libc::c_int as libc::c_uchar,
    12 as libc::c_int as libc::c_uchar,
    49 as libc::c_int as libc::c_uchar,
    21 as libc::c_int as libc::c_uchar,
    21 as libc::c_int as libc::c_uchar,
    24 as libc::c_int as libc::c_uchar,
    25 as libc::c_int as libc::c_uchar,
    27 as libc::c_int as libc::c_uchar,
    30 as libc::c_int as libc::c_uchar,
    20 as libc::c_int as libc::c_uchar,
    61 as libc::c_int as libc::c_uchar,
    63 as libc::c_int as libc::c_uchar,
    43 as libc::c_int as libc::c_uchar,
    13 as libc::c_int as libc::c_uchar,
    65 as libc::c_int as libc::c_uchar,
    111 as libc::c_int as libc::c_uchar,
    49 as libc::c_int as libc::c_uchar,
    57 as libc::c_int as libc::c_uchar,
    58 as libc::c_int as libc::c_uchar,
    59 as libc::c_int as libc::c_uchar,
    60 as libc::c_int as libc::c_uchar,
    18 as libc::c_int as libc::c_uchar,
    39 as libc::c_int as libc::c_uchar,
    41 as libc::c_int as libc::c_uchar,
    61 as libc::c_int as libc::c_uchar,
    63 as libc::c_int as libc::c_uchar,
    16 as libc::c_int as libc::c_uchar,
    29 as libc::c_int as libc::c_uchar,
    28 as libc::c_int as libc::c_uchar,
    38 as libc::c_int as libc::c_uchar,
    21 as libc::c_int as libc::c_uchar,
    98 as libc::c_int as libc::c_uchar,
    31 as libc::c_int as libc::c_uchar,
    26 as libc::c_int as libc::c_uchar,
    23 as libc::c_int as libc::c_uchar,
    35 as libc::c_int as libc::c_uchar,
    9 as libc::c_int as libc::c_uchar,
    10 as libc::c_int as libc::c_uchar,
    43 as libc::c_int as libc::c_uchar,
    36 as libc::c_int as libc::c_uchar,
    47 as libc::c_int as libc::c_uchar,
    20 as libc::c_int as libc::c_uchar,
    49 as libc::c_int as libc::c_uchar,
    45 as libc::c_int as libc::c_uchar,
    16 as libc::c_int as libc::c_uchar,
    11 as libc::c_int as libc::c_uchar,
    66 as libc::c_int as libc::c_uchar,
    22 as libc::c_int as libc::c_uchar,
    21 as libc::c_int as libc::c_uchar,
    105 as libc::c_int as libc::c_uchar,
    61 as libc::c_int as libc::c_uchar,
    63 as libc::c_int as libc::c_uchar,
    6 as libc::c_int as libc::c_uchar,
    26 as libc::c_int as libc::c_uchar,
    23 as libc::c_int as libc::c_uchar,
    46 as libc::c_int as libc::c_uchar,
    43 as libc::c_int as libc::c_uchar,
    51 as libc::c_int as libc::c_uchar,
    69 as libc::c_int as libc::c_uchar,
    20 as libc::c_int as libc::c_uchar,
    49 as libc::c_int as libc::c_uchar,
    115 as libc::c_int as libc::c_uchar,
    1 as libc::c_int as libc::c_uchar,
    50 as libc::c_int as libc::c_uchar,
    29 as libc::c_int as libc::c_uchar,
    28 as libc::c_int as libc::c_uchar,
    34 as libc::c_int as libc::c_uchar,
    97 as libc::c_int as libc::c_uchar,
    61 as libc::c_int as libc::c_uchar,
    63 as libc::c_int as libc::c_uchar,
    26 as libc::c_int as libc::c_uchar,
    23 as libc::c_int as libc::c_uchar,
    35 as libc::c_int as libc::c_uchar,
    29 as libc::c_int as libc::c_uchar,
    19 as libc::c_int as libc::c_uchar,
    29 as libc::c_int as libc::c_uchar,
    52 as libc::c_int as libc::c_uchar,
    32 as libc::c_int as libc::c_uchar,
    33 as libc::c_int as libc::c_uchar,
    26 as libc::c_int as libc::c_uchar,
    23 as libc::c_int as libc::c_uchar,
    26 as libc::c_int as libc::c_uchar,
    23 as libc::c_int as libc::c_uchar,
    53 as libc::c_int as libc::c_uchar,
    106 as libc::c_int as libc::c_uchar,
    29 as libc::c_int as libc::c_uchar,
    52 as libc::c_int as libc::c_uchar,
    49 as libc::c_int as libc::c_uchar,
    29 as libc::c_int as libc::c_uchar,
    52 as libc::c_int as libc::c_uchar,
    67 as libc::c_int as libc::c_uchar,
    26 as libc::c_int as libc::c_uchar,
    23 as libc::c_int as libc::c_uchar,
    62 as libc::c_int as libc::c_uchar,
    26 as libc::c_int as libc::c_uchar,
    23 as libc::c_int as libc::c_uchar,
    64 as libc::c_int as libc::c_uchar,
    29 as libc::c_int as libc::c_uchar,
    37 as libc::c_int as libc::c_uchar,
    54 as libc::c_int as libc::c_uchar,
    55 as libc::c_int as libc::c_uchar,
    29 as libc::c_int as libc::c_uchar,
    40 as libc::c_int as libc::c_uchar,
    26 as libc::c_int as libc::c_uchar,
    23 as libc::c_int as libc::c_uchar,
    29 as libc::c_int as libc::c_uchar,
    42 as libc::c_int as libc::c_uchar,
    26 as libc::c_int as libc::c_uchar,
    23 as libc::c_int as libc::c_uchar,
    29 as libc::c_int as libc::c_uchar,
    56 as libc::c_int as libc::c_uchar,
    26 as libc::c_int as libc::c_uchar,
    23 as libc::c_int as libc::c_uchar,
    68 as libc::c_int as libc::c_uchar,
    96 as libc::c_int as libc::c_uchar,
    26 as libc::c_int as libc::c_uchar,
    23 as libc::c_int as libc::c_uchar,
];
static mut yy_lookahead: [libc::c_uchar; 138] = [
    30 as libc::c_int as libc::c_uchar,
    31 as libc::c_int as libc::c_uchar,
    32 as libc::c_int as libc::c_uchar,
    33 as libc::c_int as libc::c_uchar,
    34 as libc::c_int as libc::c_uchar,
    35 as libc::c_int as libc::c_uchar,
    0 as libc::c_int as libc::c_uchar,
    1 as libc::c_int as libc::c_uchar,
    46 as libc::c_int as libc::c_uchar,
    39 as libc::c_int as libc::c_uchar,
    16 as libc::c_int as libc::c_uchar,
    5 as libc::c_int as libc::c_uchar,
    5 as libc::c_int as libc::c_uchar,
    43 as libc::c_int as libc::c_uchar,
    7 as libc::c_int as libc::c_uchar,
    8 as libc::c_int as libc::c_uchar,
    9 as libc::c_int as libc::c_uchar,
    47 as libc::c_int as libc::c_uchar,
    48 as libc::c_int as libc::c_uchar,
    13 as libc::c_int as libc::c_uchar,
    16 as libc::c_int as libc::c_uchar,
    1 as libc::c_int as libc::c_uchar,
    14 as libc::c_int as libc::c_uchar,
    17 as libc::c_int as libc::c_uchar,
    5 as libc::c_int as libc::c_uchar,
    5 as libc::c_int as libc::c_uchar,
    7 as libc::c_int as libc::c_uchar,
    8 as libc::c_int as libc::c_uchar,
    9 as libc::c_int as libc::c_uchar,
    10 as libc::c_int as libc::c_uchar,
    6 as libc::c_int as libc::c_uchar,
    25 as libc::c_int as libc::c_uchar,
    26 as libc::c_int as libc::c_uchar,
    13 as libc::c_int as libc::c_uchar,
    29 as libc::c_int as libc::c_uchar,
    15 as libc::c_int as libc::c_uchar,
    12 as libc::c_int as libc::c_uchar,
    17 as libc::c_int as libc::c_uchar,
    21 as libc::c_int as libc::c_uchar,
    22 as libc::c_int as libc::c_uchar,
    23 as libc::c_int as libc::c_uchar,
    24 as libc::c_int as libc::c_uchar,
    2 as libc::c_int as libc::c_uchar,
    3 as libc::c_int as libc::c_uchar,
    4 as libc::c_int as libc::c_uchar,
    25 as libc::c_int as libc::c_uchar,
    26 as libc::c_int as libc::c_uchar,
    1 as libc::c_int as libc::c_uchar,
    36 as libc::c_int as libc::c_uchar,
    37 as libc::c_int as libc::c_uchar,
    38 as libc::c_int as libc::c_uchar,
    5 as libc::c_int as libc::c_uchar,
    14 as libc::c_int as libc::c_uchar,
    41 as libc::c_int as libc::c_uchar,
    42 as libc::c_int as libc::c_uchar,
    43 as libc::c_int as libc::c_uchar,
    44 as libc::c_int as libc::c_uchar,
    39 as libc::c_int as libc::c_uchar,
    40 as libc::c_int as libc::c_uchar,
    13 as libc::c_int as libc::c_uchar,
    12 as libc::c_int as libc::c_uchar,
    15 as libc::c_int as libc::c_uchar,
    6 as libc::c_int as libc::c_uchar,
    17 as libc::c_int as libc::c_uchar,
    14 as libc::c_int as libc::c_uchar,
    1 as libc::c_int as libc::c_uchar,
    48 as libc::c_int as libc::c_uchar,
    49 as libc::c_int as libc::c_uchar,
    36 as libc::c_int as libc::c_uchar,
    5 as libc::c_int as libc::c_uchar,
    14 as libc::c_int as libc::c_uchar,
    25 as libc::c_int as libc::c_uchar,
    26 as libc::c_int as libc::c_uchar,
    1 as libc::c_int as libc::c_uchar,
    42 as libc::c_int as libc::c_uchar,
    43 as libc::c_int as libc::c_uchar,
    29 as libc::c_int as libc::c_uchar,
    13 as libc::c_int as libc::c_uchar,
    19 as libc::c_int as libc::c_uchar,
    15 as libc::c_int as libc::c_uchar,
    6 as libc::c_int as libc::c_uchar,
    17 as libc::c_int as libc::c_uchar,
    28 as libc::c_int as libc::c_uchar,
    29 as libc::c_int as libc::c_uchar,
    18 as libc::c_int as libc::c_uchar,
    36 as libc::c_int as libc::c_uchar,
    37 as libc::c_int as libc::c_uchar,
    38 as libc::c_int as libc::c_uchar,
    16 as libc::c_int as libc::c_uchar,
    25 as libc::c_int as libc::c_uchar,
    26 as libc::c_int as libc::c_uchar,
    42 as libc::c_int as libc::c_uchar,
    43 as libc::c_int as libc::c_uchar,
    44 as libc::c_int as libc::c_uchar,
    36 as libc::c_int as libc::c_uchar,
    37 as libc::c_int as libc::c_uchar,
    36 as libc::c_int as libc::c_uchar,
    37 as libc::c_int as libc::c_uchar,
    10 as libc::c_int as libc::c_uchar,
    11 as libc::c_int as libc::c_uchar,
    42 as libc::c_int as libc::c_uchar,
    43 as libc::c_int as libc::c_uchar,
    42 as libc::c_int as libc::c_uchar,
    43 as libc::c_int as libc::c_uchar,
    44 as libc::c_int as libc::c_uchar,
    14 as libc::c_int as libc::c_uchar,
    36 as libc::c_int as libc::c_uchar,
    37 as libc::c_int as libc::c_uchar,
    17 as libc::c_int as libc::c_uchar,
    36 as libc::c_int as libc::c_uchar,
    37 as libc::c_int as libc::c_uchar,
    14 as libc::c_int as libc::c_uchar,
    42 as libc::c_int as libc::c_uchar,
    43 as libc::c_int as libc::c_uchar,
    44 as libc::c_int as libc::c_uchar,
    42 as libc::c_int as libc::c_uchar,
    43 as libc::c_int as libc::c_uchar,
    44 as libc::c_int as libc::c_uchar,
    36 as libc::c_int as libc::c_uchar,
    37 as libc::c_int as libc::c_uchar,
    20 as libc::c_int as libc::c_uchar,
    45 as libc::c_int as libc::c_uchar,
    36 as libc::c_int as libc::c_uchar,
    37 as libc::c_int as libc::c_uchar,
    42 as libc::c_int as libc::c_uchar,
    43 as libc::c_int as libc::c_uchar,
    36 as libc::c_int as libc::c_uchar,
    37 as libc::c_int as libc::c_uchar,
    42 as libc::c_int as libc::c_uchar,
    43 as libc::c_int as libc::c_uchar,
    36 as libc::c_int as libc::c_uchar,
    37 as libc::c_int as libc::c_uchar,
    42 as libc::c_int as libc::c_uchar,
    43 as libc::c_int as libc::c_uchar,
    29 as libc::c_int as libc::c_uchar,
    50 as libc::c_int as libc::c_uchar,
    42 as libc::c_int as libc::c_uchar,
    43 as libc::c_int as libc::c_uchar,
];
static mut yy_shift_ofst: [libc::c_schar; 70] = [
    -(7 as libc::c_int) as libc::c_schar,
    6 as libc::c_int as libc::c_schar,
    -(7 as libc::c_int) as libc::c_schar,
    -(7 as libc::c_int) as libc::c_schar,
    -(7 as libc::c_int) as libc::c_schar,
    72 as libc::c_int as libc::c_schar,
    -(6 as libc::c_int) as libc::c_schar,
    4 as libc::c_int as libc::c_schar,
    91 as libc::c_int as libc::c_schar,
    -(7 as libc::c_int) as libc::c_schar,
    -(7 as libc::c_int) as libc::c_schar,
    8 as libc::c_int as libc::c_schar,
    -(7 as libc::c_int) as libc::c_schar,
    20 as libc::c_int as libc::c_schar,
    -(7 as libc::c_int) as libc::c_schar,
    -(7 as libc::c_int) as libc::c_schar,
    -(7 as libc::c_int) as libc::c_schar,
    40 as libc::c_int as libc::c_schar,
    7 as libc::c_int as libc::c_schar,
    74 as libc::c_int as libc::c_schar,
    7 as libc::c_int as libc::c_schar,
    -(7 as libc::c_int) as libc::c_schar,
    -(7 as libc::c_int) as libc::c_schar,
    -(7 as libc::c_int) as libc::c_schar,
    -(7 as libc::c_int) as libc::c_schar,
    -(7 as libc::c_int) as libc::c_schar,
    -(7 as libc::c_int) as libc::c_schar,
    19 as libc::c_int as libc::c_schar,
    24 as libc::c_int as libc::c_schar,
    -(7 as libc::c_int) as libc::c_schar,
    -(7 as libc::c_int) as libc::c_schar,
    88 as libc::c_int as libc::c_schar,
    -(7 as libc::c_int) as libc::c_schar,
    7 as libc::c_int as libc::c_schar,
    -(7 as libc::c_int) as libc::c_schar,
    48 as libc::c_int as libc::c_schar,
    7 as libc::c_int as libc::c_schar,
    74 as libc::c_int as libc::c_schar,
    -(7 as libc::c_int) as libc::c_schar,
    7 as libc::c_int as libc::c_schar,
    74 as libc::c_int as libc::c_schar,
    7 as libc::c_int as libc::c_schar,
    74 as libc::c_int as libc::c_schar,
    38 as libc::c_int as libc::c_schar,
    50 as libc::c_int as libc::c_schar,
    -(7 as libc::c_int) as libc::c_schar,
    46 as libc::c_int as libc::c_schar,
    -(7 as libc::c_int) as libc::c_schar,
    -(7 as libc::c_int) as libc::c_schar,
    66 as libc::c_int as libc::c_schar,
    59 as libc::c_int as libc::c_schar,
    7 as libc::c_int as libc::c_schar,
    74 as libc::c_int as libc::c_schar,
    100 as libc::c_int as libc::c_schar,
    17 as libc::c_int as libc::c_schar,
    7 as libc::c_int as libc::c_schar,
    56 as libc::c_int as libc::c_schar,
    -(7 as libc::c_int) as libc::c_schar,
    -(7 as libc::c_int) as libc::c_schar,
    -(7 as libc::c_int) as libc::c_schar,
    -(7 as libc::c_int) as libc::c_schar,
    7 as libc::c_int as libc::c_schar,
    -(7 as libc::c_int) as libc::c_schar,
    7 as libc::c_int as libc::c_schar,
    -(7 as libc::c_int) as libc::c_schar,
    -(7 as libc::c_int) as libc::c_schar,
    97 as libc::c_int as libc::c_schar,
    -(7 as libc::c_int) as libc::c_schar,
    64 as libc::c_int as libc::c_schar,
    -(7 as libc::c_int) as libc::c_schar,
];
static mut yy_reduce_ofst: [libc::c_schar; 70] = [
    54 as libc::c_int as libc::c_schar,
    -(30 as libc::c_int) as libc::c_schar,
    -(39 as libc::c_int) as libc::c_schar,
    -(39 as libc::c_int) as libc::c_schar,
    -(39 as libc::c_int) as libc::c_schar,
    -(38 as libc::c_int) as libc::c_schar,
    -(39 as libc::c_int) as libc::c_schar,
    -(39 as libc::c_int) as libc::c_schar,
    18 as libc::c_int as libc::c_schar,
    -(39 as libc::c_int) as libc::c_schar,
    -(39 as libc::c_int) as libc::c_schar,
    -(39 as libc::c_int) as libc::c_schar,
    5 as libc::c_int as libc::c_schar,
    -(30 as libc::c_int) as libc::c_schar,
    -(39 as libc::c_int) as libc::c_schar,
    -(39 as libc::c_int) as libc::c_schar,
    -(39 as libc::c_int) as libc::c_schar,
    -(39 as libc::c_int) as libc::c_schar,
    58 as libc::c_int as libc::c_schar,
    -(39 as libc::c_int) as libc::c_schar,
    32 as libc::c_int as libc::c_schar,
    -(39 as libc::c_int) as libc::c_schar,
    -(39 as libc::c_int) as libc::c_schar,
    -(39 as libc::c_int) as libc::c_schar,
    -(39 as libc::c_int) as libc::c_schar,
    -(39 as libc::c_int) as libc::c_schar,
    -(39 as libc::c_int) as libc::c_schar,
    12 as libc::c_int as libc::c_schar,
    -(39 as libc::c_int) as libc::c_schar,
    -(39 as libc::c_int) as libc::c_schar,
    -(39 as libc::c_int) as libc::c_schar,
    -(39 as libc::c_int) as libc::c_schar,
    -(39 as libc::c_int) as libc::c_schar,
    49 as libc::c_int as libc::c_schar,
    -(39 as libc::c_int) as libc::c_schar,
    -(39 as libc::c_int) as libc::c_schar,
    82 as libc::c_int as libc::c_schar,
    -(39 as libc::c_int) as libc::c_schar,
    -(39 as libc::c_int) as libc::c_schar,
    86 as libc::c_int as libc::c_schar,
    -(39 as libc::c_int) as libc::c_schar,
    90 as libc::c_int as libc::c_schar,
    -(39 as libc::c_int) as libc::c_schar,
    -(39 as libc::c_int) as libc::c_schar,
    -(39 as libc::c_int) as libc::c_schar,
    47 as libc::c_int as libc::c_schar,
    -(30 as libc::c_int) as libc::c_schar,
    -(39 as libc::c_int) as libc::c_schar,
    -(39 as libc::c_int) as libc::c_schar,
    -(39 as libc::c_int) as libc::c_schar,
    -(39 as libc::c_int) as libc::c_schar,
    60 as libc::c_int as libc::c_schar,
    -(39 as libc::c_int) as libc::c_schar,
    -(39 as libc::c_int) as libc::c_schar,
    76 as libc::c_int as libc::c_schar,
    94 as libc::c_int as libc::c_schar,
    -(39 as libc::c_int) as libc::c_schar,
    -(39 as libc::c_int) as libc::c_schar,
    -(39 as libc::c_int) as libc::c_schar,
    -(39 as libc::c_int) as libc::c_schar,
    -(39 as libc::c_int) as libc::c_schar,
    70 as libc::c_int as libc::c_schar,
    -(39 as libc::c_int) as libc::c_schar,
    73 as libc::c_int as libc::c_schar,
    -(39 as libc::c_int) as libc::c_schar,
    -(39 as libc::c_int) as libc::c_schar,
    -(39 as libc::c_int) as libc::c_schar,
    105 as libc::c_int as libc::c_schar,
    -(30 as libc::c_int) as libc::c_schar,
    -(39 as libc::c_int) as libc::c_schar,
];
static mut yy_default: [libc::c_uchar; 70] = [
    72 as libc::c_int as libc::c_uchar,
    114 as libc::c_int as libc::c_uchar,
    71 as libc::c_int as libc::c_uchar,
    73 as libc::c_int as libc::c_uchar,
    74 as libc::c_int as libc::c_uchar,
    114 as libc::c_int as libc::c_uchar,
    75 as libc::c_int as libc::c_uchar,
    114 as libc::c_int as libc::c_uchar,
    114 as libc::c_int as libc::c_uchar,
    100 as libc::c_int as libc::c_uchar,
    101 as libc::c_int as libc::c_uchar,
    114 as libc::c_int as libc::c_uchar,
    72 as libc::c_int as libc::c_uchar,
    114 as libc::c_int as libc::c_uchar,
    76 as libc::c_int as libc::c_uchar,
    77 as libc::c_int as libc::c_uchar,
    78 as libc::c_int as libc::c_uchar,
    114 as libc::c_int as libc::c_uchar,
    114 as libc::c_int as libc::c_uchar,
    79 as libc::c_int as libc::c_uchar,
    114 as libc::c_int as libc::c_uchar,
    82 as libc::c_int as libc::c_uchar,
    83 as libc::c_int as libc::c_uchar,
    85 as libc::c_int as libc::c_uchar,
    86 as libc::c_int as libc::c_uchar,
    87 as libc::c_int as libc::c_uchar,
    88 as libc::c_int as libc::c_uchar,
    114 as libc::c_int as libc::c_uchar,
    94 as libc::c_int as libc::c_uchar,
    84 as libc::c_int as libc::c_uchar,
    89 as libc::c_int as libc::c_uchar,
    114 as libc::c_int as libc::c_uchar,
    90 as libc::c_int as libc::c_uchar,
    92 as libc::c_int as libc::c_uchar,
    91 as libc::c_int as libc::c_uchar,
    114 as libc::c_int as libc::c_uchar,
    114 as libc::c_int as libc::c_uchar,
    95 as libc::c_int as libc::c_uchar,
    93 as libc::c_int as libc::c_uchar,
    114 as libc::c_int as libc::c_uchar,
    80 as libc::c_int as libc::c_uchar,
    114 as libc::c_int as libc::c_uchar,
    81 as libc::c_int as libc::c_uchar,
    114 as libc::c_int as libc::c_uchar,
    114 as libc::c_int as libc::c_uchar,
    72 as libc::c_int as libc::c_uchar,
    114 as libc::c_int as libc::c_uchar,
    99 as libc::c_int as libc::c_uchar,
    102 as libc::c_int as libc::c_uchar,
    114 as libc::c_int as libc::c_uchar,
    114 as libc::c_int as libc::c_uchar,
    114 as libc::c_int as libc::c_uchar,
    111 as libc::c_int as libc::c_uchar,
    114 as libc::c_int as libc::c_uchar,
    114 as libc::c_int as libc::c_uchar,
    114 as libc::c_int as libc::c_uchar,
    114 as libc::c_int as libc::c_uchar,
    107 as libc::c_int as libc::c_uchar,
    108 as libc::c_int as libc::c_uchar,
    109 as libc::c_int as libc::c_uchar,
    110 as libc::c_int as libc::c_uchar,
    114 as libc::c_int as libc::c_uchar,
    112 as libc::c_int as libc::c_uchar,
    114 as libc::c_int as libc::c_uchar,
    113 as libc::c_int as libc::c_uchar,
    103 as libc::c_int as libc::c_uchar,
    114 as libc::c_int as libc::c_uchar,
    72 as libc::c_int as libc::c_uchar,
    114 as libc::c_int as libc::c_uchar,
    104 as libc::c_int as libc::c_uchar,
];
#[no_mangle]
#[cold]
pub unsafe extern "C" fn configparserAlloc(
    mut mallocProc: Option<unsafe extern "C" fn(size_t) -> *mut libc::c_void>,
) -> *mut libc::c_void {
    let mut pParser: *mut yyParser = 0 as *mut yyParser;
    pParser = (Some(mallocProc.expect("non-null function pointer")))
        .expect("non-null function pointer")(
        ::core::mem::size_of::<yyParser>() as libc::c_ulong
    ) as *mut yyParser;
    if !pParser.is_null() {
        (*pParser).yyidx = -(1 as libc::c_int);
    }
    return pParser as *mut libc::c_void;
}
unsafe extern "C" fn yy_destructor(mut yymajor: libc::c_uchar, mut yypminor: *mut YYMINORTYPE) {
    match yymajor as libc::c_int {
        1 | 2 | 3 | 4 | 5 | 6 | 7 | 8 | 9 | 10 | 11 | 12 | 13 | 14 | 15 | 16 | 17 | 18 | 19
        | 20 | 21 | 22 | 23 | 24 | 25 | 26 => {
            buffer_free((*yypminor).yy0);
        }
        36 => {
            if !((*yypminor).yy91).is_null() {
                ((*(*(*yypminor).yy91).fn_0).free).expect("non-null function pointer")(
                    (*yypminor).yy91,
                );
            }
        }
        37 => {
            if !((*yypminor).yy91).is_null() {
                ((*(*(*yypminor).yy91).fn_0).free).expect("non-null function pointer")(
                    (*yypminor).yy91,
                );
            }
        }
        38 => {
            if !((*yypminor).yy91).is_null() {
                ((*(*(*yypminor).yy91).fn_0).free).expect("non-null function pointer")(
                    (*yypminor).yy91,
                );
            }
        }
        41 => {
            array_free((*yypminor).yy42);
        }
        42 => {
            array_free((*yypminor).yy42);
        }
        43 => {
            buffer_free((*yypminor).yy29);
        }
        44 => {
            buffer_free((*yypminor).yy29);
        }
        _ => {}
    };
}
unsafe extern "C" fn yy_pop_parser_stack(mut pParser: *mut yyParser) -> libc::c_int {
    let mut yymajor: libc::c_uchar = 0;
    let mut yytos: *mut yyStackEntry = 0 as *mut yyStackEntry;
    if (*pParser).yyidx < 0 as libc::c_int {
        return 0 as libc::c_int;
    }
    yytos = &mut *((*pParser).yystack)
        .as_mut_ptr()
        .offset((*pParser).yyidx as isize) as *mut yyStackEntry;
    yymajor = (*yytos).major as libc::c_uchar;
    yy_destructor(yymajor, &mut (*yytos).minor);
    (*pParser).yyidx -= 1;
    return yymajor as libc::c_int;
}
#[no_mangle]
#[cold]
pub unsafe extern "C" fn configparserFree(
    mut p: *mut libc::c_void,
    mut freeProc: Option<unsafe extern "C" fn(*mut libc::c_void) -> ()>,
) {
    let mut pParser: *mut yyParser = p as *mut yyParser;
    if pParser.is_null() {
        return;
    }
    while (*pParser).yyidx >= 0 as libc::c_int {
        yy_pop_parser_stack(pParser);
    }
    (Some(freeProc.expect("non-null function pointer"))).expect("non-null function pointer")(
        pParser as *mut libc::c_void,
    );
}
unsafe extern "C" fn yy_find_shift_action(
    mut pParser: *mut yyParser,
    mut iLookAhead: libc::c_int,
) -> libc::c_int {
    let mut i: libc::c_int = 0;
    let mut stateno: libc::c_int = (*pParser).yystack[(*pParser).yyidx as usize].stateno;
    i = yy_shift_ofst[stateno as usize] as libc::c_int;
    if i == -(7 as libc::c_int) {
        return yy_default[stateno as usize] as libc::c_int;
    }
    if iLookAhead == 51 as libc::c_int {
        return 70 as libc::c_int + 44 as libc::c_int + 2 as libc::c_int;
    }
    i += iLookAhead;
    if i < 0 as libc::c_int
        || i as size_t
            >= (::core::mem::size_of::<[libc::c_uchar; 138]>() as libc::c_ulong)
                .wrapping_div(::core::mem::size_of::<libc::c_uchar>() as libc::c_ulong)
        || yy_lookahead[i as usize] as libc::c_int != iLookAhead
    {
        return yy_default[stateno as usize] as libc::c_int;
    } else {
        return yy_action[i as usize] as libc::c_int;
    };
}
unsafe extern "C" fn yy_find_reduce_action(
    mut pParser: *mut yyParser,
    mut iLookAhead: libc::c_int,
) -> libc::c_int {
    let mut i: libc::c_int = 0;
    let mut stateno: libc::c_int = (*pParser).yystack[(*pParser).yyidx as usize].stateno;
    i = yy_reduce_ofst[stateno as usize] as libc::c_int;
    if i == -(39 as libc::c_int) {
        return yy_default[stateno as usize] as libc::c_int;
    }
    if iLookAhead == 51 as libc::c_int {
        return 70 as libc::c_int + 44 as libc::c_int + 2 as libc::c_int;
    }
    i += iLookAhead;
    if i < 0 as libc::c_int
        || i as size_t
            >= (::core::mem::size_of::<[libc::c_uchar; 138]>() as libc::c_ulong)
                .wrapping_div(::core::mem::size_of::<libc::c_uchar>() as libc::c_ulong)
        || yy_lookahead[i as usize] as libc::c_int != iLookAhead
    {
        return yy_default[stateno as usize] as libc::c_int;
    } else {
        return yy_action[i as usize] as libc::c_int;
    };
}
unsafe extern "C" fn yy_shift(
    mut yypParser: *mut yyParser,
    mut yyNewState: libc::c_int,
    mut yyMajor: libc::c_int,
    mut yypMinor: *mut YYMINORTYPE,
) {
    let mut yytos: *mut yyStackEntry = 0 as *mut yyStackEntry;
    (*yypParser).yyidx += 1;
    if (*yypParser).yyidx >= 100 as libc::c_int {
        let mut ctx: *mut config_t = (*yypParser).ctx;
        (*yypParser).yyidx -= 1;
        while (*yypParser).yyidx >= 0 as libc::c_int {
            yy_pop_parser_stack(yypParser);
        }
        (*yypParser).ctx = ctx;
        return;
    }
    yytos = &mut *((*yypParser).yystack)
        .as_mut_ptr()
        .offset((*yypParser).yyidx as isize) as *mut yyStackEntry;
    (*yytos).stateno = yyNewState;
    (*yytos).major = yyMajor;
    (*yytos).minor = *yypMinor;
}
static mut yyRuleInfo: [C2RustUnnamed_29; 44] = [
    {
        let mut init = C2RustUnnamed_29 {
            lhs: 28 as libc::c_int as libc::c_uchar,
            nrhs: 1 as libc::c_int as libc::c_uchar,
        };
        init
    },
    {
        let mut init = C2RustUnnamed_29 {
            lhs: 29 as libc::c_int as libc::c_uchar,
            nrhs: 2 as libc::c_int as libc::c_uchar,
        };
        init
    },
    {
        let mut init = C2RustUnnamed_29 {
            lhs: 29 as libc::c_int as libc::c_uchar,
            nrhs: 0 as libc::c_int as libc::c_uchar,
        };
        init
    },
    {
        let mut init = C2RustUnnamed_29 {
            lhs: 30 as libc::c_int as libc::c_uchar,
            nrhs: 1 as libc::c_int as libc::c_uchar,
        };
        init
    },
    {
        let mut init = C2RustUnnamed_29 {
            lhs: 30 as libc::c_int as libc::c_uchar,
            nrhs: 1 as libc::c_int as libc::c_uchar,
        };
        init
    },
    {
        let mut init = C2RustUnnamed_29 {
            lhs: 30 as libc::c_int as libc::c_uchar,
            nrhs: 2 as libc::c_int as libc::c_uchar,
        };
        init
    },
    {
        let mut init = C2RustUnnamed_29 {
            lhs: 30 as libc::c_int as libc::c_uchar,
            nrhs: 1 as libc::c_int as libc::c_uchar,
        };
        init
    },
    {
        let mut init = C2RustUnnamed_29 {
            lhs: 30 as libc::c_int as libc::c_uchar,
            nrhs: 1 as libc::c_int as libc::c_uchar,
        };
        init
    },
    {
        let mut init = C2RustUnnamed_29 {
            lhs: 30 as libc::c_int as libc::c_uchar,
            nrhs: 1 as libc::c_int as libc::c_uchar,
        };
        init
    },
    {
        let mut init = C2RustUnnamed_29 {
            lhs: 31 as libc::c_int as libc::c_uchar,
            nrhs: 3 as libc::c_int as libc::c_uchar,
        };
        init
    },
    {
        let mut init = C2RustUnnamed_29 {
            lhs: 31 as libc::c_int as libc::c_uchar,
            nrhs: 3 as libc::c_int as libc::c_uchar,
        };
        init
    },
    {
        let mut init = C2RustUnnamed_29 {
            lhs: 31 as libc::c_int as libc::c_uchar,
            nrhs: 3 as libc::c_int as libc::c_uchar,
        };
        init
    },
    {
        let mut init = C2RustUnnamed_29 {
            lhs: 43 as libc::c_int as libc::c_uchar,
            nrhs: 1 as libc::c_int as libc::c_uchar,
        };
        init
    },
    {
        let mut init = C2RustUnnamed_29 {
            lhs: 37 as libc::c_int as libc::c_uchar,
            nrhs: 3 as libc::c_int as libc::c_uchar,
        };
        init
    },
    {
        let mut init = C2RustUnnamed_29 {
            lhs: 37 as libc::c_int as libc::c_uchar,
            nrhs: 1 as libc::c_int as libc::c_uchar,
        };
        init
    },
    {
        let mut init = C2RustUnnamed_29 {
            lhs: 36 as libc::c_int as libc::c_uchar,
            nrhs: 1 as libc::c_int as libc::c_uchar,
        };
        init
    },
    {
        let mut init = C2RustUnnamed_29 {
            lhs: 36 as libc::c_int as libc::c_uchar,
            nrhs: 1 as libc::c_int as libc::c_uchar,
        };
        init
    },
    {
        let mut init = C2RustUnnamed_29 {
            lhs: 36 as libc::c_int as libc::c_uchar,
            nrhs: 1 as libc::c_int as libc::c_uchar,
        };
        init
    },
    {
        let mut init = C2RustUnnamed_29 {
            lhs: 36 as libc::c_int as libc::c_uchar,
            nrhs: 1 as libc::c_int as libc::c_uchar,
        };
        init
    },
    {
        let mut init = C2RustUnnamed_29 {
            lhs: 42 as libc::c_int as libc::c_uchar,
            nrhs: 2 as libc::c_int as libc::c_uchar,
        };
        init
    },
    {
        let mut init = C2RustUnnamed_29 {
            lhs: 42 as libc::c_int as libc::c_uchar,
            nrhs: 3 as libc::c_int as libc::c_uchar,
        };
        init
    },
    {
        let mut init = C2RustUnnamed_29 {
            lhs: 41 as libc::c_int as libc::c_uchar,
            nrhs: 3 as libc::c_int as libc::c_uchar,
        };
        init
    },
    {
        let mut init = C2RustUnnamed_29 {
            lhs: 41 as libc::c_int as libc::c_uchar,
            nrhs: 2 as libc::c_int as libc::c_uchar,
        };
        init
    },
    {
        let mut init = C2RustUnnamed_29 {
            lhs: 41 as libc::c_int as libc::c_uchar,
            nrhs: 1 as libc::c_int as libc::c_uchar,
        };
        init
    },
    {
        let mut init = C2RustUnnamed_29 {
            lhs: 38 as libc::c_int as libc::c_uchar,
            nrhs: 1 as libc::c_int as libc::c_uchar,
        };
        init
    },
    {
        let mut init = C2RustUnnamed_29 {
            lhs: 38 as libc::c_int as libc::c_uchar,
            nrhs: 3 as libc::c_int as libc::c_uchar,
        };
        init
    },
    {
        let mut init = C2RustUnnamed_29 {
            lhs: 46 as libc::c_int as libc::c_uchar,
            nrhs: 1 as libc::c_int as libc::c_uchar,
        };
        init
    },
    {
        let mut init = C2RustUnnamed_29 {
            lhs: 46 as libc::c_int as libc::c_uchar,
            nrhs: 0 as libc::c_int as libc::c_uchar,
        };
        init
    },
    {
        let mut init = C2RustUnnamed_29 {
            lhs: 47 as libc::c_int as libc::c_uchar,
            nrhs: 1 as libc::c_int as libc::c_uchar,
        };
        init
    },
    {
        let mut init = C2RustUnnamed_29 {
            lhs: 32 as libc::c_int as libc::c_uchar,
            nrhs: 4 as libc::c_int as libc::c_uchar,
        };
        init
    },
    {
        let mut init = C2RustUnnamed_29 {
            lhs: 33 as libc::c_int as libc::c_uchar,
            nrhs: 4 as libc::c_int as libc::c_uchar,
        };
        init
    },
    {
        let mut init = C2RustUnnamed_29 {
            lhs: 33 as libc::c_int as libc::c_uchar,
            nrhs: 4 as libc::c_int as libc::c_uchar,
        };
        init
    },
    {
        let mut init = C2RustUnnamed_29 {
            lhs: 33 as libc::c_int as libc::c_uchar,
            nrhs: 1 as libc::c_int as libc::c_uchar,
        };
        init
    },
    {
        let mut init = C2RustUnnamed_29 {
            lhs: 39 as libc::c_int as libc::c_uchar,
            nrhs: 4 as libc::c_int as libc::c_uchar,
        };
        init
    },
    {
        let mut init = C2RustUnnamed_29 {
            lhs: 40 as libc::c_int as libc::c_uchar,
            nrhs: 4 as libc::c_int as libc::c_uchar,
        };
        init
    },
    {
        let mut init = C2RustUnnamed_29 {
            lhs: 48 as libc::c_int as libc::c_uchar,
            nrhs: 7 as libc::c_int as libc::c_uchar,
        };
        init
    },
    {
        let mut init = C2RustUnnamed_29 {
            lhs: 49 as libc::c_int as libc::c_uchar,
            nrhs: 0 as libc::c_int as libc::c_uchar,
        };
        init
    },
    {
        let mut init = C2RustUnnamed_29 {
            lhs: 45 as libc::c_int as libc::c_uchar,
            nrhs: 1 as libc::c_int as libc::c_uchar,
        };
        init
    },
    {
        let mut init = C2RustUnnamed_29 {
            lhs: 45 as libc::c_int as libc::c_uchar,
            nrhs: 1 as libc::c_int as libc::c_uchar,
        };
        init
    },
    {
        let mut init = C2RustUnnamed_29 {
            lhs: 45 as libc::c_int as libc::c_uchar,
            nrhs: 1 as libc::c_int as libc::c_uchar,
        };
        init
    },
    {
        let mut init = C2RustUnnamed_29 {
            lhs: 45 as libc::c_int as libc::c_uchar,
            nrhs: 1 as libc::c_int as libc::c_uchar,
        };
        init
    },
    {
        let mut init = C2RustUnnamed_29 {
            lhs: 44 as libc::c_int as libc::c_uchar,
            nrhs: 1 as libc::c_int as libc::c_uchar,
        };
        init
    },
    {
        let mut init = C2RustUnnamed_29 {
            lhs: 34 as libc::c_int as libc::c_uchar,
            nrhs: 2 as libc::c_int as libc::c_uchar,
        };
        init
    },
    {
        let mut init = C2RustUnnamed_29 {
            lhs: 35 as libc::c_int as libc::c_uchar,
            nrhs: 2 as libc::c_int as libc::c_uchar,
        };
        init
    },
];
unsafe extern "C" fn yy_reduce(mut yypParser: *mut yyParser, mut yyruleno: libc::c_int) {
    let mut yygoto: libc::c_int = 0;
    let mut yyact: libc::c_int = 0;
    let mut yygotominor: YYMINORTYPE = YYMINORTYPE {
        yy0: 0 as *mut buffer,
    };
    let mut yymsp: *mut yyStackEntry = 0 as *mut yyStackEntry;
    let mut yysize: libc::c_int = 0;
    let mut ctx: *mut config_t = (*yypParser).ctx;
    yymsp = &mut *((*yypParser).yystack)
        .as_mut_ptr()
        .offset((*yypParser).yyidx as isize) as *mut yyStackEntry;
    match yyruleno {
        5 => {
            let ref mut fresh83 = (*yymsp.offset(-(1 as libc::c_int) as isize)).minor.yy18;
            *fresh83 = 0 as *mut data_config;
            yy_destructor(
                1 as libc::c_int as libc::c_uchar,
                &mut (*yymsp.offset(0 as libc::c_int as isize)).minor,
            );
        }
        8 => {
            yy_destructor(
                1 as libc::c_int as libc::c_uchar,
                &mut (*yymsp.offset(0 as libc::c_int as isize)).minor,
            );
        }
        9 => {
            if (*ctx).ok != 0 {
                buffer_copy_buffer(
                    &mut (*(*yymsp.offset(0 as libc::c_int as isize)).minor.yy91).key,
                    (*yymsp.offset(-(2 as libc::c_int) as isize)).minor.yy29,
                );
                if strncmp(
                    (*(*yymsp.offset(-(2 as libc::c_int) as isize)).minor.yy29).ptr,
                    b"env.\0" as *const u8 as *const libc::c_char,
                    (::core::mem::size_of::<[libc::c_char; 5]>() as libc::c_ulong)
                        .wrapping_sub(1 as libc::c_int as libc::c_ulong),
                ) == 0 as libc::c_int
                {
                    fprintf(
                        stderr,
                        b"Setting env variable is not supported in conditional %d %s: %s\n\0"
                            as *const u8 as *const libc::c_char,
                        (*(*ctx).current).context_ndx,
                        (*(*ctx).current).key.ptr,
                        (*(*yymsp.offset(-(2 as libc::c_int) as isize)).minor.yy29).ptr,
                    );
                    (*ctx).ok = 0 as libc::c_int;
                } else if (array_get_element_klen(
                    (*(*ctx).current).value,
                    (*(*yymsp.offset(0 as libc::c_int as isize)).minor.yy91)
                        .key
                        .ptr,
                    buffer_clen(&mut (*(*yymsp.offset(0 as libc::c_int as isize)).minor.yy91).key),
                ))
                .is_null()
                {
                    array_insert_unique(
                        (*(*ctx).current).value,
                        (*yymsp.offset(0 as libc::c_int as isize)).minor.yy91,
                    );
                    let ref mut fresh84 = (*yymsp.offset(0 as libc::c_int as isize)).minor.yy91;
                    *fresh84 = 0 as *mut data_unset;
                } else {
                    fprintf(
                        stderr,
                        b"Duplicate config variable in conditional %d %s: %s\n\0" as *const u8
                            as *const libc::c_char,
                        (*(*ctx).current).context_ndx,
                        (*(*ctx).current).key.ptr,
                        (*(*yymsp.offset(0 as libc::c_int as isize)).minor.yy91)
                            .key
                            .ptr,
                    );
                    (*ctx).ok = 0 as libc::c_int;
                }
            }
            buffer_free((*yymsp.offset(-(2 as libc::c_int) as isize)).minor.yy29);
            let ref mut fresh85 = (*yymsp.offset(-(2 as libc::c_int) as isize)).minor.yy29;
            *fresh85 = 0 as *mut buffer;
            if !((*yymsp.offset(0 as libc::c_int as isize)).minor.yy91).is_null() {
                ((*(*(*yymsp.offset(0 as libc::c_int as isize)).minor.yy91).fn_0).free)
                    .expect("non-null function pointer")(
                    (*yymsp.offset(0 as libc::c_int as isize)).minor.yy91,
                );
            }
            let ref mut fresh86 = (*yymsp.offset(0 as libc::c_int as isize)).minor.yy91;
            *fresh86 = 0 as *mut data_unset;
            yy_destructor(
                2 as libc::c_int as libc::c_uchar,
                &mut (*yymsp.offset(-(1 as libc::c_int) as isize)).minor,
            );
        }
        10 => {
            if (*ctx).ok != 0 {
                if strncmp(
                    (*(*yymsp.offset(-(2 as libc::c_int) as isize)).minor.yy29).ptr,
                    b"env.\0" as *const u8 as *const libc::c_char,
                    (::core::mem::size_of::<[libc::c_char; 5]>() as libc::c_ulong)
                        .wrapping_sub(1 as libc::c_int as libc::c_ulong),
                ) == 0 as libc::c_int
                {
                    fprintf(
                        stderr,
                        b"Setting env variable is not supported in conditional %d %s: %s\n\0"
                            as *const u8 as *const libc::c_char,
                        (*(*ctx).current).context_ndx,
                        (*(*ctx).current).key.ptr,
                        (*(*yymsp.offset(-(2 as libc::c_int) as isize)).minor.yy29).ptr,
                    );
                    (*ctx).ok = 0 as libc::c_int;
                } else {
                    buffer_copy_buffer(
                        &mut (*(*yymsp.offset(0 as libc::c_int as isize)).minor.yy91).key,
                        (*yymsp.offset(-(2 as libc::c_int) as isize)).minor.yy29,
                    );
                    array_replace(
                        (*(*ctx).current).value,
                        (*yymsp.offset(0 as libc::c_int as isize)).minor.yy91,
                    );
                    let ref mut fresh87 = (*yymsp.offset(0 as libc::c_int as isize)).minor.yy91;
                    *fresh87 = 0 as *mut data_unset;
                }
            }
            buffer_free((*yymsp.offset(-(2 as libc::c_int) as isize)).minor.yy29);
            let ref mut fresh88 = (*yymsp.offset(-(2 as libc::c_int) as isize)).minor.yy29;
            *fresh88 = 0 as *mut buffer;
            if !((*yymsp.offset(0 as libc::c_int as isize)).minor.yy91).is_null() {
                ((*(*(*yymsp.offset(0 as libc::c_int as isize)).minor.yy91).fn_0).free)
                    .expect("non-null function pointer")(
                    (*yymsp.offset(0 as libc::c_int as isize)).minor.yy91,
                );
            }
            let ref mut fresh89 = (*yymsp.offset(0 as libc::c_int as isize)).minor.yy91;
            *fresh89 = 0 as *mut data_unset;
            yy_destructor(
                3 as libc::c_int as libc::c_uchar,
                &mut (*yymsp.offset(-(1 as libc::c_int) as isize)).minor,
            );
        }
        11 => {
            if (*ctx).ok != 0 {
                let mut vars: *mut array = (*(*ctx).current).value;
                let mut du: *mut data_unset = 0 as *mut data_unset;
                if strncmp(
                    (*(*yymsp.offset(-(2 as libc::c_int) as isize)).minor.yy29).ptr,
                    b"env.\0" as *const u8 as *const libc::c_char,
                    (::core::mem::size_of::<[libc::c_char; 5]>() as libc::c_ulong)
                        .wrapping_sub(1 as libc::c_int as libc::c_ulong),
                ) == 0 as libc::c_int
                {
                    fprintf(
                        stderr,
                        b"Appending env variable is not supported in conditional %d %s: %s\n\0"
                            as *const u8 as *const libc::c_char,
                        (*(*ctx).current).context_ndx,
                        (*(*ctx).current).key.ptr,
                        (*(*yymsp.offset(-(2 as libc::c_int) as isize)).minor.yy29).ptr,
                    );
                    (*ctx).ok = 0 as libc::c_int;
                } else {
                    du = array_extract_element_klen(
                        vars,
                        (*(*yymsp.offset(-(2 as libc::c_int) as isize)).minor.yy29).ptr,
                        buffer_clen((*yymsp.offset(-(2 as libc::c_int) as isize)).minor.yy29),
                    );
                    if !du.is_null() || {
                        du = configparser_get_variable(
                            ctx,
                            (*yymsp.offset(-(2 as libc::c_int) as isize)).minor.yy29,
                        );
                        !du.is_null()
                    } {
                        du = configparser_merge_data(
                            du,
                            (*yymsp.offset(0 as libc::c_int as isize)).minor.yy91,
                        );
                        if du.is_null() {
                            (*ctx).ok = 0 as libc::c_int;
                        } else {
                            buffer_copy_buffer(
                                &mut (*du).key,
                                (*yymsp.offset(-(2 as libc::c_int) as isize)).minor.yy29,
                            );
                            array_insert_unique((*(*ctx).current).value, du);
                        }
                    } else {
                        buffer_copy_buffer(
                            &mut (*(*yymsp.offset(0 as libc::c_int as isize)).minor.yy91).key,
                            (*yymsp.offset(-(2 as libc::c_int) as isize)).minor.yy29,
                        );
                        array_insert_unique(
                            (*(*ctx).current).value,
                            (*yymsp.offset(0 as libc::c_int as isize)).minor.yy91,
                        );
                        let ref mut fresh90 = (*yymsp.offset(0 as libc::c_int as isize)).minor.yy91;
                        *fresh90 = 0 as *mut data_unset;
                    }
                }
            }
            buffer_free((*yymsp.offset(-(2 as libc::c_int) as isize)).minor.yy29);
            let ref mut fresh91 = (*yymsp.offset(-(2 as libc::c_int) as isize)).minor.yy29;
            *fresh91 = 0 as *mut buffer;
            if !((*yymsp.offset(0 as libc::c_int as isize)).minor.yy91).is_null() {
                ((*(*(*yymsp.offset(0 as libc::c_int as isize)).minor.yy91).fn_0).free)
                    .expect("non-null function pointer")(
                    (*yymsp.offset(0 as libc::c_int as isize)).minor.yy91,
                );
            }
            let ref mut fresh92 = (*yymsp.offset(0 as libc::c_int as isize)).minor.yy91;
            *fresh92 = 0 as *mut data_unset;
            yy_destructor(
                4 as libc::c_int as libc::c_uchar,
                &mut (*yymsp.offset(-(1 as libc::c_int) as isize)).minor,
            );
        }
        12 => {
            if (strchr(
                (*(*yymsp.offset(0 as libc::c_int as isize)).minor.yy0).ptr,
                '.' as i32,
            ))
            .is_null()
            {
                yygotominor.yy29 = buffer_init();
                buffer_copy_string(
                    yygotominor.yy29,
                    b"var.\0" as *const u8 as *const libc::c_char,
                );
                buffer_append_buffer(
                    yygotominor.yy29,
                    (*yymsp.offset(0 as libc::c_int as isize)).minor.yy0,
                );
            } else {
                yygotominor.yy29 = (*yymsp.offset(0 as libc::c_int as isize)).minor.yy0;
                let ref mut fresh93 = (*yymsp.offset(0 as libc::c_int as isize)).minor.yy0;
                *fresh93 = 0 as *mut buffer;
            }
            buffer_free((*yymsp.offset(0 as libc::c_int as isize)).minor.yy0);
            let ref mut fresh94 = (*yymsp.offset(0 as libc::c_int as isize)).minor.yy0;
            *fresh94 = 0 as *mut buffer;
        }
        13 => {
            yygotominor.yy91 = 0 as *mut data_unset;
            if (*ctx).ok != 0 {
                yygotominor.yy91 = configparser_merge_data(
                    (*yymsp.offset(-(2 as libc::c_int) as isize)).minor.yy91,
                    (*yymsp.offset(0 as libc::c_int as isize)).minor.yy91,
                );
                let ref mut fresh95 = (*yymsp.offset(-(2 as libc::c_int) as isize)).minor.yy91;
                *fresh95 = 0 as *mut data_unset;
                if (yygotominor.yy91).is_null() {
                    (*ctx).ok = 0 as libc::c_int;
                }
            }
            if !((*yymsp.offset(-(2 as libc::c_int) as isize)).minor.yy91).is_null() {
                ((*(*(*yymsp.offset(-(2 as libc::c_int) as isize)).minor.yy91).fn_0).free)
                    .expect("non-null function pointer")(
                    (*yymsp.offset(-(2 as libc::c_int) as isize)).minor.yy91,
                );
            }
            let ref mut fresh96 = (*yymsp.offset(-(2 as libc::c_int) as isize)).minor.yy91;
            *fresh96 = 0 as *mut data_unset;
            if !((*yymsp.offset(0 as libc::c_int as isize)).minor.yy91).is_null() {
                ((*(*(*yymsp.offset(0 as libc::c_int as isize)).minor.yy91).fn_0).free)
                    .expect("non-null function pointer")(
                    (*yymsp.offset(0 as libc::c_int as isize)).minor.yy91,
                );
            }
            let ref mut fresh97 = (*yymsp.offset(0 as libc::c_int as isize)).minor.yy91;
            *fresh97 = 0 as *mut data_unset;
            yy_destructor(
                6 as libc::c_int as libc::c_uchar,
                &mut (*yymsp.offset(-(1 as libc::c_int) as isize)).minor,
            );
        }
        14 => {
            yygotominor.yy91 = (*yymsp.offset(0 as libc::c_int as isize)).minor.yy91;
            let ref mut fresh98 = (*yymsp.offset(0 as libc::c_int as isize)).minor.yy91;
            *fresh98 = 0 as *mut data_unset;
        }
        15 => {
            yygotominor.yy91 = 0 as *mut data_unset;
            if (*ctx).ok != 0 {
                if strncmp(
                    (*(*yymsp.offset(0 as libc::c_int as isize)).minor.yy29).ptr,
                    b"env.\0" as *const u8 as *const libc::c_char,
                    (::core::mem::size_of::<[libc::c_char; 5]>() as libc::c_ulong)
                        .wrapping_sub(1 as libc::c_int as libc::c_ulong),
                ) == 0 as libc::c_int
                {
                    let mut env: *mut libc::c_char = 0 as *mut libc::c_char;
                    env = getenv(
                        ((*(*yymsp.offset(0 as libc::c_int as isize)).minor.yy29).ptr)
                            .offset(4 as libc::c_int as isize),
                    );
                    if !env.is_null() {
                        let mut ds: *mut data_string = 0 as *mut data_string;
                        ds = array_data_string_init();
                        buffer_append_string(&mut (*ds).value, env);
                        yygotominor.yy91 = ds as *mut data_unset;
                    } else {
                        fprintf(
                            stderr,
                            b"Undefined env variable: %s\n\0" as *const u8 as *const libc::c_char,
                            ((*(*yymsp.offset(0 as libc::c_int as isize)).minor.yy29).ptr)
                                .offset(4 as libc::c_int as isize),
                        );
                        (*ctx).ok = 0 as libc::c_int;
                    }
                } else {
                    yygotominor.yy91 = configparser_get_variable(
                        ctx,
                        (*yymsp.offset(0 as libc::c_int as isize)).minor.yy29,
                    );
                    if (yygotominor.yy91).is_null() {
                        fprintf(
                            stderr,
                            b"Undefined config variable: %s\n\0" as *const u8
                                as *const libc::c_char,
                            (*(*yymsp.offset(0 as libc::c_int as isize)).minor.yy29).ptr,
                        );
                        (*ctx).ok = 0 as libc::c_int;
                    }
                }
            }
            buffer_free((*yymsp.offset(0 as libc::c_int as isize)).minor.yy29);
            let ref mut fresh99 = (*yymsp.offset(0 as libc::c_int as isize)).minor.yy29;
            *fresh99 = 0 as *mut buffer;
        }
        16 => {
            yygotominor.yy91 = array_data_string_init() as *mut data_unset;
            memcpy(
                &mut (*(yygotominor.yy91 as *mut data_string)).value as *mut buffer
                    as *mut libc::c_void,
                (*yymsp.offset(0 as libc::c_int as isize)).minor.yy0 as *const libc::c_void,
                ::core::mem::size_of::<buffer>() as libc::c_ulong,
            );
            free((*yymsp.offset(0 as libc::c_int as isize)).minor.yy0 as *mut libc::c_void);
            let ref mut fresh100 = (*yymsp.offset(0 as libc::c_int as isize)).minor.yy0;
            *fresh100 = 0 as *mut buffer;
        }
        17 => {
            let mut endptr: *mut libc::c_char = 0 as *mut libc::c_char;
            yygotominor.yy91 = array_data_integer_init() as *mut data_unset;
            *__errno_location() = 0 as libc::c_int;
            (*(yygotominor.yy91 as *mut data_integer)).value = strtol(
                (*(*yymsp.offset(0 as libc::c_int as isize)).minor.yy0).ptr,
                &mut endptr,
                10 as libc::c_int,
            ) as libc::c_int;
            if endptr != (*(*yymsp.offset(0 as libc::c_int as isize)).minor.yy0).ptr {
                while *(*__ctype_b_loc())
                    .offset(*(endptr as *mut libc::c_uchar) as libc::c_int as isize)
                    as libc::c_int
                    & _ISspace as libc::c_int as libc::c_ushort as libc::c_int
                    != 0
                {
                    endptr = endptr.offset(1);
                }
            }
            if 0 as libc::c_int != *__errno_location() || *endptr as libc::c_int != '\0' as i32 {
                fprintf(
                    stderr,
                    b"error parsing number: '%s'\n\0" as *const u8 as *const libc::c_char,
                    (*(*yymsp.offset(0 as libc::c_int as isize)).minor.yy0).ptr,
                );
                (*ctx).ok = 0 as libc::c_int;
            }
            buffer_free((*yymsp.offset(0 as libc::c_int as isize)).minor.yy0);
            let ref mut fresh101 = (*yymsp.offset(0 as libc::c_int as isize)).minor.yy0;
            *fresh101 = 0 as *mut buffer;
        }
        18 => {
            yygotominor.yy91 = array_data_array_init() as *mut data_unset;
            memcpy(
                &mut (*(yygotominor.yy91 as *mut data_array)).value as *mut array
                    as *mut libc::c_void,
                (*yymsp.offset(0 as libc::c_int as isize)).minor.yy42 as *const libc::c_void,
                ::core::mem::size_of::<array>() as libc::c_ulong,
            );
            free((*yymsp.offset(0 as libc::c_int as isize)).minor.yy42 as *mut libc::c_void);
            let ref mut fresh102 = (*yymsp.offset(0 as libc::c_int as isize)).minor.yy42;
            *fresh102 = 0 as *mut array;
        }
        19 => {
            yygotominor.yy42 = array_init(8 as libc::c_int as uint32_t);
            yy_destructor(
                9 as libc::c_int as libc::c_uchar,
                &mut (*yymsp.offset(-(1 as libc::c_int) as isize)).minor,
            );
            yy_destructor(
                10 as libc::c_int as libc::c_uchar,
                &mut (*yymsp.offset(0 as libc::c_int as isize)).minor,
            );
        }
        20 => {
            yygotominor.yy42 = (*yymsp.offset(-(1 as libc::c_int) as isize)).minor.yy42;
            let ref mut fresh103 = (*yymsp.offset(-(1 as libc::c_int) as isize)).minor.yy42;
            *fresh103 = 0 as *mut array;
            yy_destructor(
                9 as libc::c_int as libc::c_uchar,
                &mut (*yymsp.offset(-(2 as libc::c_int) as isize)).minor,
            );
            yy_destructor(
                10 as libc::c_int as libc::c_uchar,
                &mut (*yymsp.offset(0 as libc::c_int as isize)).minor,
            );
        }
        21 => {
            yygotominor.yy42 = 0 as *mut array;
            if (*ctx).ok != 0 {
                if buffer_is_unset(
                    &mut (*(*yymsp.offset(0 as libc::c_int as isize)).minor.yy91).key,
                ) != 0
                    || (array_get_element_klen(
                        (*yymsp.offset(-(2 as libc::c_int) as isize)).minor.yy42,
                        (*(*yymsp.offset(0 as libc::c_int as isize)).minor.yy91)
                            .key
                            .ptr,
                        buffer_clen(
                            &mut (*(*yymsp.offset(0 as libc::c_int as isize)).minor.yy91).key,
                        ),
                    ))
                    .is_null()
                {
                    array_insert_unique(
                        (*yymsp.offset(-(2 as libc::c_int) as isize)).minor.yy42,
                        (*yymsp.offset(0 as libc::c_int as isize)).minor.yy91,
                    );
                    let ref mut fresh104 = (*yymsp.offset(0 as libc::c_int as isize)).minor.yy91;
                    *fresh104 = 0 as *mut data_unset;
                } else {
                    fprintf(
                        stderr,
                        b"Error: duplicate array-key: %s. Please get rid of the duplicate entry.\n\0"
                            as *const u8 as *const libc::c_char,
                        (*(*yymsp.offset(0 as libc::c_int as isize)).minor.yy91).key.ptr,
                    );
                    (*ctx).ok = 0 as libc::c_int;
                }
                yygotominor.yy42 = (*yymsp.offset(-(2 as libc::c_int) as isize)).minor.yy42;
                let ref mut fresh105 = (*yymsp.offset(-(2 as libc::c_int) as isize)).minor.yy42;
                *fresh105 = 0 as *mut array;
            }
            array_free((*yymsp.offset(-(2 as libc::c_int) as isize)).minor.yy42);
            let ref mut fresh106 = (*yymsp.offset(-(2 as libc::c_int) as isize)).minor.yy42;
            *fresh106 = 0 as *mut array;
            if !((*yymsp.offset(0 as libc::c_int as isize)).minor.yy91).is_null() {
                ((*(*(*yymsp.offset(0 as libc::c_int as isize)).minor.yy91).fn_0).free)
                    .expect("non-null function pointer")(
                    (*yymsp.offset(0 as libc::c_int as isize)).minor.yy91,
                );
            }
            let ref mut fresh107 = (*yymsp.offset(0 as libc::c_int as isize)).minor.yy91;
            *fresh107 = 0 as *mut data_unset;
            yy_destructor(
                11 as libc::c_int as libc::c_uchar,
                &mut (*yymsp.offset(-(1 as libc::c_int) as isize)).minor,
            );
        }
        22 => {
            yygotominor.yy42 = (*yymsp.offset(-(1 as libc::c_int) as isize)).minor.yy42;
            let ref mut fresh108 = (*yymsp.offset(-(1 as libc::c_int) as isize)).minor.yy42;
            *fresh108 = 0 as *mut array;
            yy_destructor(
                11 as libc::c_int as libc::c_uchar,
                &mut (*yymsp.offset(0 as libc::c_int as isize)).minor,
            );
        }
        23 => {
            yygotominor.yy42 = 0 as *mut array;
            if (*ctx).ok != 0 {
                yygotominor.yy42 = array_init(4 as libc::c_int as uint32_t);
                array_insert_unique(
                    yygotominor.yy42,
                    (*yymsp.offset(0 as libc::c_int as isize)).minor.yy91,
                );
                let ref mut fresh109 = (*yymsp.offset(0 as libc::c_int as isize)).minor.yy91;
                *fresh109 = 0 as *mut data_unset;
            }
            if !((*yymsp.offset(0 as libc::c_int as isize)).minor.yy91).is_null() {
                ((*(*(*yymsp.offset(0 as libc::c_int as isize)).minor.yy91).fn_0).free)
                    .expect("non-null function pointer")(
                    (*yymsp.offset(0 as libc::c_int as isize)).minor.yy91,
                );
            }
            let ref mut fresh110 = (*yymsp.offset(0 as libc::c_int as isize)).minor.yy91;
            *fresh110 = 0 as *mut data_unset;
        }
        24 => {
            yygotominor.yy91 = (*yymsp.offset(0 as libc::c_int as isize)).minor.yy91;
            let ref mut fresh111 = (*yymsp.offset(0 as libc::c_int as isize)).minor.yy91;
            *fresh111 = 0 as *mut data_unset;
        }
        25 => {
            yygotominor.yy91 = 0 as *mut data_unset;
            if (*ctx).ok != 0 {
                buffer_copy_buffer(
                    &mut (*(*yymsp.offset(0 as libc::c_int as isize)).minor.yy91).key,
                    (*yymsp.offset(-(2 as libc::c_int) as isize)).minor.yy29,
                );
                yygotominor.yy91 = (*yymsp.offset(0 as libc::c_int as isize)).minor.yy91;
                let ref mut fresh112 = (*yymsp.offset(0 as libc::c_int as isize)).minor.yy91;
                *fresh112 = 0 as *mut data_unset;
            }
            if !((*yymsp.offset(0 as libc::c_int as isize)).minor.yy91).is_null() {
                ((*(*(*yymsp.offset(0 as libc::c_int as isize)).minor.yy91).fn_0).free)
                    .expect("non-null function pointer")(
                    (*yymsp.offset(0 as libc::c_int as isize)).minor.yy91,
                );
            }
            let ref mut fresh113 = (*yymsp.offset(0 as libc::c_int as isize)).minor.yy91;
            *fresh113 = 0 as *mut data_unset;
            buffer_free((*yymsp.offset(-(2 as libc::c_int) as isize)).minor.yy29);
            let ref mut fresh114 = (*yymsp.offset(-(2 as libc::c_int) as isize)).minor.yy29;
            *fresh114 = 0 as *mut buffer;
            yy_destructor(
                12 as libc::c_int as libc::c_uchar,
                &mut (*yymsp.offset(-(1 as libc::c_int) as isize)).minor,
            );
        }
        26 => {
            yy_destructor(
                1 as libc::c_int as libc::c_uchar,
                &mut (*yymsp.offset(0 as libc::c_int as isize)).minor,
            );
        }
        28 => {
            let mut dc: *mut data_config = 0 as *mut data_config;
            dc = configparser_get_data_config(
                (*(*ctx).srv).config_context,
                b"global\0" as *const u8 as *const libc::c_char,
                (::core::mem::size_of::<[libc::c_char; 7]>() as libc::c_ulong as uint32_t)
                    .wrapping_sub(1 as libc::c_int as libc::c_uint) as size_t,
            );
            if dc.is_null() {
                ck_assert_failed(
                    b"/home/kkysen/work/rust/lighttpd/src/configparser.y\0" as *const u8
                        as *const libc::c_char,
                    557 as libc::c_int as libc::c_uint,
                    b"dc\0" as *const u8 as *const libc::c_char,
                );
            }
            configparser_push(ctx, dc, 0 as libc::c_int);
            yy_destructor(
                13 as libc::c_int as libc::c_uchar,
                &mut (*yymsp.offset(0 as libc::c_int as isize)).minor,
            );
        }
        29 => {
            if ((*ctx).current).is_null() {
                ck_assert_failed(
                    b"/home/kkysen/work/rust/lighttpd/src/configparser.y\0" as *const u8
                        as *const libc::c_char,
                    562 as libc::c_int as libc::c_uint,
                    b"ctx->current\0" as *const u8 as *const libc::c_char,
                );
            }
            configparser_pop(ctx);
            if ((*ctx).current).is_null() {
                ck_assert_failed(
                    b"/home/kkysen/work/rust/lighttpd/src/configparser.y\0" as *const u8
                        as *const libc::c_char,
                    564 as libc::c_int as libc::c_uint,
                    b"ctx->current\0" as *const u8 as *const libc::c_char,
                );
            }
            yy_destructor(
                14 as libc::c_int as libc::c_uchar,
                &mut (*yymsp.offset(-(2 as libc::c_int) as isize)).minor,
            );
            yy_destructor(
                15 as libc::c_int as libc::c_uchar,
                &mut (*yymsp.offset(0 as libc::c_int as isize)).minor,
            );
        }
        30 => {
            yygotominor.yy18 = 0 as *mut data_config;
            if (*ctx).ok != 0 {
                if (*(*yymsp.offset(-(3 as libc::c_int) as isize)).minor.yy18).context_ndx
                    >= (*(*yymsp.offset(0 as libc::c_int as isize)).minor.yy18).context_ndx
                {
                    fprintf(
                        stderr,
                        b"unreachable else condition\n\0" as *const u8 as *const libc::c_char,
                    );
                    (*ctx).ok = 0 as libc::c_int;
                }
                if (*(*yymsp.offset(-(3 as libc::c_int) as isize)).minor.yy18).cond as libc::c_uint
                    == CONFIG_COND_ELSE as libc::c_int as libc::c_uint
                {
                    fprintf(
                        stderr,
                        b"unreachable condition following else catch-all\n\0" as *const u8
                            as *const libc::c_char,
                    );
                    (*ctx).ok = 0 as libc::c_int;
                }
                let ref mut fresh115 =
                    (*(*yymsp.offset(0 as libc::c_int as isize)).minor.yy18).prev;
                *fresh115 = (*yymsp.offset(-(3 as libc::c_int) as isize)).minor.yy18;
                let ref mut fresh116 =
                    (*(*yymsp.offset(-(3 as libc::c_int) as isize)).minor.yy18).next;
                *fresh116 = (*yymsp.offset(0 as libc::c_int as isize)).minor.yy18;
                yygotominor.yy18 = (*yymsp.offset(0 as libc::c_int as isize)).minor.yy18;
            }
            let ref mut fresh117 = (*yymsp.offset(-(3 as libc::c_int) as isize)).minor.yy18;
            *fresh117 = 0 as *mut data_config;
            let ref mut fresh118 = (*yymsp.offset(0 as libc::c_int as isize)).minor.yy18;
            *fresh118 = 0 as *mut data_config;
            yy_destructor(
                16 as libc::c_int as libc::c_uchar,
                &mut (*yymsp.offset(-(1 as libc::c_int) as isize)).minor,
            );
        }
        31 => {
            yygotominor.yy18 = 0 as *mut data_config;
            if (*ctx).ok != 0 {
                if (*(*yymsp.offset(-(3 as libc::c_int) as isize)).minor.yy18).context_ndx
                    >= (*(*yymsp.offset(0 as libc::c_int as isize)).minor.yy18).context_ndx
                {
                    fprintf(
                        stderr,
                        b"unreachable else condition\n\0" as *const u8 as *const libc::c_char,
                    );
                    (*ctx).ok = 0 as libc::c_int;
                }
                if (*(*yymsp.offset(-(3 as libc::c_int) as isize)).minor.yy18).cond as libc::c_uint
                    == CONFIG_COND_ELSE as libc::c_int as libc::c_uint
                {
                    fprintf(
                        stderr,
                        b"unreachable condition following else catch-all\n\0" as *const u8
                            as *const libc::c_char,
                    );
                    (*ctx).ok = 0 as libc::c_int;
                }
            }
            if (*ctx).ok != 0 {
                let mut pos: size_t = 0;
                let mut dc_0: *mut data_config = 0 as *mut data_config;
                dc_0 = array_extract_element_klen(
                    (*ctx).all_configs,
                    (*(*yymsp.offset(0 as libc::c_int as isize)).minor.yy18)
                        .key
                        .ptr,
                    buffer_clen(&mut (*(*yymsp.offset(0 as libc::c_int as isize)).minor.yy18).key),
                ) as *mut data_config;
                if !((*yymsp.offset(0 as libc::c_int as isize)).minor.yy18 == dc_0) {
                    ck_assert_failed(
                        b"/home/kkysen/work/rust/lighttpd/src/configparser.y\0" as *const u8
                            as *const libc::c_char,
                        602 as libc::c_int as libc::c_uint,
                        b"yymsp[0].minor.yy18 == dc\0" as *const u8 as *const libc::c_char,
                    );
                }
                buffer_copy_buffer(
                    &mut (*(*yymsp.offset(0 as libc::c_int as isize)).minor.yy18).key,
                    &mut (*(*yymsp.offset(-(3 as libc::c_int) as isize)).minor.yy18).key,
                );
                let ref mut fresh119 =
                    (*(*yymsp.offset(0 as libc::c_int as isize)).minor.yy18).comp_key;
                *fresh119 = ((*(*yymsp.offset(0 as libc::c_int as isize)).minor.yy18)
                    .key
                    .ptr)
                    .offset(
                        ((*(*yymsp.offset(-(3 as libc::c_int) as isize)).minor.yy18).comp_key)
                            .offset_from(
                                (*(*yymsp.offset(-(3 as libc::c_int) as isize)).minor.yy18)
                                    .key
                                    .ptr,
                            ) as libc::c_long as isize,
                    );
                (*(*yymsp.offset(0 as libc::c_int as isize)).minor.yy18).comp =
                    (*(*yymsp.offset(-(3 as libc::c_int) as isize)).minor.yy18).comp;
                pos = (buffer_clen(
                    &mut (*(*yymsp.offset(0 as libc::c_int as isize)).minor.yy18).key,
                ))
                .wrapping_sub(buffer_clen(
                    &mut (*(*yymsp.offset(-(3 as libc::c_int) as isize)).minor.yy18).string,
                ))
                .wrapping_sub(5 as libc::c_int as libc::c_uint) as size_t;
                match (*(*yymsp.offset(-(3 as libc::c_int) as isize)).minor.yy18).cond
                    as libc::c_uint
                {
                    3 => {
                        *((*(*yymsp.offset(0 as libc::c_int as isize)).minor.yy18)
                            .key
                            .ptr)
                            .offset(pos as isize) = '=' as i32 as libc::c_char;
                    }
                    1 => {
                        *((*(*yymsp.offset(0 as libc::c_int as isize)).minor.yy18)
                            .key
                            .ptr)
                            .offset(pos as isize) = '!' as i32 as libc::c_char;
                    }
                    4 => {
                        *((*(*yymsp.offset(0 as libc::c_int as isize)).minor.yy18)
                            .key
                            .ptr)
                            .offset(pos as isize) = '=' as i32 as libc::c_char;
                    }
                    2 => {
                        *((*(*yymsp.offset(0 as libc::c_int as isize)).minor.yy18)
                            .key
                            .ptr)
                            .offset(pos as isize) = '!' as i32 as libc::c_char;
                    }
                    _ => {
                        if 0 as libc::c_int == 0 {
                            ck_assert_failed(
                                b"/home/kkysen/work/rust/lighttpd/src/configparser.y\0" as *const u8
                                    as *const libc::c_char,
                                627 as libc::c_int as libc::c_uint,
                                b"0\0" as *const u8 as *const libc::c_char,
                            );
                        }
                    }
                }
                dc_0 = configparser_get_data_config(
                    (*ctx).all_configs,
                    (*(*yymsp.offset(0 as libc::c_int as isize)).minor.yy18)
                        .key
                        .ptr,
                    buffer_clen(&mut (*(*yymsp.offset(0 as libc::c_int as isize)).minor.yy18).key)
                        as size_t,
                );
                if dc_0.is_null() {
                    array_insert_unique(
                        (*ctx).all_configs,
                        (*yymsp.offset(0 as libc::c_int as isize)).minor.yy18 as *mut data_unset,
                    );
                    let ref mut fresh120 =
                        (*(*yymsp.offset(0 as libc::c_int as isize)).minor.yy18).prev;
                    *fresh120 = (*yymsp.offset(-(3 as libc::c_int) as isize)).minor.yy18;
                    let ref mut fresh121 =
                        (*(*yymsp.offset(-(3 as libc::c_int) as isize)).minor.yy18).next;
                    *fresh121 = (*yymsp.offset(0 as libc::c_int as isize)).minor.yy18;
                } else {
                    fprintf(
                        stderr,
                        b"unreachable else condition\n\0" as *const u8 as *const libc::c_char,
                    );
                    (*ctx).ok = 0 as libc::c_int;
                    ((*(*(*yymsp.offset(0 as libc::c_int as isize)).minor.yy18).fn_0).free)
                        .expect("non-null function pointer")(
                        (*yymsp.offset(0 as libc::c_int as isize)).minor.yy18 as *mut data_unset,
                    );
                    let ref mut fresh122 = (*yymsp.offset(0 as libc::c_int as isize)).minor.yy18;
                    *fresh122 = dc_0;
                }
                yygotominor.yy18 = (*yymsp.offset(0 as libc::c_int as isize)).minor.yy18;
            }
            let ref mut fresh123 = (*yymsp.offset(-(3 as libc::c_int) as isize)).minor.yy18;
            *fresh123 = 0 as *mut data_config;
            let ref mut fresh124 = (*yymsp.offset(0 as libc::c_int as isize)).minor.yy18;
            *fresh124 = 0 as *mut data_config;
            yy_destructor(
                16 as libc::c_int as libc::c_uchar,
                &mut (*yymsp.offset(-(1 as libc::c_int) as isize)).minor,
            );
        }
        32 => {
            yygotominor.yy18 = (*yymsp.offset(0 as libc::c_int as isize)).minor.yy18;
            let ref mut fresh125 = (*yymsp.offset(0 as libc::c_int as isize)).minor.yy18;
            *fresh125 = 0 as *mut data_config;
        }
        33 => {
            yygotominor.yy18 = 0 as *mut data_config;
            if (*ctx).ok != 0 {
                let mut cur: *mut data_config = 0 as *mut data_config;
                cur = (*ctx).current;
                configparser_pop(ctx);
                if !(!cur.is_null() && !((*ctx).current).is_null()) {
                    ck_assert_failed(
                        b"/home/kkysen/work/rust/lighttpd/src/configparser.y\0" as *const u8
                            as *const libc::c_char,
                        661 as libc::c_int as libc::c_uint,
                        b"cur && ctx->current\0" as *const u8 as *const libc::c_char,
                    );
                }
                yygotominor.yy18 = cur;
            }
            yy_destructor(
                14 as libc::c_int as libc::c_uchar,
                &mut (*yymsp.offset(-(2 as libc::c_int) as isize)).minor,
            );
            yy_destructor(
                15 as libc::c_int as libc::c_uchar,
                &mut (*yymsp.offset(0 as libc::c_int as isize)).minor,
            );
        }
        34 => {
            yygotominor.yy18 = 0 as *mut data_config;
            if (*ctx).ok != 0 {
                let mut cur_0: *mut data_config = 0 as *mut data_config;
                cur_0 = (*ctx).current;
                configparser_pop(ctx);
                if !(!cur_0.is_null() && !((*ctx).current).is_null()) {
                    ck_assert_failed(
                        b"/home/kkysen/work/rust/lighttpd/src/configparser.y\0" as *const u8
                            as *const libc::c_char,
                        675 as libc::c_int as libc::c_uint,
                        b"cur && ctx->current\0" as *const u8 as *const libc::c_char,
                    );
                }
                yygotominor.yy18 = cur_0;
            }
            yy_destructor(
                14 as libc::c_int as libc::c_uchar,
                &mut (*yymsp.offset(-(2 as libc::c_int) as isize)).minor,
            );
            yy_destructor(
                15 as libc::c_int as libc::c_uchar,
                &mut (*yymsp.offset(0 as libc::c_int as isize)).minor,
            );
        }
        35 => {
            if (*ctx).ok != 0
                && (*(*yymsp.offset(0 as libc::c_int as isize)).minor.yy91).type_0 as libc::c_uint
                    != TYPE_STRING as libc::c_int as libc::c_uint
            {
                fprintf(
                    stderr,
                    b"rvalue must be string\0" as *const u8 as *const libc::c_char,
                );
                (*ctx).ok = 0 as libc::c_int;
            }
            if (*ctx).ok != 0 {
                configparser_parse_condition(
                    ctx,
                    (*yymsp.offset(-(5 as libc::c_int) as isize)).minor.yy0,
                    (*yymsp.offset(-(3 as libc::c_int) as isize)).minor.yy29,
                    (*yymsp.offset(-(1 as libc::c_int) as isize)).minor.yy53,
                    &mut (*((*yymsp.offset(0 as libc::c_int as isize)).minor.yy91
                        as *mut data_string))
                        .value,
                );
            }
            buffer_free((*yymsp.offset(-(5 as libc::c_int) as isize)).minor.yy0);
            let ref mut fresh126 = (*yymsp.offset(-(5 as libc::c_int) as isize)).minor.yy0;
            *fresh126 = 0 as *mut buffer;
            buffer_free((*yymsp.offset(-(3 as libc::c_int) as isize)).minor.yy29);
            let ref mut fresh127 = (*yymsp.offset(-(3 as libc::c_int) as isize)).minor.yy29;
            *fresh127 = 0 as *mut buffer;
            ((*(*(*yymsp.offset(0 as libc::c_int as isize)).minor.yy91).fn_0).free)
                .expect("non-null function pointer")(
                (*yymsp.offset(0 as libc::c_int as isize)).minor.yy91,
            );
            let ref mut fresh128 = (*yymsp.offset(0 as libc::c_int as isize)).minor.yy91;
            *fresh128 = 0 as *mut data_unset;
            yy_destructor(
                17 as libc::c_int as libc::c_uchar,
                &mut (*yymsp.offset(-(6 as libc::c_int) as isize)).minor,
            );
            yy_destructor(
                19 as libc::c_int as libc::c_uchar,
                &mut (*yymsp.offset(-(4 as libc::c_int) as isize)).minor,
            );
            yy_destructor(
                20 as libc::c_int as libc::c_uchar,
                &mut (*yymsp.offset(-(2 as libc::c_int) as isize)).minor,
            );
        }
        36 => {
            if (*ctx).ok != 0 {
                configparser_parse_else_condition(ctx);
            }
        }
        37 => {
            yygotominor.yy53 = CONFIG_COND_EQ;
            yy_destructor(
                21 as libc::c_int as libc::c_uchar,
                &mut (*yymsp.offset(0 as libc::c_int as isize)).minor,
            );
        }
        38 => {
            yygotominor.yy53 = CONFIG_COND_MATCH;
            yy_destructor(
                22 as libc::c_int as libc::c_uchar,
                &mut (*yymsp.offset(0 as libc::c_int as isize)).minor,
            );
        }
        39 => {
            yygotominor.yy53 = CONFIG_COND_NE;
            yy_destructor(
                23 as libc::c_int as libc::c_uchar,
                &mut (*yymsp.offset(0 as libc::c_int as isize)).minor,
            );
        }
        40 => {
            yygotominor.yy53 = CONFIG_COND_NOMATCH;
            yy_destructor(
                24 as libc::c_int as libc::c_uchar,
                &mut (*yymsp.offset(0 as libc::c_int as isize)).minor,
            );
        }
        41 => {
            yygotominor.yy29 = 0 as *mut buffer;
            if (*ctx).ok != 0 {
                if (*(*yymsp.offset(0 as libc::c_int as isize)).minor.yy91).type_0 as libc::c_uint
                    == TYPE_STRING as libc::c_int as libc::c_uint
                {
                    yygotominor.yy29 = buffer_init();
                    buffer_copy_buffer(
                        yygotominor.yy29,
                        &mut (*((*yymsp.offset(0 as libc::c_int as isize)).minor.yy91
                            as *mut data_string))
                            .value,
                    );
                } else if (*(*yymsp.offset(0 as libc::c_int as isize)).minor.yy91).type_0
                    as libc::c_uint
                    == TYPE_INTEGER as libc::c_int as libc::c_uint
                {
                    yygotominor.yy29 = buffer_init();
                    buffer_append_int(
                        yygotominor.yy29,
                        (*((*yymsp.offset(0 as libc::c_int as isize)).minor.yy91
                            as *mut data_integer))
                            .value as intmax_t,
                    );
                } else {
                    fprintf(
                        stderr,
                        b"operand must be string\0" as *const u8 as *const libc::c_char,
                    );
                    (*ctx).ok = 0 as libc::c_int;
                }
            }
            if !((*yymsp.offset(0 as libc::c_int as isize)).minor.yy91).is_null() {
                ((*(*(*yymsp.offset(0 as libc::c_int as isize)).minor.yy91).fn_0).free)
                    .expect("non-null function pointer")(
                    (*yymsp.offset(0 as libc::c_int as isize)).minor.yy91,
                );
            }
            let ref mut fresh129 = (*yymsp.offset(0 as libc::c_int as isize)).minor.yy91;
            *fresh129 = 0 as *mut data_unset;
        }
        42 => {
            if (*ctx).ok != 0 {
                if 0 as libc::c_int
                    != config_parse_file(
                        (*ctx).srv,
                        ctx,
                        (*(*yymsp.offset(0 as libc::c_int as isize)).minor.yy29).ptr,
                    )
                {
                    (*ctx).ok = 0 as libc::c_int;
                }
            }
            buffer_free((*yymsp.offset(0 as libc::c_int as isize)).minor.yy29);
            let ref mut fresh130 = (*yymsp.offset(0 as libc::c_int as isize)).minor.yy29;
            *fresh130 = 0 as *mut buffer;
            yy_destructor(
                25 as libc::c_int as libc::c_uchar,
                &mut (*yymsp.offset(-(1 as libc::c_int) as isize)).minor,
            );
        }
        43 => {
            if (*ctx).ok != 0 {
                if 0 as libc::c_int
                    != config_parse_cmd(
                        (*ctx).srv,
                        ctx,
                        (*(*yymsp.offset(0 as libc::c_int as isize)).minor.yy29).ptr,
                    )
                {
                    (*ctx).ok = 0 as libc::c_int;
                }
            }
            buffer_free((*yymsp.offset(0 as libc::c_int as isize)).minor.yy29);
            let ref mut fresh131 = (*yymsp.offset(0 as libc::c_int as isize)).minor.yy29;
            *fresh131 = 0 as *mut buffer;
            yy_destructor(
                26 as libc::c_int as libc::c_uchar,
                &mut (*yymsp.offset(-(1 as libc::c_int) as isize)).minor,
            );
        }
        0 | 1 | 2 | 3 | 4 | 6 | 7 | 27 | _ => {}
    }
    yygoto = yyRuleInfo[yyruleno as usize].lhs as libc::c_int;
    yysize = yyRuleInfo[yyruleno as usize].nrhs as libc::c_int;
    (*yypParser).yyidx -= yysize;
    yyact = yy_find_reduce_action(yypParser, yygoto);
    if yyact < 70 as libc::c_int {
        yy_shift(yypParser, yyact, yygoto, &mut yygotominor);
    } else if yyact == 70 as libc::c_int + 44 as libc::c_int + 1 as libc::c_int {
        yy_accept(yypParser);
    }
}
unsafe extern "C" fn yy_parse_failed(mut yypParser: *mut yyParser) {
    let mut ctx: *mut config_t = (*yypParser).ctx;
    while (*yypParser).yyidx >= 0 as libc::c_int {
        yy_pop_parser_stack(yypParser);
    }
    (*ctx).ok = 0 as libc::c_int;
    (*yypParser).ctx = ctx;
}
unsafe extern "C" fn yy_syntax_error(
    mut yypParser: *mut yyParser,
    mut yymajor: libc::c_int,
    mut yyminor: YYMINORTYPE,
) {
    let mut ctx: *mut config_t = (*yypParser).ctx;
    (*yypParser).ctx = ctx;
}
unsafe extern "C" fn yy_accept(mut yypParser: *mut yyParser) {
    let mut ctx: *mut config_t = (*yypParser).ctx;
    while (*yypParser).yyidx >= 0 as libc::c_int {
        yy_pop_parser_stack(yypParser);
    }
    (*yypParser).ctx = ctx;
}
#[no_mangle]
#[cold]
pub unsafe extern "C" fn configparser(
    mut yyp: *mut libc::c_void,
    mut yymajor: libc::c_int,
    mut yyminor: *mut buffer,
    mut ctx: *mut config_t,
) {
    let mut yyminorunion: YYMINORTYPE = YYMINORTYPE {
        yy0: 0 as *mut buffer,
    };
    let mut yyact: libc::c_int = 0;
    let mut yyendofinput: libc::c_int = 0;
    let mut yyerrorhit: libc::c_int = 0 as libc::c_int;
    let mut yypParser: *mut yyParser = 0 as *mut yyParser;
    yypParser = yyp as *mut yyParser;
    if (*yypParser).yyidx < 0 as libc::c_int {
        if yymajor == 0 as libc::c_int {
            return;
        }
        (*yypParser).yyidx = 0 as libc::c_int;
        (*yypParser).yyerrcnt = -(1 as libc::c_int);
        (*yypParser).yystack[0 as libc::c_int as usize].stateno = 0 as libc::c_int;
        (*yypParser).yystack[0 as libc::c_int as usize].major = 0 as libc::c_int;
    }
    yyminorunion.yy0 = yyminor;
    yyendofinput = (yymajor == 0 as libc::c_int) as libc::c_int;
    (*yypParser).ctx = ctx;
    loop {
        yyact = yy_find_shift_action(yypParser, yymajor);
        if yyact < 70 as libc::c_int {
            yy_shift(yypParser, yyact, yymajor, &mut yyminorunion);
            (*yypParser).yyerrcnt -= 1;
            if yyendofinput != 0 && (*yypParser).yyidx >= 0 as libc::c_int {
                yymajor = 0 as libc::c_int;
            } else {
                yymajor = 51 as libc::c_int;
            }
        } else if yyact < 70 as libc::c_int + 44 as libc::c_int {
            yy_reduce(yypParser, yyact - 70 as libc::c_int);
        } else if yyact == 70 as libc::c_int + 44 as libc::c_int {
            let mut yymx: libc::c_int = 0;
            if (*yypParser).yyerrcnt < 0 as libc::c_int {
                yy_syntax_error(yypParser, yymajor, yyminorunion);
            }
            yymx = (*yypParser).yystack[(*yypParser).yyidx as usize].major;
            if yymx == 27 as libc::c_int || yyerrorhit != 0 {
                yy_destructor(yymajor as libc::c_uchar, &mut yyminorunion);
                yymajor = 51 as libc::c_int;
            } else {
                while (*yypParser).yyidx >= 0 as libc::c_int && yymx != 27 as libc::c_int && {
                    yyact = yy_find_shift_action(yypParser, 27 as libc::c_int);
                    yyact >= 70 as libc::c_int
                } {
                    yy_pop_parser_stack(yypParser);
                }
                if (*yypParser).yyidx < 0 as libc::c_int || yymajor == 0 as libc::c_int {
                    yy_destructor(yymajor as libc::c_uchar, &mut yyminorunion);
                    yy_parse_failed(yypParser);
                    yymajor = 51 as libc::c_int;
                } else if yymx != 27 as libc::c_int {
                    let mut u2: YYMINORTYPE = YYMINORTYPE {
                        yy0: 0 as *mut buffer,
                    };
                    u2.yy101 = 0 as libc::c_int;
                    yy_shift(yypParser, yyact, 27 as libc::c_int, &mut u2);
                }
            }
            (*yypParser).yyerrcnt = 3 as libc::c_int;
            yyerrorhit = 1 as libc::c_int;
        } else {
            yy_accept(yypParser);
            yymajor = 51 as libc::c_int;
        }
        if !(yymajor != 51 as libc::c_int && (*yypParser).yyidx >= 0 as libc::c_int) {
            break;
        }
    }
}
static mut base64_standard_table: [libc::c_char; 66] = unsafe {
    *::core::mem::transmute::<&[u8; 66], &[libc::c_char; 66]>(
        b"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=\0",
    )
};
static mut base64_standard_reverse_table: [libc::c_schar; 128] = [
    -(1 as libc::c_int) as libc::c_schar,
    -(2 as libc::c_int) as libc::c_schar,
    -(2 as libc::c_int) as libc::c_schar,
    -(2 as libc::c_int) as libc::c_schar,
    -(2 as libc::c_int) as libc::c_schar,
    -(2 as libc::c_int) as libc::c_schar,
    -(2 as libc::c_int) as libc::c_schar,
    -(2 as libc::c_int) as libc::c_schar,
    -(2 as libc::c_int) as libc::c_schar,
    -(2 as libc::c_int) as libc::c_schar,
    -(2 as libc::c_int) as libc::c_schar,
    -(2 as libc::c_int) as libc::c_schar,
    -(2 as libc::c_int) as libc::c_schar,
    -(2 as libc::c_int) as libc::c_schar,
    -(2 as libc::c_int) as libc::c_schar,
    -(2 as libc::c_int) as libc::c_schar,
    -(2 as libc::c_int) as libc::c_schar,
    -(2 as libc::c_int) as libc::c_schar,
    -(2 as libc::c_int) as libc::c_schar,
    -(2 as libc::c_int) as libc::c_schar,
    -(2 as libc::c_int) as libc::c_schar,
    -(2 as libc::c_int) as libc::c_schar,
    -(2 as libc::c_int) as libc::c_schar,
    -(2 as libc::c_int) as libc::c_schar,
    -(2 as libc::c_int) as libc::c_schar,
    -(2 as libc::c_int) as libc::c_schar,
    -(2 as libc::c_int) as libc::c_schar,
    -(2 as libc::c_int) as libc::c_schar,
    -(2 as libc::c_int) as libc::c_schar,
    -(2 as libc::c_int) as libc::c_schar,
    -(2 as libc::c_int) as libc::c_schar,
    -(2 as libc::c_int) as libc::c_schar,
    -(2 as libc::c_int) as libc::c_schar,
    -(1 as libc::c_int) as libc::c_schar,
    -(1 as libc::c_int) as libc::c_schar,
    -(1 as libc::c_int) as libc::c_schar,
    -(1 as libc::c_int) as libc::c_schar,
    -(1 as libc::c_int) as libc::c_schar,
    -(1 as libc::c_int) as libc::c_schar,
    -(1 as libc::c_int) as libc::c_schar,
    -(1 as libc::c_int) as libc::c_schar,
    -(1 as libc::c_int) as libc::c_schar,
    -(1 as libc::c_int) as libc::c_schar,
    62 as libc::c_int as libc::c_schar,
    -(1 as libc::c_int) as libc::c_schar,
    -(1 as libc::c_int) as libc::c_schar,
    -(1 as libc::c_int) as libc::c_schar,
    63 as libc::c_int as libc::c_schar,
    52 as libc::c_int as libc::c_schar,
    53 as libc::c_int as libc::c_schar,
    54 as libc::c_int as libc::c_schar,
    55 as libc::c_int as libc::c_schar,
    56 as libc::c_int as libc::c_schar,
    57 as libc::c_int as libc::c_schar,
    58 as libc::c_int as libc::c_schar,
    59 as libc::c_int as libc::c_schar,
    60 as libc::c_int as libc::c_schar,
    61 as libc::c_int as libc::c_schar,
    -(1 as libc::c_int) as libc::c_schar,
    -(1 as libc::c_int) as libc::c_schar,
    -(1 as libc::c_int) as libc::c_schar,
    -(3 as libc::c_int) as libc::c_schar,
    -(1 as libc::c_int) as libc::c_schar,
    -(1 as libc::c_int) as libc::c_schar,
    -(1 as libc::c_int) as libc::c_schar,
    0 as libc::c_int as libc::c_schar,
    1 as libc::c_int as libc::c_schar,
    2 as libc::c_int as libc::c_schar,
    3 as libc::c_int as libc::c_schar,
    4 as libc::c_int as libc::c_schar,
    5 as libc::c_int as libc::c_schar,
    6 as libc::c_int as libc::c_schar,
    7 as libc::c_int as libc::c_schar,
    8 as libc::c_int as libc::c_schar,
    9 as libc::c_int as libc::c_schar,
    10 as libc::c_int as libc::c_schar,
    11 as libc::c_int as libc::c_schar,
    12 as libc::c_int as libc::c_schar,
    13 as libc::c_int as libc::c_schar,
    14 as libc::c_int as libc::c_schar,
    15 as libc::c_int as libc::c_schar,
    16 as libc::c_int as libc::c_schar,
    17 as libc::c_int as libc::c_schar,
    18 as libc::c_int as libc::c_schar,
    19 as libc::c_int as libc::c_schar,
    20 as libc::c_int as libc::c_schar,
    21 as libc::c_int as libc::c_schar,
    22 as libc::c_int as libc::c_schar,
    23 as libc::c_int as libc::c_schar,
    24 as libc::c_int as libc::c_schar,
    25 as libc::c_int as libc::c_schar,
    -(1 as libc::c_int) as libc::c_schar,
    -(1 as libc::c_int) as libc::c_schar,
    -(1 as libc::c_int) as libc::c_schar,
    -(1 as libc::c_int) as libc::c_schar,
    -(1 as libc::c_int) as libc::c_schar,
    -(1 as libc::c_int) as libc::c_schar,
    26 as libc::c_int as libc::c_schar,
    27 as libc::c_int as libc::c_schar,
    28 as libc::c_int as libc::c_schar,
    29 as libc::c_int as libc::c_schar,
    30 as libc::c_int as libc::c_schar,
    31 as libc::c_int as libc::c_schar,
    32 as libc::c_int as libc::c_schar,
    33 as libc::c_int as libc::c_schar,
    34 as libc::c_int as libc::c_schar,
    35 as libc::c_int as libc::c_schar,
    36 as libc::c_int as libc::c_schar,
    37 as libc::c_int as libc::c_schar,
    38 as libc::c_int as libc::c_schar,
    39 as libc::c_int as libc::c_schar,
    40 as libc::c_int as libc::c_schar,
    41 as libc::c_int as libc::c_schar,
    42 as libc::c_int as libc::c_schar,
    43 as libc::c_int as libc::c_schar,
    44 as libc::c_int as libc::c_schar,
    45 as libc::c_int as libc::c_schar,
    46 as libc::c_int as libc::c_schar,
    47 as libc::c_int as libc::c_schar,
    48 as libc::c_int as libc::c_schar,
    49 as libc::c_int as libc::c_schar,
    50 as libc::c_int as libc::c_schar,
    51 as libc::c_int as libc::c_schar,
    -(1 as libc::c_int) as libc::c_schar,
    -(1 as libc::c_int) as libc::c_schar,
    -(1 as libc::c_int) as libc::c_schar,
    -(1 as libc::c_int) as libc::c_schar,
    -(1 as libc::c_int) as libc::c_schar,
];
static mut base64_url_table: [libc::c_char; 66] = unsafe {
    *::core::mem::transmute::<&[u8; 66], &[libc::c_char; 66]>(
        b"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789-_=\0",
    )
};
static mut base64_url_reverse_table: [libc::c_schar; 128] = [
    -(1 as libc::c_int) as libc::c_schar,
    -(2 as libc::c_int) as libc::c_schar,
    -(2 as libc::c_int) as libc::c_schar,
    -(2 as libc::c_int) as libc::c_schar,
    -(2 as libc::c_int) as libc::c_schar,
    -(2 as libc::c_int) as libc::c_schar,
    -(2 as libc::c_int) as libc::c_schar,
    -(2 as libc::c_int) as libc::c_schar,
    -(2 as libc::c_int) as libc::c_schar,
    -(2 as libc::c_int) as libc::c_schar,
    -(2 as libc::c_int) as libc::c_schar,
    -(2 as libc::c_int) as libc::c_schar,
    -(2 as libc::c_int) as libc::c_schar,
    -(2 as libc::c_int) as libc::c_schar,
    -(2 as libc::c_int) as libc::c_schar,
    -(2 as libc::c_int) as libc::c_schar,
    -(2 as libc::c_int) as libc::c_schar,
    -(2 as libc::c_int) as libc::c_schar,
    -(2 as libc::c_int) as libc::c_schar,
    -(2 as libc::c_int) as libc::c_schar,
    -(2 as libc::c_int) as libc::c_schar,
    -(2 as libc::c_int) as libc::c_schar,
    -(2 as libc::c_int) as libc::c_schar,
    -(2 as libc::c_int) as libc::c_schar,
    -(2 as libc::c_int) as libc::c_schar,
    -(2 as libc::c_int) as libc::c_schar,
    -(2 as libc::c_int) as libc::c_schar,
    -(2 as libc::c_int) as libc::c_schar,
    -(2 as libc::c_int) as libc::c_schar,
    -(2 as libc::c_int) as libc::c_schar,
    -(2 as libc::c_int) as libc::c_schar,
    -(2 as libc::c_int) as libc::c_schar,
    -(2 as libc::c_int) as libc::c_schar,
    -(1 as libc::c_int) as libc::c_schar,
    -(1 as libc::c_int) as libc::c_schar,
    -(1 as libc::c_int) as libc::c_schar,
    -(1 as libc::c_int) as libc::c_schar,
    -(1 as libc::c_int) as libc::c_schar,
    -(1 as libc::c_int) as libc::c_schar,
    -(1 as libc::c_int) as libc::c_schar,
    -(1 as libc::c_int) as libc::c_schar,
    -(1 as libc::c_int) as libc::c_schar,
    -(1 as libc::c_int) as libc::c_schar,
    -(1 as libc::c_int) as libc::c_schar,
    -(1 as libc::c_int) as libc::c_schar,
    62 as libc::c_int as libc::c_schar,
    -(1 as libc::c_int) as libc::c_schar,
    -(1 as libc::c_int) as libc::c_schar,
    52 as libc::c_int as libc::c_schar,
    53 as libc::c_int as libc::c_schar,
    54 as libc::c_int as libc::c_schar,
    55 as libc::c_int as libc::c_schar,
    56 as libc::c_int as libc::c_schar,
    57 as libc::c_int as libc::c_schar,
    58 as libc::c_int as libc::c_schar,
    59 as libc::c_int as libc::c_schar,
    60 as libc::c_int as libc::c_schar,
    61 as libc::c_int as libc::c_schar,
    -(1 as libc::c_int) as libc::c_schar,
    -(1 as libc::c_int) as libc::c_schar,
    -(1 as libc::c_int) as libc::c_schar,
    -(3 as libc::c_int) as libc::c_schar,
    -(1 as libc::c_int) as libc::c_schar,
    -(1 as libc::c_int) as libc::c_schar,
    -(1 as libc::c_int) as libc::c_schar,
    0 as libc::c_int as libc::c_schar,
    1 as libc::c_int as libc::c_schar,
    2 as libc::c_int as libc::c_schar,
    3 as libc::c_int as libc::c_schar,
    4 as libc::c_int as libc::c_schar,
    5 as libc::c_int as libc::c_schar,
    6 as libc::c_int as libc::c_schar,
    7 as libc::c_int as libc::c_schar,
    8 as libc::c_int as libc::c_schar,
    9 as libc::c_int as libc::c_schar,
    10 as libc::c_int as libc::c_schar,
    11 as libc::c_int as libc::c_schar,
    12 as libc::c_int as libc::c_schar,
    13 as libc::c_int as libc::c_schar,
    14 as libc::c_int as libc::c_schar,
    15 as libc::c_int as libc::c_schar,
    16 as libc::c_int as libc::c_schar,
    17 as libc::c_int as libc::c_schar,
    18 as libc::c_int as libc::c_schar,
    19 as libc::c_int as libc::c_schar,
    20 as libc::c_int as libc::c_schar,
    21 as libc::c_int as libc::c_schar,
    22 as libc::c_int as libc::c_schar,
    23 as libc::c_int as libc::c_schar,
    24 as libc::c_int as libc::c_schar,
    25 as libc::c_int as libc::c_schar,
    -(1 as libc::c_int) as libc::c_schar,
    -(1 as libc::c_int) as libc::c_schar,
    -(1 as libc::c_int) as libc::c_schar,
    -(1 as libc::c_int) as libc::c_schar,
    63 as libc::c_int as libc::c_schar,
    -(1 as libc::c_int) as libc::c_schar,
    26 as libc::c_int as libc::c_schar,
    27 as libc::c_int as libc::c_schar,
    28 as libc::c_int as libc::c_schar,
    29 as libc::c_int as libc::c_schar,
    30 as libc::c_int as libc::c_schar,
    31 as libc::c_int as libc::c_schar,
    32 as libc::c_int as libc::c_schar,
    33 as libc::c_int as libc::c_schar,
    34 as libc::c_int as libc::c_schar,
    35 as libc::c_int as libc::c_schar,
    36 as libc::c_int as libc::c_schar,
    37 as libc::c_int as libc::c_schar,
    38 as libc::c_int as libc::c_schar,
    39 as libc::c_int as libc::c_schar,
    40 as libc::c_int as libc::c_schar,
    41 as libc::c_int as libc::c_schar,
    42 as libc::c_int as libc::c_schar,
    43 as libc::c_int as libc::c_schar,
    44 as libc::c_int as libc::c_schar,
    45 as libc::c_int as libc::c_schar,
    46 as libc::c_int as libc::c_schar,
    47 as libc::c_int as libc::c_schar,
    48 as libc::c_int as libc::c_schar,
    49 as libc::c_int as libc::c_schar,
    50 as libc::c_int as libc::c_schar,
    51 as libc::c_int as libc::c_schar,
    -(1 as libc::c_int) as libc::c_schar,
    -(1 as libc::c_int) as libc::c_schar,
    -(1 as libc::c_int) as libc::c_schar,
    -(1 as libc::c_int) as libc::c_schar,
    -(1 as libc::c_int) as libc::c_schar,
];
#[no_mangle]
pub unsafe extern "C" fn li_base64_dec(
    result: *mut libc::c_uchar,
    out_length: size_t,
    in_0: *const libc::c_char,
    in_length: size_t,
    charset: base64_charset,
) -> size_t {
    let mut i: size_t = 0;
    let base64_reverse_table: *const libc::c_schar = if charset as libc::c_uint != 0 {
        base64_url_reverse_table.as_ptr()
    } else {
        base64_standard_reverse_table.as_ptr()
    };
    let mut ch: int_fast32_t = 0 as libc::c_int as int_fast32_t;
    let mut out4: int_fast32_t = 0 as libc::c_int as int_fast32_t;
    let mut out_pos: size_t = 0 as libc::c_int as size_t;
    i = 0 as libc::c_int as size_t;
    while i < in_length {
        let c: uint_fast32_t = *(in_0 as *mut libc::c_uchar).offset(i as isize) as uint_fast32_t;
        ch = (if c < 128 as libc::c_int as libc::c_ulong {
            *base64_reverse_table.offset(c as isize) as libc::c_int
        } else {
            -(1 as libc::c_int)
        }) as int_fast32_t;
        if (ch < 0 as libc::c_int as libc::c_long) as libc::c_int as libc::c_long != 0 {
            if !(-(2 as libc::c_int) as libc::c_long == ch) {
                break;
            }
        } else {
            out4 = out4 << 6 as libc::c_int | ch;
            if i & 3 as libc::c_int as libc::c_ulong == 3 as libc::c_int as libc::c_ulong {
                *result.offset(out_pos as isize) = (out4 >> 16 as libc::c_int
                    & 0xff as libc::c_int as libc::c_long)
                    as libc::c_uchar;
                *result.offset(out_pos.wrapping_add(1 as libc::c_int as libc::c_ulong) as isize) =
                    (out4 >> 8 as libc::c_int & 0xff as libc::c_int as libc::c_long)
                        as libc::c_uchar;
                *result.offset(out_pos.wrapping_add(2 as libc::c_int as libc::c_ulong) as isize) =
                    (out4 & 0xff as libc::c_int as libc::c_long) as libc::c_uchar;
                out_pos = (out_pos as libc::c_ulong).wrapping_add(3 as libc::c_int as libc::c_ulong)
                    as size_t as size_t;
                out4 = 0 as libc::c_int as int_fast32_t;
            }
        }
        i = i.wrapping_add(1);
    }
    let mut current_block_21: u64;
    match if i == in_length
        || ch == -(3 as libc::c_int) as libc::c_long
        || *in_0.offset(i as isize) as libc::c_int != '\0' as i32
    {
        i & 3 as libc::c_int as libc::c_ulong
    } else {
        1 as libc::c_int as libc::c_ulong
    } {
        3 => {
            let fresh132 = out_pos;
            out_pos = out_pos.wrapping_add(1);
            *result.offset(fresh132 as isize) = (out4 >> 10 as libc::c_int) as libc::c_uchar;
            out4 <<= 2 as libc::c_int;
            current_block_21 = 16371176579732069108;
        }
        2 => {
            current_block_21 = 16371176579732069108;
        }
        0 => {
            current_block_21 = 16984829043662763778;
        }
        1 | _ => return 0 as libc::c_int as size_t,
    }
    match current_block_21 {
        16371176579732069108 => {
            let fresh133 = out_pos;
            out_pos = out_pos.wrapping_add(1);
            *result.offset(fresh133 as isize) =
                (out4 >> 4 as libc::c_int & 0xff as libc::c_int as libc::c_long) as libc::c_uchar;
        }
        _ => {}
    }
    if !(out_pos <= out_length) {
        ck_assert_failed(
            b"/home/kkysen/work/rust/lighttpd/src/base64.c\0" as *const u8 as *const libc::c_char,
            81 as libc::c_int as libc::c_uint,
            b"out_pos <= out_length\0" as *const u8 as *const libc::c_char,
        );
    }
    return out_pos;
}
#[no_mangle]
pub unsafe extern "C" fn li_base64_enc(
    out: *mut libc::c_char,
    out_length: size_t,
    in_0: *const libc::c_uchar,
    in_length: size_t,
    charset: base64_charset,
    pad: libc::c_int,
) -> size_t {
    let mut i: size_t = 0;
    let mut out_pos: size_t = 0 as libc::c_int as size_t;
    let mut v: uint_fast32_t = 0;
    let base64_table: *const libc::c_char = if charset as libc::c_uint != 0 {
        base64_url_table.as_ptr()
    } else {
        base64_standard_table.as_ptr()
    };
    let padchar: libc::c_char = *base64_table.offset(64 as libc::c_int as isize);
    if !(in_length <= 3221225469 as libc::c_long as libc::c_ulong) {
        ck_assert_failed(
            b"/home/kkysen/work/rust/lighttpd/src/base64.c\0" as *const u8 as *const libc::c_char,
            101 as libc::c_int as libc::c_uint,
            b"in_length <= 3221225469\0" as *const u8 as *const libc::c_char,
        );
    }
    if !(in_length
        .wrapping_add(2 as libc::c_int as libc::c_ulong)
        .wrapping_div(3 as libc::c_int as libc::c_ulong)
        .wrapping_mul(4 as libc::c_int as libc::c_ulong)
        <= out_length)
    {
        ck_assert_failed(
            b"/home/kkysen/work/rust/lighttpd/src/base64.c\0" as *const u8 as *const libc::c_char,
            102 as libc::c_int as libc::c_uint,
            b"(in_length+2)/3*4 <= out_length\0" as *const u8 as *const libc::c_char,
        );
    }
    i = 2 as libc::c_int as size_t;
    while i < in_length {
        v = ((*in_0.offset(i.wrapping_sub(2 as libc::c_int as libc::c_ulong) as isize)
            as libc::c_int)
            << 16 as libc::c_int
            | (*in_0.offset(i.wrapping_sub(1 as libc::c_int as libc::c_ulong) as isize)
                as libc::c_int)
                << 8 as libc::c_int
            | *in_0.offset(i as isize) as libc::c_int) as uint_fast32_t;
        *out.offset(out_pos.wrapping_add(0 as libc::c_int as libc::c_ulong) as isize) =
            *base64_table
                .offset((v >> 18 as libc::c_int & 0x3f as libc::c_int as libc::c_ulong) as isize);
        *out.offset(out_pos.wrapping_add(1 as libc::c_int as libc::c_ulong) as isize) =
            *base64_table
                .offset((v >> 12 as libc::c_int & 0x3f as libc::c_int as libc::c_ulong) as isize);
        *out.offset(out_pos.wrapping_add(2 as libc::c_int as libc::c_ulong) as isize) =
            *base64_table
                .offset((v >> 6 as libc::c_int & 0x3f as libc::c_int as libc::c_ulong) as isize);
        *out.offset(out_pos.wrapping_add(3 as libc::c_int as libc::c_ulong) as isize) =
            *base64_table.offset((v & 0x3f as libc::c_int as libc::c_ulong) as isize);
        out_pos = (out_pos as libc::c_ulong).wrapping_add(4 as libc::c_int as libc::c_ulong)
            as size_t as size_t;
        i = (i as libc::c_ulong).wrapping_add(3 as libc::c_int as libc::c_ulong) as size_t
            as size_t;
    }
    match in_length.wrapping_sub(i.wrapping_sub(2 as libc::c_int as libc::c_ulong)) {
        1 => {
            v = ((*in_0.offset(i.wrapping_sub(2 as libc::c_int as libc::c_ulong) as isize)
                as libc::c_int)
                << 4 as libc::c_int) as uint_fast32_t;
            *out.offset(out_pos.wrapping_add(0 as libc::c_int as libc::c_ulong) as isize) =
                *base64_table.offset(
                    (v >> 6 as libc::c_int & 0x3f as libc::c_int as libc::c_ulong) as isize,
                );
            *out.offset(out_pos.wrapping_add(1 as libc::c_int as libc::c_ulong) as isize) =
                *base64_table.offset((v & 0x3f as libc::c_int as libc::c_ulong) as isize);
            if pad != 0 {
                let ref mut fresh134 =
                    *out.offset(out_pos.wrapping_add(3 as libc::c_int as libc::c_ulong) as isize);
                *fresh134 = padchar;
                *out.offset(out_pos.wrapping_add(2 as libc::c_int as libc::c_ulong) as isize) =
                    *fresh134;
                out_pos = (out_pos as libc::c_ulong).wrapping_add(4 as libc::c_int as libc::c_ulong)
                    as size_t as size_t;
            } else {
                out_pos = (out_pos as libc::c_ulong).wrapping_add(2 as libc::c_int as libc::c_ulong)
                    as size_t as size_t;
            }
        }
        2 => {
            v = ((*in_0.offset(i.wrapping_sub(2 as libc::c_int as libc::c_ulong) as isize)
                as libc::c_int)
                << 10 as libc::c_int
                | (*in_0.offset(i.wrapping_sub(1 as libc::c_int as libc::c_ulong) as isize)
                    as libc::c_int)
                    << 2 as libc::c_int) as uint_fast32_t;
            *out.offset(out_pos.wrapping_add(0 as libc::c_int as libc::c_ulong) as isize) =
                *base64_table.offset(
                    (v >> 12 as libc::c_int & 0x3f as libc::c_int as libc::c_ulong) as isize,
                );
            *out.offset(out_pos.wrapping_add(1 as libc::c_int as libc::c_ulong) as isize) =
                *base64_table.offset(
                    (v >> 6 as libc::c_int & 0x3f as libc::c_int as libc::c_ulong) as isize,
                );
            *out.offset(out_pos.wrapping_add(2 as libc::c_int as libc::c_ulong) as isize) =
                *base64_table.offset((v & 0x3f as libc::c_int as libc::c_ulong) as isize);
            if pad != 0 {
                *out.offset(out_pos.wrapping_add(3 as libc::c_int as libc::c_ulong) as isize) =
                    padchar;
                out_pos = (out_pos as libc::c_ulong).wrapping_add(4 as libc::c_int as libc::c_ulong)
                    as size_t as size_t;
            } else {
                out_pos = (out_pos as libc::c_ulong).wrapping_add(3 as libc::c_int as libc::c_ulong)
                    as size_t as size_t;
            }
        }
        0 | _ => {}
    }
    return out_pos;
}
#[no_mangle]
pub unsafe extern "C" fn buffer_append_base64_enc(
    mut out: *mut buffer,
    mut in_0: *const libc::c_uchar,
    mut in_length: size_t,
    mut charset: base64_charset,
    mut pad: libc::c_int,
) -> *mut libc::c_char {
    let reserve: size_t = in_length
        .wrapping_add(2 as libc::c_int as libc::c_ulong)
        .wrapping_div(3 as libc::c_int as libc::c_ulong)
        .wrapping_mul(4 as libc::c_int as libc::c_ulong);
    let result: *mut libc::c_char = buffer_string_prepare_append(out, reserve);
    let out_pos: size_t = li_base64_enc(result, reserve, in_0, in_length, charset, pad);
    buffer_commit(out, out_pos);
    return result;
}
#[no_mangle]
pub unsafe extern "C" fn buffer_append_base64_decode(
    mut out: *mut buffer,
    mut in_0: *const libc::c_char,
    mut in_length: size_t,
    mut charset: base64_charset,
) -> *mut libc::c_uchar {
    let reserve: size_t = (3 as libc::c_int as libc::c_ulong)
        .wrapping_mul(in_length.wrapping_div(4 as libc::c_int as libc::c_ulong))
        .wrapping_add(3 as libc::c_int as libc::c_ulong);
    let result: *mut libc::c_uchar =
        buffer_string_prepare_append(out, reserve) as *mut libc::c_uchar;
    let out_pos: size_t = li_base64_dec(result, reserve, in_0, in_length, charset);
    buffer_commit(out, out_pos);
    return if out_pos != 0 || in_length == 0 {
        result
    } else {
        0 as *mut libc::c_uchar
    };
}
static mut hex_chars_lc: [libc::c_char; 17] =
    unsafe { *::core::mem::transmute::<&[u8; 17], &[libc::c_char; 17]>(b"0123456789abcdef\0") };
static mut hex_chars_uc: [libc::c_char; 17] =
    unsafe { *::core::mem::transmute::<&[u8; 17], &[libc::c_char; 17]>(b"0123456789ABCDEF\0") };
#[no_mangle]
#[inline(never)]
pub unsafe extern "C" fn buffer_init() -> *mut buffer {
    let b: *mut buffer = calloc(
        1 as libc::c_int as libc::c_ulong,
        ::core::mem::size_of::<buffer>() as libc::c_ulong,
    ) as *mut buffer;
    if b.is_null() {
        ck_assert_failed(
            b"/home/kkysen/work/rust/lighttpd/src/buffer.c\0" as *const u8 as *const libc::c_char,
            20 as libc::c_int as libc::c_uint,
            b"b\0" as *const u8 as *const libc::c_char,
        );
    }
    return b;
}
#[no_mangle]
pub unsafe extern "C" fn buffer_free(mut b: *mut buffer) {
    if b.is_null() {
        return;
    }
    free((*b).ptr as *mut libc::c_void);
    free(b as *mut libc::c_void);
}
#[no_mangle]
#[cold]
pub unsafe extern "C" fn buffer_free_ptr(mut b: *mut buffer) {
    free((*b).ptr as *mut libc::c_void);
    (*b).ptr = 0 as *mut libc::c_char;
    (*b).used = 0 as libc::c_int as uint32_t;
    (*b).size = 0 as libc::c_int as uint32_t;
}
#[no_mangle]
pub unsafe extern "C" fn buffer_move(mut b: *mut buffer, mut src: *mut buffer) {
    let mut tmp: buffer = buffer {
        ptr: 0 as *const libc::c_char as *mut libc::c_char,
        used: 0,
        size: 0,
    };
    buffer_clear(b);
    tmp = *src;
    *src = *b;
    *b = tmp;
}
#[cold]
#[inline(never)]
unsafe extern "C" fn buffer_realloc(b: *mut buffer, len: size_t) -> *mut libc::c_char {
    let mut sz: size_t = len
        .wrapping_add(1 as libc::c_int as libc::c_ulong)
        .wrapping_add(64 as libc::c_ulong)
        .wrapping_sub(1 as libc::c_int as libc::c_ulong)
        & !(64 as libc::c_ulong).wrapping_sub(1 as libc::c_int as libc::c_ulong);
    if !(sz > len) {
        ck_assert_failed(
            b"/home/kkysen/work/rust/lighttpd/src/buffer.c\0" as *const u8 as *const libc::c_char,
            51 as libc::c_int as libc::c_uint,
            b"sz > len\0" as *const u8 as *const libc::c_char,
        );
    }
    if sz & sz.wrapping_sub(1 as libc::c_int as libc::c_ulong) != 0
        && sz < 2147483647 as libc::c_int as libc::c_ulong
    {
        let psz: size_t = sz;
        sz = 256 as libc::c_int as size_t;
        while sz < psz {
            sz <<= 1 as libc::c_int;
        }
    }
    sz |= 1 as libc::c_int as libc::c_ulong;
    (*b).size = sz as uint32_t;
    (*b).ptr = realloc((*b).ptr as *mut libc::c_void, sz) as *mut libc::c_char;
    if ((*b).ptr).is_null() {
        ck_assert_failed(
            b"/home/kkysen/work/rust/lighttpd/src/buffer.c\0" as *const u8 as *const libc::c_char,
            62 as libc::c_int as libc::c_uint,
            b"((void*)0) != b->ptr\0" as *const u8 as *const libc::c_char,
        );
    }
    return (*b).ptr;
}
#[cold]
#[inline(never)]
unsafe extern "C" fn buffer_alloc_replace(b: *mut buffer, size: size_t) -> *mut libc::c_char {
    if !((*b).ptr).is_null() {
        free((*b).ptr as *mut libc::c_void);
        (*b).ptr = 0 as *mut libc::c_char;
    }
    let bsize2x: size_t = ((*b).size as libc::c_ulong & !(1 as libc::c_ulong)) << 1 as libc::c_int;
    return buffer_realloc(
        b,
        if bsize2x > size {
            bsize2x.wrapping_sub(1 as libc::c_int as libc::c_ulong)
        } else {
            size
        },
    );
}
#[no_mangle]
pub unsafe extern "C" fn buffer_string_prepare_copy(
    b: *mut buffer,
    size: size_t,
) -> *mut libc::c_char {
    (*b).used = 0 as libc::c_int as uint32_t;
    return if size < (*b).size as libc::c_ulong {
        (*b).ptr
    } else {
        buffer_alloc_replace(b, size)
    };
}
#[cold]
#[inline(never)]
unsafe extern "C" fn buffer_string_prepare_append_resize(
    b: *mut buffer,
    size: size_t,
) -> *mut libc::c_char {
    if (*b).used < 2 as libc::c_int as libc::c_uint {
        let s: *mut libc::c_char = buffer_string_prepare_copy(b, size);
        *s = '\0' as i32 as libc::c_char;
        return s;
    }
    let bsize2x: size_t = ((*b).size as libc::c_ulong & !(1 as libc::c_ulong)) << 1 as libc::c_int;
    let req_size: size_t = if bsize2x.wrapping_sub((*b).used as libc::c_ulong) > size {
        bsize2x.wrapping_sub(1 as libc::c_int as libc::c_ulong)
    } else {
        ((*b).used as libc::c_ulong).wrapping_add(size)
    };
    if !(req_size >= (*b).used as libc::c_ulong) {
        ck_assert_failed(
            b"/home/kkysen/work/rust/lighttpd/src/buffer.c\0" as *const u8 as *const libc::c_char,
            110 as libc::c_int as libc::c_uint,
            b"req_size >= b->used\0" as *const u8 as *const libc::c_char,
        );
    }
    return (buffer_realloc(b, req_size))
        .offset((*b).used as isize)
        .offset(-(1 as libc::c_int as isize));
}
#[no_mangle]
pub unsafe extern "C" fn buffer_string_prepare_append(
    b: *mut buffer,
    size: size_t,
) -> *mut libc::c_char {
    let len: uint32_t = if (*b).used != 0 {
        ((*b).used).wrapping_sub(1 as libc::c_int as libc::c_uint)
    } else {
        0 as libc::c_int as libc::c_uint
    };
    return if ((*b).size).wrapping_sub(len) as libc::c_ulong
        >= size.wrapping_add(1 as libc::c_int as libc::c_ulong)
    {
        ((*b).ptr).offset(len as isize)
    } else {
        buffer_string_prepare_append_resize(b, size)
    };
}
#[no_mangle]
#[inline(never)]
pub unsafe extern "C" fn buffer_extend(b: *mut buffer, x: size_t) -> *mut libc::c_char {
    let len: uint32_t = if (*b).used != 0 {
        ((*b).used).wrapping_sub(1 as libc::c_int as libc::c_uint)
    } else {
        0 as libc::c_int as libc::c_uint
    };
    let s: *mut libc::c_char = if ((*b).size).wrapping_sub(len) as libc::c_ulong
        >= x.wrapping_add(1 as libc::c_int as libc::c_ulong)
    {
        ((*b).ptr).offset(len as isize)
    } else {
        buffer_string_prepare_append_resize(b, x)
    };
    (*b).used = (len as libc::c_ulong)
        .wrapping_add(x)
        .wrapping_add(1 as libc::c_int as libc::c_ulong) as uint32_t;
    *s.offset(x as isize) = '\0' as i32 as libc::c_char;
    return s;
}
#[no_mangle]
pub unsafe extern "C" fn buffer_commit(mut b: *mut buffer, mut size: size_t) {
    let mut sz: size_t = (*b).used as size_t;
    if 0 as libc::c_int as libc::c_ulong == sz {
        sz = 1 as libc::c_int as size_t;
    }
    if size > 0 as libc::c_int as libc::c_ulong {
        sz = (sz as libc::c_ulong).wrapping_add(size) as size_t as size_t;
        if !(sz > size) {
            ck_assert_failed(
                b"/home/kkysen/work/rust/lighttpd/src/buffer.c\0" as *const u8
                    as *const libc::c_char,
                153 as libc::c_int as libc::c_uint,
                b"sz > size\0" as *const u8 as *const libc::c_char,
            );
        }
    }
    (*b).used = sz as uint32_t;
    *((*b).ptr).offset(sz.wrapping_sub(1 as libc::c_int as libc::c_ulong) as isize) =
        '\0' as i32 as libc::c_char;
}
#[no_mangle]
#[cold]
pub unsafe extern "C" fn buffer_copy_string(mut b: *mut buffer, mut s: *const libc::c_char) {
    if (0 as *mut libc::c_void as *const libc::c_char == s) as libc::c_int as libc::c_long != 0 {
        s = b"\0" as *const u8 as *const libc::c_char;
    }
    buffer_copy_string_len(b, s, strlen(s));
}
#[no_mangle]
pub unsafe extern "C" fn buffer_copy_string_len(
    b: *mut buffer,
    s: *const libc::c_char,
    len: size_t,
) {
    (*b).used = len.wrapping_add(1 as libc::c_int as libc::c_ulong) as uint32_t;
    let d: *mut libc::c_char = if len < (*b).size as libc::c_ulong {
        (*b).ptr
    } else {
        buffer_alloc_replace(b, len)
    };
    *d.offset(len as isize) = '\0' as i32 as libc::c_char;
    memcpy(d as *mut libc::c_void, s as *const libc::c_void, len);
}
#[no_mangle]
#[cold]
pub unsafe extern "C" fn buffer_append_string(mut b: *mut buffer, mut s: *const libc::c_char) {
    if (0 as *mut libc::c_void as *const libc::c_char == s) as libc::c_int as libc::c_long != 0 {
        s = b"\0" as *const u8 as *const libc::c_char;
    }
    buffer_append_string_len(b, s, strlen(s));
}
#[no_mangle]
pub unsafe extern "C" fn buffer_append_string_len(
    b: *mut buffer,
    s: *const libc::c_char,
    len: size_t,
) {
    memcpy(
        buffer_extend(b, len) as *mut libc::c_void,
        s as *const libc::c_void,
        len,
    );
}
#[no_mangle]
pub unsafe extern "C" fn buffer_append_str2(
    b: *mut buffer,
    s1: *const libc::c_char,
    len1: size_t,
    s2: *const libc::c_char,
    len2: size_t,
) {
    let s: *mut libc::c_char = buffer_extend(b, len1.wrapping_add(len2));
    mempcpy(
        mempcpy(s as *mut libc::c_void, s1 as *const libc::c_void, len1),
        s2 as *const libc::c_void,
        len2,
    );
}
#[no_mangle]
pub unsafe extern "C" fn buffer_append_str3(
    b: *mut buffer,
    s1: *const libc::c_char,
    len1: size_t,
    s2: *const libc::c_char,
    len2: size_t,
    s3: *const libc::c_char,
    len3: size_t,
) {
    let mut s: *mut libc::c_char = buffer_extend(b, len1.wrapping_add(len2).wrapping_add(len3));
    mempcpy(
        mempcpy(
            mempcpy(s as *mut libc::c_void, s1 as *const libc::c_void, len1),
            s2 as *const libc::c_void,
            len2,
        ),
        s3 as *const libc::c_void,
        len3,
    );
}
#[no_mangle]
pub unsafe extern "C" fn buffer_append_iovec(b: *mut buffer, iov: *const const_iovec, n: size_t) {
    let mut len: size_t = 0 as libc::c_int as size_t;
    let mut i: size_t = 0 as libc::c_int as size_t;
    while i < n {
        len = (len as libc::c_ulong).wrapping_add((*iov.offset(i as isize)).iov_len) as size_t
            as size_t;
        i = i.wrapping_add(1);
    }
    let mut s: *mut libc::c_char = buffer_extend(b, len);
    let mut i_0: size_t = 0 as libc::c_int as size_t;
    while i_0 < n {
        if !(0 as libc::c_int as libc::c_ulong == (*iov.offset(i_0 as isize)).iov_len) {
            s = mempcpy(
                s as *mut libc::c_void,
                (*iov.offset(i_0 as isize)).iov_base,
                (*iov.offset(i_0 as isize)).iov_len,
            ) as *mut libc::c_char;
        }
        i_0 = i_0.wrapping_add(1);
    }
}
#[no_mangle]
pub unsafe extern "C" fn buffer_append_path_len(
    mut b: *mut buffer,
    mut a: *const libc::c_char,
    mut alen: size_t,
) {
    let mut s: *mut libc::c_char =
        buffer_string_prepare_append(b, alen.wrapping_add(1 as libc::c_int as libc::c_ulong));
    let aslash: libc::c_int = (alen != 0
        && *a.offset(0 as libc::c_int as isize) as libc::c_int == '/' as i32)
        as libc::c_int;
    if (*b).used > 1 as libc::c_int as libc::c_uint
        && *s.offset(-(1 as libc::c_int) as isize) as libc::c_int == '/' as i32
    {
        if aslash != 0 {
            a = a.offset(1);
            alen = alen.wrapping_sub(1);
        }
    } else {
        if 0 as libc::c_int as libc::c_uint == (*b).used {
            (*b).used = 1 as libc::c_int as uint32_t;
        }
        if aslash == 0 {
            let fresh135 = s;
            s = s.offset(1);
            *fresh135 = '/' as i32 as libc::c_char;
            (*b).used = ((*b).used).wrapping_add(1);
        }
    }
    (*b).used = ((*b).used as libc::c_ulong).wrapping_add(alen) as uint32_t as uint32_t;
    *s.offset(alen as isize) = '\0' as i32 as libc::c_char;
    memcpy(s as *mut libc::c_void, a as *const libc::c_void, alen);
}
#[no_mangle]
pub unsafe extern "C" fn buffer_copy_path_len2(
    b: *mut buffer,
    s1: *const libc::c_char,
    mut len1: size_t,
    s2: *const libc::c_char,
    mut len2: size_t,
) {
    memcpy(
        buffer_string_prepare_copy(
            b,
            len1.wrapping_add(len2)
                .wrapping_add(1 as libc::c_int as libc::c_ulong),
        ) as *mut libc::c_void,
        s1 as *const libc::c_void,
        len1,
    );
    (*b).used = len1.wrapping_add(1 as libc::c_int as libc::c_ulong) as uint32_t;
    buffer_append_path_len(b, s2, len2);
}
#[no_mangle]
pub unsafe extern "C" fn buffer_copy_string_len_lc(
    b: *mut buffer,
    s: *const libc::c_char,
    len: size_t,
) {
    let d: *mut libc::c_char = buffer_string_prepare_copy(b, len);
    (*b).used = len.wrapping_add(1 as libc::c_int as libc::c_ulong) as uint32_t;
    *d.offset(len as isize) = '\0' as i32 as libc::c_char;
    let mut i: size_t = 0 as libc::c_int as size_t;
    while i < len {
        *d.offset(i as isize) = (if !((*s.offset(i as isize) as uint32_t)
            .wrapping_sub('A' as i32 as libc::c_uint)
            <= ('Z' as i32 - 'A' as i32) as libc::c_uint)
        {
            *s.offset(i as isize) as libc::c_int
        } else {
            *s.offset(i as isize) as libc::c_int | 0x20 as libc::c_int
        }) as libc::c_char;
        i = i.wrapping_add(1);
    }
}
#[no_mangle]
pub unsafe extern "C" fn buffer_append_uint_hex_lc(mut b: *mut buffer, mut value: uintmax_t) {
    let mut buf: *mut libc::c_char = 0 as *mut libc::c_char;
    let mut shift: libc::c_uint = 0 as libc::c_int as libc::c_uint;
    let mut copy: uintmax_t = value;
    loop {
        copy >>= 8 as libc::c_int;
        shift = shift.wrapping_add(8 as libc::c_int as libc::c_uint);
        if !(0 as libc::c_int as libc::c_ulong != copy) {
            break;
        }
    }
    buf = buffer_extend(b, (shift >> 2 as libc::c_int) as size_t);
    while shift > 0 as libc::c_int as libc::c_uint {
        shift = shift.wrapping_sub(4 as libc::c_int as libc::c_uint);
        let fresh136 = buf;
        buf = buf.offset(1);
        *fresh136 = hex_chars_lc[(value >> shift & 0xf as libc::c_int as libc::c_ulong) as usize];
    }
}
unsafe extern "C" fn utostr(mut buf: *mut libc::c_char, mut val: uintmax_t) -> *mut libc::c_char {
    let mut cur: *mut libc::c_char = buf.offset(
        (2 as libc::c_int as libc::c_ulong).wrapping_add(
            (8 as libc::c_int as libc::c_ulong)
                .wrapping_mul(::core::mem::size_of::<intmax_t>() as libc::c_ulong)
                .wrapping_mul(31 as libc::c_int as libc::c_ulong)
                .wrapping_add(99 as libc::c_int as libc::c_ulong)
                .wrapping_div(100 as libc::c_int as libc::c_ulong),
        ) as isize,
    );
    let mut x: uintmax_t = 0;
    loop {
        x = val.wrapping_div(10 as libc::c_int as libc::c_ulong);
        cur = cur.offset(-1);
        *cur = ('0' as i32
            + val.wrapping_sub(x.wrapping_mul(10 as libc::c_int as libc::c_ulong)) as libc::c_int)
            as libc::c_char;
        val = x;
        if !(0 as libc::c_int as libc::c_ulong != val) {
            break;
        }
    }
    return cur;
}
unsafe extern "C" fn itostr(mut buf: *mut libc::c_char, mut val: intmax_t) -> *mut libc::c_char {
    let mut uval: uintmax_t = if val >= 0 as libc::c_int as libc::c_long {
        val as uintmax_t
    } else {
        (!val as uintmax_t).wrapping_add(1 as libc::c_int as libc::c_ulong)
    };
    let mut cur: *mut libc::c_char = utostr(buf, uval);
    if val < 0 as libc::c_int as libc::c_long {
        cur = cur.offset(-1);
        *cur = '-' as i32 as libc::c_char;
    }
    return cur;
}
#[no_mangle]
pub unsafe extern "C" fn buffer_append_int(mut b: *mut buffer, mut val: intmax_t) {
    let mut buf: [libc::c_char; 22] = [0; 22];
    let str: *const libc::c_char = itostr(buf.as_mut_ptr(), val);
    buffer_append_string_len(
        b,
        str,
        buf.as_mut_ptr()
            .offset(::core::mem::size_of::<[libc::c_char; 22]>() as libc::c_ulong as isize)
            .offset_from(str) as libc::c_long as size_t,
    );
}
#[no_mangle]
pub unsafe extern "C" fn buffer_append_strftime(
    b: *mut buffer,
    format: *const libc::c_char,
    tm: *const tm,
) {
    if (0 as *mut libc::c_void as *const tm == tm) as libc::c_int as libc::c_long != 0 {
        return;
    }
    let mut rv: size_t = strftime(
        buffer_string_prepare_append(b, 63 as libc::c_int as size_t),
        64 as libc::c_int as size_t,
        format,
        tm,
    );
    if (0 as libc::c_int as libc::c_ulong == rv) as libc::c_int as libc::c_long != 0
        || (rv > 63 as libc::c_int as libc::c_ulong) as libc::c_int as libc::c_long != 0
    {
        rv = strftime(
            buffer_string_prepare_append(b, 4095 as libc::c_int as size_t),
            4096 as libc::c_int as size_t,
            format,
            tm,
        );
        if (rv > 4095 as libc::c_int as libc::c_ulong) as libc::c_int as libc::c_long != 0 {
            return;
        }
    }
    (*b).used = ((*b).used as libc::c_uint).wrapping_add((rv as uint32_t).wrapping_add(
        (0 as libc::c_int as libc::c_uint == (*b).used) as libc::c_int as libc::c_uint,
    )) as uint32_t as uint32_t;
}
#[no_mangle]
pub unsafe extern "C" fn li_itostrn(
    mut buf: *mut libc::c_char,
    mut buf_len: size_t,
    mut val: intmax_t,
) -> size_t {
    let mut p_buf: [libc::c_char; 22] = [0; 22];
    let str: *mut libc::c_char = itostr(p_buf.as_mut_ptr(), val);
    let mut len: size_t = p_buf
        .as_mut_ptr()
        .offset(::core::mem::size_of::<[libc::c_char; 22]>() as libc::c_ulong as isize)
        .offset_from(str) as libc::c_long as size_t;
    if !(len <= buf_len) {
        ck_assert_failed(
            b"/home/kkysen/work/rust/lighttpd/src/buffer.c\0" as *const u8 as *const libc::c_char,
            351 as libc::c_int as libc::c_uint,
            b"len <= buf_len\0" as *const u8 as *const libc::c_char,
        );
    }
    memcpy(buf as *mut libc::c_void, str as *const libc::c_void, len);
    return len;
}
#[no_mangle]
pub unsafe extern "C" fn li_utostrn(
    mut buf: *mut libc::c_char,
    mut buf_len: size_t,
    mut val: uintmax_t,
) -> size_t {
    let mut p_buf: [libc::c_char; 22] = [0; 22];
    let str: *mut libc::c_char = utostr(p_buf.as_mut_ptr(), val);
    let mut len: size_t = p_buf
        .as_mut_ptr()
        .offset(::core::mem::size_of::<[libc::c_char; 22]>() as libc::c_ulong as isize)
        .offset_from(str) as libc::c_long as size_t;
    if !(len <= buf_len) {
        ck_assert_failed(
            b"/home/kkysen/work/rust/lighttpd/src/buffer.c\0" as *const u8 as *const libc::c_char,
            360 as libc::c_int as libc::c_uint,
            b"len <= buf_len\0" as *const u8 as *const libc::c_char,
        );
    }
    memcpy(buf as *mut libc::c_void, str as *const libc::c_void, len);
    return len;
}
#[no_mangle]
pub unsafe extern "C" fn hex2int(mut hex: libc::c_uchar) -> libc::c_char {
    let mut n: libc::c_uchar = 0;
    n = (hex as libc::c_int - '0' as i32) as libc::c_uchar;
    return (if n as libc::c_int <= 9 as libc::c_int || {
        n = ((hex as libc::c_int & 0xdf as libc::c_int) - 'A' as i32) as libc::c_uchar;
        (if n as libc::c_int <= 5 as libc::c_int {
            n = (n as libc::c_int + 10 as libc::c_int) as libc::c_uchar;
            n as libc::c_int
        } else {
            0 as libc::c_int
        }) != 0
    } {
        n as libc::c_char as libc::c_int
    } else {
        0xff as libc::c_int
    }) as libc::c_char;
}
#[no_mangle]
pub unsafe extern "C" fn li_hex2bin(
    bin: *mut libc::c_uchar,
    binlen: size_t,
    hexstr: *const libc::c_char,
    len: size_t,
) -> libc::c_int {
    if len > binlen << 1 as libc::c_int {
        return -(1 as libc::c_int);
    }
    let mut i: libc::c_int = 0 as libc::c_int;
    let mut ilen: libc::c_int = len as libc::c_int;
    while i < ilen {
        let mut hi: libc::c_int = *hexstr.offset(i as isize) as libc::c_int;
        let mut lo: libc::c_int = *hexstr.offset((i + 1 as libc::c_int) as isize) as libc::c_int;
        if '0' as i32 <= hi && hi <= '9' as i32 {
            hi -= '0' as i32;
        } else {
            hi |= 0x20 as libc::c_int;
            if (hi as uint32_t).wrapping_sub('a' as i32 as libc::c_uint)
                <= ('f' as i32 - 'a' as i32) as libc::c_uint
            {
                hi += -('a' as i32) + 10 as libc::c_int;
            } else {
                return -(1 as libc::c_int);
            }
        }
        if '0' as i32 <= lo && lo <= '9' as i32 {
            lo -= '0' as i32;
        } else {
            lo |= 0x20 as libc::c_int;
            if (lo as uint32_t).wrapping_sub('a' as i32 as libc::c_uint)
                <= ('f' as i32 - 'a' as i32) as libc::c_uint
            {
                lo += -('a' as i32) + 10 as libc::c_int;
            } else {
                return -(1 as libc::c_int);
            }
        }
        *bin.offset((i >> 1 as libc::c_int) as isize) =
            (hi << 4 as libc::c_int | lo) as libc::c_uchar;
        i += 2 as libc::c_int;
    }
    return 0 as libc::c_int;
}
#[no_mangle]
#[inline(never)]
pub unsafe extern "C" fn buffer_eq_icase_ssn(
    a: *const libc::c_char,
    b: *const libc::c_char,
    len: size_t,
) -> libc::c_int {
    let mut i: size_t = 0 as libc::c_int as size_t;
    while i < len {
        let mut ca: libc::c_uint = *(a as *mut libc::c_uchar).offset(i as isize) as libc::c_uint;
        let mut cb: libc::c_uint = *(b as *mut libc::c_uchar).offset(i as isize) as libc::c_uint;
        if ca != cb {
            ca |= 0x20 as libc::c_int as libc::c_uint;
            cb |= 0x20 as libc::c_int as libc::c_uint;
            if ca != cb {
                return 0 as libc::c_int;
            }
            if !(ca.wrapping_sub('a' as i32 as libc::c_uint)
                <= ('z' as i32 - 'a' as i32) as libc::c_uint)
            {
                return 0 as libc::c_int;
            }
            if !(cb.wrapping_sub('a' as i32 as libc::c_uint)
                <= ('z' as i32 - 'a' as i32) as libc::c_uint)
            {
                return 0 as libc::c_int;
            }
        }
        i = i.wrapping_add(1);
    }
    return 1 as libc::c_int;
}
#[no_mangle]
pub unsafe extern "C" fn buffer_eq_icase_ss(
    a: *const libc::c_char,
    alen: size_t,
    b: *const libc::c_char,
    blen: size_t,
) -> libc::c_int {
    return if alen == blen {
        buffer_eq_icase_ssn(a, b, blen)
    } else {
        0 as libc::c_int
    };
}
#[no_mangle]
pub unsafe extern "C" fn buffer_eq_icase_slen(
    b: *const buffer,
    s: *const libc::c_char,
    slen: size_t,
) -> libc::c_int {
    return if (*b).used as libc::c_ulong == slen.wrapping_add(1 as libc::c_int as libc::c_ulong) {
        buffer_eq_icase_ssn((*b).ptr, s, slen)
    } else {
        0 as libc::c_int
    };
}
#[no_mangle]
pub unsafe extern "C" fn buffer_eq_slen(
    b: *const buffer,
    s: *const libc::c_char,
    slen: size_t,
) -> libc::c_int {
    return ((*b).used as libc::c_ulong == slen.wrapping_add(1 as libc::c_int as libc::c_ulong)
        && 0 as libc::c_int
            == memcmp(
                (*b).ptr as *const libc::c_void,
                s as *const libc::c_void,
                slen,
            )) as libc::c_int;
}
#[no_mangle]
pub unsafe extern "C" fn buffer_is_equal(
    mut a: *const buffer,
    mut b: *const buffer,
) -> libc::c_int {
    return ((*a).used == (*b).used
        && 0 as libc::c_int
            == memcmp(
                (*a).ptr as *const libc::c_void,
                (*b).ptr as *const libc::c_void,
                (*a).used as libc::c_ulong,
            )) as libc::c_int;
}
#[no_mangle]
pub unsafe extern "C" fn li_tohex_lc(
    buf: *mut libc::c_char,
    mut buf_len: size_t,
    s: *const libc::c_char,
    mut s_len: size_t,
) {
    if !((2 as libc::c_int as libc::c_ulong).wrapping_mul(s_len) > s_len) {
        ck_assert_failed(
            b"/home/kkysen/work/rust/lighttpd/src/buffer.c\0" as *const u8 as *const libc::c_char,
            444 as libc::c_int as libc::c_uint,
            b"2 * s_len > s_len\0" as *const u8 as *const libc::c_char,
        );
    }
    if !((2 as libc::c_int as libc::c_ulong).wrapping_mul(s_len) < buf_len) {
        ck_assert_failed(
            b"/home/kkysen/work/rust/lighttpd/src/buffer.c\0" as *const u8 as *const libc::c_char,
            445 as libc::c_int as libc::c_uint,
            b"2 * s_len < buf_len\0" as *const u8 as *const libc::c_char,
        );
    }
    let mut i: size_t = 0 as libc::c_int as size_t;
    while i < s_len {
        *buf.offset((2 as libc::c_int as libc::c_ulong).wrapping_mul(i) as isize) =
            hex_chars_lc[(*s.offset(i as isize) as libc::c_int >> 4 as libc::c_int
                & 0xf as libc::c_int) as usize];
        *buf.offset(
            (2 as libc::c_int as libc::c_ulong)
                .wrapping_mul(i)
                .wrapping_add(1 as libc::c_int as libc::c_ulong) as isize,
        ) = hex_chars_lc[(*s.offset(i as isize) as libc::c_int & 0xf as libc::c_int) as usize];
        i = i.wrapping_add(1);
    }
    *buf.offset((2 as libc::c_int as libc::c_ulong).wrapping_mul(s_len) as isize) =
        '\0' as i32 as libc::c_char;
}
#[no_mangle]
pub unsafe extern "C" fn li_tohex_uc(
    buf: *mut libc::c_char,
    mut buf_len: size_t,
    s: *const libc::c_char,
    mut s_len: size_t,
) {
    if !((2 as libc::c_int as libc::c_ulong).wrapping_mul(s_len) > s_len) {
        ck_assert_failed(
            b"/home/kkysen/work/rust/lighttpd/src/buffer.c\0" as *const u8 as *const libc::c_char,
            455 as libc::c_int as libc::c_uint,
            b"2 * s_len > s_len\0" as *const u8 as *const libc::c_char,
        );
    }
    if !((2 as libc::c_int as libc::c_ulong).wrapping_mul(s_len) < buf_len) {
        ck_assert_failed(
            b"/home/kkysen/work/rust/lighttpd/src/buffer.c\0" as *const u8 as *const libc::c_char,
            456 as libc::c_int as libc::c_uint,
            b"2 * s_len < buf_len\0" as *const u8 as *const libc::c_char,
        );
    }
    let mut i: size_t = 0 as libc::c_int as size_t;
    while i < s_len {
        *buf.offset((2 as libc::c_int as libc::c_ulong).wrapping_mul(i) as isize) =
            hex_chars_uc[(*s.offset(i as isize) as libc::c_int >> 4 as libc::c_int
                & 0xf as libc::c_int) as usize];
        *buf.offset(
            (2 as libc::c_int as libc::c_ulong)
                .wrapping_mul(i)
                .wrapping_add(1 as libc::c_int as libc::c_ulong) as isize,
        ) = hex_chars_uc[(*s.offset(i as isize) as libc::c_int & 0xf as libc::c_int) as usize];
        i = i.wrapping_add(1);
    }
    *buf.offset((2 as libc::c_int as libc::c_ulong).wrapping_mul(s_len) as isize) =
        '\0' as i32 as libc::c_char;
}
#[no_mangle]
pub unsafe extern "C" fn buffer_substr_replace(
    b: *mut buffer,
    offset: size_t,
    len: size_t,
    replace: *const buffer,
) {
    let blen: size_t = buffer_clen(b) as size_t;
    let rlen: size_t = buffer_clen(replace) as size_t;
    if rlen > len {
        buffer_extend(b, blen.wrapping_sub(len).wrapping_add(rlen));
        memmove(
            ((*b).ptr).offset(offset as isize).offset(rlen as isize) as *mut libc::c_void,
            ((*b).ptr).offset(offset as isize).offset(len as isize) as *const libc::c_void,
            blen.wrapping_sub(offset).wrapping_sub(len),
        );
    }
    memcpy(
        ((*b).ptr).offset(offset as isize) as *mut libc::c_void,
        (*replace).ptr as *const libc::c_void,
        rlen,
    );
    if rlen < len {
        memmove(
            ((*b).ptr).offset(offset as isize).offset(rlen as isize) as *mut libc::c_void,
            ((*b).ptr).offset(offset as isize).offset(len as isize) as *const libc::c_void,
            blen.wrapping_sub(offset).wrapping_sub(len),
        );
        buffer_truncate(b, blen.wrapping_sub(len).wrapping_add(rlen) as uint32_t);
    }
}
#[no_mangle]
pub unsafe extern "C" fn buffer_append_string_encoded_hex_lc(
    b: *mut buffer,
    s: *const libc::c_char,
    mut len: size_t,
) {
    let p: *mut libc::c_uchar =
        buffer_extend(b, len.wrapping_mul(2 as libc::c_int as libc::c_ulong)) as *mut libc::c_uchar;
    let mut i: size_t = 0 as libc::c_int as size_t;
    while i < len {
        *p.offset((i << 1 as libc::c_int) as isize) =
            hex_chars_lc[(*s.offset(i as isize) as libc::c_int >> 4 as libc::c_int
                & 0xf as libc::c_int) as usize] as libc::c_uchar;
        *p.offset(
            (i << 1 as libc::c_int).wrapping_add(1 as libc::c_int as libc::c_ulong) as isize,
        ) = hex_chars_lc[(*s.offset(i as isize) as libc::c_int & 0xf as libc::c_int) as usize]
            as libc::c_uchar;
        i = i.wrapping_add(1);
    }
}
#[no_mangle]
pub unsafe extern "C" fn buffer_append_string_encoded_hex_uc(
    b: *mut buffer,
    s: *const libc::c_char,
    mut len: size_t,
) {
    let p: *mut libc::c_uchar =
        buffer_extend(b, len.wrapping_mul(2 as libc::c_int as libc::c_ulong)) as *mut libc::c_uchar;
    let mut i: size_t = 0 as libc::c_int as size_t;
    while i < len {
        *p.offset((i << 1 as libc::c_int) as isize) =
            hex_chars_uc[(*s.offset(i as isize) as libc::c_int >> 4 as libc::c_int
                & 0xf as libc::c_int) as usize] as libc::c_uchar;
        *p.offset(
            (i << 1 as libc::c_int).wrapping_add(1 as libc::c_int as libc::c_ulong) as isize,
        ) = hex_chars_uc[(*s.offset(i as isize) as libc::c_int & 0xf as libc::c_int) as usize]
            as libc::c_uchar;
        i = i.wrapping_add(1);
    }
}
static mut encoded_chars_rel_uri_part: [libc::c_char; 256] = [
    1 as libc::c_int as libc::c_char,
    1 as libc::c_int as libc::c_char,
    1 as libc::c_int as libc::c_char,
    1 as libc::c_int as libc::c_char,
    1 as libc::c_int as libc::c_char,
    1 as libc::c_int as libc::c_char,
    1 as libc::c_int as libc::c_char,
    1 as libc::c_int as libc::c_char,
    1 as libc::c_int as libc::c_char,
    1 as libc::c_int as libc::c_char,
    1 as libc::c_int as libc::c_char,
    1 as libc::c_int as libc::c_char,
    1 as libc::c_int as libc::c_char,
    1 as libc::c_int as libc::c_char,
    1 as libc::c_int as libc::c_char,
    1 as libc::c_int as libc::c_char,
    1 as libc::c_int as libc::c_char,
    1 as libc::c_int as libc::c_char,
    1 as libc::c_int as libc::c_char,
    1 as libc::c_int as libc::c_char,
    1 as libc::c_int as libc::c_char,
    1 as libc::c_int as libc::c_char,
    1 as libc::c_int as libc::c_char,
    1 as libc::c_int as libc::c_char,
    1 as libc::c_int as libc::c_char,
    1 as libc::c_int as libc::c_char,
    1 as libc::c_int as libc::c_char,
    1 as libc::c_int as libc::c_char,
    1 as libc::c_int as libc::c_char,
    1 as libc::c_int as libc::c_char,
    1 as libc::c_int as libc::c_char,
    1 as libc::c_int as libc::c_char,
    1 as libc::c_int as libc::c_char,
    0 as libc::c_int as libc::c_char,
    1 as libc::c_int as libc::c_char,
    1 as libc::c_int as libc::c_char,
    1 as libc::c_int as libc::c_char,
    1 as libc::c_int as libc::c_char,
    1 as libc::c_int as libc::c_char,
    1 as libc::c_int as libc::c_char,
    0 as libc::c_int as libc::c_char,
    0 as libc::c_int as libc::c_char,
    0 as libc::c_int as libc::c_char,
    1 as libc::c_int as libc::c_char,
    1 as libc::c_int as libc::c_char,
    0 as libc::c_int as libc::c_char,
    0 as libc::c_int as libc::c_char,
    1 as libc::c_int as libc::c_char,
    0 as libc::c_int as libc::c_char,
    0 as libc::c_int as libc::c_char,
    0 as libc::c_int as libc::c_char,
    0 as libc::c_int as libc::c_char,
    0 as libc::c_int as libc::c_char,
    0 as libc::c_int as libc::c_char,
    0 as libc::c_int as libc::c_char,
    0 as libc::c_int as libc::c_char,
    0 as libc::c_int as libc::c_char,
    0 as libc::c_int as libc::c_char,
    1 as libc::c_int as libc::c_char,
    1 as libc::c_int as libc::c_char,
    1 as libc::c_int as libc::c_char,
    1 as libc::c_int as libc::c_char,
    1 as libc::c_int as libc::c_char,
    1 as libc::c_int as libc::c_char,
    1 as libc::c_int as libc::c_char,
    0 as libc::c_int as libc::c_char,
    0 as libc::c_int as libc::c_char,
    0 as libc::c_int as libc::c_char,
    0 as libc::c_int as libc::c_char,
    0 as libc::c_int as libc::c_char,
    0 as libc::c_int as libc::c_char,
    0 as libc::c_int as libc::c_char,
    0 as libc::c_int as libc::c_char,
    0 as libc::c_int as libc::c_char,
    0 as libc::c_int as libc::c_char,
    0 as libc::c_int as libc::c_char,
    0 as libc::c_int as libc::c_char,
    0 as libc::c_int as libc::c_char,
    0 as libc::c_int as libc::c_char,
    0 as libc::c_int as libc::c_char,
    0 as libc::c_int as libc::c_char,
    0 as libc::c_int as libc::c_char,
    0 as libc::c_int as libc::c_char,
    0 as libc::c_int as libc::c_char,
    0 as libc::c_int as libc::c_char,
    0 as libc::c_int as libc::c_char,
    0 as libc::c_int as libc::c_char,
    0 as libc::c_int as libc::c_char,
    0 as libc::c_int as libc::c_char,
    0 as libc::c_int as libc::c_char,
    0 as libc::c_int as libc::c_char,
    1 as libc::c_int as libc::c_char,
    1 as libc::c_int as libc::c_char,
    1 as libc::c_int as libc::c_char,
    1 as libc::c_int as libc::c_char,
    0 as libc::c_int as libc::c_char,
    1 as libc::c_int as libc::c_char,
    0 as libc::c_int as libc::c_char,
    0 as libc::c_int as libc::c_char,
    0 as libc::c_int as libc::c_char,
    0 as libc::c_int as libc::c_char,
    0 as libc::c_int as libc::c_char,
    0 as libc::c_int as libc::c_char,
    0 as libc::c_int as libc::c_char,
    0 as libc::c_int as libc::c_char,
    0 as libc::c_int as libc::c_char,
    0 as libc::c_int as libc::c_char,
    0 as libc::c_int as libc::c_char,
    0 as libc::c_int as libc::c_char,
    0 as libc::c_int as libc::c_char,
    0 as libc::c_int as libc::c_char,
    0 as libc::c_int as libc::c_char,
    0 as libc::c_int as libc::c_char,
    0 as libc::c_int as libc::c_char,
    0 as libc::c_int as libc::c_char,
    0 as libc::c_int as libc::c_char,
    0 as libc::c_int as libc::c_char,
    0 as libc::c_int as libc::c_char,
    0 as libc::c_int as libc::c_char,
    0 as libc::c_int as libc::c_char,
    0 as libc::c_int as libc::c_char,
    0 as libc::c_int as libc::c_char,
    0 as libc::c_int as libc::c_char,
    1 as libc::c_int as libc::c_char,
    1 as libc::c_int as libc::c_char,
    1 as libc::c_int as libc::c_char,
    0 as libc::c_int as libc::c_char,
    1 as libc::c_int as libc::c_char,
    1 as libc::c_int as libc::c_char,
    1 as libc::c_int as libc::c_char,
    1 as libc::c_int as libc::c_char,
    1 as libc::c_int as libc::c_char,
    1 as libc::c_int as libc::c_char,
    1 as libc::c_int as libc::c_char,
    1 as libc::c_int as libc::c_char,
    1 as libc::c_int as libc::c_char,
    1 as libc::c_int as libc::c_char,
    1 as libc::c_int as libc::c_char,
    1 as libc::c_int as libc::c_char,
    1 as libc::c_int as libc::c_char,
    1 as libc::c_int as libc::c_char,
    1 as libc::c_int as libc::c_char,
    1 as libc::c_int as libc::c_char,
    1 as libc::c_int as libc::c_char,
    1 as libc::c_int as libc::c_char,
    1 as libc::c_int as libc::c_char,
    1 as libc::c_int as libc::c_char,
    1 as libc::c_int as libc::c_char,
    1 as libc::c_int as libc::c_char,
    1 as libc::c_int as libc::c_char,
    1 as libc::c_int as libc::c_char,
    1 as libc::c_int as libc::c_char,
    1 as libc::c_int as libc::c_char,
    1 as libc::c_int as libc::c_char,
    1 as libc::c_int as libc::c_char,
    1 as libc::c_int as libc::c_char,
    1 as libc::c_int as libc::c_char,
    1 as libc::c_int as libc::c_char,
    1 as libc::c_int as libc::c_char,
    1 as libc::c_int as libc::c_char,
    1 as libc::c_int as libc::c_char,
    1 as libc::c_int as libc::c_char,
    1 as libc::c_int as libc::c_char,
    1 as libc::c_int as libc::c_char,
    1 as libc::c_int as libc::c_char,
    1 as libc::c_int as libc::c_char,
    1 as libc::c_int as libc::c_char,
    1 as libc::c_int as libc::c_char,
    1 as libc::c_int as libc::c_char,
    1 as libc::c_int as libc::c_char,
    1 as libc::c_int as libc::c_char,
    1 as libc::c_int as libc::c_char,
    1 as libc::c_int as libc::c_char,
    1 as libc::c_int as libc::c_char,
    1 as libc::c_int as libc::c_char,
    1 as libc::c_int as libc::c_char,
    1 as libc::c_int as libc::c_char,
    1 as libc::c_int as libc::c_char,
    1 as libc::c_int as libc::c_char,
    1 as libc::c_int as libc::c_char,
    1 as libc::c_int as libc::c_char,
    1 as libc::c_int as libc::c_char,
    1 as libc::c_int as libc::c_char,
    1 as libc::c_int as libc::c_char,
    1 as libc::c_int as libc::c_char,
    1 as libc::c_int as libc::c_char,
    1 as libc::c_int as libc::c_char,
    1 as libc::c_int as libc::c_char,
    1 as libc::c_int as libc::c_char,
    1 as libc::c_int as libc::c_char,
    1 as libc::c_int as libc::c_char,
    1 as libc::c_int as libc::c_char,
    1 as libc::c_int as libc::c_char,
    1 as libc::c_int as libc::c_char,
    1 as libc::c_int as libc::c_char,
    1 as libc::c_int as libc::c_char,
    1 as libc::c_int as libc::c_char,
    1 as libc::c_int as libc::c_char,
    1 as libc::c_int as libc::c_char,
    1 as libc::c_int as libc::c_char,
    1 as libc::c_int as libc::c_char,
    1 as libc::c_int as libc::c_char,
    1 as libc::c_int as libc::c_char,
    1 as libc::c_int as libc::c_char,
    1 as libc::c_int as libc::c_char,
    1 as libc::c_int as libc::c_char,
    1 as libc::c_int as libc::c_char,
    1 as libc::c_int as libc::c_char,
    1 as libc::c_int as libc::c_char,
    1 as libc::c_int as libc::c_char,
    1 as libc::c_int as libc::c_char,
    1 as libc::c_int as libc::c_char,
    1 as libc::c_int as libc::c_char,
    1 as libc::c_int as libc::c_char,
    1 as libc::c_int as libc::c_char,
    1 as libc::c_int as libc::c_char,
    1 as libc::c_int as libc::c_char,
    1 as libc::c_int as libc::c_char,
    1 as libc::c_int as libc::c_char,
    1 as libc::c_int as libc::c_char,
    1 as libc::c_int as libc::c_char,
    1 as libc::c_int as libc::c_char,
    1 as libc::c_int as libc::c_char,
    1 as libc::c_int as libc::c_char,
    1 as libc::c_int as libc::c_char,
    1 as libc::c_int as libc::c_char,
    1 as libc::c_int as libc::c_char,
    1 as libc::c_int as libc::c_char,
    1 as libc::c_int as libc::c_char,
    1 as libc::c_int as libc::c_char,
    1 as libc::c_int as libc::c_char,
    1 as libc::c_int as libc::c_char,
    1 as libc::c_int as libc::c_char,
    1 as libc::c_int as libc::c_char,
    1 as libc::c_int as libc::c_char,
    1 as libc::c_int as libc::c_char,
    1 as libc::c_int as libc::c_char,
    1 as libc::c_int as libc::c_char,
    1 as libc::c_int as libc::c_char,
    1 as libc::c_int as libc::c_char,
    1 as libc::c_int as libc::c_char,
    1 as libc::c_int as libc::c_char,
    1 as libc::c_int as libc::c_char,
    1 as libc::c_int as libc::c_char,
    1 as libc::c_int as libc::c_char,
    1 as libc::c_int as libc::c_char,
    1 as libc::c_int as libc::c_char,
    1 as libc::c_int as libc::c_char,
    1 as libc::c_int as libc::c_char,
    1 as libc::c_int as libc::c_char,
    1 as libc::c_int as libc::c_char,
    1 as libc::c_int as libc::c_char,
    1 as libc::c_int as libc::c_char,
    1 as libc::c_int as libc::c_char,
    1 as libc::c_int as libc::c_char,
    1 as libc::c_int as libc::c_char,
];
static mut encoded_chars_rel_uri: [libc::c_char; 256] = [
    1 as libc::c_int as libc::c_char,
    1 as libc::c_int as libc::c_char,
    1 as libc::c_int as libc::c_char,
    1 as libc::c_int as libc::c_char,
    1 as libc::c_int as libc::c_char,
    1 as libc::c_int as libc::c_char,
    1 as libc::c_int as libc::c_char,
    1 as libc::c_int as libc::c_char,
    1 as libc::c_int as libc::c_char,
    1 as libc::c_int as libc::c_char,
    1 as libc::c_int as libc::c_char,
    1 as libc::c_int as libc::c_char,
    1 as libc::c_int as libc::c_char,
    1 as libc::c_int as libc::c_char,
    1 as libc::c_int as libc::c_char,
    1 as libc::c_int as libc::c_char,
    1 as libc::c_int as libc::c_char,
    1 as libc::c_int as libc::c_char,
    1 as libc::c_int as libc::c_char,
    1 as libc::c_int as libc::c_char,
    1 as libc::c_int as libc::c_char,
    1 as libc::c_int as libc::c_char,
    1 as libc::c_int as libc::c_char,
    1 as libc::c_int as libc::c_char,
    1 as libc::c_int as libc::c_char,
    1 as libc::c_int as libc::c_char,
    1 as libc::c_int as libc::c_char,
    1 as libc::c_int as libc::c_char,
    1 as libc::c_int as libc::c_char,
    1 as libc::c_int as libc::c_char,
    1 as libc::c_int as libc::c_char,
    1 as libc::c_int as libc::c_char,
    1 as libc::c_int as libc::c_char,
    0 as libc::c_int as libc::c_char,
    1 as libc::c_int as libc::c_char,
    1 as libc::c_int as libc::c_char,
    1 as libc::c_int as libc::c_char,
    1 as libc::c_int as libc::c_char,
    1 as libc::c_int as libc::c_char,
    1 as libc::c_int as libc::c_char,
    0 as libc::c_int as libc::c_char,
    0 as libc::c_int as libc::c_char,
    0 as libc::c_int as libc::c_char,
    1 as libc::c_int as libc::c_char,
    1 as libc::c_int as libc::c_char,
    0 as libc::c_int as libc::c_char,
    0 as libc::c_int as libc::c_char,
    0 as libc::c_int as libc::c_char,
    0 as libc::c_int as libc::c_char,
    0 as libc::c_int as libc::c_char,
    0 as libc::c_int as libc::c_char,
    0 as libc::c_int as libc::c_char,
    0 as libc::c_int as libc::c_char,
    0 as libc::c_int as libc::c_char,
    0 as libc::c_int as libc::c_char,
    0 as libc::c_int as libc::c_char,
    0 as libc::c_int as libc::c_char,
    0 as libc::c_int as libc::c_char,
    1 as libc::c_int as libc::c_char,
    1 as libc::c_int as libc::c_char,
    1 as libc::c_int as libc::c_char,
    1 as libc::c_int as libc::c_char,
    1 as libc::c_int as libc::c_char,
    1 as libc::c_int as libc::c_char,
    1 as libc::c_int as libc::c_char,
    0 as libc::c_int as libc::c_char,
    0 as libc::c_int as libc::c_char,
    0 as libc::c_int as libc::c_char,
    0 as libc::c_int as libc::c_char,
    0 as libc::c_int as libc::c_char,
    0 as libc::c_int as libc::c_char,
    0 as libc::c_int as libc::c_char,
    0 as libc::c_int as libc::c_char,
    0 as libc::c_int as libc::c_char,
    0 as libc::c_int as libc::c_char,
    0 as libc::c_int as libc::c_char,
    0 as libc::c_int as libc::c_char,
    0 as libc::c_int as libc::c_char,
    0 as libc::c_int as libc::c_char,
    0 as libc::c_int as libc::c_char,
    0 as libc::c_int as libc::c_char,
    0 as libc::c_int as libc::c_char,
    0 as libc::c_int as libc::c_char,
    0 as libc::c_int as libc::c_char,
    0 as libc::c_int as libc::c_char,
    0 as libc::c_int as libc::c_char,
    0 as libc::c_int as libc::c_char,
    0 as libc::c_int as libc::c_char,
    0 as libc::c_int as libc::c_char,
    0 as libc::c_int as libc::c_char,
    0 as libc::c_int as libc::c_char,
    1 as libc::c_int as libc::c_char,
    1 as libc::c_int as libc::c_char,
    1 as libc::c_int as libc::c_char,
    1 as libc::c_int as libc::c_char,
    0 as libc::c_int as libc::c_char,
    1 as libc::c_int as libc::c_char,
    0 as libc::c_int as libc::c_char,
    0 as libc::c_int as libc::c_char,
    0 as libc::c_int as libc::c_char,
    0 as libc::c_int as libc::c_char,
    0 as libc::c_int as libc::c_char,
    0 as libc::c_int as libc::c_char,
    0 as libc::c_int as libc::c_char,
    0 as libc::c_int as libc::c_char,
    0 as libc::c_int as libc::c_char,
    0 as libc::c_int as libc::c_char,
    0 as libc::c_int as libc::c_char,
    0 as libc::c_int as libc::c_char,
    0 as libc::c_int as libc::c_char,
    0 as libc::c_int as libc::c_char,
    0 as libc::c_int as libc::c_char,
    0 as libc::c_int as libc::c_char,
    0 as libc::c_int as libc::c_char,
    0 as libc::c_int as libc::c_char,
    0 as libc::c_int as libc::c_char,
    0 as libc::c_int as libc::c_char,
    0 as libc::c_int as libc::c_char,
    0 as libc::c_int as libc::c_char,
    0 as libc::c_int as libc::c_char,
    0 as libc::c_int as libc::c_char,
    0 as libc::c_int as libc::c_char,
    0 as libc::c_int as libc::c_char,
    1 as libc::c_int as libc::c_char,
    1 as libc::c_int as libc::c_char,
    1 as libc::c_int as libc::c_char,
    0 as libc::c_int as libc::c_char,
    1 as libc::c_int as libc::c_char,
    1 as libc::c_int as libc::c_char,
    1 as libc::c_int as libc::c_char,
    1 as libc::c_int as libc::c_char,
    1 as libc::c_int as libc::c_char,
    1 as libc::c_int as libc::c_char,
    1 as libc::c_int as libc::c_char,
    1 as libc::c_int as libc::c_char,
    1 as libc::c_int as libc::c_char,
    1 as libc::c_int as libc::c_char,
    1 as libc::c_int as libc::c_char,
    1 as libc::c_int as libc::c_char,
    1 as libc::c_int as libc::c_char,
    1 as libc::c_int as libc::c_char,
    1 as libc::c_int as libc::c_char,
    1 as libc::c_int as libc::c_char,
    1 as libc::c_int as libc::c_char,
    1 as libc::c_int as libc::c_char,
    1 as libc::c_int as libc::c_char,
    1 as libc::c_int as libc::c_char,
    1 as libc::c_int as libc::c_char,
    1 as libc::c_int as libc::c_char,
    1 as libc::c_int as libc::c_char,
    1 as libc::c_int as libc::c_char,
    1 as libc::c_int as libc::c_char,
    1 as libc::c_int as libc::c_char,
    1 as libc::c_int as libc::c_char,
    1 as libc::c_int as libc::c_char,
    1 as libc::c_int as libc::c_char,
    1 as libc::c_int as libc::c_char,
    1 as libc::c_int as libc::c_char,
    1 as libc::c_int as libc::c_char,
    1 as libc::c_int as libc::c_char,
    1 as libc::c_int as libc::c_char,
    1 as libc::c_int as libc::c_char,
    1 as libc::c_int as libc::c_char,
    1 as libc::c_int as libc::c_char,
    1 as libc::c_int as libc::c_char,
    1 as libc::c_int as libc::c_char,
    1 as libc::c_int as libc::c_char,
    1 as libc::c_int as libc::c_char,
    1 as libc::c_int as libc::c_char,
    1 as libc::c_int as libc::c_char,
    1 as libc::c_int as libc::c_char,
    1 as libc::c_int as libc::c_char,
    1 as libc::c_int as libc::c_char,
    1 as libc::c_int as libc::c_char,
    1 as libc::c_int as libc::c_char,
    1 as libc::c_int as libc::c_char,
    1 as libc::c_int as libc::c_char,
    1 as libc::c_int as libc::c_char,
    1 as libc::c_int as libc::c_char,
    1 as libc::c_int as libc::c_char,
    1 as libc::c_int as libc::c_char,
    1 as libc::c_int as libc::c_char,
    1 as libc::c_int as libc::c_char,
    1 as libc::c_int as libc::c_char,
    1 as libc::c_int as libc::c_char,
    1 as libc::c_int as libc::c_char,
    1 as libc::c_int as libc::c_char,
    1 as libc::c_int as libc::c_char,
    1 as libc::c_int as libc::c_char,
    1 as libc::c_int as libc::c_char,
    1 as libc::c_int as libc::c_char,
    1 as libc::c_int as libc::c_char,
    1 as libc::c_int as libc::c_char,
    1 as libc::c_int as libc::c_char,
    1 as libc::c_int as libc::c_char,
    1 as libc::c_int as libc::c_char,
    1 as libc::c_int as libc::c_char,
    1 as libc::c_int as libc::c_char,
    1 as libc::c_int as libc::c_char,
    1 as libc::c_int as libc::c_char,
    1 as libc::c_int as libc::c_char,
    1 as libc::c_int as libc::c_char,
    1 as libc::c_int as libc::c_char,
    1 as libc::c_int as libc::c_char,
    1 as libc::c_int as libc::c_char,
    1 as libc::c_int as libc::c_char,
    1 as libc::c_int as libc::c_char,
    1 as libc::c_int as libc::c_char,
    1 as libc::c_int as libc::c_char,
    1 as libc::c_int as libc::c_char,
    1 as libc::c_int as libc::c_char,
    1 as libc::c_int as libc::c_char,
    1 as libc::c_int as libc::c_char,
    1 as libc::c_int as libc::c_char,
    1 as libc::c_int as libc::c_char,
    1 as libc::c_int as libc::c_char,
    1 as libc::c_int as libc::c_char,
    1 as libc::c_int as libc::c_char,
    1 as libc::c_int as libc::c_char,
    1 as libc::c_int as libc::c_char,
    1 as libc::c_int as libc::c_char,
    1 as libc::c_int as libc::c_char,
    1 as libc::c_int as libc::c_char,
    1 as libc::c_int as libc::c_char,
    1 as libc::c_int as libc::c_char,
    1 as libc::c_int as libc::c_char,
    1 as libc::c_int as libc::c_char,
    1 as libc::c_int as libc::c_char,
    1 as libc::c_int as libc::c_char,
    1 as libc::c_int as libc::c_char,
    1 as libc::c_int as libc::c_char,
    1 as libc::c_int as libc::c_char,
    1 as libc::c_int as libc::c_char,
    1 as libc::c_int as libc::c_char,
    1 as libc::c_int as libc::c_char,
    1 as libc::c_int as libc::c_char,
    1 as libc::c_int as libc::c_char,
    1 as libc::c_int as libc::c_char,
    1 as libc::c_int as libc::c_char,
    1 as libc::c_int as libc::c_char,
    1 as libc::c_int as libc::c_char,
    1 as libc::c_int as libc::c_char,
    1 as libc::c_int as libc::c_char,
    1 as libc::c_int as libc::c_char,
    1 as libc::c_int as libc::c_char,
    1 as libc::c_int as libc::c_char,
    1 as libc::c_int as libc::c_char,
    1 as libc::c_int as libc::c_char,
    1 as libc::c_int as libc::c_char,
    1 as libc::c_int as libc::c_char,
    1 as libc::c_int as libc::c_char,
    1 as libc::c_int as libc::c_char,
    1 as libc::c_int as libc::c_char,
    1 as libc::c_int as libc::c_char,
    1 as libc::c_int as libc::c_char,
    1 as libc::c_int as libc::c_char,
];
static mut encoded_chars_html: [libc::c_char; 256] = [
    1 as libc::c_int as libc::c_char,
    1 as libc::c_int as libc::c_char,
    1 as libc::c_int as libc::c_char,
    1 as libc::c_int as libc::c_char,
    1 as libc::c_int as libc::c_char,
    1 as libc::c_int as libc::c_char,
    1 as libc::c_int as libc::c_char,
    1 as libc::c_int as libc::c_char,
    1 as libc::c_int as libc::c_char,
    1 as libc::c_int as libc::c_char,
    1 as libc::c_int as libc::c_char,
    1 as libc::c_int as libc::c_char,
    1 as libc::c_int as libc::c_char,
    1 as libc::c_int as libc::c_char,
    1 as libc::c_int as libc::c_char,
    1 as libc::c_int as libc::c_char,
    1 as libc::c_int as libc::c_char,
    1 as libc::c_int as libc::c_char,
    1 as libc::c_int as libc::c_char,
    1 as libc::c_int as libc::c_char,
    1 as libc::c_int as libc::c_char,
    1 as libc::c_int as libc::c_char,
    1 as libc::c_int as libc::c_char,
    1 as libc::c_int as libc::c_char,
    1 as libc::c_int as libc::c_char,
    1 as libc::c_int as libc::c_char,
    1 as libc::c_int as libc::c_char,
    1 as libc::c_int as libc::c_char,
    1 as libc::c_int as libc::c_char,
    1 as libc::c_int as libc::c_char,
    1 as libc::c_int as libc::c_char,
    1 as libc::c_int as libc::c_char,
    0 as libc::c_int as libc::c_char,
    0 as libc::c_int as libc::c_char,
    1 as libc::c_int as libc::c_char,
    0 as libc::c_int as libc::c_char,
    0 as libc::c_int as libc::c_char,
    0 as libc::c_int as libc::c_char,
    1 as libc::c_int as libc::c_char,
    1 as libc::c_int as libc::c_char,
    0 as libc::c_int as libc::c_char,
    0 as libc::c_int as libc::c_char,
    0 as libc::c_int as libc::c_char,
    0 as libc::c_int as libc::c_char,
    0 as libc::c_int as libc::c_char,
    0 as libc::c_int as libc::c_char,
    0 as libc::c_int as libc::c_char,
    0 as libc::c_int as libc::c_char,
    0 as libc::c_int as libc::c_char,
    0 as libc::c_int as libc::c_char,
    0 as libc::c_int as libc::c_char,
    0 as libc::c_int as libc::c_char,
    0 as libc::c_int as libc::c_char,
    0 as libc::c_int as libc::c_char,
    0 as libc::c_int as libc::c_char,
    0 as libc::c_int as libc::c_char,
    0 as libc::c_int as libc::c_char,
    0 as libc::c_int as libc::c_char,
    0 as libc::c_int as libc::c_char,
    0 as libc::c_int as libc::c_char,
    1 as libc::c_int as libc::c_char,
    0 as libc::c_int as libc::c_char,
    1 as libc::c_int as libc::c_char,
    0 as libc::c_int as libc::c_char,
    0 as libc::c_int as libc::c_char,
    0 as libc::c_int as libc::c_char,
    0 as libc::c_int as libc::c_char,
    0 as libc::c_int as libc::c_char,
    0 as libc::c_int as libc::c_char,
    0 as libc::c_int as libc::c_char,
    0 as libc::c_int as libc::c_char,
    0 as libc::c_int as libc::c_char,
    0 as libc::c_int as libc::c_char,
    0 as libc::c_int as libc::c_char,
    0 as libc::c_int as libc::c_char,
    0 as libc::c_int as libc::c_char,
    0 as libc::c_int as libc::c_char,
    0 as libc::c_int as libc::c_char,
    0 as libc::c_int as libc::c_char,
    0 as libc::c_int as libc::c_char,
    0 as libc::c_int as libc::c_char,
    0 as libc::c_int as libc::c_char,
    0 as libc::c_int as libc::c_char,
    0 as libc::c_int as libc::c_char,
    0 as libc::c_int as libc::c_char,
    0 as libc::c_int as libc::c_char,
    0 as libc::c_int as libc::c_char,
    0 as libc::c_int as libc::c_char,
    0 as libc::c_int as libc::c_char,
    0 as libc::c_int as libc::c_char,
    0 as libc::c_int as libc::c_char,
    0 as libc::c_int as libc::c_char,
    0 as libc::c_int as libc::c_char,
    0 as libc::c_int as libc::c_char,
    0 as libc::c_int as libc::c_char,
    0 as libc::c_int as libc::c_char,
    1 as libc::c_int as libc::c_char,
    0 as libc::c_int as libc::c_char,
    0 as libc::c_int as libc::c_char,
    0 as libc::c_int as libc::c_char,
    0 as libc::c_int as libc::c_char,
    0 as libc::c_int as libc::c_char,
    0 as libc::c_int as libc::c_char,
    0 as libc::c_int as libc::c_char,
    0 as libc::c_int as libc::c_char,
    0 as libc::c_int as libc::c_char,
    0 as libc::c_int as libc::c_char,
    0 as libc::c_int as libc::c_char,
    0 as libc::c_int as libc::c_char,
    0 as libc::c_int as libc::c_char,
    0 as libc::c_int as libc::c_char,
    0 as libc::c_int as libc::c_char,
    0 as libc::c_int as libc::c_char,
    0 as libc::c_int as libc::c_char,
    0 as libc::c_int as libc::c_char,
    0 as libc::c_int as libc::c_char,
    0 as libc::c_int as libc::c_char,
    0 as libc::c_int as libc::c_char,
    0 as libc::c_int as libc::c_char,
    0 as libc::c_int as libc::c_char,
    0 as libc::c_int as libc::c_char,
    0 as libc::c_int as libc::c_char,
    0 as libc::c_int as libc::c_char,
    0 as libc::c_int as libc::c_char,
    0 as libc::c_int as libc::c_char,
    0 as libc::c_int as libc::c_char,
    0 as libc::c_int as libc::c_char,
    1 as libc::c_int as libc::c_char,
    1 as libc::c_int as libc::c_char,
    1 as libc::c_int as libc::c_char,
    1 as libc::c_int as libc::c_char,
    1 as libc::c_int as libc::c_char,
    1 as libc::c_int as libc::c_char,
    1 as libc::c_int as libc::c_char,
    1 as libc::c_int as libc::c_char,
    1 as libc::c_int as libc::c_char,
    1 as libc::c_int as libc::c_char,
    1 as libc::c_int as libc::c_char,
    1 as libc::c_int as libc::c_char,
    1 as libc::c_int as libc::c_char,
    1 as libc::c_int as libc::c_char,
    1 as libc::c_int as libc::c_char,
    1 as libc::c_int as libc::c_char,
    1 as libc::c_int as libc::c_char,
    1 as libc::c_int as libc::c_char,
    1 as libc::c_int as libc::c_char,
    1 as libc::c_int as libc::c_char,
    1 as libc::c_int as libc::c_char,
    1 as libc::c_int as libc::c_char,
    1 as libc::c_int as libc::c_char,
    1 as libc::c_int as libc::c_char,
    1 as libc::c_int as libc::c_char,
    1 as libc::c_int as libc::c_char,
    1 as libc::c_int as libc::c_char,
    1 as libc::c_int as libc::c_char,
    1 as libc::c_int as libc::c_char,
    1 as libc::c_int as libc::c_char,
    1 as libc::c_int as libc::c_char,
    1 as libc::c_int as libc::c_char,
    1 as libc::c_int as libc::c_char,
    1 as libc::c_int as libc::c_char,
    1 as libc::c_int as libc::c_char,
    1 as libc::c_int as libc::c_char,
    1 as libc::c_int as libc::c_char,
    1 as libc::c_int as libc::c_char,
    1 as libc::c_int as libc::c_char,
    1 as libc::c_int as libc::c_char,
    1 as libc::c_int as libc::c_char,
    1 as libc::c_int as libc::c_char,
    1 as libc::c_int as libc::c_char,
    1 as libc::c_int as libc::c_char,
    1 as libc::c_int as libc::c_char,
    1 as libc::c_int as libc::c_char,
    1 as libc::c_int as libc::c_char,
    1 as libc::c_int as libc::c_char,
    1 as libc::c_int as libc::c_char,
    1 as libc::c_int as libc::c_char,
    1 as libc::c_int as libc::c_char,
    1 as libc::c_int as libc::c_char,
    1 as libc::c_int as libc::c_char,
    1 as libc::c_int as libc::c_char,
    1 as libc::c_int as libc::c_char,
    1 as libc::c_int as libc::c_char,
    1 as libc::c_int as libc::c_char,
    1 as libc::c_int as libc::c_char,
    1 as libc::c_int as libc::c_char,
    1 as libc::c_int as libc::c_char,
    1 as libc::c_int as libc::c_char,
    1 as libc::c_int as libc::c_char,
    1 as libc::c_int as libc::c_char,
    1 as libc::c_int as libc::c_char,
    1 as libc::c_int as libc::c_char,
    1 as libc::c_int as libc::c_char,
    1 as libc::c_int as libc::c_char,
    1 as libc::c_int as libc::c_char,
    1 as libc::c_int as libc::c_char,
    1 as libc::c_int as libc::c_char,
    1 as libc::c_int as libc::c_char,
    1 as libc::c_int as libc::c_char,
    1 as libc::c_int as libc::c_char,
    1 as libc::c_int as libc::c_char,
    1 as libc::c_int as libc::c_char,
    1 as libc::c_int as libc::c_char,
    1 as libc::c_int as libc::c_char,
    1 as libc::c_int as libc::c_char,
    1 as libc::c_int as libc::c_char,
    1 as libc::c_int as libc::c_char,
    1 as libc::c_int as libc::c_char,
    1 as libc::c_int as libc::c_char,
    1 as libc::c_int as libc::c_char,
    1 as libc::c_int as libc::c_char,
    1 as libc::c_int as libc::c_char,
    1 as libc::c_int as libc::c_char,
    1 as libc::c_int as libc::c_char,
    1 as libc::c_int as libc::c_char,
    1 as libc::c_int as libc::c_char,
    1 as libc::c_int as libc::c_char,
    1 as libc::c_int as libc::c_char,
    1 as libc::c_int as libc::c_char,
    1 as libc::c_int as libc::c_char,
    1 as libc::c_int as libc::c_char,
    1 as libc::c_int as libc::c_char,
    1 as libc::c_int as libc::c_char,
    1 as libc::c_int as libc::c_char,
    1 as libc::c_int as libc::c_char,
    1 as libc::c_int as libc::c_char,
    1 as libc::c_int as libc::c_char,
    1 as libc::c_int as libc::c_char,
    1 as libc::c_int as libc::c_char,
    1 as libc::c_int as libc::c_char,
    1 as libc::c_int as libc::c_char,
    1 as libc::c_int as libc::c_char,
    1 as libc::c_int as libc::c_char,
    1 as libc::c_int as libc::c_char,
    1 as libc::c_int as libc::c_char,
    1 as libc::c_int as libc::c_char,
    1 as libc::c_int as libc::c_char,
    1 as libc::c_int as libc::c_char,
    1 as libc::c_int as libc::c_char,
    1 as libc::c_int as libc::c_char,
    1 as libc::c_int as libc::c_char,
    1 as libc::c_int as libc::c_char,
    1 as libc::c_int as libc::c_char,
    1 as libc::c_int as libc::c_char,
    1 as libc::c_int as libc::c_char,
    1 as libc::c_int as libc::c_char,
    1 as libc::c_int as libc::c_char,
    1 as libc::c_int as libc::c_char,
    1 as libc::c_int as libc::c_char,
    1 as libc::c_int as libc::c_char,
    1 as libc::c_int as libc::c_char,
    1 as libc::c_int as libc::c_char,
    1 as libc::c_int as libc::c_char,
    1 as libc::c_int as libc::c_char,
    1 as libc::c_int as libc::c_char,
    1 as libc::c_int as libc::c_char,
];
static mut encoded_chars_minimal_xml: [libc::c_char; 256] = [
    1 as libc::c_int as libc::c_char,
    1 as libc::c_int as libc::c_char,
    1 as libc::c_int as libc::c_char,
    1 as libc::c_int as libc::c_char,
    1 as libc::c_int as libc::c_char,
    1 as libc::c_int as libc::c_char,
    1 as libc::c_int as libc::c_char,
    1 as libc::c_int as libc::c_char,
    1 as libc::c_int as libc::c_char,
    1 as libc::c_int as libc::c_char,
    1 as libc::c_int as libc::c_char,
    1 as libc::c_int as libc::c_char,
    1 as libc::c_int as libc::c_char,
    1 as libc::c_int as libc::c_char,
    1 as libc::c_int as libc::c_char,
    1 as libc::c_int as libc::c_char,
    1 as libc::c_int as libc::c_char,
    1 as libc::c_int as libc::c_char,
    1 as libc::c_int as libc::c_char,
    1 as libc::c_int as libc::c_char,
    1 as libc::c_int as libc::c_char,
    1 as libc::c_int as libc::c_char,
    1 as libc::c_int as libc::c_char,
    1 as libc::c_int as libc::c_char,
    1 as libc::c_int as libc::c_char,
    1 as libc::c_int as libc::c_char,
    1 as libc::c_int as libc::c_char,
    1 as libc::c_int as libc::c_char,
    1 as libc::c_int as libc::c_char,
    1 as libc::c_int as libc::c_char,
    1 as libc::c_int as libc::c_char,
    1 as libc::c_int as libc::c_char,
    0 as libc::c_int as libc::c_char,
    0 as libc::c_int as libc::c_char,
    1 as libc::c_int as libc::c_char,
    0 as libc::c_int as libc::c_char,
    0 as libc::c_int as libc::c_char,
    0 as libc::c_int as libc::c_char,
    1 as libc::c_int as libc::c_char,
    1 as libc::c_int as libc::c_char,
    0 as libc::c_int as libc::c_char,
    0 as libc::c_int as libc::c_char,
    0 as libc::c_int as libc::c_char,
    0 as libc::c_int as libc::c_char,
    0 as libc::c_int as libc::c_char,
    0 as libc::c_int as libc::c_char,
    0 as libc::c_int as libc::c_char,
    0 as libc::c_int as libc::c_char,
    0 as libc::c_int as libc::c_char,
    0 as libc::c_int as libc::c_char,
    0 as libc::c_int as libc::c_char,
    0 as libc::c_int as libc::c_char,
    0 as libc::c_int as libc::c_char,
    0 as libc::c_int as libc::c_char,
    0 as libc::c_int as libc::c_char,
    0 as libc::c_int as libc::c_char,
    0 as libc::c_int as libc::c_char,
    0 as libc::c_int as libc::c_char,
    0 as libc::c_int as libc::c_char,
    0 as libc::c_int as libc::c_char,
    1 as libc::c_int as libc::c_char,
    0 as libc::c_int as libc::c_char,
    1 as libc::c_int as libc::c_char,
    0 as libc::c_int as libc::c_char,
    0 as libc::c_int as libc::c_char,
    0 as libc::c_int as libc::c_char,
    0 as libc::c_int as libc::c_char,
    0 as libc::c_int as libc::c_char,
    0 as libc::c_int as libc::c_char,
    0 as libc::c_int as libc::c_char,
    0 as libc::c_int as libc::c_char,
    0 as libc::c_int as libc::c_char,
    0 as libc::c_int as libc::c_char,
    0 as libc::c_int as libc::c_char,
    0 as libc::c_int as libc::c_char,
    0 as libc::c_int as libc::c_char,
    0 as libc::c_int as libc::c_char,
    0 as libc::c_int as libc::c_char,
    0 as libc::c_int as libc::c_char,
    0 as libc::c_int as libc::c_char,
    0 as libc::c_int as libc::c_char,
    0 as libc::c_int as libc::c_char,
    0 as libc::c_int as libc::c_char,
    0 as libc::c_int as libc::c_char,
    0 as libc::c_int as libc::c_char,
    0 as libc::c_int as libc::c_char,
    0 as libc::c_int as libc::c_char,
    0 as libc::c_int as libc::c_char,
    0 as libc::c_int as libc::c_char,
    0 as libc::c_int as libc::c_char,
    0 as libc::c_int as libc::c_char,
    0 as libc::c_int as libc::c_char,
    0 as libc::c_int as libc::c_char,
    0 as libc::c_int as libc::c_char,
    0 as libc::c_int as libc::c_char,
    0 as libc::c_int as libc::c_char,
    1 as libc::c_int as libc::c_char,
    0 as libc::c_int as libc::c_char,
    0 as libc::c_int as libc::c_char,
    0 as libc::c_int as libc::c_char,
    0 as libc::c_int as libc::c_char,
    0 as libc::c_int as libc::c_char,
    0 as libc::c_int as libc::c_char,
    0 as libc::c_int as libc::c_char,
    0 as libc::c_int as libc::c_char,
    0 as libc::c_int as libc::c_char,
    0 as libc::c_int as libc::c_char,
    0 as libc::c_int as libc::c_char,
    0 as libc::c_int as libc::c_char,
    0 as libc::c_int as libc::c_char,
    0 as libc::c_int as libc::c_char,
    0 as libc::c_int as libc::c_char,
    0 as libc::c_int as libc::c_char,
    0 as libc::c_int as libc::c_char,
    0 as libc::c_int as libc::c_char,
    0 as libc::c_int as libc::c_char,
    0 as libc::c_int as libc::c_char,
    0 as libc::c_int as libc::c_char,
    0 as libc::c_int as libc::c_char,
    0 as libc::c_int as libc::c_char,
    0 as libc::c_int as libc::c_char,
    0 as libc::c_int as libc::c_char,
    0 as libc::c_int as libc::c_char,
    0 as libc::c_int as libc::c_char,
    0 as libc::c_int as libc::c_char,
    0 as libc::c_int as libc::c_char,
    0 as libc::c_int as libc::c_char,
    1 as libc::c_int as libc::c_char,
    0 as libc::c_int as libc::c_char,
    0 as libc::c_int as libc::c_char,
    0 as libc::c_int as libc::c_char,
    0 as libc::c_int as libc::c_char,
    0 as libc::c_int as libc::c_char,
    0 as libc::c_int as libc::c_char,
    0 as libc::c_int as libc::c_char,
    0 as libc::c_int as libc::c_char,
    0 as libc::c_int as libc::c_char,
    0 as libc::c_int as libc::c_char,
    0 as libc::c_int as libc::c_char,
    0 as libc::c_int as libc::c_char,
    0 as libc::c_int as libc::c_char,
    0 as libc::c_int as libc::c_char,
    0 as libc::c_int as libc::c_char,
    0 as libc::c_int as libc::c_char,
    0 as libc::c_int as libc::c_char,
    0 as libc::c_int as libc::c_char,
    0 as libc::c_int as libc::c_char,
    0 as libc::c_int as libc::c_char,
    0 as libc::c_int as libc::c_char,
    0 as libc::c_int as libc::c_char,
    0 as libc::c_int as libc::c_char,
    0 as libc::c_int as libc::c_char,
    0 as libc::c_int as libc::c_char,
    0 as libc::c_int as libc::c_char,
    0 as libc::c_int as libc::c_char,
    0 as libc::c_int as libc::c_char,
    0 as libc::c_int as libc::c_char,
    0 as libc::c_int as libc::c_char,
    0 as libc::c_int as libc::c_char,
    0 as libc::c_int as libc::c_char,
    0 as libc::c_int as libc::c_char,
    0 as libc::c_int as libc::c_char,
    0 as libc::c_int as libc::c_char,
    0 as libc::c_int as libc::c_char,
    0 as libc::c_int as libc::c_char,
    0 as libc::c_int as libc::c_char,
    0 as libc::c_int as libc::c_char,
    0 as libc::c_int as libc::c_char,
    0 as libc::c_int as libc::c_char,
    0 as libc::c_int as libc::c_char,
    0 as libc::c_int as libc::c_char,
    0 as libc::c_int as libc::c_char,
    0 as libc::c_int as libc::c_char,
    0 as libc::c_int as libc::c_char,
    0 as libc::c_int as libc::c_char,
    0 as libc::c_int as libc::c_char,
    0 as libc::c_int as libc::c_char,
    0 as libc::c_int as libc::c_char,
    0 as libc::c_int as libc::c_char,
    0 as libc::c_int as libc::c_char,
    0 as libc::c_int as libc::c_char,
    0 as libc::c_int as libc::c_char,
    0 as libc::c_int as libc::c_char,
    0 as libc::c_int as libc::c_char,
    0 as libc::c_int as libc::c_char,
    0 as libc::c_int as libc::c_char,
    0 as libc::c_int as libc::c_char,
    0 as libc::c_int as libc::c_char,
    0 as libc::c_int as libc::c_char,
    0 as libc::c_int as libc::c_char,
    0 as libc::c_int as libc::c_char,
    0 as libc::c_int as libc::c_char,
    0 as libc::c_int as libc::c_char,
    0 as libc::c_int as libc::c_char,
    0 as libc::c_int as libc::c_char,
    0 as libc::c_int as libc::c_char,
    0 as libc::c_int as libc::c_char,
    0 as libc::c_int as libc::c_char,
    0 as libc::c_int as libc::c_char,
    0 as libc::c_int as libc::c_char,
    0 as libc::c_int as libc::c_char,
    0 as libc::c_int as libc::c_char,
    0 as libc::c_int as libc::c_char,
    0 as libc::c_int as libc::c_char,
    0 as libc::c_int as libc::c_char,
    0 as libc::c_int as libc::c_char,
    0 as libc::c_int as libc::c_char,
    0 as libc::c_int as libc::c_char,
    0 as libc::c_int as libc::c_char,
    0 as libc::c_int as libc::c_char,
    0 as libc::c_int as libc::c_char,
    0 as libc::c_int as libc::c_char,
    0 as libc::c_int as libc::c_char,
    0 as libc::c_int as libc::c_char,
    0 as libc::c_int as libc::c_char,
    0 as libc::c_int as libc::c_char,
    0 as libc::c_int as libc::c_char,
    0 as libc::c_int as libc::c_char,
    0 as libc::c_int as libc::c_char,
    0 as libc::c_int as libc::c_char,
    0 as libc::c_int as libc::c_char,
    0 as libc::c_int as libc::c_char,
    0 as libc::c_int as libc::c_char,
    0 as libc::c_int as libc::c_char,
    0 as libc::c_int as libc::c_char,
    0 as libc::c_int as libc::c_char,
    0 as libc::c_int as libc::c_char,
    0 as libc::c_int as libc::c_char,
    0 as libc::c_int as libc::c_char,
    0 as libc::c_int as libc::c_char,
    0 as libc::c_int as libc::c_char,
    0 as libc::c_int as libc::c_char,
    0 as libc::c_int as libc::c_char,
    0 as libc::c_int as libc::c_char,
    0 as libc::c_int as libc::c_char,
    0 as libc::c_int as libc::c_char,
    0 as libc::c_int as libc::c_char,
    0 as libc::c_int as libc::c_char,
    0 as libc::c_int as libc::c_char,
    0 as libc::c_int as libc::c_char,
    0 as libc::c_int as libc::c_char,
    0 as libc::c_int as libc::c_char,
    0 as libc::c_int as libc::c_char,
    0 as libc::c_int as libc::c_char,
    0 as libc::c_int as libc::c_char,
    0 as libc::c_int as libc::c_char,
    0 as libc::c_int as libc::c_char,
    0 as libc::c_int as libc::c_char,
    0 as libc::c_int as libc::c_char,
    0 as libc::c_int as libc::c_char,
    0 as libc::c_int as libc::c_char,
    0 as libc::c_int as libc::c_char,
    0 as libc::c_int as libc::c_char,
    0 as libc::c_int as libc::c_char,
    0 as libc::c_int as libc::c_char,
    0 as libc::c_int as libc::c_char,
];
#[no_mangle]
pub unsafe extern "C" fn buffer_append_string_encoded(
    b: *mut buffer,
    s: *const libc::c_char,
    mut s_len: size_t,
    mut encoding: buffer_encoding_t,
) {
    let mut ds: *mut libc::c_uchar = 0 as *mut libc::c_uchar;
    let mut d: *mut libc::c_uchar = 0 as *mut libc::c_uchar;
    let mut d_len: size_t = 0;
    let mut ndx: size_t = 0;
    let mut map: *const libc::c_char = 0 as *const libc::c_char;
    match encoding as libc::c_uint {
        0 => {
            map = encoded_chars_rel_uri.as_ptr();
        }
        1 => {
            map = encoded_chars_rel_uri_part.as_ptr();
        }
        2 => {
            map = encoded_chars_html.as_ptr();
        }
        3 => {
            map = encoded_chars_minimal_xml.as_ptr();
        }
        _ => {}
    }
    ds = s as *mut libc::c_uchar;
    d_len = 0 as libc::c_int as size_t;
    ndx = 0 as libc::c_int as size_t;
    while ndx < s_len {
        if *map.offset((*ds as libc::c_int & 0xff as libc::c_int) as isize) != 0 {
            match encoding as libc::c_uint {
                0 | 1 => {
                    d_len = (d_len as libc::c_ulong).wrapping_add(3 as libc::c_int as libc::c_ulong)
                        as size_t as size_t;
                }
                2 | 3 => {
                    d_len = (d_len as libc::c_ulong).wrapping_add(6 as libc::c_int as libc::c_ulong)
                        as size_t as size_t;
                }
                _ => {}
            }
        } else {
            d_len = d_len.wrapping_add(1);
        }
        ds = ds.offset(1);
        ndx = ndx.wrapping_add(1);
    }
    d = buffer_extend(b, d_len) as *mut libc::c_uchar;
    if d_len == s_len {
        memcpy(d as *mut libc::c_void, s as *const libc::c_void, s_len);
        return;
    }
    ds = s as *mut libc::c_uchar;
    d_len = 0 as libc::c_int as size_t;
    ndx = 0 as libc::c_int as size_t;
    while ndx < s_len {
        if *map.offset((*ds as libc::c_int & 0xff as libc::c_int) as isize) != 0 {
            match encoding as libc::c_uint {
                0 | 1 => {
                    let fresh137 = d_len;
                    d_len = d_len.wrapping_add(1);
                    *d.offset(fresh137 as isize) = '%' as i32 as libc::c_uchar;
                    let fresh138 = d_len;
                    d_len = d_len.wrapping_add(1);
                    *d.offset(fresh138 as isize) = hex_chars_uc
                        [(*ds as libc::c_int >> 4 as libc::c_int & 0xf as libc::c_int) as usize]
                        as libc::c_uchar;
                    let fresh139 = d_len;
                    d_len = d_len.wrapping_add(1);
                    *d.offset(fresh139 as isize) = hex_chars_uc
                        [(*ds as libc::c_int & 0xf as libc::c_int) as usize]
                        as libc::c_uchar;
                }
                2 | 3 => {
                    let fresh140 = d_len;
                    d_len = d_len.wrapping_add(1);
                    *d.offset(fresh140 as isize) = '&' as i32 as libc::c_uchar;
                    let fresh141 = d_len;
                    d_len = d_len.wrapping_add(1);
                    *d.offset(fresh141 as isize) = '#' as i32 as libc::c_uchar;
                    let fresh142 = d_len;
                    d_len = d_len.wrapping_add(1);
                    *d.offset(fresh142 as isize) = 'x' as i32 as libc::c_uchar;
                    let fresh143 = d_len;
                    d_len = d_len.wrapping_add(1);
                    *d.offset(fresh143 as isize) = hex_chars_uc
                        [(*ds as libc::c_int >> 4 as libc::c_int & 0xf as libc::c_int) as usize]
                        as libc::c_uchar;
                    let fresh144 = d_len;
                    d_len = d_len.wrapping_add(1);
                    *d.offset(fresh144 as isize) = hex_chars_uc
                        [(*ds as libc::c_int & 0xf as libc::c_int) as usize]
                        as libc::c_uchar;
                    let fresh145 = d_len;
                    d_len = d_len.wrapping_add(1);
                    *d.offset(fresh145 as isize) = ';' as i32 as libc::c_uchar;
                }
                _ => {}
            }
        } else {
            let fresh146 = d_len;
            d_len = d_len.wrapping_add(1);
            *d.offset(fresh146 as isize) = *ds;
        }
        ds = ds.offset(1);
        ndx = ndx.wrapping_add(1);
    }
}
#[no_mangle]
pub unsafe extern "C" fn buffer_append_string_encoded_json(
    b: *mut buffer,
    s: *const libc::c_char,
    len: size_t,
) {
    let ds: *const libc::c_uchar = s as *mut libc::c_uchar;
    let mut dlen: size_t = 0 as libc::c_int as size_t;
    let mut i: size_t = 0 as libc::c_int as size_t;
    while i < len {
        let mut c: libc::c_int = *ds.offset(i as isize) as libc::c_int;
        if c == '"' as i32
            || c == '\\' as i32
            || c < 0x20 as libc::c_int
            || c == 0x7f as libc::c_int
        {
            match c {
                8 | 9 | 10 | 12 | 13 | 34 | 92 => {
                    dlen = (dlen as libc::c_ulong).wrapping_add(2 as libc::c_int as libc::c_ulong)
                        as size_t as size_t;
                }
                _ => {
                    dlen = (dlen as libc::c_ulong).wrapping_add(6 as libc::c_int as libc::c_ulong)
                        as size_t as size_t;
                }
            }
        } else {
            dlen = dlen.wrapping_add(1);
        }
        i = i.wrapping_add(1);
    }
    let d: *mut libc::c_uchar = buffer_extend(b, dlen) as *mut libc::c_uchar;
    if (dlen == len) as libc::c_int as libc::c_long != 0 {
        memcpy(d as *mut libc::c_void, ds as *const libc::c_void, len);
        return;
    }
    dlen = 0 as libc::c_int as size_t;
    let mut i_0: size_t = 0 as libc::c_int as size_t;
    while i_0 < len {
        let mut c_0: libc::c_int = *ds.offset(i_0 as isize) as libc::c_int;
        if c_0 == '"' as i32
            || c_0 == '\\' as i32
            || c_0 < 0x20 as libc::c_int
            || c_0 == 0x7f as libc::c_int
        {
            let fresh147 = dlen;
            dlen = dlen.wrapping_add(1);
            *d.offset(fresh147 as isize) = '\\' as i32 as libc::c_uchar;
            match c_0 {
                8 => {
                    let fresh148 = dlen;
                    dlen = dlen.wrapping_add(1);
                    *d.offset(fresh148 as isize) = 'b' as i32 as libc::c_uchar;
                }
                9 => {
                    let fresh149 = dlen;
                    dlen = dlen.wrapping_add(1);
                    *d.offset(fresh149 as isize) = 't' as i32 as libc::c_uchar;
                }
                10 => {
                    let fresh150 = dlen;
                    dlen = dlen.wrapping_add(1);
                    *d.offset(fresh150 as isize) = 'n' as i32 as libc::c_uchar;
                }
                12 => {
                    let fresh151 = dlen;
                    dlen = dlen.wrapping_add(1);
                    *d.offset(fresh151 as isize) = 'f' as i32 as libc::c_uchar;
                }
                13 => {
                    let fresh152 = dlen;
                    dlen = dlen.wrapping_add(1);
                    *d.offset(fresh152 as isize) = 'r' as i32 as libc::c_uchar;
                }
                34 => {
                    let fresh153 = dlen;
                    dlen = dlen.wrapping_add(1);
                    *d.offset(fresh153 as isize) = '"' as i32 as libc::c_uchar;
                }
                92 => {
                    let fresh154 = dlen;
                    dlen = dlen.wrapping_add(1);
                    *d.offset(fresh154 as isize) = '\\' as i32 as libc::c_uchar;
                }
                _ => {
                    *d.offset(dlen as isize) = 'u' as i32 as libc::c_uchar;
                    *d.offset(dlen.wrapping_add(1 as libc::c_int as libc::c_ulong) as isize) =
                        '0' as i32 as libc::c_uchar;
                    *d.offset(dlen.wrapping_add(2 as libc::c_int as libc::c_ulong) as isize) =
                        '0' as i32 as libc::c_uchar;
                    *d.offset(dlen.wrapping_add(3 as libc::c_int as libc::c_ulong) as isize) =
                        hex_chars_lc[(c_0 >> 4 as libc::c_int & 0xf as libc::c_int) as usize]
                            as libc::c_uchar;
                    *d.offset(dlen.wrapping_add(4 as libc::c_int as libc::c_ulong) as isize) =
                        hex_chars_lc[(c_0 & 0xf as libc::c_int) as usize] as libc::c_uchar;
                    dlen = (dlen as libc::c_ulong).wrapping_add(5 as libc::c_int as libc::c_ulong)
                        as size_t as size_t;
                }
            }
        } else {
            let fresh155 = dlen;
            dlen = dlen.wrapping_add(1);
            *d.offset(fresh155 as isize) = c_0 as libc::c_uchar;
        }
        i_0 = i_0.wrapping_add(1);
    }
}
#[no_mangle]
pub unsafe extern "C" fn buffer_append_string_c_escaped(
    b: *mut buffer,
    s: *const libc::c_char,
    mut s_len: size_t,
) {
    let mut ds: *mut libc::c_uchar = 0 as *mut libc::c_uchar;
    let mut d: *mut libc::c_uchar = 0 as *mut libc::c_uchar;
    let mut d_len: size_t = 0;
    let mut ndx: size_t = 0;
    ds = s as *mut libc::c_uchar;
    d_len = 0 as libc::c_int as size_t;
    ndx = 0 as libc::c_int as size_t;
    while ndx < s_len {
        if (*ds as libc::c_int) < 0x20 as libc::c_int || *ds as libc::c_int >= 0x7f as libc::c_int {
            match *ds as libc::c_int {
                9 | 13 | 10 => {
                    d_len = (d_len as libc::c_ulong).wrapping_add(2 as libc::c_int as libc::c_ulong)
                        as size_t as size_t;
                }
                _ => {
                    d_len = (d_len as libc::c_ulong).wrapping_add(4 as libc::c_int as libc::c_ulong)
                        as size_t as size_t;
                }
            }
        } else {
            d_len = d_len.wrapping_add(1);
        }
        ds = ds.offset(1);
        ndx = ndx.wrapping_add(1);
    }
    d = buffer_extend(b, d_len) as *mut libc::c_uchar;
    if d_len == s_len {
        memcpy(d as *mut libc::c_void, s as *const libc::c_void, s_len);
        return;
    }
    ds = s as *mut libc::c_uchar;
    d_len = 0 as libc::c_int as size_t;
    ndx = 0 as libc::c_int as size_t;
    while ndx < s_len {
        if (*ds as libc::c_int) < 0x20 as libc::c_int || *ds as libc::c_int >= 0x7f as libc::c_int {
            let fresh156 = d_len;
            d_len = d_len.wrapping_add(1);
            *d.offset(fresh156 as isize) = '\\' as i32 as libc::c_uchar;
            match *ds as libc::c_int {
                9 => {
                    let fresh157 = d_len;
                    d_len = d_len.wrapping_add(1);
                    *d.offset(fresh157 as isize) = 't' as i32 as libc::c_uchar;
                }
                13 => {
                    let fresh158 = d_len;
                    d_len = d_len.wrapping_add(1);
                    *d.offset(fresh158 as isize) = 'r' as i32 as libc::c_uchar;
                }
                10 => {
                    let fresh159 = d_len;
                    d_len = d_len.wrapping_add(1);
                    *d.offset(fresh159 as isize) = 'n' as i32 as libc::c_uchar;
                }
                _ => {
                    let fresh160 = d_len;
                    d_len = d_len.wrapping_add(1);
                    *d.offset(fresh160 as isize) = 'x' as i32 as libc::c_uchar;
                    let fresh161 = d_len;
                    d_len = d_len.wrapping_add(1);
                    *d.offset(fresh161 as isize) = hex_chars_lc
                        [(*ds as libc::c_int >> 4 as libc::c_int & 0xf as libc::c_int) as usize]
                        as libc::c_uchar;
                    let fresh162 = d_len;
                    d_len = d_len.wrapping_add(1);
                    *d.offset(fresh162 as isize) = hex_chars_lc
                        [(*ds as libc::c_int & 0xf as libc::c_int) as usize]
                        as libc::c_uchar;
                }
            }
        } else {
            let fresh163 = d_len;
            d_len = d_len.wrapping_add(1);
            *d.offset(fresh163 as isize) = *ds;
        }
        ds = ds.offset(1);
        ndx = ndx.wrapping_add(1);
    }
}
#[no_mangle]
pub unsafe extern "C" fn buffer_urldecode_path(b: *mut buffer) {
    let len: size_t = buffer_clen(b) as size_t;
    let mut src: *mut libc::c_char = (if len != 0 {
        memchr((*b).ptr as *const libc::c_void, '%' as i32, len)
    } else {
        0 as *mut libc::c_void
    }) as *mut libc::c_char;
    if src.is_null() {
        return;
    }
    let mut dst: *mut libc::c_char = src;
    loop {
        let mut high: libc::c_uchar =
            *(src as *mut libc::c_uchar).offset(1 as libc::c_int as isize);
        let mut low: libc::c_uchar = (if high as libc::c_int != 0 {
            hex2int(*(src as *mut libc::c_uchar).offset(2 as libc::c_int as isize)) as libc::c_int
        } else {
            0xff as libc::c_int
        }) as libc::c_uchar;
        high = hex2int(high) as libc::c_uchar;
        if 0xff as libc::c_int != high as libc::c_int && 0xff as libc::c_int != low as libc::c_int {
            high =
                ((high as libc::c_int) << 4 as libc::c_int | low as libc::c_int) as libc::c_uchar;
            *dst = (if high as libc::c_int >= 32 as libc::c_int
                && high as libc::c_int != 127 as libc::c_int
            {
                high as libc::c_int
            } else {
                '_' as i32
            }) as libc::c_char;
            src = src.offset(2 as libc::c_int as isize);
        }
        loop {
            src = src.offset(1);
            dst = dst.offset(1);
            *dst = *src;
            if !(*dst as libc::c_int != '%' as i32 && *src as libc::c_int != 0) {
                break;
            }
        }
        if !(*src != 0) {
            break;
        }
    }
    (*b).used =
        (dst.offset_from((*b).ptr) as libc::c_long + 1 as libc::c_int as libc::c_long) as uint32_t;
}
#[no_mangle]
pub unsafe extern "C" fn buffer_is_valid_UTF8(mut b: *const buffer) -> libc::c_int {
    let mut c: *const libc::c_uchar = (*b).ptr as *mut libc::c_uchar;
    while *c != 0 {
        if (*c.offset(0 as libc::c_int as isize) as libc::c_int) < 0x80 as libc::c_int {
            c = c.offset(1);
        } else if 0xc2 as libc::c_int <= *c.offset(0 as libc::c_int as isize) as libc::c_int
            && *c.offset(0 as libc::c_int as isize) as libc::c_int <= 0xdf as libc::c_int
            && 0x80 as libc::c_int <= *c.offset(1 as libc::c_int as isize) as libc::c_int
            && *c.offset(1 as libc::c_int as isize) as libc::c_int <= 0xbf as libc::c_int
        {
            c = c.offset(2 as libc::c_int as isize);
        } else if (0xe0 as libc::c_int == *c.offset(0 as libc::c_int as isize) as libc::c_int
            && 0xa0 as libc::c_int <= *c.offset(1 as libc::c_int as isize) as libc::c_int
            && *c.offset(1 as libc::c_int as isize) as libc::c_int <= 0xbf as libc::c_int
            || 0xe1 as libc::c_int <= *c.offset(0 as libc::c_int as isize) as libc::c_int
                && *c.offset(0 as libc::c_int as isize) as libc::c_int <= 0xef as libc::c_int
                && *c.offset(0 as libc::c_int as isize) as libc::c_int != 0xed as libc::c_int
                && 0x80 as libc::c_int <= *c.offset(1 as libc::c_int as isize) as libc::c_int
                && *c.offset(1 as libc::c_int as isize) as libc::c_int <= 0xbf as libc::c_int
            || 0xed as libc::c_int == *c.offset(0 as libc::c_int as isize) as libc::c_int
                && 0x80 as libc::c_int <= *c.offset(1 as libc::c_int as isize) as libc::c_int
                && *c.offset(1 as libc::c_int as isize) as libc::c_int <= 0x9f as libc::c_int)
            && 0x80 as libc::c_int <= *c.offset(2 as libc::c_int as isize) as libc::c_int
            && *c.offset(2 as libc::c_int as isize) as libc::c_int <= 0xbf as libc::c_int
        {
            c = c.offset(3 as libc::c_int as isize);
        } else if (0xf0 as libc::c_int == *c.offset(0 as libc::c_int as isize) as libc::c_int
            && 0x90 as libc::c_int <= *c.offset(1 as libc::c_int as isize) as libc::c_int
            && *c.offset(1 as libc::c_int as isize) as libc::c_int <= 0xbf as libc::c_int
            || 0xf1 as libc::c_int <= *c.offset(0 as libc::c_int as isize) as libc::c_int
                && *c.offset(0 as libc::c_int as isize) as libc::c_int <= 0xf3 as libc::c_int
                && 0x80 as libc::c_int <= *c.offset(1 as libc::c_int as isize) as libc::c_int
                && *c.offset(1 as libc::c_int as isize) as libc::c_int <= 0xbf as libc::c_int
            || 0xf4 as libc::c_int == *c.offset(0 as libc::c_int as isize) as libc::c_int
                && 0x80 as libc::c_int <= *c.offset(1 as libc::c_int as isize) as libc::c_int
                && *c.offset(1 as libc::c_int as isize) as libc::c_int <= 0x8f as libc::c_int)
            && 0x80 as libc::c_int <= *c.offset(2 as libc::c_int as isize) as libc::c_int
            && *c.offset(2 as libc::c_int as isize) as libc::c_int <= 0xbf as libc::c_int
            && 0x80 as libc::c_int <= *c.offset(3 as libc::c_int as isize) as libc::c_int
            && *c.offset(3 as libc::c_int as isize) as libc::c_int <= 0xbf as libc::c_int
        {
            c = c.offset(4 as libc::c_int as isize);
        } else {
            return 0 as libc::c_int;
        }
    }
    return 1 as libc::c_int;
}
#[no_mangle]
pub unsafe extern "C" fn buffer_path_simplify(mut b: *mut buffer) {
    let mut out: *mut libc::c_char = (*b).ptr;
    let end: *mut libc::c_char = ((*b).ptr)
        .offset((*b).used as isize)
        .offset(-(1 as libc::c_int as isize));
    if buffer_is_blank(b) as libc::c_long != 0 {
        buffer_blank(b);
        return;
    }
    *end = '/' as i32 as libc::c_char;
    let mut walk: *mut libc::c_char = out;
    if (*walk as libc::c_int == '/' as i32) as libc::c_int as libc::c_long != 0 {
        loop {
            walk = walk.offset(1);
            if *walk as libc::c_int == '.' as i32 || *walk as libc::c_int == '/' as i32 {
                break;
            }
            loop {
                walk = walk.offset(1);
                if !(*walk as libc::c_int != '/' as i32) {
                    break;
                }
            }
            if !(walk != end) {
                break;
            }
        }
        if (walk == end) as libc::c_int as libc::c_long != 0 {
            *end = '\0' as i32 as libc::c_char;
            return;
        }
        out = walk.offset(-(1 as libc::c_int as isize));
    } else {
        if *walk.offset(0 as libc::c_int as isize) as libc::c_int == '.' as i32
            && *walk.offset(1 as libc::c_int as isize) as libc::c_int == '/' as i32
        {
            walk = walk.offset(1);
            *out = *walk;
        } else if *walk.offset(0 as libc::c_int as isize) as libc::c_int == '.' as i32
            && *walk.offset(1 as libc::c_int as isize) as libc::c_int == '.' as i32
            && *walk.offset(2 as libc::c_int as isize) as libc::c_int == '/' as i32
        {
            walk = walk.offset(2 as libc::c_int as isize);
            *out = *walk;
        } else {
            loop {
                walk = walk.offset(1);
                if !(*walk as libc::c_int != '/' as i32) {
                    break;
                }
            }
            out = walk;
        }
        walk = walk.offset(1);
    }
    while walk <= end {
        if (*walk.offset(0 as libc::c_int as isize) as libc::c_int == '/' as i32) as libc::c_int
            as libc::c_long
            != 0
        {
            walk = walk.offset(1);
            if walk < end {
                continue;
            }
            out = out.offset(1);
            break;
        } else {
            if (*walk.offset(0 as libc::c_int as isize) as libc::c_int == '.' as i32) as libc::c_int
                as libc::c_long
                != 0
            {
                if *walk.offset(1 as libc::c_int as isize) as libc::c_int == '.' as i32
                    && *walk.offset(2 as libc::c_int as isize) as libc::c_int == '/' as i32
                {
                    while out > (*b).ptr && {
                        out = out.offset(-1);
                        *out as libc::c_int != '/' as i32
                    } {}
                    *out = '/' as i32 as libc::c_char;
                    walk = walk.offset(3 as libc::c_int as isize);
                    if !(walk >= end) {
                        continue;
                    }
                    out = out.offset(1);
                    break;
                } else if *walk.offset(1 as libc::c_int as isize) as libc::c_int == '/' as i32 {
                    walk = walk.offset(2 as libc::c_int as isize);
                    if !(walk >= end) {
                        continue;
                    }
                    out = out.offset(1);
                    break;
                } else {
                    out = out.offset(1);
                    *out = '.' as i32 as libc::c_char;
                    walk = walk.offset(1);
                }
            }
            loop {
                let fresh164 = walk;
                walk = walk.offset(1);
                out = out.offset(1);
                *out = *fresh164;
                if !(*out as libc::c_int != '/' as i32) {
                    break;
                }
            }
        }
    }
    *end = '\0' as i32 as libc::c_char;
    *out = *end;
    (*b).used =
        (out.offset_from((*b).ptr) as libc::c_long + 1 as libc::c_int as libc::c_long) as uint32_t;
}
#[no_mangle]
pub unsafe extern "C" fn buffer_to_lower(b: *mut buffer) {
    let s: *mut libc::c_uchar = (*b).ptr as *mut libc::c_uchar;
    let used: uint_fast32_t = (*b).used as uint_fast32_t;
    let mut i: uint_fast32_t = 0 as libc::c_int as uint_fast32_t;
    while i < used {
        if (*s.offset(i as isize) as uint32_t).wrapping_sub('A' as i32 as libc::c_uint)
            <= ('Z' as i32 - 'A' as i32) as libc::c_uint
        {
            let ref mut fresh165 = *s.offset(i as isize);
            *fresh165 = (*fresh165 as libc::c_int | 0x20 as libc::c_int) as libc::c_uchar;
        }
        i = i.wrapping_add(1);
    }
}
#[no_mangle]
pub unsafe extern "C" fn buffer_to_upper(b: *mut buffer) {
    let s: *mut libc::c_uchar = (*b).ptr as *mut libc::c_uchar;
    let used: uint_fast32_t = (*b).used as uint_fast32_t;
    let mut i: uint_fast32_t = 0 as libc::c_int as uint_fast32_t;
    while i < used {
        if (*s.offset(i as isize) as uint32_t).wrapping_sub('a' as i32 as libc::c_uint)
            <= ('z' as i32 - 'a' as i32) as libc::c_uint
        {
            let ref mut fresh166 = *s.offset(i as isize);
            *fresh166 = (*fresh166 as libc::c_int & 0xdf as libc::c_int) as libc::c_uchar;
        }
        i = i.wrapping_add(1);
    }
}
static mut encoded_chars_http_uri_reqd: [libc::c_char; 256] = [
    1 as libc::c_int as libc::c_char,
    1 as libc::c_int as libc::c_char,
    1 as libc::c_int as libc::c_char,
    1 as libc::c_int as libc::c_char,
    1 as libc::c_int as libc::c_char,
    1 as libc::c_int as libc::c_char,
    1 as libc::c_int as libc::c_char,
    1 as libc::c_int as libc::c_char,
    1 as libc::c_int as libc::c_char,
    1 as libc::c_int as libc::c_char,
    1 as libc::c_int as libc::c_char,
    1 as libc::c_int as libc::c_char,
    1 as libc::c_int as libc::c_char,
    1 as libc::c_int as libc::c_char,
    1 as libc::c_int as libc::c_char,
    1 as libc::c_int as libc::c_char,
    1 as libc::c_int as libc::c_char,
    1 as libc::c_int as libc::c_char,
    1 as libc::c_int as libc::c_char,
    1 as libc::c_int as libc::c_char,
    1 as libc::c_int as libc::c_char,
    1 as libc::c_int as libc::c_char,
    1 as libc::c_int as libc::c_char,
    1 as libc::c_int as libc::c_char,
    1 as libc::c_int as libc::c_char,
    1 as libc::c_int as libc::c_char,
    1 as libc::c_int as libc::c_char,
    1 as libc::c_int as libc::c_char,
    1 as libc::c_int as libc::c_char,
    1 as libc::c_int as libc::c_char,
    1 as libc::c_int as libc::c_char,
    1 as libc::c_int as libc::c_char,
    1 as libc::c_int as libc::c_char,
    0 as libc::c_int as libc::c_char,
    1 as libc::c_int as libc::c_char,
    1 as libc::c_int as libc::c_char,
    0 as libc::c_int as libc::c_char,
    1 as libc::c_int as libc::c_char,
    0 as libc::c_int as libc::c_char,
    0 as libc::c_int as libc::c_char,
    0 as libc::c_int as libc::c_char,
    0 as libc::c_int as libc::c_char,
    0 as libc::c_int as libc::c_char,
    0 as libc::c_int as libc::c_char,
    0 as libc::c_int as libc::c_char,
    0 as libc::c_int as libc::c_char,
    0 as libc::c_int as libc::c_char,
    0 as libc::c_int as libc::c_char,
    0 as libc::c_int as libc::c_char,
    0 as libc::c_int as libc::c_char,
    0 as libc::c_int as libc::c_char,
    0 as libc::c_int as libc::c_char,
    0 as libc::c_int as libc::c_char,
    0 as libc::c_int as libc::c_char,
    0 as libc::c_int as libc::c_char,
    0 as libc::c_int as libc::c_char,
    0 as libc::c_int as libc::c_char,
    0 as libc::c_int as libc::c_char,
    0 as libc::c_int as libc::c_char,
    0 as libc::c_int as libc::c_char,
    1 as libc::c_int as libc::c_char,
    0 as libc::c_int as libc::c_char,
    1 as libc::c_int as libc::c_char,
    0 as libc::c_int as libc::c_char,
    0 as libc::c_int as libc::c_char,
    0 as libc::c_int as libc::c_char,
    0 as libc::c_int as libc::c_char,
    0 as libc::c_int as libc::c_char,
    0 as libc::c_int as libc::c_char,
    0 as libc::c_int as libc::c_char,
    0 as libc::c_int as libc::c_char,
    0 as libc::c_int as libc::c_char,
    0 as libc::c_int as libc::c_char,
    0 as libc::c_int as libc::c_char,
    0 as libc::c_int as libc::c_char,
    0 as libc::c_int as libc::c_char,
    0 as libc::c_int as libc::c_char,
    0 as libc::c_int as libc::c_char,
    0 as libc::c_int as libc::c_char,
    0 as libc::c_int as libc::c_char,
    0 as libc::c_int as libc::c_char,
    0 as libc::c_int as libc::c_char,
    0 as libc::c_int as libc::c_char,
    0 as libc::c_int as libc::c_char,
    0 as libc::c_int as libc::c_char,
    0 as libc::c_int as libc::c_char,
    0 as libc::c_int as libc::c_char,
    0 as libc::c_int as libc::c_char,
    0 as libc::c_int as libc::c_char,
    0 as libc::c_int as libc::c_char,
    0 as libc::c_int as libc::c_char,
    1 as libc::c_int as libc::c_char,
    1 as libc::c_int as libc::c_char,
    1 as libc::c_int as libc::c_char,
    1 as libc::c_int as libc::c_char,
    0 as libc::c_int as libc::c_char,
    1 as libc::c_int as libc::c_char,
    0 as libc::c_int as libc::c_char,
    0 as libc::c_int as libc::c_char,
    0 as libc::c_int as libc::c_char,
    0 as libc::c_int as libc::c_char,
    0 as libc::c_int as libc::c_char,
    0 as libc::c_int as libc::c_char,
    0 as libc::c_int as libc::c_char,
    0 as libc::c_int as libc::c_char,
    0 as libc::c_int as libc::c_char,
    0 as libc::c_int as libc::c_char,
    0 as libc::c_int as libc::c_char,
    0 as libc::c_int as libc::c_char,
    0 as libc::c_int as libc::c_char,
    0 as libc::c_int as libc::c_char,
    0 as libc::c_int as libc::c_char,
    0 as libc::c_int as libc::c_char,
    0 as libc::c_int as libc::c_char,
    0 as libc::c_int as libc::c_char,
    0 as libc::c_int as libc::c_char,
    0 as libc::c_int as libc::c_char,
    0 as libc::c_int as libc::c_char,
    0 as libc::c_int as libc::c_char,
    0 as libc::c_int as libc::c_char,
    0 as libc::c_int as libc::c_char,
    0 as libc::c_int as libc::c_char,
    0 as libc::c_int as libc::c_char,
    1 as libc::c_int as libc::c_char,
    1 as libc::c_int as libc::c_char,
    1 as libc::c_int as libc::c_char,
    0 as libc::c_int as libc::c_char,
    1 as libc::c_int as libc::c_char,
    1 as libc::c_int as libc::c_char,
    1 as libc::c_int as libc::c_char,
    1 as libc::c_int as libc::c_char,
    1 as libc::c_int as libc::c_char,
    1 as libc::c_int as libc::c_char,
    1 as libc::c_int as libc::c_char,
    1 as libc::c_int as libc::c_char,
    1 as libc::c_int as libc::c_char,
    1 as libc::c_int as libc::c_char,
    1 as libc::c_int as libc::c_char,
    1 as libc::c_int as libc::c_char,
    1 as libc::c_int as libc::c_char,
    1 as libc::c_int as libc::c_char,
    1 as libc::c_int as libc::c_char,
    1 as libc::c_int as libc::c_char,
    1 as libc::c_int as libc::c_char,
    1 as libc::c_int as libc::c_char,
    1 as libc::c_int as libc::c_char,
    1 as libc::c_int as libc::c_char,
    1 as libc::c_int as libc::c_char,
    1 as libc::c_int as libc::c_char,
    1 as libc::c_int as libc::c_char,
    1 as libc::c_int as libc::c_char,
    1 as libc::c_int as libc::c_char,
    1 as libc::c_int as libc::c_char,
    1 as libc::c_int as libc::c_char,
    1 as libc::c_int as libc::c_char,
    1 as libc::c_int as libc::c_char,
    1 as libc::c_int as libc::c_char,
    1 as libc::c_int as libc::c_char,
    1 as libc::c_int as libc::c_char,
    1 as libc::c_int as libc::c_char,
    1 as libc::c_int as libc::c_char,
    1 as libc::c_int as libc::c_char,
    1 as libc::c_int as libc::c_char,
    1 as libc::c_int as libc::c_char,
    1 as libc::c_int as libc::c_char,
    1 as libc::c_int as libc::c_char,
    1 as libc::c_int as libc::c_char,
    1 as libc::c_int as libc::c_char,
    1 as libc::c_int as libc::c_char,
    1 as libc::c_int as libc::c_char,
    1 as libc::c_int as libc::c_char,
    1 as libc::c_int as libc::c_char,
    1 as libc::c_int as libc::c_char,
    1 as libc::c_int as libc::c_char,
    1 as libc::c_int as libc::c_char,
    1 as libc::c_int as libc::c_char,
    1 as libc::c_int as libc::c_char,
    1 as libc::c_int as libc::c_char,
    1 as libc::c_int as libc::c_char,
    1 as libc::c_int as libc::c_char,
    1 as libc::c_int as libc::c_char,
    1 as libc::c_int as libc::c_char,
    1 as libc::c_int as libc::c_char,
    1 as libc::c_int as libc::c_char,
    1 as libc::c_int as libc::c_char,
    1 as libc::c_int as libc::c_char,
    1 as libc::c_int as libc::c_char,
    1 as libc::c_int as libc::c_char,
    1 as libc::c_int as libc::c_char,
    1 as libc::c_int as libc::c_char,
    1 as libc::c_int as libc::c_char,
    1 as libc::c_int as libc::c_char,
    1 as libc::c_int as libc::c_char,
    1 as libc::c_int as libc::c_char,
    1 as libc::c_int as libc::c_char,
    1 as libc::c_int as libc::c_char,
    1 as libc::c_int as libc::c_char,
    1 as libc::c_int as libc::c_char,
    1 as libc::c_int as libc::c_char,
    1 as libc::c_int as libc::c_char,
    1 as libc::c_int as libc::c_char,
    1 as libc::c_int as libc::c_char,
    1 as libc::c_int as libc::c_char,
    1 as libc::c_int as libc::c_char,
    1 as libc::c_int as libc::c_char,
    1 as libc::c_int as libc::c_char,
    1 as libc::c_int as libc::c_char,
    1 as libc::c_int as libc::c_char,
    1 as libc::c_int as libc::c_char,
    1 as libc::c_int as libc::c_char,
    1 as libc::c_int as libc::c_char,
    1 as libc::c_int as libc::c_char,
    1 as libc::c_int as libc::c_char,
    1 as libc::c_int as libc::c_char,
    1 as libc::c_int as libc::c_char,
    1 as libc::c_int as libc::c_char,
    1 as libc::c_int as libc::c_char,
    1 as libc::c_int as libc::c_char,
    1 as libc::c_int as libc::c_char,
    1 as libc::c_int as libc::c_char,
    1 as libc::c_int as libc::c_char,
    1 as libc::c_int as libc::c_char,
    1 as libc::c_int as libc::c_char,
    1 as libc::c_int as libc::c_char,
    1 as libc::c_int as libc::c_char,
    1 as libc::c_int as libc::c_char,
    1 as libc::c_int as libc::c_char,
    1 as libc::c_int as libc::c_char,
    1 as libc::c_int as libc::c_char,
    1 as libc::c_int as libc::c_char,
    1 as libc::c_int as libc::c_char,
    1 as libc::c_int as libc::c_char,
    1 as libc::c_int as libc::c_char,
    1 as libc::c_int as libc::c_char,
    1 as libc::c_int as libc::c_char,
    1 as libc::c_int as libc::c_char,
    1 as libc::c_int as libc::c_char,
    1 as libc::c_int as libc::c_char,
    1 as libc::c_int as libc::c_char,
    1 as libc::c_int as libc::c_char,
    1 as libc::c_int as libc::c_char,
    1 as libc::c_int as libc::c_char,
    1 as libc::c_int as libc::c_char,
    1 as libc::c_int as libc::c_char,
    1 as libc::c_int as libc::c_char,
    1 as libc::c_int as libc::c_char,
    1 as libc::c_int as libc::c_char,
    1 as libc::c_int as libc::c_char,
    1 as libc::c_int as libc::c_char,
    1 as libc::c_int as libc::c_char,
    1 as libc::c_int as libc::c_char,
    1 as libc::c_int as libc::c_char,
    1 as libc::c_int as libc::c_char,
    1 as libc::c_int as libc::c_char,
    1 as libc::c_int as libc::c_char,
    1 as libc::c_int as libc::c_char,
];
unsafe extern "C" fn burl_is_unreserved(c: libc::c_int) -> libc::c_int {
    return (light_isalnum(c) != 0
        || c == '-' as i32
        || c == '.' as i32
        || c == '_' as i32
        || c == '~' as i32) as libc::c_int;
}
unsafe extern "C" fn burl_normalize_basic_unreserved_fix(
    mut b: *mut buffer,
    mut t: *mut buffer,
    mut i: libc::c_int,
    mut qs: libc::c_int,
) -> libc::c_int {
    let mut j: libc::c_int = i;
    let used: libc::c_int = buffer_clen(b) as libc::c_int;
    let s: *const libc::c_uchar = (*b).ptr as *mut libc::c_uchar;
    let p: *mut libc::c_uchar = buffer_string_prepare_copy(
        t,
        (i + (used - i) * 3 as libc::c_int + 1 as libc::c_int) as size_t,
    ) as *mut libc::c_uchar;
    let mut n1: libc::c_uint = 0;
    let mut n2: libc::c_uint = 0;
    memcpy(
        p as *mut libc::c_void,
        s as *const libc::c_void,
        i as size_t,
    );
    while i < used {
        if encoded_chars_http_uri_reqd[*s.offset(i as isize) as usize] == 0 {
            if *s.offset(i as isize) as libc::c_int == '?' as i32 && -(1 as libc::c_int) == qs {
                qs = j;
            }
            *p.offset(j as isize) = *s.offset(i as isize);
        } else if *s.offset(i as isize) as libc::c_int == '%' as i32
            && {
                n1 = (*s.offset((i + 1 as libc::c_int) as isize) as libc::c_int - '0' as i32)
                    as libc::c_uint;
                n1 <= 9 as libc::c_int as libc::c_uint || {
                    n1 = ((*s.offset((i + 1 as libc::c_int) as isize) as libc::c_int
                        & 0xdf as libc::c_int)
                        - 'A' as i32) as libc::c_uint;
                    (if n1 <= 5 as libc::c_int as libc::c_uint {
                        n1 = n1.wrapping_add(10 as libc::c_int as libc::c_uint);
                        n1
                    } else {
                        0 as libc::c_int as libc::c_uint
                    }) != 0
                }
            }
            && {
                n2 = (*s.offset((i + 2 as libc::c_int) as isize) as libc::c_int - '0' as i32)
                    as libc::c_uint;
                n2 <= 9 as libc::c_int as libc::c_uint || {
                    n2 = ((*s.offset((i + 2 as libc::c_int) as isize) as libc::c_int
                        & 0xdf as libc::c_int)
                        - 'A' as i32) as libc::c_uint;
                    (if n2 <= 5 as libc::c_int as libc::c_uint {
                        n2 = n2.wrapping_add(10 as libc::c_int as libc::c_uint);
                        n2
                    } else {
                        0 as libc::c_int as libc::c_uint
                    }) != 0
                }
            }
        {
            let x: libc::c_uint = n1 << 4 as libc::c_int | n2;
            if burl_is_unreserved(x as libc::c_int) != 0 {
                *p.offset(j as isize) = x as libc::c_uchar;
            } else {
                *p.offset(j as isize) = '%' as i32 as libc::c_uchar;
                j += 1;
                *p.offset(j as isize) = hex_chars_uc[n1 as usize] as libc::c_uchar;
                j += 1;
                *p.offset(j as isize) = hex_chars_uc[n2 as usize] as libc::c_uchar;
                if x >= 0xf5 as libc::c_int as libc::c_uint
                    || x | 0x1 as libc::c_int as libc::c_uint == 0xc1 as libc::c_int as libc::c_uint
                {
                    qs = -(2 as libc::c_int);
                }
            }
            i += 2 as libc::c_int;
        } else {
            if *s.offset(i as isize) as libc::c_int == '#' as i32 {
                break;
            }
            *p.offset(j as isize) = '%' as i32 as libc::c_uchar;
            j += 1;
            *p.offset(j as isize) =
                hex_chars_uc[(*s.offset(i as isize) as libc::c_int >> 4 as libc::c_int
                    & 0xf as libc::c_int) as usize] as libc::c_uchar;
            j += 1;
            *p.offset(j as isize) = hex_chars_uc
                [(*s.offset(i as isize) as libc::c_int & 0xf as libc::c_int) as usize]
                as libc::c_uchar;
            if *s.offset(i as isize) as libc::c_int >= 0xf5 as libc::c_int
                || *s.offset(i as isize) as libc::c_int | 0x1 as libc::c_int == 0xc1 as libc::c_int
            {
                qs = -(2 as libc::c_int);
            }
        }
        i += 1;
        j += 1;
    }
    buffer_copy_string_len(b, p as *mut libc::c_char, j as size_t);
    return qs;
}
unsafe extern "C" fn burl_normalize_basic_unreserved(
    mut b: *mut buffer,
    mut t: *mut buffer,
) -> libc::c_int {
    let s: *const libc::c_uchar = (*b).ptr as *mut libc::c_uchar;
    let used: libc::c_int = buffer_clen(b) as libc::c_int;
    let mut n1: libc::c_uint = 0;
    let mut n2: libc::c_uint = 0;
    let mut x: libc::c_uint = 0;
    let mut qs: libc::c_int = -(1 as libc::c_int);
    let mut i: libc::c_int = 0 as libc::c_int;
    while i < used {
        if encoded_chars_http_uri_reqd[*s.offset(i as isize) as usize] == 0 {
            if *s.offset(i as isize) as libc::c_int == '?' as i32 && -(1 as libc::c_int) == qs {
                qs = i;
            }
        } else if *s.offset(i as isize) as libc::c_int == '%' as i32
            && {
                n1 = (*s.offset((i + 1 as libc::c_int) as isize) as libc::c_int - '0' as i32)
                    as libc::c_uint;
                n1 <= 9 as libc::c_int as libc::c_uint || {
                    n1 = ((*s.offset((i + 1 as libc::c_int) as isize) as libc::c_int
                        & 0xdf as libc::c_int)
                        - 'A' as i32) as libc::c_uint;
                    (if n1 <= 5 as libc::c_int as libc::c_uint {
                        n1 = n1.wrapping_add(10 as libc::c_int as libc::c_uint);
                        n1
                    } else {
                        0 as libc::c_int as libc::c_uint
                    }) != 0
                }
            }
            && {
                n2 = (*s.offset((i + 2 as libc::c_int) as isize) as libc::c_int - '0' as i32)
                    as libc::c_uint;
                n2 <= 9 as libc::c_int as libc::c_uint || {
                    n2 = ((*s.offset((i + 2 as libc::c_int) as isize) as libc::c_int
                        & 0xdf as libc::c_int)
                        - 'A' as i32) as libc::c_uint;
                    (if n2 <= 5 as libc::c_int as libc::c_uint {
                        n2 = n2.wrapping_add(10 as libc::c_int as libc::c_uint);
                        n2
                    } else {
                        0 as libc::c_int as libc::c_uint
                    }) != 0
                }
            }
            && {
                x = n1 << 4 as libc::c_int | n2;
                burl_is_unreserved(x as libc::c_int) == 0
            }
        {
            if x >= 0xf5 as libc::c_int as libc::c_uint
                || x | 0x1 as libc::c_int as libc::c_uint == 0xc1 as libc::c_int as libc::c_uint
            {
                qs = -(2 as libc::c_int);
            }
            if *s.offset((i + 1 as libc::c_int) as isize) as libc::c_int >= 'a' as i32 {
                let ref mut fresh167 = *((*b).ptr).offset((i + 1 as libc::c_int) as isize);
                *fresh167 = (*fresh167 as libc::c_int & 0xdf as libc::c_int) as libc::c_char;
            }
            if *s.offset((i + 2 as libc::c_int) as isize) as libc::c_int >= 'a' as i32 {
                let ref mut fresh168 = *((*b).ptr).offset((i + 2 as libc::c_int) as isize);
                *fresh168 = (*fresh168 as libc::c_int & 0xdf as libc::c_int) as libc::c_char;
            }
            i += 2 as libc::c_int;
        } else if *s.offset(i as isize) as libc::c_int == '#' as i32 {
            buffer_truncate(b, i as size_t as uint32_t);
            break;
        } else {
            qs = burl_normalize_basic_unreserved_fix(b, t, i, qs);
            break;
        }
        i += 1;
    }
    return qs;
}
unsafe extern "C" fn burl_normalize_basic_required_fix(
    mut b: *mut buffer,
    mut t: *mut buffer,
    mut i: libc::c_int,
    mut qs: libc::c_int,
) -> libc::c_int {
    let mut j: libc::c_int = i;
    let used: libc::c_int = buffer_clen(b) as libc::c_int;
    let s: *const libc::c_uchar = (*b).ptr as *mut libc::c_uchar;
    let p: *mut libc::c_uchar = buffer_string_prepare_copy(
        t,
        (i + (used - i) * 3 as libc::c_int + 1 as libc::c_int) as size_t,
    ) as *mut libc::c_uchar;
    let mut n1: libc::c_uint = 0;
    let mut n2: libc::c_uint = 0;
    memcpy(
        p as *mut libc::c_void,
        s as *const libc::c_void,
        i as size_t,
    );
    while i < used {
        if encoded_chars_http_uri_reqd[*s.offset(i as isize) as usize] == 0 {
            if *s.offset(i as isize) as libc::c_int == '?' as i32 && -(1 as libc::c_int) == qs {
                qs = j;
            }
            *p.offset(j as isize) = *s.offset(i as isize);
        } else if *s.offset(i as isize) as libc::c_int == '%' as i32
            && {
                n1 = (*s.offset((i + 1 as libc::c_int) as isize) as libc::c_int - '0' as i32)
                    as libc::c_uint;
                n1 <= 9 as libc::c_int as libc::c_uint || {
                    n1 = ((*s.offset((i + 1 as libc::c_int) as isize) as libc::c_int
                        & 0xdf as libc::c_int)
                        - 'A' as i32) as libc::c_uint;
                    (if n1 <= 5 as libc::c_int as libc::c_uint {
                        n1 = n1.wrapping_add(10 as libc::c_int as libc::c_uint);
                        n1
                    } else {
                        0 as libc::c_int as libc::c_uint
                    }) != 0
                }
            }
            && {
                n2 = (*s.offset((i + 2 as libc::c_int) as isize) as libc::c_int - '0' as i32)
                    as libc::c_uint;
                n2 <= 9 as libc::c_int as libc::c_uint || {
                    n2 = ((*s.offset((i + 2 as libc::c_int) as isize) as libc::c_int
                        & 0xdf as libc::c_int)
                        - 'A' as i32) as libc::c_uint;
                    (if n2 <= 5 as libc::c_int as libc::c_uint {
                        n2 = n2.wrapping_add(10 as libc::c_int as libc::c_uint);
                        n2
                    } else {
                        0 as libc::c_int as libc::c_uint
                    }) != 0
                }
            }
        {
            let x: libc::c_uint = n1 << 4 as libc::c_int | n2;
            if encoded_chars_http_uri_reqd[x as usize] == 0
                && (if qs < 0 as libc::c_int {
                    (x != '/' as i32 as libc::c_uint && x != '?' as i32 as libc::c_uint)
                        as libc::c_int
                } else {
                    (x != '&' as i32 as libc::c_uint
                        && x != '=' as i32 as libc::c_uint
                        && x != ';' as i32 as libc::c_uint
                        && x != '+' as i32 as libc::c_uint) as libc::c_int
                }) != 0
            {
                *p.offset(j as isize) = x as libc::c_uchar;
            } else {
                *p.offset(j as isize) = '%' as i32 as libc::c_uchar;
                j += 1;
                *p.offset(j as isize) = hex_chars_uc[n1 as usize] as libc::c_uchar;
                j += 1;
                *p.offset(j as isize) = hex_chars_uc[n2 as usize] as libc::c_uchar;
                if x >= 0xf5 as libc::c_int as libc::c_uint
                    || x | 0x1 as libc::c_int as libc::c_uint == 0xc1 as libc::c_int as libc::c_uint
                {
                    qs = -(2 as libc::c_int);
                }
            }
            i += 2 as libc::c_int;
        } else {
            if *s.offset(i as isize) as libc::c_int == '#' as i32 {
                break;
            }
            *p.offset(j as isize) = '%' as i32 as libc::c_uchar;
            j += 1;
            *p.offset(j as isize) =
                hex_chars_uc[(*s.offset(i as isize) as libc::c_int >> 4 as libc::c_int
                    & 0xf as libc::c_int) as usize] as libc::c_uchar;
            j += 1;
            *p.offset(j as isize) = hex_chars_uc
                [(*s.offset(i as isize) as libc::c_int & 0xf as libc::c_int) as usize]
                as libc::c_uchar;
            if *s.offset(i as isize) as libc::c_int >= 0xf5 as libc::c_int
                || *s.offset(i as isize) as libc::c_int | 0x1 as libc::c_int == 0xc1 as libc::c_int
            {
                qs = -(2 as libc::c_int);
            }
        }
        i += 1;
        j += 1;
    }
    buffer_copy_string_len(b, p as *mut libc::c_char, j as size_t);
    return qs;
}
unsafe extern "C" fn burl_normalize_basic_required(
    mut b: *mut buffer,
    mut t: *mut buffer,
) -> libc::c_int {
    let s: *const libc::c_uchar = (*b).ptr as *mut libc::c_uchar;
    let used: libc::c_int = buffer_clen(b) as libc::c_int;
    let mut n1: libc::c_uint = 0;
    let mut n2: libc::c_uint = 0;
    let mut x: libc::c_uint = 0;
    let mut qs: libc::c_int = -(1 as libc::c_int);
    let mut i: libc::c_int = 0 as libc::c_int;
    while i < used {
        if encoded_chars_http_uri_reqd[*s.offset(i as isize) as usize] == 0 {
            if *s.offset(i as isize) as libc::c_int == '?' as i32 && -(1 as libc::c_int) == qs {
                qs = i;
            }
        } else if *s.offset(i as isize) as libc::c_int == '%' as i32
            && {
                n1 = (*s.offset((i + 1 as libc::c_int) as isize) as libc::c_int - '0' as i32)
                    as libc::c_uint;
                n1 <= 9 as libc::c_int as libc::c_uint || {
                    n1 = ((*s.offset((i + 1 as libc::c_int) as isize) as libc::c_int
                        & 0xdf as libc::c_int)
                        - 'A' as i32) as libc::c_uint;
                    (if n1 <= 5 as libc::c_int as libc::c_uint {
                        n1 = n1.wrapping_add(10 as libc::c_int as libc::c_uint);
                        n1
                    } else {
                        0 as libc::c_int as libc::c_uint
                    }) != 0
                }
            }
            && {
                n2 = (*s.offset((i + 2 as libc::c_int) as isize) as libc::c_int - '0' as i32)
                    as libc::c_uint;
                n2 <= 9 as libc::c_int as libc::c_uint || {
                    n2 = ((*s.offset((i + 2 as libc::c_int) as isize) as libc::c_int
                        & 0xdf as libc::c_int)
                        - 'A' as i32) as libc::c_uint;
                    (if n2 <= 5 as libc::c_int as libc::c_uint {
                        n2 = n2.wrapping_add(10 as libc::c_int as libc::c_uint);
                        n2
                    } else {
                        0 as libc::c_int as libc::c_uint
                    }) != 0
                }
            }
            && {
                x = n1 << 4 as libc::c_int | n2;
                encoded_chars_http_uri_reqd[x as usize] as libc::c_int != 0
                    || (if qs < 0 as libc::c_int {
                        (x == '/' as i32 as libc::c_uint || x == '?' as i32 as libc::c_uint)
                            as libc::c_int
                    } else {
                        (x == '&' as i32 as libc::c_uint
                            || x == '=' as i32 as libc::c_uint
                            || x == ';' as i32 as libc::c_uint
                            || x == '+' as i32 as libc::c_uint)
                            as libc::c_int
                    }) != 0
            }
        {
            if x >= 0xf5 as libc::c_int as libc::c_uint
                || x | 0x1 as libc::c_int as libc::c_uint == 0xc1 as libc::c_int as libc::c_uint
            {
                qs = -(2 as libc::c_int);
            }
            if *s.offset((i + 1 as libc::c_int) as isize) as libc::c_int >= 'a' as i32 {
                let ref mut fresh169 = *((*b).ptr).offset((i + 1 as libc::c_int) as isize);
                *fresh169 = (*fresh169 as libc::c_int & 0xdf as libc::c_int) as libc::c_char;
            }
            if *s.offset((i + 2 as libc::c_int) as isize) as libc::c_int >= 'a' as i32 {
                let ref mut fresh170 = *((*b).ptr).offset((i + 2 as libc::c_int) as isize);
                *fresh170 = (*fresh170 as libc::c_int & 0xdf as libc::c_int) as libc::c_char;
            }
            i += 2 as libc::c_int;
        } else if *s.offset(i as isize) as libc::c_int == '#' as i32 {
            buffer_truncate(b, i as size_t as uint32_t);
            break;
        } else {
            qs = burl_normalize_basic_required_fix(b, t, i, qs);
            break;
        }
        i += 1;
    }
    return qs;
}
unsafe extern "C" fn burl_contains_ctrls(mut b: *const buffer) -> libc::c_int {
    let s: *const libc::c_char = (*b).ptr;
    let used: libc::c_int = buffer_clen(b) as libc::c_int;
    let mut i: libc::c_int = 0 as libc::c_int;
    while i < used {
        if *s.offset(i as isize) as libc::c_int == '%' as i32
            && ((*s.offset((i + 1 as libc::c_int) as isize) as libc::c_int) < '2' as i32
                || *s.offset((i + 1 as libc::c_int) as isize) as libc::c_int == '7' as i32
                    && *s.offset((i + 2 as libc::c_int) as isize) as libc::c_int == 'F' as i32)
        {
            return 1 as libc::c_int;
        }
        i += 1;
    }
    return 0 as libc::c_int;
}
unsafe extern "C" fn burl_normalize_qs20_to_plus_fix(mut b: *mut buffer, mut i: libc::c_int) {
    let s: *mut libc::c_char = (*b).ptr;
    let used: libc::c_int = buffer_clen(b) as libc::c_int;
    let mut j: libc::c_int = i;
    while i < used {
        *s.offset(j as isize) = *s.offset(i as isize);
        if *s.offset(i as isize) as libc::c_int == '%' as i32
            && *s.offset((i + 1 as libc::c_int) as isize) as libc::c_int == '2' as i32
            && *s.offset((i + 2 as libc::c_int) as isize) as libc::c_int == '0' as i32
        {
            *s.offset(j as isize) = '+' as i32 as libc::c_char;
            i += 2 as libc::c_int;
        }
        i += 1;
        j += 1;
    }
    buffer_truncate(b, j as uint32_t);
}
unsafe extern "C" fn burl_normalize_qs20_to_plus(mut b: *mut buffer, mut qs: libc::c_int) {
    let s: *const libc::c_char = (*b).ptr;
    let used: libc::c_int = if qs < 0 as libc::c_int {
        0 as libc::c_int
    } else {
        buffer_clen(b) as libc::c_int
    };
    let mut i: libc::c_int = 0;
    if qs < 0 as libc::c_int {
        return;
    }
    i = qs + 1 as libc::c_int;
    while i < used {
        if *s.offset(i as isize) as libc::c_int == '%' as i32
            && *s.offset((i + 1 as libc::c_int) as isize) as libc::c_int == '2' as i32
            && *s.offset((i + 2 as libc::c_int) as isize) as libc::c_int == '0' as i32
        {
            break;
        }
        i += 1;
    }
    if i != used {
        burl_normalize_qs20_to_plus_fix(b, i);
    }
}
unsafe extern "C" fn burl_normalize_2F_to_slash_fix(
    mut b: *mut buffer,
    mut qs: libc::c_int,
    mut i: libc::c_int,
) -> libc::c_int {
    let s: *mut libc::c_char = (*b).ptr;
    let blen: libc::c_int = buffer_clen(b) as libc::c_int;
    let used: libc::c_int = if qs < 0 as libc::c_int { blen } else { qs };
    let mut j: libc::c_int = i;
    while i < used {
        *s.offset(j as isize) = *s.offset(i as isize);
        if *s.offset(i as isize) as libc::c_int == '%' as i32
            && *s.offset((i + 1 as libc::c_int) as isize) as libc::c_int == '2' as i32
            && *s.offset((i + 2 as libc::c_int) as isize) as libc::c_int == 'F' as i32
        {
            *s.offset(j as isize) = '/' as i32 as libc::c_char;
            i += 2 as libc::c_int;
        }
        i += 1;
        j += 1;
    }
    if qs >= 0 as libc::c_int {
        let qslen: libc::c_int = blen - qs;
        memmove(
            s.offset(j as isize) as *mut libc::c_void,
            s.offset(qs as isize) as *const libc::c_void,
            qslen as size_t,
        );
        qs = j;
        j += qslen;
    }
    buffer_truncate(b, j as uint32_t);
    return qs;
}
unsafe extern "C" fn burl_normalize_2F_to_slash(
    mut b: *mut buffer,
    mut qs: libc::c_int,
    mut flags: libc::c_int,
) -> libc::c_int {
    let s: *const libc::c_char = (*b).ptr;
    let used: libc::c_int = if qs < 0 as libc::c_int {
        buffer_clen(b) as libc::c_int
    } else {
        qs
    };
    let mut i: libc::c_int = 0 as libc::c_int;
    while i < used {
        if *s.offset(i as isize) as libc::c_int == '%' as i32
            && *s.offset((i + 1 as libc::c_int) as isize) as libc::c_int == '2' as i32
            && *s.offset((i + 2 as libc::c_int) as isize) as libc::c_int == 'F' as i32
        {
            return if flags & HTTP_PARSEOPT_URL_NORMALIZE_PATH_2F_DECODE as libc::c_int != 0 {
                burl_normalize_2F_to_slash_fix(b, qs, i)
            } else {
                -(2 as libc::c_int)
            };
        }
        i += 1;
    }
    return qs;
}
unsafe extern "C" fn burl_normalize_path(
    mut b: *mut buffer,
    mut t: *mut buffer,
    mut qs: libc::c_int,
    mut flags: libc::c_int,
) -> libc::c_int {
    let s: *const libc::c_uchar = (*b).ptr as *mut libc::c_uchar;
    let used: libc::c_int = buffer_clen(b) as libc::c_int;
    let mut path_simplify: libc::c_int = 0 as libc::c_int;
    let mut i: libc::c_int = 0 as libc::c_int;
    let mut len: libc::c_int = if qs < 0 as libc::c_int { used } else { qs };
    while i < len {
        if *s.offset(i as isize) as libc::c_int == '.' as i32
            && (*s.offset((i + 1 as libc::c_int) as isize) as libc::c_int != '.' as i32 || {
                i += 1;
                i != 0
            })
            && (*s.offset((i + 1 as libc::c_int) as isize) as libc::c_int == '/' as i32
                || *s.offset((i + 1 as libc::c_int) as isize) as libc::c_int == '?' as i32
                || *s.offset((i + 1 as libc::c_int) as isize) as libc::c_int == '\0' as i32)
        {
            path_simplify = 1 as libc::c_int;
            break;
        } else {
            while i < len && *s.offset(i as isize) as libc::c_int != '/' as i32 {
                i += 1;
            }
            if *s.offset(i as isize) as libc::c_int == '/' as i32
                && *s.offset((i + 1 as libc::c_int) as isize) as libc::c_int == '/' as i32
            {
                path_simplify = 1 as libc::c_int;
                break;
            } else {
                i += 1;
            }
        }
    }
    if path_simplify != 0 {
        if flags & HTTP_PARSEOPT_URL_NORMALIZE_PATH_DOTSEG_REJECT as libc::c_int != 0 {
            return -(2 as libc::c_int);
        }
        if qs >= 0 as libc::c_int {
            buffer_copy_string_len(t, ((*b).ptr).offset(qs as isize), (used - qs) as size_t);
            buffer_truncate(b, qs as uint32_t);
        }
        buffer_path_simplify(b);
        if qs >= 0 as libc::c_int {
            qs = buffer_clen(b) as libc::c_int;
            buffer_append_string_len(b, (*t).ptr, buffer_clen(t) as size_t);
        }
    }
    return qs;
}
#[no_mangle]
pub unsafe extern "C" fn burl_normalize(
    mut b: *mut buffer,
    mut t: *mut buffer,
    mut flags: libc::c_int,
) -> libc::c_int {
    let mut qs: libc::c_int = 0;
    qs = if flags & HTTP_PARSEOPT_URL_NORMALIZE_REQUIRED as libc::c_int != 0 {
        burl_normalize_basic_required(b, t)
    } else {
        burl_normalize_basic_unreserved(b, t)
    };
    if -(2 as libc::c_int) == qs {
        return -(2 as libc::c_int);
    }
    if flags & HTTP_PARSEOPT_URL_NORMALIZE_CTRLS_REJECT as libc::c_int != 0 {
        if burl_contains_ctrls(b) != 0 {
            return -(2 as libc::c_int);
        }
    }
    if flags
        & (HTTP_PARSEOPT_URL_NORMALIZE_PATH_2F_DECODE as libc::c_int
            | HTTP_PARSEOPT_URL_NORMALIZE_PATH_2F_REJECT as libc::c_int)
        != 0
    {
        qs = burl_normalize_2F_to_slash(b, qs, flags);
        if -(2 as libc::c_int) == qs {
            return -(2 as libc::c_int);
        }
    }
    if flags
        & (HTTP_PARSEOPT_URL_NORMALIZE_PATH_DOTSEG_REMOVE as libc::c_int
            | HTTP_PARSEOPT_URL_NORMALIZE_PATH_DOTSEG_REJECT as libc::c_int)
        != 0
    {
        qs = burl_normalize_path(b, t, qs, flags);
        if -(2 as libc::c_int) == qs {
            return -(2 as libc::c_int);
        }
    }
    if flags & HTTP_PARSEOPT_URL_NORMALIZE_QUERY_20_PLUS as libc::c_int != 0 {
        if qs >= 0 as libc::c_int {
            burl_normalize_qs20_to_plus(b, qs);
        }
    }
    return qs;
}
unsafe extern "C" fn burl_append_encode_nde(b: *mut buffer, str: *const libc::c_char, len: size_t) {
    let p: *mut libc::c_char =
        buffer_string_prepare_append(b, len.wrapping_mul(3 as libc::c_int as libc::c_ulong));
    let mut n1: libc::c_uint = 0;
    let mut n2: libc::c_uint = 0;
    let mut j: libc::c_int = 0 as libc::c_int;
    let mut i: libc::c_uint = 0 as libc::c_int as libc::c_uint;
    while (i as libc::c_ulong) < len {
        if *str.offset(i as isize) as libc::c_int == '%' as i32
            && {
                n1 = (*str.offset(i.wrapping_add(1 as libc::c_int as libc::c_uint) as isize)
                    as libc::c_int
                    - '0' as i32) as libc::c_uint;
                n1 <= 9 as libc::c_int as libc::c_uint || {
                    n1 = ((*str.offset(i.wrapping_add(1 as libc::c_int as libc::c_uint) as isize)
                        as libc::c_int
                        & 0xdf as libc::c_int)
                        - 'A' as i32) as libc::c_uint;
                    (if n1 <= 5 as libc::c_int as libc::c_uint {
                        n1 = n1.wrapping_add(10 as libc::c_int as libc::c_uint);
                        n1
                    } else {
                        0 as libc::c_int as libc::c_uint
                    }) != 0
                }
            }
            && {
                n2 = (*str.offset(i.wrapping_add(2 as libc::c_int as libc::c_uint) as isize)
                    as libc::c_int
                    - '0' as i32) as libc::c_uint;
                n2 <= 9 as libc::c_int as libc::c_uint || {
                    n2 = ((*str.offset(i.wrapping_add(2 as libc::c_int as libc::c_uint) as isize)
                        as libc::c_int
                        & 0xdf as libc::c_int)
                        - 'A' as i32) as libc::c_uint;
                    (if n2 <= 5 as libc::c_int as libc::c_uint {
                        n2 = n2.wrapping_add(10 as libc::c_int as libc::c_uint);
                        n2
                    } else {
                        0 as libc::c_int as libc::c_uint
                    }) != 0
                }
            }
        {
            let x: libc::c_uint = n1 << 4 as libc::c_int | n2;
            if burl_is_unreserved(x as libc::c_int) != 0 {
                *p.offset(j as isize) = x as libc::c_char;
            } else {
                *p.offset(j as isize) = '%' as i32 as libc::c_char;
                j += 1;
                *p.offset(j as isize) =
                    *str.offset(i.wrapping_add(1 as libc::c_int as libc::c_uint) as isize);
                j += 1;
                *p.offset(j as isize) =
                    *str.offset(i.wrapping_add(2 as libc::c_int as libc::c_uint) as isize);
            }
            i = i.wrapping_add(2 as libc::c_int as libc::c_uint);
        } else if burl_is_unreserved(*str.offset(i as isize) as libc::c_int) != 0 {
            *p.offset(j as isize) = *str.offset(i as isize);
        } else {
            *p.offset(j as isize) = '%' as i32 as libc::c_char;
            j += 1;
            *p.offset(j as isize) = hex_chars_uc[(*str.offset(i as isize) as libc::c_int
                >> 4 as libc::c_int
                & 0xf as libc::c_int) as usize];
            j += 1;
            *p.offset(j as isize) = hex_chars_uc
                [(*str.offset(i as isize) as libc::c_int & 0xf as libc::c_int) as usize];
        }
        i = i.wrapping_add(1);
        j += 1;
    }
    buffer_commit(b, j as size_t);
}
unsafe extern "C" fn burl_append_encode_psnde(
    b: *mut buffer,
    str: *const libc::c_char,
    len: size_t,
) {
    let p: *mut libc::c_char =
        buffer_string_prepare_append(b, len.wrapping_mul(3 as libc::c_int as libc::c_ulong));
    let mut n1: libc::c_uint = 0;
    let mut n2: libc::c_uint = 0;
    let mut j: libc::c_int = 0 as libc::c_int;
    let mut i: libc::c_uint = 0 as libc::c_int as libc::c_uint;
    while (i as libc::c_ulong) < len {
        if *str.offset(i as isize) as libc::c_int == '%' as i32
            && {
                n1 = (*str.offset(i.wrapping_add(1 as libc::c_int as libc::c_uint) as isize)
                    as libc::c_int
                    - '0' as i32) as libc::c_uint;
                n1 <= 9 as libc::c_int as libc::c_uint || {
                    n1 = ((*str.offset(i.wrapping_add(1 as libc::c_int as libc::c_uint) as isize)
                        as libc::c_int
                        & 0xdf as libc::c_int)
                        - 'A' as i32) as libc::c_uint;
                    (if n1 <= 5 as libc::c_int as libc::c_uint {
                        n1 = n1.wrapping_add(10 as libc::c_int as libc::c_uint);
                        n1
                    } else {
                        0 as libc::c_int as libc::c_uint
                    }) != 0
                }
            }
            && {
                n2 = (*str.offset(i.wrapping_add(2 as libc::c_int as libc::c_uint) as isize)
                    as libc::c_int
                    - '0' as i32) as libc::c_uint;
                n2 <= 9 as libc::c_int as libc::c_uint || {
                    n2 = ((*str.offset(i.wrapping_add(2 as libc::c_int as libc::c_uint) as isize)
                        as libc::c_int
                        & 0xdf as libc::c_int)
                        - 'A' as i32) as libc::c_uint;
                    (if n2 <= 5 as libc::c_int as libc::c_uint {
                        n2 = n2.wrapping_add(10 as libc::c_int as libc::c_uint);
                        n2
                    } else {
                        0 as libc::c_int as libc::c_uint
                    }) != 0
                }
            }
        {
            let x: libc::c_uint = n1 << 4 as libc::c_int | n2;
            if burl_is_unreserved(x as libc::c_int) != 0 {
                *p.offset(j as isize) = x as libc::c_char;
            } else {
                *p.offset(j as isize) = '%' as i32 as libc::c_char;
                j += 1;
                *p.offset(j as isize) =
                    *str.offset(i.wrapping_add(1 as libc::c_int as libc::c_uint) as isize);
                j += 1;
                *p.offset(j as isize) =
                    *str.offset(i.wrapping_add(2 as libc::c_int as libc::c_uint) as isize);
            }
            i = i.wrapping_add(2 as libc::c_int as libc::c_uint);
        } else if burl_is_unreserved(*str.offset(i as isize) as libc::c_int) != 0
            || *str.offset(i as isize) as libc::c_int == '/' as i32
        {
            *p.offset(j as isize) = *str.offset(i as isize);
        } else {
            *p.offset(j as isize) = '%' as i32 as libc::c_char;
            j += 1;
            *p.offset(j as isize) = hex_chars_uc[(*str.offset(i as isize) as libc::c_int
                >> 4 as libc::c_int
                & 0xf as libc::c_int) as usize];
            j += 1;
            *p.offset(j as isize) = hex_chars_uc
                [(*str.offset(i as isize) as libc::c_int & 0xf as libc::c_int) as usize];
        }
        i = i.wrapping_add(1);
        j += 1;
    }
    buffer_commit(b, j as size_t);
}
unsafe extern "C" fn burl_append_encode_all(b: *mut buffer, str: *const libc::c_char, len: size_t) {
    let p: *mut libc::c_char =
        buffer_string_prepare_append(b, len.wrapping_mul(3 as libc::c_int as libc::c_ulong));
    let mut j: libc::c_int = 0 as libc::c_int;
    let mut i: libc::c_uint = 0 as libc::c_int as libc::c_uint;
    while (i as libc::c_ulong) < len {
        if burl_is_unreserved(*str.offset(i as isize) as libc::c_int) != 0 {
            *p.offset(j as isize) = *str.offset(i as isize);
        } else {
            *p.offset(j as isize) = '%' as i32 as libc::c_char;
            j += 1;
            *p.offset(j as isize) = hex_chars_uc[(*str.offset(i as isize) as libc::c_int
                >> 4 as libc::c_int
                & 0xf as libc::c_int) as usize];
            j += 1;
            *p.offset(j as isize) = hex_chars_uc
                [(*str.offset(i as isize) as libc::c_int & 0xf as libc::c_int) as usize];
        }
        i = i.wrapping_add(1);
        j += 1;
    }
    buffer_commit(b, j as size_t);
}
unsafe extern "C" fn burl_offset_tolower(b: *mut buffer, off: size_t) {
    let mut p: *mut libc::c_char = ((*b).ptr).offset(off as isize);
    while *p.offset(0 as libc::c_int as isize) != 0 {
        if (*p.offset(0 as libc::c_int as isize) as uint32_t)
            .wrapping_sub('A' as i32 as libc::c_uint)
            <= ('Z' as i32 - 'A' as i32) as libc::c_uint
        {
            let ref mut fresh171 = *p.offset(0 as libc::c_int as isize);
            *fresh171 = (*fresh171 as libc::c_int | 0x20 as libc::c_int) as libc::c_char;
        } else if *p.offset(0 as libc::c_int as isize) as libc::c_int == '%' as i32
            && light_isxdigit(*p.offset(1 as libc::c_int as isize) as libc::c_int) != 0
            && light_isxdigit(*p.offset(2 as libc::c_int as isize) as libc::c_int) != 0
        {
            p = p.offset(2 as libc::c_int as isize);
        }
        p = p.offset(1);
    }
}
unsafe extern "C" fn burl_offset_toupper(b: *mut buffer, off: size_t) {
    let mut p: *mut libc::c_char = ((*b).ptr).offset(off as isize);
    while *p.offset(0 as libc::c_int as isize) != 0 {
        if (*p.offset(0 as libc::c_int as isize) as uint32_t)
            .wrapping_sub('a' as i32 as libc::c_uint)
            <= ('z' as i32 - 'a' as i32) as libc::c_uint
        {
            let ref mut fresh172 = *p.offset(0 as libc::c_int as isize);
            *fresh172 = (*fresh172 as libc::c_int & 0xdf as libc::c_int) as libc::c_char;
        } else if *p.offset(0 as libc::c_int as isize) as libc::c_int == '%' as i32
            && light_isxdigit(*p.offset(1 as libc::c_int as isize) as libc::c_int) != 0
            && light_isxdigit(*p.offset(2 as libc::c_int as isize) as libc::c_int) != 0
        {
            p = p.offset(2 as libc::c_int as isize);
        }
        p = p.offset(1);
    }
}
#[no_mangle]
pub unsafe extern "C" fn burl_append(
    b: *mut buffer,
    str: *const libc::c_char,
    len: size_t,
    flags: libc::c_int,
) {
    let mut off: size_t = 0 as libc::c_int as size_t;
    if 0 as libc::c_int as libc::c_ulong == len {
        return;
    }
    if 0 as libc::c_int == flags {
        buffer_append_string_len(b, str, len);
        return;
    }
    if flags & (BURL_TOUPPER as libc::c_int | BURL_TOLOWER as libc::c_int) != 0 {
        off = buffer_clen(b) as size_t;
    }
    if flags & BURL_ENCODE_NONE as libc::c_int != 0 {
        buffer_append_string_len(b, str, len);
    } else if flags & BURL_ENCODE_ALL as libc::c_int != 0 {
        burl_append_encode_all(b, str, len);
    } else if flags & BURL_ENCODE_NDE as libc::c_int != 0 {
        burl_append_encode_nde(b, str, len);
    } else if flags & BURL_ENCODE_PSNDE as libc::c_int != 0 {
        burl_append_encode_psnde(b, str, len);
    } else if flags & BURL_ENCODE_B64U as libc::c_int != 0 {
        let mut s: *const libc::c_uchar = str as *const libc::c_uchar;
        buffer_append_base64_enc(b, s, len, BASE64_URL, 0 as libc::c_int);
    } else if flags & BURL_DECODE_B64U as libc::c_int != 0 {
        buffer_append_base64_decode(b, str, len, BASE64_URL);
    }
    if flags & (BURL_TOLOWER as libc::c_int | BURL_TOUPPER as libc::c_int) != 0 {
        if flags & BURL_TOLOWER as libc::c_int != 0 {
            burl_offset_tolower(b, off);
        } else {
            burl_offset_toupper(b, off);
        };
    }
}
static mut log_stderrh: fdlog_st = {
    let mut init = fdlog_st {
        mode: FDLOG_FD,
        fd: 2 as libc::c_int,
        b: {
            let mut init = buffer {
                ptr: 0 as *const libc::c_char as *mut libc::c_char,
                used: 0 as libc::c_int as uint32_t,
                size: 0 as libc::c_int as uint32_t,
            };
            init
        },
        fn_0: 0 as *const libc::c_char,
    };
    init
};
static mut log_errh: *mut fdlog_st = unsafe { &log_stderrh as *const fdlog_st as *mut fdlog_st };
static mut log_tlast: unix_time64_t = 0 as libc::c_int as unix_time64_t;
#[no_mangle]
pub static mut log_con_jqueue: *mut connection = 0 as *const connection as *mut connection;
#[no_mangle]
pub static mut log_epoch_secs: unix_time64_t = 0 as libc::c_int as unix_time64_t;
#[no_mangle]
pub static mut log_monotonic_secs: unix_time64_t = 0 as libc::c_int as unix_time64_t;
#[no_mangle]
pub unsafe extern "C" fn write_all(
    mut fd: libc::c_int,
    buf: *const libc::c_void,
    mut count: size_t,
) -> ssize_t {
    let mut written: ssize_t = 0 as libc::c_int as ssize_t;
    let mut wr: ssize_t = 0;
    loop {
        wr = write(
            fd,
            (buf as *const libc::c_char).offset(written as isize) as *const libc::c_void,
            count,
        );
        if !(if wr > 0 as libc::c_int as libc::c_long {
            written += wr;
            count = (count as libc::c_ulong).wrapping_sub(wr as libc::c_ulong) as size_t as size_t;
            count
        } else {
            (wr < 0 as libc::c_int as libc::c_long && *__errno_location() == 4 as libc::c_int)
                as libc::c_int as libc::c_ulong
        } != 0)
        {
            break;
        }
    }
    if (0 as libc::c_int as libc::c_ulong == count) as libc::c_int as libc::c_long != 0 {
        return written;
    } else {
        if 0 as libc::c_int as libc::c_long == wr {
            *__errno_location() = 5 as libc::c_int;
        }
        return -(1 as libc::c_int) as ssize_t;
    };
}
unsafe extern "C" fn log_buffer_timestamp(b: *mut buffer) {
    if -(2 as libc::c_int) as libc::c_long == log_tlast {
        let mut ts: unix_timespec64_t = {
            let mut init = timespec {
                tv_sec: 0 as libc::c_int as __time_t,
                tv_nsec: 0 as libc::c_int as __syscall_slong_t,
            };
            init
        };
        clock_gettime(0 as libc::c_int, &mut ts);
        let mut tm: tm = tm {
            tm_sec: 0,
            tm_min: 0,
            tm_hour: 0,
            tm_mday: 0,
            tm_mon: 0,
            tm_year: 0,
            tm_wday: 0,
            tm_yday: 0,
            tm_isdst: 0,
            tm_gmtoff: 0,
            tm_zone: 0 as *const libc::c_char,
        };
        buffer_append_strftime(
            b,
            b"%F %T\0" as *const u8 as *const libc::c_char,
            localtime_r(&mut ts.tv_sec, &mut tm),
        );
        buffer_append_string_len(
            b,
            b".000000000: \0" as *const u8 as *const libc::c_char,
            (::core::mem::size_of::<[libc::c_char; 13]>() as libc::c_ulong as uint32_t)
                .wrapping_sub(1 as libc::c_int as libc::c_uint) as size_t,
        );
        let mut n: [libc::c_char; 22] = [0; 22];
        let nlen: size_t = li_utostrn(
            n.as_mut_ptr(),
            ::core::mem::size_of::<[libc::c_char; 22]>() as libc::c_ulong,
            ts.tv_nsec as libc::c_ulong,
        );
        memcpy(
            ((*b).ptr)
                .offset(buffer_clen(b) as isize)
                .offset(-(nlen as isize))
                .offset(-(2 as libc::c_int as isize)) as *mut libc::c_void,
            n.as_mut_ptr() as *const libc::c_void,
            nlen,
        );
    } else {
        static mut tlen: uint32_t = 0;
        static mut tstr: [libc::c_char; 24] = [0; 24];
        if (log_tlast != log_epoch_secs) as libc::c_int as libc::c_long != 0 {
            let mut tm_0: tm = tm {
                tm_sec: 0,
                tm_min: 0,
                tm_hour: 0,
                tm_mday: 0,
                tm_mon: 0,
                tm_year: 0,
                tm_wday: 0,
                tm_yday: 0,
                tm_isdst: 0,
                tm_gmtoff: 0,
                tm_zone: 0 as *const libc::c_char,
            };
            log_tlast = log_epoch_secs;
            tlen = strftime(
                tstr.as_mut_ptr(),
                ::core::mem::size_of::<[libc::c_char; 24]>() as libc::c_ulong,
                b"%F %T\0" as *const u8 as *const libc::c_char,
                localtime_r(&mut log_tlast, &mut tm_0),
            ) as uint32_t;
            tstr[tlen as usize] = ':' as i32 as libc::c_char;
            tlen = tlen.wrapping_add(1);
            tstr[tlen as usize] = ' ' as i32 as libc::c_char;
            tlen = tlen.wrapping_add(1);
        }
        buffer_copy_string_len(b, tstr.as_mut_ptr(), tlen as size_t);
    };
}
unsafe extern "C" fn log_buffer_prefix(
    b: *mut buffer,
    filename: *const libc::c_char,
    line: libc::c_uint,
) {
    let mut lstr: [libc::c_char; 22] = [0; 22];
    let mut iov: [const_iovec; 5] = [
        {
            let mut init = const_iovec {
                iov_base: b"(\0" as *const u8 as *const libc::c_char as *const libc::c_void,
                iov_len: (::core::mem::size_of::<[libc::c_char; 2]>() as libc::c_ulong as uint32_t)
                    .wrapping_sub(1 as libc::c_int as libc::c_uint)
                    as size_t,
            };
            init
        },
        {
            let mut init = const_iovec {
                iov_base: filename as *const libc::c_void,
                iov_len: strlen(filename),
            };
            init
        },
        {
            let mut init = const_iovec {
                iov_base: b".\0" as *const u8 as *const libc::c_char as *const libc::c_void,
                iov_len: (::core::mem::size_of::<[libc::c_char; 2]>() as libc::c_ulong as uint32_t)
                    .wrapping_sub(1 as libc::c_int as libc::c_uint)
                    as size_t,
            };
            init
        },
        {
            let mut init = const_iovec {
                iov_base: lstr.as_mut_ptr() as *const libc::c_void,
                iov_len: li_itostrn(
                    lstr.as_mut_ptr(),
                    ::core::mem::size_of::<[libc::c_char; 22]>() as libc::c_ulong,
                    line as intmax_t,
                ),
            };
            init
        },
        {
            let mut init = const_iovec {
                iov_base: b") \0" as *const u8 as *const libc::c_char as *const libc::c_void,
                iov_len: (::core::mem::size_of::<[libc::c_char; 3]>() as libc::c_ulong as uint32_t)
                    .wrapping_sub(1 as libc::c_int as libc::c_uint)
                    as size_t,
            };
            init
        },
    ];
    buffer_append_iovec(
        b,
        iov.as_mut_ptr(),
        (::core::mem::size_of::<[const_iovec; 5]>() as libc::c_ulong)
            .wrapping_div(::core::mem::size_of::<const_iovec>() as libc::c_ulong),
    );
}
unsafe extern "C" fn log_buffer_append_encoded(b: *mut buffer, s: *const libc::c_char, n: size_t) {
    let mut i: size_t = 0;
    i = 0 as libc::c_int as size_t;
    while i < n
        && ' ' as i32 <= *s.offset(i as isize) as libc::c_int
        && *s.offset(i as isize) as libc::c_int <= '~' as i32
    {
        i = i.wrapping_add(1);
    }
    if i == n {
        buffer_append_string_len(b, s, n);
    } else {
        buffer_append_string_c_escaped(b, s, n);
    };
}
unsafe extern "C" fn log_buffer_vsprintf(
    b: *mut buffer,
    fmt: *const libc::c_char,
    mut ap: ::core::ffi::VaList,
) {
    let mut blen: size_t = buffer_clen(b) as size_t;
    let mut bsp: size_t =
        (buffer_string_space(b)).wrapping_add(1 as libc::c_int as libc::c_uint) as size_t;
    let mut s: *mut libc::c_char = ((*b).ptr).offset(blen as isize);
    let mut n: size_t = 0;
    let mut aptry: ::core::ffi::VaListImpl;
    aptry = ap.clone();
    n = vsnprintf(s, bsp, fmt, aptry.as_va_list()) as size_t;
    if n < bsp {
        buffer_truncate(b, blen.wrapping_add(n) as uint32_t);
    } else {
        s = buffer_extend(b, n);
        vsnprintf(
            s,
            n.wrapping_add(1 as libc::c_int as libc::c_ulong),
            fmt,
            ap.as_va_list(),
        );
    }
    let mut i: size_t = 0;
    i = 0 as libc::c_int as size_t;
    while i < n
        && ' ' as i32 <= *s.offset(i as isize) as libc::c_int
        && *s.offset(i as isize) as libc::c_int <= '~' as i32
    {
        i = i.wrapping_add(1);
    }
    if i == n {
        return;
    }
    let src: *mut libc::c_char = malloc(n) as *mut libc::c_char;
    memcpy(src as *mut libc::c_void, s as *const libc::c_void, n);
    buffer_truncate(b, blen as uint32_t);
    buffer_append_string_c_escaped(b, src, n);
    free(src as *mut libc::c_void);
}
unsafe extern "C" fn log_buffer_prepare(
    errh: *const log_error_st,
    filename: *const libc::c_char,
    line: libc::c_uint,
) -> *mut buffer {
    let b: *mut buffer = &mut (*log_errh).b;
    buffer_clear(b);
    if (*errh).mode as libc::c_uint != FDLOG_SYSLOG as libc::c_int as libc::c_uint {
        if -(1 as libc::c_int) == (*errh).fd {
            return 0 as *mut buffer;
        }
        log_buffer_timestamp(b);
    }
    log_buffer_prefix(b, filename, line);
    return b;
}
unsafe extern "C" fn log_error_write(errh: *const log_error_st, b: *mut buffer) {
    if (*errh).mode as libc::c_uint != FDLOG_SYSLOG as libc::c_int as libc::c_uint {
        buffer_append_string_len(
            b,
            b"\n\0" as *const u8 as *const libc::c_char,
            (::core::mem::size_of::<[libc::c_char; 2]>() as libc::c_ulong as uint32_t)
                .wrapping_sub(1 as libc::c_int as libc::c_uint) as size_t,
        );
        write_all(
            (*errh).fd,
            (*b).ptr as *const libc::c_void,
            buffer_clen(b) as size_t,
        );
    } else {
        syslog(
            3 as libc::c_int,
            b"%s\0" as *const u8 as *const libc::c_char,
            (*b).ptr,
        );
    };
}
#[inline(never)]
unsafe extern "C" fn log_error_append_strerror(b: *mut buffer, errnum: libc::c_int) {
    let mut buf: [libc::c_char; 1024] = [0; 1024];
    let mut rc: errno_t = ck_strerror_s(
        buf.as_mut_ptr(),
        ::core::mem::size_of::<[libc::c_char; 1024]>() as libc::c_ulong,
        errnum,
    );
    if 0 as libc::c_int == rc || rc == 34 as libc::c_int {
        buffer_append_str2(
            b,
            b": \0" as *const u8 as *const libc::c_char,
            (::core::mem::size_of::<[libc::c_char; 3]>() as libc::c_ulong as uint32_t)
                .wrapping_sub(1 as libc::c_int as libc::c_uint) as size_t,
            buf.as_mut_ptr(),
            strlen(buf.as_mut_ptr()),
        );
    }
}
unsafe extern "C" fn log_error_va_list_impl(
    mut errh: *const log_error_st,
    filename: *const libc::c_char,
    line: libc::c_uint,
    fmt: *const libc::c_char,
    mut ap: ::core::ffi::VaList,
    perr: libc::c_int,
) {
    let errnum: libc::c_int = *__errno_location();
    if errh.is_null() {
        errh = log_errh;
    }
    let b: *mut buffer = log_buffer_prepare(errh, filename, line);
    if b.is_null() {
        return;
    }
    log_buffer_vsprintf(b, fmt, ap.as_va_list());
    if perr != 0 {
        log_error_append_strerror(b, errnum);
    }
    log_error_write(errh, b);
    buffer_clear(b);
    *__errno_location() = errnum;
}
#[no_mangle]
#[cold]
pub unsafe extern "C" fn log_error(
    errh: *mut log_error_st,
    filename: *const libc::c_char,
    line: libc::c_uint,
    mut fmt: *const libc::c_char,
    mut args: ...
) {
    let mut ap: ::core::ffi::VaListImpl;
    ap = args.clone();
    log_error_va_list_impl(errh, filename, line, fmt, ap.as_va_list(), 0 as libc::c_int);
}
#[no_mangle]
#[cold]
pub unsafe extern "C" fn log_perror(
    errh: *mut log_error_st,
    filename: *const libc::c_char,
    line: libc::c_uint,
    fmt: *const libc::c_char,
    mut args: ...
) {
    let mut ap: ::core::ffi::VaListImpl;
    ap = args.clone();
    log_error_va_list_impl(errh, filename, line, fmt, ap.as_va_list(), 1 as libc::c_int);
}
#[no_mangle]
#[cold]
pub unsafe extern "C" fn log_error_multiline(
    mut errh: *mut log_error_st,
    filename: *const libc::c_char,
    line: libc::c_uint,
    multiline: *const libc::c_char,
    len: size_t,
    fmt: *const libc::c_char,
    mut args: ...
) {
    if 0 as libc::c_int as libc::c_ulong == len {
        return;
    }
    let errnum: libc::c_int = *__errno_location();
    if errh.is_null() {
        errh = log_errh;
    }
    let b: *mut buffer = log_buffer_prepare(errh, filename, line);
    if b.is_null() {
        return;
    }
    let mut ap: ::core::ffi::VaListImpl;
    ap = args.clone();
    log_buffer_vsprintf(b, fmt, ap.as_va_list());
    let prefix_len: uint32_t = buffer_clen(b);
    let end: *const libc::c_char = multiline.offset(len as isize);
    let mut pos: *const libc::c_char = multiline;
    while pos < end {
        let current_line: *const libc::c_char = pos;
        pos = strchr(pos, '\n' as i32);
        if pos.is_null() {
            pos = end;
        }
        let mut n: size_t = pos.offset_from(current_line) as libc::c_long as size_t;
        if n != 0
            && *current_line.offset(n.wrapping_sub(1 as libc::c_int as libc::c_ulong) as isize)
                as libc::c_int
                == '\r' as i32
        {
            n = n.wrapping_sub(1);
        }
        buffer_truncate(b, prefix_len);
        log_buffer_append_encoded(b, current_line, n);
        log_error_write(errh, b);
        pos = pos.offset(1);
    }
    buffer_clear(b);
    *__errno_location() = errnum;
}
#[no_mangle]
#[cold]
pub unsafe extern "C" fn log_set_global_errh(
    errh: *mut log_error_st,
    ts_high_precision: libc::c_int,
) -> *mut log_error_st {
    log_tlast = (if ts_high_precision != 0 {
        -(2 as libc::c_int)
    } else {
        -(1 as libc::c_int)
    }) as unix_time64_t;
    buffer_free_ptr(&mut log_stderrh.b);
    log_errh = if !errh.is_null() {
        errh
    } else {
        &mut log_stderrh
    };
    return log_errh;
}
static mut http_headers_off: [int8_t; 28] = [
    -(1 as libc::c_int) as int8_t,
    -(1 as libc::c_int) as int8_t,
    0 as libc::c_int as int8_t,
    1 as libc::c_int as int8_t,
    4 as libc::c_int as int8_t,
    9 as libc::c_int as int8_t,
    11 as libc::c_int as int8_t,
    17 as libc::c_int as int8_t,
    21 as libc::c_int as int8_t,
    25 as libc::c_int as int8_t,
    27 as libc::c_int as int8_t,
    -(1 as libc::c_int) as int8_t,
    30 as libc::c_int as int8_t,
    31 as libc::c_int as int8_t,
    37 as libc::c_int as int8_t,
    40 as libc::c_int as int8_t,
    45 as libc::c_int as int8_t,
    49 as libc::c_int as int8_t,
    -(1 as libc::c_int) as int8_t,
    52 as libc::c_int as int8_t,
    -(1 as libc::c_int) as int8_t,
    -(1 as libc::c_int) as int8_t,
    53 as libc::c_int as int8_t,
    54 as libc::c_int as int8_t,
    -(1 as libc::c_int) as int8_t,
    55 as libc::c_int as int8_t,
    -(1 as libc::c_int) as int8_t,
    57 as libc::c_int as int8_t,
];
static mut http_headers: [keyvlenvalue; 59] = [keyvlenvalue {
    key: 0,
    vlen: 0,
    value: [0; 28],
}; 59];
#[no_mangle]
pub unsafe extern "C" fn http_header_hkey_get(
    s: *const libc::c_char,
    slen: size_t,
) -> http_header_e {
    if (slen < ::core::mem::size_of::<[int8_t; 28]>() as libc::c_ulong) as libc::c_int
        as libc::c_long
        != 0
    {
        let i: libc::c_int = http_headers_off[slen as usize] as libc::c_int;
        let c: libc::c_int =
            *s.offset(0 as libc::c_int as isize) as libc::c_int | 0x20 as libc::c_int;
        let mut kv: *const keyvlenvalue = http_headers.as_ptr().offset(i as isize);
        if (i != -(1 as libc::c_int)) as libc::c_int as libc::c_long != 0 {
            loop {
                if !((c != (*kv).value[0 as libc::c_int as usize] as libc::c_int) as libc::c_int
                    as libc::c_long
                    != 0)
                {
                    if buffer_eq_icase_ssn(
                        s.offset(1 as libc::c_int as isize),
                        ((*kv).value).as_ptr().offset(1 as libc::c_int as isize),
                        slen.wrapping_sub(1 as libc::c_int as libc::c_ulong),
                    ) != 0
                    {
                        return (*kv).key as http_header_e;
                    }
                }
                kv = kv.offset(1);
                if !(slen == (*kv).vlen as libc::c_ulong) {
                    break;
                }
            }
        }
    }
    return HTTP_HEADER_OTHER;
}
#[no_mangle]
pub unsafe extern "C" fn http_header_hkey_get_lc(
    s: *const libc::c_char,
    slen: size_t,
) -> http_header_e {
    if (slen < ::core::mem::size_of::<[int8_t; 28]>() as libc::c_ulong) as libc::c_int
        as libc::c_long
        != 0
    {
        let i: libc::c_int = http_headers_off[slen as usize] as libc::c_int;
        let c: libc::c_int = *s.offset(0 as libc::c_int as isize) as libc::c_int;
        let mut kv: *const keyvlenvalue = http_headers.as_ptr().offset(i as isize);
        if (i != -(1 as libc::c_int)) as libc::c_int as libc::c_long != 0 {
            loop {
                if !((c != (*kv).value[0 as libc::c_int as usize] as libc::c_int) as libc::c_int
                    as libc::c_long
                    != 0)
                {
                    if 0 as libc::c_int
                        == memcmp(
                            s.offset(1 as libc::c_int as isize) as *const libc::c_void,
                            ((*kv).value).as_ptr().offset(1 as libc::c_int as isize)
                                as *const libc::c_void,
                            slen.wrapping_sub(1 as libc::c_int as libc::c_ulong),
                        )
                    {
                        return (*kv).key as http_header_e;
                    }
                }
                kv = kv.offset(1);
                if !(slen == (*kv).vlen as libc::c_ulong) {
                    break;
                }
            }
        }
    }
    return HTTP_HEADER_OTHER;
}
#[no_mangle]
pub unsafe extern "C" fn http_header_str_to_code(s: *const libc::c_char) -> libc::c_int {
    return if light_isdigit(*s.offset(0 as libc::c_int as isize) as libc::c_int) != 0
        && light_isdigit(*s.offset(1 as libc::c_int as isize) as libc::c_int) != 0
        && light_isdigit(*s.offset(2 as libc::c_int as isize) as libc::c_int) != 0
        && (*s.offset(3 as libc::c_int as isize) as libc::c_int == '\0' as i32
            || *s.offset(3 as libc::c_int as isize) as libc::c_int == ' ' as i32
            || *s.offset(3 as libc::c_int as isize) as libc::c_int == '\t' as i32)
    {
        (*s.offset(0 as libc::c_int as isize) as libc::c_int - '0' as i32) * 100 as libc::c_int
            + (*s.offset(1 as libc::c_int as isize) as libc::c_int - '0' as i32) * 10 as libc::c_int
            + (*s.offset(2 as libc::c_int as isize) as libc::c_int - '0' as i32)
    } else {
        -(1 as libc::c_int)
    };
}
#[no_mangle]
pub unsafe extern "C" fn http_header_str_contains_token(
    s: *const libc::c_char,
    slen: uint32_t,
    m: *const libc::c_char,
    mlen: uint32_t,
) -> libc::c_int {
    let mut i: uint32_t = 0 as libc::c_int as uint32_t;
    loop {
        while i < slen
            && (*s.offset(i as isize) as libc::c_int == ' ' as i32
                || *s.offset(i as isize) as libc::c_int == '\t' as i32
                || *s.offset(i as isize) as libc::c_int == ',' as i32)
        {
            i = i.wrapping_add(1);
        }
        if slen.wrapping_sub(i) < mlen {
            return 0 as libc::c_int;
        }
        if buffer_eq_icase_ssn(s.offset(i as isize), m, mlen as size_t) != 0 {
            i = (i as libc::c_uint).wrapping_add(mlen) as uint32_t as uint32_t;
            if i == slen
                || *s.offset(i as isize) as libc::c_int == ' ' as i32
                || *s.offset(i as isize) as libc::c_int == '\t' as i32
                || *s.offset(i as isize) as libc::c_int == ',' as i32
                || *s.offset(i as isize) as libc::c_int == ';' as i32
            {
                return 1 as libc::c_int;
            }
        }
        while i < slen && *s.offset(i as isize) as libc::c_int != ',' as i32 {
            i = i.wrapping_add(1);
        }
        if !(i < slen) {
            break;
        }
    }
    return 0 as libc::c_int;
}
#[no_mangle]
pub unsafe extern "C" fn http_header_remove_token(
    b: *mut buffer,
    m: *const libc::c_char,
    mlen: uint32_t,
) -> libc::c_int {
    let mut rc: libc::c_int = 0 as libc::c_int;
    let mut s: *mut libc::c_char = (*b).ptr;
    while !s.is_null() {
        while *s as libc::c_int == ' ' as i32
            || *s as libc::c_int == '\t' as i32
            || *s as libc::c_int == ',' as i32
        {
            s = s.offset(1);
        }
        if 0 as libc::c_int == strncasecmp(s, m, mlen as libc::c_ulong) {
            s = s.offset(mlen as isize);
            if *s as libc::c_int == '\0' as i32
                || *s as libc::c_int == ' ' as i32
                || *s as libc::c_int == '\t' as i32
                || *s as libc::c_int == ',' as i32
                || *s as libc::c_int == ';' as i32
            {
                memset(
                    s.offset(-(mlen as isize)) as *mut libc::c_void,
                    ' ' as i32,
                    mlen as libc::c_ulong,
                );
                while *s as libc::c_int != '\0' as i32 && *s as libc::c_int != ',' as i32 {
                    s = s.offset(1);
                }
                rc = 1 as libc::c_int;
                if *s as libc::c_int == ',' as i32 {
                    let fresh173 = s;
                    s = s.offset(1);
                    *fresh173 = ' ' as i32 as libc::c_char;
                    continue;
                } else {
                    s = s.offset(-(mlen as isize));
                    while *s as libc::c_int != ',' as i32 && s != (*b).ptr {
                        s = s.offset(-1);
                    }
                    buffer_truncate(
                        b,
                        s.offset_from((*b).ptr) as libc::c_long as size_t as uint32_t,
                    );
                    break;
                }
            }
        }
        s = strchr(s, ',' as i32);
    }
    return rc;
}
#[inline]
unsafe extern "C" fn http_header_token_append(
    vb: *mut buffer,
    v: *const libc::c_char,
    vlen: uint32_t,
) {
    if buffer_is_blank(vb) == 0 {
        buffer_append_string_len(
            vb,
            b", \0" as *const u8 as *const libc::c_char,
            (::core::mem::size_of::<[libc::c_char; 3]>() as libc::c_ulong as uint32_t)
                .wrapping_sub(1 as libc::c_int as libc::c_uint) as size_t,
        );
    }
    buffer_append_string_len(vb, v, vlen as size_t);
}
#[cold]
#[inline]
unsafe extern "C" fn http_header_token_append_cookie(
    vb: *mut buffer,
    v: *const libc::c_char,
    vlen: uint32_t,
) {
    if buffer_is_blank(vb) == 0 {
        buffer_append_string_len(
            vb,
            b"; \0" as *const u8 as *const libc::c_char,
            (::core::mem::size_of::<[libc::c_char; 3]>() as libc::c_ulong as uint32_t)
                .wrapping_sub(1 as libc::c_int as libc::c_uint) as size_t,
        );
    }
    buffer_append_string_len(vb, v, vlen as size_t);
}
#[inline]
unsafe extern "C" fn http_header_generic_get_ifnotempty(
    a: *const array,
    id: http_header_e,
    k: *const libc::c_char,
    klen: uint32_t,
) -> *mut buffer {
    let ds: *mut data_string =
        array_get_element_klen_ext(a, id as libc::c_int, k, klen) as *mut data_string;
    return if !ds.is_null() && buffer_is_blank(&mut (*ds).value) == 0 {
        &mut (*ds).value
    } else {
        0 as *mut buffer
    };
}
#[inline]
unsafe extern "C" fn http_header_set_key_value(
    a: *mut array,
    mut id: http_header_e,
    k: *const libc::c_char,
    klen: size_t,
    v: *const libc::c_char,
    vlen: size_t,
) {
    buffer_copy_string_len(
        array_get_buf_ptr_ext(a, id as libc::c_int, k, klen as uint32_t),
        v,
        vlen,
    );
}
#[no_mangle]
pub unsafe extern "C" fn http_header_response_get(
    r: *const request_st,
    mut id: http_header_e,
    mut k: *const libc::c_char,
    mut klen: uint32_t,
) -> *mut buffer {
    return if (*r).resp_htags & (1 as libc::c_ulong) << id as libc::c_uint != 0 {
        http_header_generic_get_ifnotempty(&(*r).resp_headers, id, k, klen)
    } else {
        0 as *mut buffer
    };
}
#[no_mangle]
pub unsafe extern "C" fn http_header_response_set_ptr(
    r: *mut request_st,
    mut id: http_header_e,
    mut k: *const libc::c_char,
    mut klen: uint32_t,
) -> *mut buffer {
    (*r).resp_htags |= (1 as libc::c_ulong) << id as libc::c_uint;
    let vb: *mut buffer = array_get_buf_ptr_ext(&mut (*r).resp_headers, id as libc::c_int, k, klen);
    buffer_clear(vb);
    return vb;
}
#[no_mangle]
pub unsafe extern "C" fn http_header_response_unset(
    r: *mut request_st,
    mut id: http_header_e,
    mut k: *const libc::c_char,
    mut klen: uint32_t,
) {
    if (*r).resp_htags & (1 as libc::c_ulong) << id as libc::c_uint != 0 {
        if id as libc::c_uint > HTTP_HEADER_OTHER as libc::c_int as libc::c_uint {
            (*r).resp_htags &= !((1 as libc::c_ulong) << id as libc::c_uint);
        }
        http_header_set_key_value(
            &mut (*r).resp_headers,
            id,
            k,
            klen as size_t,
            b"\0" as *const u8 as *const libc::c_char,
            (::core::mem::size_of::<[libc::c_char; 1]>() as libc::c_ulong as uint32_t)
                .wrapping_sub(1 as libc::c_int as libc::c_uint) as size_t,
        );
    }
}
#[no_mangle]
pub unsafe extern "C" fn http_header_response_set(
    r: *mut request_st,
    mut id: http_header_e,
    mut k: *const libc::c_char,
    mut klen: uint32_t,
    mut v: *const libc::c_char,
    mut vlen: uint32_t,
) {
    if vlen != 0 {
        (*r).resp_htags |= (1 as libc::c_ulong) << id as libc::c_uint;
    } else {
        if id as libc::c_uint > HTTP_HEADER_OTHER as libc::c_int as libc::c_uint {
            (*r).resp_htags &= !((1 as libc::c_ulong) << id as libc::c_uint);
        } else {
        };
    };
    http_header_set_key_value(
        &mut (*r).resp_headers,
        id,
        k,
        klen as size_t,
        v,
        vlen as size_t,
    );
}
#[no_mangle]
pub unsafe extern "C" fn http_header_response_append(
    r: *mut request_st,
    mut id: http_header_e,
    mut k: *const libc::c_char,
    mut klen: uint32_t,
    mut v: *const libc::c_char,
    mut vlen: uint32_t,
) {
    if 0 as libc::c_int as libc::c_uint == vlen {
        return;
    }
    (*r).resp_htags |= (1 as libc::c_ulong) << id as libc::c_uint;
    let vb: *mut buffer = array_get_buf_ptr_ext(&mut (*r).resp_headers, id as libc::c_int, k, klen);
    http_header_token_append(vb, v, vlen);
}
#[cold]
unsafe extern "C" fn http_header_response_insert_addtl(
    r: *mut request_st,
    mut id: http_header_e,
    mut k: *const libc::c_char,
    mut klen: uint32_t,
    vb: *mut buffer,
    mut vlen: uint32_t,
) {
    let mut h: *mut libc::c_char = buffer_string_prepare_append(
        vb,
        (2 as libc::c_int as libc::c_uint)
            .wrapping_add(klen)
            .wrapping_add(vlen)
            .wrapping_add(2 as libc::c_int as libc::c_uint) as size_t,
    );
    buffer_append_str3(
        vb,
        b"\r\n\0" as *const u8 as *const libc::c_char,
        (::core::mem::size_of::<[libc::c_char; 3]>() as libc::c_ulong as uint32_t)
            .wrapping_sub(1 as libc::c_int as libc::c_uint) as size_t,
        k,
        klen as size_t,
        b": \0" as *const u8 as *const libc::c_char,
        (::core::mem::size_of::<[libc::c_char; 3]>() as libc::c_ulong as uint32_t)
            .wrapping_sub(1 as libc::c_int as libc::c_uint) as size_t,
    );
    if (*r).http_version as libc::c_int >= HTTP_VERSION_2 as libc::c_int {
        (*r).resp_header_repeated = 1 as libc::c_int as libc::c_char;
        h = h.offset(2 as libc::c_int as isize);
        let mut i: uint32_t = 0 as libc::c_int as uint32_t;
        while i < klen {
            if (*h.offset(i as isize) as uint32_t).wrapping_sub('A' as i32 as libc::c_uint)
                <= ('Z' as i32 - 'A' as i32) as libc::c_uint
            {
                let ref mut fresh174 = *h.offset(i as isize);
                *fresh174 = (*fresh174 as libc::c_int | 0x20 as libc::c_int) as libc::c_char;
            }
            i = i.wrapping_add(1);
        }
    }
}
#[no_mangle]
pub unsafe extern "C" fn http_header_response_insert(
    r: *mut request_st,
    mut id: http_header_e,
    mut k: *const libc::c_char,
    mut klen: uint32_t,
    mut v: *const libc::c_char,
    mut vlen: uint32_t,
) {
    if 0 as libc::c_int as libc::c_uint == vlen {
        return;
    }
    (*r).resp_htags |= (1 as libc::c_ulong) << id as libc::c_uint;
    let vb: *mut buffer = array_get_buf_ptr_ext(&mut (*r).resp_headers, id as libc::c_int, k, klen);
    if buffer_is_blank(vb) == 0 {
        http_header_response_insert_addtl(r, id, k, klen, vb, vlen);
    }
    buffer_append_string_len(vb, v, vlen as size_t);
}
#[no_mangle]
pub unsafe extern "C" fn http_header_request_get(
    r: *const request_st,
    mut id: http_header_e,
    mut k: *const libc::c_char,
    mut klen: uint32_t,
) -> *mut buffer {
    return if (*r).rqst_htags & (1 as libc::c_ulong) << id as libc::c_uint != 0 {
        http_header_generic_get_ifnotempty(&(*r).rqst_headers, id, k, klen)
    } else {
        0 as *mut buffer
    };
}
#[no_mangle]
pub unsafe extern "C" fn http_header_request_set_ptr(
    r: *mut request_st,
    mut id: http_header_e,
    mut k: *const libc::c_char,
    mut klen: uint32_t,
) -> *mut buffer {
    (*r).rqst_htags |= (1 as libc::c_ulong) << id as libc::c_uint;
    let vb: *mut buffer = array_get_buf_ptr_ext(&mut (*r).rqst_headers, id as libc::c_int, k, klen);
    buffer_clear(vb);
    return vb;
}
#[no_mangle]
pub unsafe extern "C" fn http_header_request_unset(
    r: *mut request_st,
    mut id: http_header_e,
    mut k: *const libc::c_char,
    mut klen: uint32_t,
) {
    if (*r).rqst_htags & (1 as libc::c_ulong) << id as libc::c_uint != 0 {
        if id as libc::c_uint > HTTP_HEADER_OTHER as libc::c_int as libc::c_uint {
            (*r).rqst_htags &= !((1 as libc::c_ulong) << id as libc::c_uint);
        }
        http_header_set_key_value(
            &mut (*r).rqst_headers,
            id,
            k,
            klen as size_t,
            b"\0" as *const u8 as *const libc::c_char,
            (::core::mem::size_of::<[libc::c_char; 1]>() as libc::c_ulong as uint32_t)
                .wrapping_sub(1 as libc::c_int as libc::c_uint) as size_t,
        );
    }
}
#[no_mangle]
pub unsafe extern "C" fn http_header_request_set(
    r: *mut request_st,
    mut id: http_header_e,
    mut k: *const libc::c_char,
    mut klen: uint32_t,
    mut v: *const libc::c_char,
    mut vlen: uint32_t,
) {
    if vlen != 0 {
        (*r).rqst_htags |= (1 as libc::c_ulong) << id as libc::c_uint;
    } else {
        if id as libc::c_uint > HTTP_HEADER_OTHER as libc::c_int as libc::c_uint {
            (*r).rqst_htags &= !((1 as libc::c_ulong) << id as libc::c_uint);
        } else {
        };
    };
    http_header_set_key_value(
        &mut (*r).rqst_headers,
        id,
        k,
        klen as size_t,
        v,
        vlen as size_t,
    );
}
#[no_mangle]
pub unsafe extern "C" fn http_header_request_append(
    r: *mut request_st,
    mut id: http_header_e,
    mut k: *const libc::c_char,
    mut klen: uint32_t,
    mut v: *const libc::c_char,
    mut vlen: uint32_t,
) {
    if 0 as libc::c_int as libc::c_uint == vlen {
        return;
    }
    (*r).rqst_htags |= (1 as libc::c_ulong) << id as libc::c_uint;
    let vb: *mut buffer = array_get_buf_ptr_ext(&mut (*r).rqst_headers, id as libc::c_int, k, klen);
    if id as libc::c_uint != HTTP_HEADER_COOKIE as libc::c_int as libc::c_uint {
        http_header_token_append(vb, v, vlen);
    } else {
        http_header_token_append_cookie(vb, v, vlen);
    };
}
#[no_mangle]
pub unsafe extern "C" fn http_header_env_get(
    r: *const request_st,
    mut k: *const libc::c_char,
    mut klen: uint32_t,
) -> *mut buffer {
    let ds: *mut data_string = array_get_element_klen(&(*r).env, k, klen) as *mut data_string;
    return if !ds.is_null() && buffer_is_blank(&mut (*ds).value) == 0 {
        &mut (*ds).value
    } else {
        0 as *mut buffer
    };
}
#[no_mangle]
pub unsafe extern "C" fn http_header_env_set_ptr(
    mut r: *mut request_st,
    mut k: *const libc::c_char,
    mut klen: uint32_t,
) -> *mut buffer {
    let vb: *mut buffer = array_get_buf_ptr(&mut (*r).env, k, klen);
    buffer_clear(vb);
    return vb;
}
#[no_mangle]
pub unsafe extern "C" fn http_header_env_set(
    r: *mut request_st,
    mut k: *const libc::c_char,
    mut klen: uint32_t,
    mut v: *const libc::c_char,
    mut vlen: uint32_t,
) {
    array_set_key_value(&mut (*r).env, k, klen, v, vlen);
}
#[no_mangle]
pub unsafe extern "C" fn http_header_env_append(
    r: *mut request_st,
    mut k: *const libc::c_char,
    mut klen: uint32_t,
    mut v: *const libc::c_char,
    mut vlen: uint32_t,
) {
    let vb: *mut buffer = array_get_buf_ptr(&mut (*r).env, k, klen);
    if 0 as libc::c_int as libc::c_uint == vlen {
        return;
    }
    http_header_token_append(vb, v, vlen);
}
#[no_mangle]
pub unsafe extern "C" fn http_header_parse_hoff(
    mut n: *const libc::c_char,
    clen: uint32_t,
    mut hoff: *mut libc::c_ushort,
) -> uint32_t {
    let mut hlen: uint32_t = 0 as libc::c_int as uint32_t;
    let mut b: *const libc::c_char = 0 as *const libc::c_char;
    loop {
        b = n;
        n = memchr(
            b as *const libc::c_void,
            '\n' as i32,
            clen.wrapping_sub(hlen) as libc::c_ulong,
        ) as *const libc::c_char;
        if n.is_null() {
            break;
        }
        let mut x: uint32_t =
            (n.offset_from(b) as libc::c_long + 1 as libc::c_int as libc::c_long) as uint32_t;
        hlen = (hlen as libc::c_uint).wrapping_add(x) as uint32_t as uint32_t;
        if x <= 2 as libc::c_int as libc::c_uint
            && (x == 1 as libc::c_int as libc::c_uint
                || *n.offset(-(1 as libc::c_int) as isize) as libc::c_int == '\r' as i32)
        {
            *hoff.offset(
                (*hoff.offset(0 as libc::c_int as isize) as libc::c_int + 1 as libc::c_int)
                    as isize,
            ) = hlen as libc::c_ushort;
            return hlen;
        }
        let ref mut fresh175 = *hoff.offset(0 as libc::c_int as isize);
        *fresh175 = (*fresh175).wrapping_add(1);
        if *fresh175 as libc::c_int >= 8192 as libc::c_int - 1 as libc::c_int {
            break;
        }
        *hoff.offset(*hoff.offset(0 as libc::c_int as isize) as isize) = hlen as libc::c_ushort;
        n = n.offset(1);
    }
    return 0 as libc::c_int as uint32_t;
}
static mut http_versions: [keyvalue; 4] = [keyvalue {
    key: 0,
    vlen: 0,
    value: 0 as *const libc::c_char,
}; 4];
static mut http_methods: [buffer; 40] = [buffer {
    ptr: 0 as *const libc::c_char as *mut libc::c_char,
    used: 0,
    size: 0,
}; 40];
static mut http_status: [keyvalue; 62] = [keyvalue {
    key: 0,
    vlen: 0,
    value: 0 as *const libc::c_char,
}; 62];
#[no_mangle]
pub unsafe extern "C" fn http_method_buf(mut i: http_method_t) -> *const buffer {
    return if (i as libc::c_uint as libc::c_ulong)
        < (::core::mem::size_of::<[buffer; 40]>() as libc::c_ulong)
            .wrapping_div(::core::mem::size_of::<buffer>() as libc::c_ulong)
            .wrapping_sub(2 as libc::c_int as libc::c_ulong)
    {
        http_methods.as_ptr().offset(i as libc::c_int as isize)
    } else {
        http_methods
            .as_ptr()
            .offset(i as libc::c_int as isize)
            .offset(
                (::core::mem::size_of::<[buffer; 40]>() as libc::c_ulong)
                    .wrapping_div(::core::mem::size_of::<buffer>() as libc::c_ulong)
                    as isize,
            )
    };
}
#[inline(never)]
unsafe extern "C" fn keyvalue_from_key(mut kv: *const keyvalue, k: libc::c_int) -> *const keyvalue {
    while (*kv).key != k && (*kv).key != -(1 as libc::c_int) {
        kv = kv.offset(1);
    }
    return kv;
}
#[no_mangle]
pub unsafe extern "C" fn get_http_version_name(mut i: libc::c_int) -> *const libc::c_char {
    return (*keyvalue_from_key(http_versions.as_ptr(), i)).value;
}
#[no_mangle]
pub unsafe extern "C" fn get_http_method_key(
    mut s: *const libc::c_char,
    slen: size_t,
) -> http_method_t {
    if slen == 3 as libc::c_int as libc::c_ulong
        && *s.offset(0 as libc::c_int as isize) as libc::c_int == 'G' as i32
        && *s.offset(1 as libc::c_int as isize) as libc::c_int == 'E' as i32
        && *s.offset(2 as libc::c_int as isize) as libc::c_int == 'T' as i32
    {
        return HTTP_METHOD_GET;
    }
    let mut kv: *const buffer = http_methods.as_ptr().offset(1 as libc::c_int as isize);
    while (*kv).used != 0
        && (((*kv).used).wrapping_sub(1 as libc::c_int as libc::c_uint) as libc::c_ulong != slen
            || 0 as libc::c_int
                != memcmp(
                    (*kv).ptr as *const libc::c_void,
                    s as *const libc::c_void,
                    slen,
                ))
    {
        kv = kv.offset(1);
    }
    let i: uint_fast32_t = kv.offset_from(http_methods.as_ptr()) as libc::c_long as uint_fast32_t;
    return (if i
        < (::core::mem::size_of::<[buffer; 40]>() as libc::c_ulong)
            .wrapping_div(::core::mem::size_of::<buffer>() as libc::c_ulong)
            .wrapping_sub(2 as libc::c_int as libc::c_ulong)
    {
        i as http_method_t as libc::c_int
    } else if i
        == (::core::mem::size_of::<[buffer; 40]>() as libc::c_ulong)
            .wrapping_div(::core::mem::size_of::<buffer>() as libc::c_ulong)
            .wrapping_sub(2 as libc::c_int as libc::c_ulong)
    {
        HTTP_METHOD_PRI as libc::c_int
    } else {
        HTTP_METHOD_UNSET as libc::c_int
    }) as http_method_t;
}
#[no_mangle]
pub unsafe extern "C" fn http_status_append(b: *mut buffer, status: libc::c_int) {
    if 200 as libc::c_int == status {
        buffer_append_string_len(
            b,
            b"200 OK\0" as *const u8 as *const libc::c_char,
            (::core::mem::size_of::<[libc::c_char; 7]>() as libc::c_ulong as uint32_t)
                .wrapping_sub(1 as libc::c_int as libc::c_uint) as size_t,
        );
        return;
    }
    let kv: *const keyvalue = keyvalue_from_key(http_status.as_ptr(), status);
    if (0 as libc::c_int as libc::c_uint != (*kv).vlen) as libc::c_int as libc::c_long != 0 {
        buffer_append_string_len(b, (*kv).value, (*kv).vlen as size_t);
    } else {
        buffer_append_int(b, status as intmax_t);
        buffer_append_string_len(
            b,
            b" \0" as *const u8 as *const libc::c_char,
            (::core::mem::size_of::<[libc::c_char; 2]>() as libc::c_ulong as uint32_t)
                .wrapping_sub(1 as libc::c_int as libc::c_uint) as size_t,
        );
    };
}
#[no_mangle]
pub unsafe extern "C" fn http_version_append(b: *mut buffer, version: http_version_t) {
    let kv: *const keyvalue = keyvalue_from_key(http_versions.as_ptr(), version as libc::c_int);
    if (0 as libc::c_int as libc::c_uint != (*kv).vlen) as libc::c_int as libc::c_long != 0 {
        buffer_append_string_len(b, (*kv).value, (*kv).vlen as size_t);
    }
}
static mut keyvalue_match_data: *mut pcre2_real_match_data_8 =
    0 as *const pcre2_real_match_data_8 as *mut pcre2_real_match_data_8;
#[no_mangle]
#[cold]
pub unsafe extern "C" fn pcre_keyvalue_buffer_init() -> *mut pcre_keyvalue_buffer {
    let mut kvb: *mut pcre_keyvalue_buffer = 0 as *mut pcre_keyvalue_buffer;
    kvb = calloc(
        1 as libc::c_int as libc::c_ulong,
        ::core::mem::size_of::<pcre_keyvalue_buffer>() as libc::c_ulong,
    ) as *mut pcre_keyvalue_buffer;
    if kvb.is_null() {
        ck_assert_failed(
            b"/home/kkysen/work/rust/lighttpd/src/keyvalue.c\0" as *const u8 as *const libc::c_char,
            48 as libc::c_int as libc::c_uint,
            b"((void*)0) != kvb\0" as *const u8 as *const libc::c_char,
        );
    }
    return kvb;
}
#[no_mangle]
#[cold]
pub unsafe extern "C" fn pcre_keyvalue_buffer_append(
    mut errh: *mut log_error_st,
    mut kvb: *mut pcre_keyvalue_buffer,
    mut key: *const buffer,
    mut value: *const buffer,
    pcre_jit: libc::c_int,
) -> libc::c_int {
    let mut kv: *mut pcre_keyvalue = 0 as *mut pcre_keyvalue;
    if 0 as libc::c_int as libc::c_uint == (*kvb).used & 3 as libc::c_int as libc::c_uint {
        (*kvb).kv = realloc(
            (*kvb).kv as *mut libc::c_void,
            (((*kvb).used).wrapping_add(4 as libc::c_int as libc::c_uint) as libc::c_ulong)
                .wrapping_mul(::core::mem::size_of::<pcre_keyvalue>() as libc::c_ulong),
        ) as *mut pcre_keyvalue;
        if ((*kvb).kv).is_null() {
            ck_assert_failed(
                b"/home/kkysen/work/rust/lighttpd/src/keyvalue.c\0" as *const u8
                    as *const libc::c_char,
                61 as libc::c_int as libc::c_uint,
                b"((void*)0) != kvb->kv\0" as *const u8 as *const libc::c_char,
            );
        }
    }
    let fresh176 = (*kvb).used;
    (*kvb).used = ((*kvb).used).wrapping_add(1);
    kv = ((*kvb).kv).offset(fresh176 as isize);
    memcpy(
        &mut (*kv).value as *mut buffer as *mut libc::c_void,
        value as *const libc::c_void,
        ::core::mem::size_of::<buffer>() as libc::c_ulong,
    );
    let mut errcode: libc::c_int = 0;
    let mut erroff: size_t = 0;
    let mut errbuf: [PCRE2_UCHAR8; 1024] = [0; 1024];
    (*kv).code = pcre2_compile_8(
        (*key).ptr as PCRE2_SPTR8,
        buffer_clen(key) as size_t,
        0x80000 as libc::c_uint,
        &mut errcode,
        &mut erroff,
        0 as *mut pcre2_compile_context_8,
    );
    if ((*kv).code).is_null() {
        pcre2_get_error_message_8(
            errcode,
            errbuf.as_mut_ptr(),
            ::core::mem::size_of::<[PCRE2_UCHAR8; 1024]>() as libc::c_ulong,
        );
        log_error(
            errh,
            b"/home/kkysen/work/rust/lighttpd/src/keyvalue.c\0" as *const u8 as *const libc::c_char,
            80 as libc::c_int as libc::c_uint,
            b"pcre2_compile: %s at offset %zu, regex: %s\0" as *const u8 as *const libc::c_char,
            errbuf.as_mut_ptr() as *mut libc::c_char,
            erroff,
            (*key).ptr,
        );
        return 0 as libc::c_int;
    }
    if pcre_jit != 0 {
        errcode = pcre2_jit_compile_8((*kv).code, 0x1 as libc::c_uint);
        if 0 as libc::c_int != errcode && errcode != -(45 as libc::c_int) {
            pcre2_get_error_message_8(
                errcode,
                errbuf.as_mut_ptr(),
                ::core::mem::size_of::<[PCRE2_UCHAR8; 1024]>() as libc::c_ulong,
            );
            log_error(
                errh,
                b"/home/kkysen/work/rust/lighttpd/src/keyvalue.c\0" as *const u8
                    as *const libc::c_char,
                90 as libc::c_int as libc::c_uint,
                b"pcre2_jit_compile: %s, regex: %s\0" as *const u8 as *const libc::c_char,
                errbuf.as_mut_ptr() as *mut libc::c_char,
                (*key).ptr,
            );
        }
    }
    let mut captures: uint32_t = 0;
    errcode = pcre2_pattern_info_8(
        (*kv).code,
        4 as libc::c_int as uint32_t,
        &mut captures as *mut uint32_t as *mut libc::c_void,
    );
    if 0 as libc::c_int != errcode {
        pcre2_get_error_message_8(
            errcode,
            errbuf.as_mut_ptr(),
            ::core::mem::size_of::<[PCRE2_UCHAR8; 1024]>() as libc::c_ulong,
        );
        log_error(
            errh,
            b"/home/kkysen/work/rust/lighttpd/src/keyvalue.c\0" as *const u8 as *const libc::c_char,
            100 as libc::c_int as libc::c_uint,
            b"pcre2_pattern_info: %s, regex: %s\0" as *const u8 as *const libc::c_char,
            errbuf.as_mut_ptr() as *mut libc::c_char,
            (*key).ptr,
        );
        return 0 as libc::c_int;
    } else {
        if captures > 19 as libc::c_int as libc::c_uint {
            log_error(
                errh,
                b"/home/kkysen/work/rust/lighttpd/src/keyvalue.c\0" as *const u8
                    as *const libc::c_char,
                105 as libc::c_int as libc::c_uint,
                b"Too many captures in regex, use (?:...) instead of (...): %s\0" as *const u8
                    as *const libc::c_char,
                (*key).ptr,
            );
            return 0 as libc::c_int;
        }
    }
    if keyvalue_match_data.is_null() {
        keyvalue_match_data = pcre2_match_data_create_8(
            20 as libc::c_int as uint32_t,
            0 as *mut pcre2_general_context_8,
        );
        if keyvalue_match_data.is_null() {
            ck_assert_failed(
                b"/home/kkysen/work/rust/lighttpd/src/keyvalue.c\0" as *const u8
                    as *const libc::c_char,
                114 as libc::c_int as libc::c_uint,
                b"keyvalue_match_data\0" as *const u8 as *const libc::c_char,
            );
        }
    }
    (*kv).match_data = keyvalue_match_data;
    return 1 as libc::c_int;
}
#[no_mangle]
#[cold]
pub unsafe extern "C" fn pcre_keyvalue_buffer_free(mut kvb: *mut pcre_keyvalue_buffer) {
    let mut kv: *mut pcre_keyvalue = (*kvb).kv;
    let mut i: libc::c_int = 0 as libc::c_int;
    let mut used: libc::c_int = (*kvb).used as libc::c_int;
    while i < used {
        if !((*kv).code).is_null() {
            pcre2_code_free_8((*kv).code);
        }
        if !keyvalue_match_data.is_null() {
            pcre2_match_data_free_8(keyvalue_match_data);
            keyvalue_match_data = 0 as *mut pcre2_real_match_data_8;
        }
        i += 1;
        kv = kv.offset(1);
    }
    if !((*kvb).kv).is_null() {
        free((*kvb).kv as *mut libc::c_void);
    }
    free(kvb as *mut libc::c_void);
}
unsafe extern "C" fn pcre_keyvalue_buffer_append_match(
    mut b: *mut buffer,
    mut ctx: *const pcre_keyvalue_ctx,
    mut num: libc::c_uint,
    mut flags: libc::c_int,
) {
    if num < (*ctx).n as libc::c_uint {
        let mut ovec: *const size_t = (*ctx).ovec as *mut size_t;
        num <<= 1 as libc::c_int;
        let off: size_t = *ovec.offset(num as isize);
        let len: size_t = (*ovec
            .offset(num.wrapping_add(1 as libc::c_int as libc::c_uint) as isize))
        .wrapping_sub(off);
        burl_append(b, ((*ctx).subject).offset(off as isize), len, flags);
    }
}
unsafe extern "C" fn pcre_keyvalue_buffer_append_ctxmatch(
    mut b: *mut buffer,
    mut ctx: *const pcre_keyvalue_ctx,
    mut num: libc::c_uint,
    mut flags: libc::c_int,
) {
    let cache: *const cond_match_t = (*ctx).cache;
    if cache.is_null() {
        return;
    }
    if num < (*cache).captures as libc::c_uint {
        let mut ovec: *const size_t = (*cache).matches as *mut size_t;
        num <<= 1 as libc::c_int;
        let off: size_t = *ovec.offset(num as isize);
        let len: size_t = (*ovec
            .offset(num.wrapping_add(1 as libc::c_int as libc::c_uint) as isize))
        .wrapping_sub(off);
        burl_append(
            b,
            ((*(*cache).comp_value).ptr).offset(off as isize),
            len,
            flags,
        );
    }
}
unsafe extern "C" fn pcre_keyvalue_buffer_subst_ext(
    mut b: *mut buffer,
    mut pattern: *const libc::c_char,
    mut ctx: *const pcre_keyvalue_ctx,
) -> libc::c_int {
    let mut p: *const libc::c_uchar =
        (pattern as *mut libc::c_uchar).offset(2 as libc::c_int as isize);
    let mut flags: libc::c_int = 0 as libc::c_int;
    while light_isdigit(*p as libc::c_int) == 0
        && *p as libc::c_int != '}' as i32
        && *p as libc::c_int != '\0' as i32
    {
        if *p.offset(0 as libc::c_int as isize) as libc::c_int == 'e' as i32
            && *p.offset(1 as libc::c_int as isize) as libc::c_int == 's' as i32
            && *p.offset(2 as libc::c_int as isize) as libc::c_int == 'c' as i32
        {
            p = p.offset(3 as libc::c_int as isize);
            if *p.offset(0 as libc::c_int as isize) as libc::c_int == ':' as i32 {
                flags |= BURL_ENCODE_ALL as libc::c_int;
                p = p.offset(1 as libc::c_int as isize);
            } else if 0 as libc::c_int
                == strncmp(
                    p as *const libc::c_char,
                    b"ape:\0" as *const u8 as *const libc::c_char,
                    4 as libc::c_int as libc::c_ulong,
                )
            {
                flags |= BURL_ENCODE_ALL as libc::c_int;
                p = p.offset(4 as libc::c_int as isize);
            } else if 0 as libc::c_int
                == strncmp(
                    p as *const libc::c_char,
                    b"nde:\0" as *const u8 as *const libc::c_char,
                    4 as libc::c_int as libc::c_ulong,
                )
            {
                flags |= BURL_ENCODE_NDE as libc::c_int;
                p = p.offset(4 as libc::c_int as isize);
            } else if 0 as libc::c_int
                == strncmp(
                    p as *const libc::c_char,
                    b"psnde:\0" as *const u8 as *const libc::c_char,
                    6 as libc::c_int as libc::c_ulong,
                )
            {
                flags |= BURL_ENCODE_PSNDE as libc::c_int;
                p = p.offset(6 as libc::c_int as isize);
            } else {
                p = strchr(p as *const libc::c_char, ':' as i32) as *const libc::c_uchar;
                if p.is_null() {
                    return -(1 as libc::c_int);
                }
                p = p.offset(1);
            }
        } else if *p.offset(0 as libc::c_int as isize) as libc::c_int == 'n' as i32
            && *p.offset(1 as libc::c_int as isize) as libc::c_int == 'o' as i32
        {
            p = p.offset(2 as libc::c_int as isize);
            if 0 as libc::c_int
                == strncmp(
                    p as *const libc::c_char,
                    b"esc:\0" as *const u8 as *const libc::c_char,
                    4 as libc::c_int as libc::c_ulong,
                )
            {
                flags |= BURL_ENCODE_NONE as libc::c_int;
                p = p.offset(4 as libc::c_int as isize);
            } else if 0 as libc::c_int
                == strncmp(
                    p as *const libc::c_char,
                    b"escape:\0" as *const u8 as *const libc::c_char,
                    7 as libc::c_int as libc::c_ulong,
                )
            {
                flags |= BURL_ENCODE_NONE as libc::c_int;
                p = p.offset(7 as libc::c_int as isize);
            } else {
                p = strchr(p as *const libc::c_char, ':' as i32) as *const libc::c_uchar;
                if p.is_null() {
                    return -(1 as libc::c_int);
                }
                p = p.offset(1);
            }
        } else if *p.offset(0 as libc::c_int as isize) as libc::c_int == 't' as i32
            && *p.offset(1 as libc::c_int as isize) as libc::c_int == 'o' as i32
        {
            p = p.offset(2 as libc::c_int as isize);
            if 0 as libc::c_int
                == strncmp(
                    p as *const libc::c_char,
                    b"lower:\0" as *const u8 as *const libc::c_char,
                    6 as libc::c_int as libc::c_ulong,
                )
            {
                flags |= BURL_TOLOWER as libc::c_int;
                p = p.offset(6 as libc::c_int as isize);
            } else if 0 as libc::c_int
                == strncmp(
                    p as *const libc::c_char,
                    b"upper:\0" as *const u8 as *const libc::c_char,
                    6 as libc::c_int as libc::c_ulong,
                )
            {
                flags |= BURL_TOLOWER as libc::c_int;
                p = p.offset(6 as libc::c_int as isize);
            } else {
                p = strchr(p as *const libc::c_char, ':' as i32) as *const libc::c_uchar;
                if p.is_null() {
                    return -(1 as libc::c_int);
                }
                p = p.offset(1);
            }
        } else if *p.offset(0 as libc::c_int as isize) as libc::c_int == 'u' as i32
            && *p.offset(1 as libc::c_int as isize) as libc::c_int == 'r' as i32
            && *p.offset(2 as libc::c_int as isize) as libc::c_int == 'l' as i32
            && *p.offset(3 as libc::c_int as isize) as libc::c_int == '.' as i32
        {
            let burl: *const burl_parts_t = (*ctx).burl;
            p = p.offset(4 as libc::c_int as isize);
            if 0 as libc::c_int
                == strncmp(
                    p as *const libc::c_char,
                    b"scheme}\0" as *const u8 as *const libc::c_char,
                    7 as libc::c_int as libc::c_ulong,
                )
            {
                if !((*burl).scheme).is_null() {
                    burl_append(
                        b,
                        (*(*burl).scheme).ptr,
                        buffer_clen((*burl).scheme) as size_t,
                        flags,
                    );
                }
                p = p.offset(6 as libc::c_int as isize);
            } else if 0 as libc::c_int
                == strncmp(
                    p as *const libc::c_char,
                    b"authority}\0" as *const u8 as *const libc::c_char,
                    10 as libc::c_int as libc::c_ulong,
                )
            {
                if !((*burl).authority).is_null() {
                    burl_append(
                        b,
                        (*(*burl).authority).ptr,
                        buffer_clen((*burl).authority) as size_t,
                        flags,
                    );
                }
                p = p.offset(9 as libc::c_int as isize);
            } else if 0 as libc::c_int
                == strncmp(
                    p as *const libc::c_char,
                    b"port}\0" as *const u8 as *const libc::c_char,
                    5 as libc::c_int as libc::c_ulong,
                )
            {
                buffer_append_int(b, (*burl).port as libc::c_int as intmax_t);
                p = p.offset(4 as libc::c_int as isize);
            } else if 0 as libc::c_int
                == strncmp(
                    p as *const libc::c_char,
                    b"path}\0" as *const u8 as *const libc::c_char,
                    5 as libc::c_int as libc::c_ulong,
                )
            {
                let target: *const buffer = (*burl).path;
                let len: uint32_t = buffer_clen(target);
                let ptr: *const libc::c_char = (*target).ptr;
                let qmark: *const libc::c_char =
                    memchr(ptr as *const libc::c_void, '?' as i32, len as libc::c_ulong)
                        as *const libc::c_char;
                burl_append(
                    b,
                    ptr,
                    (if !qmark.is_null() {
                        qmark.offset_from(ptr) as libc::c_long as uint32_t
                    } else {
                        len
                    }) as size_t,
                    flags,
                );
                p = p.offset(4 as libc::c_int as isize);
            } else if 0 as libc::c_int
                == strncmp(
                    p as *const libc::c_char,
                    b"query}\0" as *const u8 as *const libc::c_char,
                    6 as libc::c_int as libc::c_ulong,
                )
            {
                if !((*burl).query).is_null() {
                    burl_append(
                        b,
                        (*(*burl).query).ptr,
                        buffer_clen((*burl).query) as size_t,
                        flags,
                    );
                }
                p = p.offset(5 as libc::c_int as isize);
            } else {
                p = strchr(p as *const libc::c_char, '}' as i32) as *const libc::c_uchar;
                if p.is_null() {
                    return -(1 as libc::c_int);
                }
            }
            break;
        } else if *p.offset(0 as libc::c_int as isize) as libc::c_int == 'q' as i32
            && *p.offset(1 as libc::c_int as isize) as libc::c_int == 's' as i32
            && *p.offset(2 as libc::c_int as isize) as libc::c_int == 'a' as i32
            && *p.offset(3 as libc::c_int as isize) as libc::c_int == '}' as i32
        {
            let mut qs: *const buffer = (*(*ctx).burl).query;
            if !qs.is_null() && buffer_is_unset(qs) == 0 {
                if !(strchr((*b).ptr, '?' as i32)).is_null() {
                    if buffer_is_blank(qs) == 0 {
                        buffer_append_string_len(
                            b,
                            b"&\0" as *const u8 as *const libc::c_char,
                            (::core::mem::size_of::<[libc::c_char; 2]>() as libc::c_ulong
                                as uint32_t)
                                .wrapping_sub(1 as libc::c_int as libc::c_uint)
                                as size_t,
                        );
                    }
                } else {
                    buffer_append_string_len(
                        b,
                        b"?\0" as *const u8 as *const libc::c_char,
                        (::core::mem::size_of::<[libc::c_char; 2]>() as libc::c_ulong as uint32_t)
                            .wrapping_sub(1 as libc::c_int as libc::c_uint)
                            as size_t,
                    );
                }
                burl_append(b, (*qs).ptr, buffer_clen(qs) as size_t, flags);
            }
            p = p.offset(3 as libc::c_int as isize);
            break;
        } else if *p.offset(0 as libc::c_int as isize) as libc::c_int == 'e' as i32
            && *p.offset(1 as libc::c_int as isize) as libc::c_int == 'n' as i32
            && *p.offset(2 as libc::c_int as isize) as libc::c_int == 'c' as i32
            && 0 as libc::c_int
                == strncmp(
                    (p as *const libc::c_char).offset(3 as libc::c_int as isize),
                    b"b64u:\0" as *const u8 as *const libc::c_char,
                    5 as libc::c_int as libc::c_ulong,
                )
        {
            flags |= BURL_ENCODE_B64U as libc::c_int;
            p = p.offset(8 as libc::c_int as isize);
        } else if *p.offset(0 as libc::c_int as isize) as libc::c_int == 'd' as i32
            && *p.offset(1 as libc::c_int as isize) as libc::c_int == 'e' as i32
            && *p.offset(2 as libc::c_int as isize) as libc::c_int == 'c' as i32
            && 0 as libc::c_int
                == strncmp(
                    (p as *const libc::c_char).offset(3 as libc::c_int as isize),
                    b"b64u:\0" as *const u8 as *const libc::c_char,
                    5 as libc::c_int as libc::c_ulong,
                )
        {
            flags |= BURL_DECODE_B64U as libc::c_int;
            p = p.offset(8 as libc::c_int as isize);
        } else {
            p = p.offset(1);
        }
    }
    if *p as libc::c_int == '\0' as i32 {
        return -(1 as libc::c_int);
    }
    if *p as libc::c_int != '}' as i32 {
        let mut num: libc::c_uint = (*p as libc::c_int - '0' as i32) as libc::c_uint;
        p = p.offset(1);
        if light_isdigit(*p as libc::c_int) != 0 {
            let fresh177 = p;
            p = p.offset(1);
            num = num
                .wrapping_mul(10 as libc::c_int as libc::c_uint)
                .wrapping_add((*fresh177 as libc::c_int - '0' as i32) as libc::c_uint);
        }
        if *p as libc::c_int != '}' as i32 {
            p = strchr(p as *const libc::c_char, '}' as i32) as *const libc::c_uchar;
            if p.is_null() {
                return -(1 as libc::c_int);
            }
        }
        if 0 as libc::c_int == flags {
            flags = BURL_ENCODE_PSNDE as libc::c_int;
        }
        if *pattern.offset(0 as libc::c_int as isize) as libc::c_int == '$' as i32 {
            pcre_keyvalue_buffer_append_match(b, ctx, num, flags);
        } else {
            pcre_keyvalue_buffer_append_ctxmatch(b, ctx, num, flags);
        };
    }
    return (p
        .offset(1 as libc::c_int as isize)
        .offset_from(pattern as *mut libc::c_uchar) as libc::c_long
        - 2 as libc::c_int as libc::c_long) as libc::c_int;
}
unsafe extern "C" fn pcre_keyvalue_buffer_subst(
    mut b: *mut buffer,
    mut patternb: *const buffer,
    mut ctx: *const pcre_keyvalue_ctx,
) {
    let mut pattern: *const libc::c_char = (*patternb).ptr;
    let pattern_len: size_t = buffer_clen(patternb) as size_t;
    let mut start: size_t = 0 as libc::c_int as size_t;
    buffer_clear(b);
    let mut k: size_t = 0 as libc::c_int as size_t;
    while k.wrapping_add(1 as libc::c_int as libc::c_ulong) < pattern_len {
        if *pattern.offset(k as isize) as libc::c_int == '$' as i32
            || *pattern.offset(k as isize) as libc::c_int == '%' as i32
        {
            buffer_append_string_len(b, pattern.offset(start as isize), k.wrapping_sub(start));
            if *pattern.offset(k.wrapping_add(1 as libc::c_int as libc::c_ulong) as isize)
                as libc::c_int
                == '{' as i32
            {
                let mut num: libc::c_int =
                    pcre_keyvalue_buffer_subst_ext(b, pattern.offset(k as isize), ctx);
                if num < 0 as libc::c_int {
                    return;
                }
                k = (k as libc::c_ulong).wrapping_add(num as size_t) as size_t as size_t;
            } else if light_isdigit(
                *(pattern as *mut libc::c_uchar)
                    .offset(k.wrapping_add(1 as libc::c_int as libc::c_ulong) as isize)
                    as libc::c_int,
            ) != 0
            {
                let mut num_0: libc::c_uint = (*pattern
                    .offset(k.wrapping_add(1 as libc::c_int as libc::c_ulong) as isize)
                    as libc::c_uint)
                    .wrapping_sub('0' as i32 as libc::c_uint);
                if *pattern.offset(k as isize) as libc::c_int == '$' as i32 {
                    pcre_keyvalue_buffer_append_match(b, ctx, num_0, 0 as libc::c_int);
                } else {
                    pcre_keyvalue_buffer_append_ctxmatch(b, ctx, num_0, 0 as libc::c_int);
                };
            } else {
                buffer_append_string_len(
                    b,
                    pattern.offset(k as isize),
                    (if *pattern.offset(k as isize) as libc::c_int
                        == *pattern
                            .offset(k.wrapping_add(1 as libc::c_int as libc::c_ulong) as isize)
                            as libc::c_int
                    {
                        1 as libc::c_int
                    } else {
                        2 as libc::c_int
                    }) as size_t,
                );
            }
            k = k.wrapping_add(1);
            start = k.wrapping_add(1 as libc::c_int as libc::c_ulong);
        }
        k = k.wrapping_add(1);
    }
    buffer_append_string_len(
        b,
        pattern.offset(start as isize),
        pattern_len.wrapping_sub(start),
    );
}
#[no_mangle]
pub unsafe extern "C" fn pcre_keyvalue_buffer_process(
    mut kvb: *const pcre_keyvalue_buffer,
    mut ctx: *mut pcre_keyvalue_ctx,
    mut input: *const buffer,
    mut result: *mut buffer,
) -> handler_t {
    let mut kv: *const pcre_keyvalue = (*kvb).kv;
    let mut i: libc::c_int = 0 as libc::c_int;
    let mut used: libc::c_int = (*kvb).used as libc::c_int;
    while i < used {
        let mut n: libc::c_int = pcre2_match_8(
            (*kv).code,
            (*input).ptr as PCRE2_SPTR8,
            buffer_clen(input) as size_t,
            0 as libc::c_int as size_t,
            0 as libc::c_int as uint32_t,
            (*kv).match_data,
            0 as *mut pcre2_match_context_8,
        );
        if n < 0 as libc::c_int {
            if n != -(1 as libc::c_int) {
                return HANDLER_ERROR;
            }
        } else if buffer_is_blank(&(*kv).value) != 0 {
            (*ctx).m = i;
            return HANDLER_GO_ON;
        } else {
            (*ctx).m = i;
            (*ctx).n = n;
            (*ctx).subject = (*input).ptr;
            (*ctx).ovec = pcre2_get_ovector_pointer_8((*kv).match_data) as *mut libc::c_void;
            pcre_keyvalue_buffer_subst(result, &(*kv).value, ctx);
            return HANDLER_FINISHED;
        }
        i += 1;
        kv = kv.offset(1);
    }
    return HANDLER_GO_ON;
}
unsafe extern "C" fn pcre_keyvalue_burl_percent_toupper(mut b: *mut buffer) {
    let s: *const libc::c_uchar = (*b).ptr as *mut libc::c_uchar;
    let used: libc::c_int = buffer_clen(b) as libc::c_int;
    let mut n1: libc::c_uint = 0;
    let mut n2: libc::c_uint = 0;
    let mut i: libc::c_int = 0 as libc::c_int;
    while i < used {
        if *s.offset(i as isize) as libc::c_int == '%' as i32
            && {
                n1 = (*s.offset((i + 1 as libc::c_int) as isize) as libc::c_int - '0' as i32)
                    as libc::c_uint;
                n1 <= 9 as libc::c_int as libc::c_uint || {
                    n1 = ((*s.offset((i + 1 as libc::c_int) as isize) as libc::c_int
                        & 0xdf as libc::c_int)
                        - 'A' as i32) as libc::c_uint;
                    (if n1 <= 5 as libc::c_int as libc::c_uint {
                        n1 = n1.wrapping_add(10 as libc::c_int as libc::c_uint);
                        n1
                    } else {
                        0 as libc::c_int as libc::c_uint
                    }) != 0
                }
            }
            && {
                n2 = (*s.offset((i + 2 as libc::c_int) as isize) as libc::c_int - '0' as i32)
                    as libc::c_uint;
                n2 <= 9 as libc::c_int as libc::c_uint || {
                    n2 = ((*s.offset((i + 2 as libc::c_int) as isize) as libc::c_int
                        & 0xdf as libc::c_int)
                        - 'A' as i32) as libc::c_uint;
                    (if n2 <= 5 as libc::c_int as libc::c_uint {
                        n2 = n2.wrapping_add(10 as libc::c_int as libc::c_uint);
                        n2
                    } else {
                        0 as libc::c_int as libc::c_uint
                    }) != 0
                }
            }
        {
            if *s.offset((i + 1 as libc::c_int) as isize) as libc::c_int >= 'a' as i32 {
                let ref mut fresh178 = *((*b).ptr).offset((i + 1 as libc::c_int) as isize);
                *fresh178 = (*fresh178 as libc::c_int & 0xdf as libc::c_int) as libc::c_char;
            }
            if *s.offset((i + 2 as libc::c_int) as isize) as libc::c_int >= 'a' as i32 {
                let ref mut fresh179 = *((*b).ptr).offset((i + 2 as libc::c_int) as isize);
                *fresh179 = (*fresh179 as libc::c_int & 0xdf as libc::c_int) as libc::c_char;
            }
            i += 2 as libc::c_int;
        }
        i += 1;
    }
}
unsafe extern "C" fn pcre_keyvalue_burl_percent_percent_toupper(mut b: *mut buffer) {
    let s: *const libc::c_uchar = (*b).ptr as *mut libc::c_uchar;
    let used: libc::c_int = buffer_clen(b) as libc::c_int;
    let mut n1: libc::c_uint = 0;
    let mut n2: libc::c_uint = 0;
    let mut i: libc::c_int = 0 as libc::c_int;
    while i < used {
        if *s.offset(i as isize) as libc::c_int == '%' as i32
            && *s.offset((i + 1 as libc::c_int) as isize) as libc::c_int == '%' as i32
            && {
                n1 = (*s.offset((i + 2 as libc::c_int) as isize) as libc::c_int - '0' as i32)
                    as libc::c_uint;
                n1 <= 9 as libc::c_int as libc::c_uint || {
                    n1 = ((*s.offset((i + 2 as libc::c_int) as isize) as libc::c_int
                        & 0xdf as libc::c_int)
                        - 'A' as i32) as libc::c_uint;
                    (if n1 <= 5 as libc::c_int as libc::c_uint {
                        n1 = n1.wrapping_add(10 as libc::c_int as libc::c_uint);
                        n1
                    } else {
                        0 as libc::c_int as libc::c_uint
                    }) != 0
                }
            }
            && {
                n2 = (*s.offset((i + 3 as libc::c_int) as isize) as libc::c_int - '0' as i32)
                    as libc::c_uint;
                n2 <= 9 as libc::c_int as libc::c_uint || {
                    n2 = ((*s.offset((i + 3 as libc::c_int) as isize) as libc::c_int
                        & 0xdf as libc::c_int)
                        - 'A' as i32) as libc::c_uint;
                    (if n2 <= 5 as libc::c_int as libc::c_uint {
                        n2 = n2.wrapping_add(10 as libc::c_int as libc::c_uint);
                        n2
                    } else {
                        0 as libc::c_int as libc::c_uint
                    }) != 0
                }
            }
        {
            if *s.offset((i + 2 as libc::c_int) as isize) as libc::c_int >= 'a' as i32 {
                let ref mut fresh180 = *((*b).ptr).offset((i + 2 as libc::c_int) as isize);
                *fresh180 = (*fresh180 as libc::c_int & 0xdf as libc::c_int) as libc::c_char;
            }
            if *s.offset((i + 3 as libc::c_int) as isize) as libc::c_int >= 'a' as i32 {
                let ref mut fresh181 = *((*b).ptr).offset((i + 3 as libc::c_int) as isize);
                *fresh181 = (*fresh181 as libc::c_int & 0xdf as libc::c_int) as libc::c_char;
            }
            i += 3 as libc::c_int;
        }
        i += 1;
    }
}
unsafe extern "C" fn pcre_keyvalue_burl_percent_high_UTF8(mut b: *mut buffer, mut t: *mut buffer) {
    let s: *const libc::c_uchar = (*b).ptr as *mut libc::c_uchar;
    let mut p: *mut libc::c_uchar = 0 as *mut libc::c_uchar;
    let used: libc::c_int = buffer_clen(b) as libc::c_int;
    let mut count: libc::c_uint = 0 as libc::c_int as libc::c_uint;
    let mut j: libc::c_uint = 0 as libc::c_int as libc::c_uint;
    let mut i: libc::c_int = 0 as libc::c_int;
    while i < used {
        if *s.offset(i as isize) as libc::c_int > 0x7f as libc::c_int {
            count = count.wrapping_add(1);
        }
        i += 1;
    }
    if 0 as libc::c_int as libc::c_uint == count {
        return;
    }
    p = buffer_string_prepare_copy(
        t,
        (used as libc::c_uint).wrapping_add(count.wrapping_mul(2 as libc::c_int as libc::c_uint))
            as size_t,
    ) as *mut libc::c_uchar;
    let mut i_0: libc::c_int = 0 as libc::c_int;
    while i_0 < used {
        if *s.offset(i_0 as isize) as libc::c_int <= 0x7f as libc::c_int {
            *p.offset(j as isize) = *s.offset(i_0 as isize);
        } else {
            *p.offset(j as isize) = '%' as i32 as libc::c_uchar;
            j = j.wrapping_add(1);
            *p.offset(j as isize) =
                hex_chars_uc[(*s.offset(i_0 as isize) as libc::c_int >> 4 as libc::c_int
                    & 0xf as libc::c_int) as usize] as libc::c_uchar;
            j = j.wrapping_add(1);
            *p.offset(j as isize) = hex_chars_uc
                [(*s.offset(i_0 as isize) as libc::c_int & 0xf as libc::c_int) as usize]
                as libc::c_uchar;
        }
        i_0 += 1;
        j = j.wrapping_add(1);
    }
    buffer_copy_string_len(b, p as *mut libc::c_char, j as size_t);
}
unsafe extern "C" fn pcre_keyvalue_burl_percent_percent_high_UTF8(
    mut b: *mut buffer,
    mut t: *mut buffer,
) {
    let s: *const libc::c_uchar = (*b).ptr as *mut libc::c_uchar;
    let mut p: *mut libc::c_uchar = 0 as *mut libc::c_uchar;
    let used: libc::c_int = buffer_clen(b) as libc::c_int;
    let mut count: libc::c_uint = 0 as libc::c_int as libc::c_uint;
    let mut j: libc::c_uint = 0 as libc::c_int as libc::c_uint;
    let mut i: libc::c_int = 0 as libc::c_int;
    while i < used {
        if *s.offset(i as isize) as libc::c_int > 0x7f as libc::c_int {
            count = count.wrapping_add(1);
        }
        i += 1;
    }
    if 0 as libc::c_int as libc::c_uint == count {
        return;
    }
    p = buffer_string_prepare_copy(
        t,
        (used as libc::c_uint).wrapping_add(count.wrapping_mul(3 as libc::c_int as libc::c_uint))
            as size_t,
    ) as *mut libc::c_uchar;
    let mut i_0: libc::c_int = 0 as libc::c_int;
    while i_0 < used {
        if *s.offset(i_0 as isize) as libc::c_int <= 0x7f as libc::c_int {
            *p.offset(j as isize) = *s.offset(i_0 as isize);
        } else {
            *p.offset(j as isize) = '%' as i32 as libc::c_uchar;
            j = j.wrapping_add(1);
            *p.offset(j as isize) = '%' as i32 as libc::c_uchar;
            j = j.wrapping_add(1);
            *p.offset(j as isize) =
                hex_chars_uc[(*s.offset(i_0 as isize) as libc::c_int >> 4 as libc::c_int
                    & 0xf as libc::c_int) as usize] as libc::c_uchar;
            j = j.wrapping_add(1);
            *p.offset(j as isize) = hex_chars_uc
                [(*s.offset(i_0 as isize) as libc::c_int & 0xf as libc::c_int) as usize]
                as libc::c_uchar;
        }
        i_0 += 1;
        j = j.wrapping_add(1);
    }
    buffer_copy_string_len(b, p as *mut libc::c_char, j as size_t);
}
#[no_mangle]
#[cold]
pub unsafe extern "C" fn pcre_keyvalue_burl_normalize_key(mut k: *mut buffer, mut t: *mut buffer) {
    pcre_keyvalue_burl_percent_toupper(k);
    pcre_keyvalue_burl_percent_high_UTF8(k, t);
}
#[no_mangle]
#[cold]
pub unsafe extern "C" fn pcre_keyvalue_burl_normalize_value(
    mut v: *mut buffer,
    mut t: *mut buffer,
) {
    pcre_keyvalue_burl_percent_percent_toupper(v);
    pcre_keyvalue_burl_percent_percent_high_UTF8(v, t);
}
static mut chunk_buf_sz: size_t = 8192 as libc::c_int as size_t;
static mut chunks: *mut chunk = 0 as *const chunk as *mut chunk;
static mut chunks_oversized: *mut chunk = 0 as *const chunk as *mut chunk;
static mut chunks_filechunk: *mut chunk = 0 as *const chunk as *mut chunk;
static mut chunk_buffers: *mut chunk = 0 as *const chunk as *mut chunk;
static mut chunks_oversized_n: libc::c_int = 0;
static mut chunkqueue_default_tempdirs: *const array = 0 as *const array;
static mut chunkqueue_default_tempfile_size: off_t =
    (1 as libc::c_int * 1024 as libc::c_int * 1024 as libc::c_int) as off_t;
#[no_mangle]
#[cold]
pub unsafe extern "C" fn chunkqueue_set_chunk_size(mut sz: size_t) {
    let mut x: size_t = 1024 as libc::c_int as size_t;
    while x < sz && x < ((1 as libc::c_uint) << 30 as libc::c_int) as libc::c_ulong {
        x <<= 1 as libc::c_int;
    }
    chunk_buf_sz = if sz > 0 as libc::c_int as libc::c_ulong {
        x
    } else {
        8192 as libc::c_int as libc::c_ulong
    };
}
#[no_mangle]
#[cold]
pub unsafe extern "C" fn chunkqueue_set_tempdirs_default_reset() {
    chunk_buf_sz = 8192 as libc::c_int as size_t;
    chunkqueue_default_tempdirs = 0 as *const array;
    chunkqueue_default_tempfile_size =
        (1 as libc::c_int * 1024 as libc::c_int * 1024 as libc::c_int) as off_t;
}
#[no_mangle]
pub unsafe extern "C" fn chunkqueue_init(mut cq: *mut chunkqueue) -> *mut chunkqueue {
    if cq.is_null() {
        cq = calloc(
            1 as libc::c_int as libc::c_ulong,
            ::core::mem::size_of::<chunkqueue>() as libc::c_ulong,
        ) as *mut chunkqueue;
        if cq.is_null() {
            ck_assert_failed(
                b"/home/kkysen/work/rust/lighttpd/src/chunk.c\0" as *const u8
                    as *const libc::c_char,
                52 as libc::c_int as libc::c_uint,
                b"((void*)0) != cq\0" as *const u8 as *const libc::c_char,
            );
        }
    }
    (*cq).first = 0 as *mut chunk;
    (*cq).last = 0 as *mut chunk;
    (*cq).tempdirs = chunkqueue_default_tempdirs;
    (*cq).upload_temp_file_size = chunkqueue_default_tempfile_size;
    return cq;
}
unsafe extern "C" fn chunk_init() -> *mut chunk {
    let c: *mut chunk = calloc(
        1 as libc::c_int as libc::c_ulong,
        ::core::mem::size_of::<chunk>() as libc::c_ulong,
    ) as *mut chunk;
    if c.is_null() {
        ck_assert_failed(
            b"/home/kkysen/work/rust/lighttpd/src/chunk.c\0" as *const u8 as *const libc::c_char,
            67 as libc::c_int as libc::c_uint,
            b"((void*)0) != c\0" as *const u8 as *const libc::c_char,
        );
    }
    (*c).file.fd = -(1 as libc::c_int);
    (*c).file.mmap.start = -(1 as libc::c_int) as *mut libc::c_void as *mut libc::c_char;
    (*c).mem = buffer_init();
    return c;
}
unsafe extern "C" fn chunk_init_sz(mut sz: size_t) -> *mut chunk {
    let c: *mut chunk = chunk_init();
    buffer_string_prepare_copy((*c).mem, sz.wrapping_sub(1 as libc::c_int as libc::c_ulong));
    return c;
}
unsafe extern "C" fn chunk_reset_file_chunk(mut c: *mut chunk) {
    if (*c).file.is_temp != 0 {
        (*c).file.is_temp = 0 as libc::c_int;
        if buffer_is_blank((*c).mem) == 0 {
            unlink((*(*c).mem).ptr);
        }
    }
    if ((*c).file.refchg).is_some() {
        ((*c).file.refchg).expect("non-null function pointer")(
            (*c).file.ref_0,
            -(1 as libc::c_int),
        );
        (*c).file.refchg = None;
        (*c).file.ref_0 = 0 as *mut libc::c_void;
    } else if (*c).file.fd != -(1 as libc::c_int) {
        close((*c).file.fd);
    }
    if -(1 as libc::c_int) as *mut libc::c_void != (*c).file.mmap.start as *mut libc::c_void {
        munmap(
            (*c).file.mmap.start as *mut libc::c_void,
            (*c).file.mmap.length,
        );
        (*c).file.mmap.start = -(1 as libc::c_int) as *mut libc::c_void as *mut libc::c_char;
        (*c).file.mmap.offset = 0 as libc::c_int as off_t;
        (*c).file.mmap.length = (*c).file.mmap.offset as size_t;
    }
    (*c).file.fd = -(1 as libc::c_int);
    (*c).file.length = 0 as libc::c_int as off_t;
    (*c).type_0 = MEM_CHUNK;
}
unsafe extern "C" fn chunk_reset(mut c: *mut chunk) {
    if (*c).type_0 as libc::c_uint == FILE_CHUNK as libc::c_int as libc::c_uint {
        chunk_reset_file_chunk(c);
    }
    buffer_clear((*c).mem);
    (*c).offset = 0 as libc::c_int as off_t;
}
unsafe extern "C" fn chunk_free(mut c: *mut chunk) {
    if (*c).type_0 as libc::c_uint == FILE_CHUNK as libc::c_int as libc::c_uint {
        chunk_reset_file_chunk(c);
    }
    buffer_free((*c).mem);
    free(c as *mut libc::c_void);
}
unsafe extern "C" fn chunk_pop_oversized(mut sz: size_t) -> *mut chunk {
    if !chunks_oversized.is_null() && (*(*chunks_oversized).mem).size as libc::c_ulong >= sz {
        chunks_oversized_n -= 1;
        let mut c: *mut chunk = chunks_oversized;
        chunks_oversized = (*c).next;
        return c;
    }
    return 0 as *mut chunk;
}
unsafe extern "C" fn chunk_push_oversized(c: *mut chunk, sz: size_t) {
    if chunks_oversized_n < 64 as libc::c_int
        && chunk_buf_sz >= 4096 as libc::c_int as libc::c_ulong
    {
        chunks_oversized_n += 1;
        let mut co: *mut *mut chunk = &mut chunks_oversized;
        while !(*co).is_null() && sz < (*(**co).mem).size as libc::c_ulong {
            co = &mut (**co).next;
        }
        (*c).next = *co;
        *co = c;
    } else {
        let tb: *mut buffer = if !chunks_oversized.is_null() {
            (*chunks_oversized).mem
        } else {
            0 as *mut buffer
        };
        if !tb.is_null() && ((*tb).size as libc::c_ulong) < sz {
            (*chunks_oversized).mem = (*c).mem;
            (*c).mem = tb;
        }
        chunk_free(c);
    };
}
unsafe extern "C" fn chunk_buffer_acquire_sz(sz: size_t) -> *mut buffer {
    let mut c: *mut chunk = 0 as *mut chunk;
    let mut b: *mut buffer = 0 as *mut buffer;
    if sz <= chunk_buf_sz | 1 as libc::c_int as libc::c_ulong {
        if !chunks.is_null() {
            c = chunks;
            chunks = (*c).next;
        } else {
            c = chunk_init_sz(chunk_buf_sz);
        }
    } else {
        c = chunk_pop_oversized(sz);
        if c.is_null() {
            c = chunk_init_sz(
                (sz & !(1 as libc::c_ulong))
                    .wrapping_add(chunk_buf_sz.wrapping_sub(1 as libc::c_int as libc::c_ulong))
                    & !chunk_buf_sz.wrapping_sub(1 as libc::c_int as libc::c_ulong),
            );
        }
    }
    (*c).next = chunk_buffers;
    chunk_buffers = c;
    b = (*c).mem;
    (*c).mem = 0 as *mut buffer;
    return b;
}
#[no_mangle]
pub unsafe extern "C" fn chunk_buffer_acquire() -> *mut buffer {
    return chunk_buffer_acquire_sz(chunk_buf_sz);
}
#[no_mangle]
pub unsafe extern "C" fn chunk_buffer_release(mut b: *mut buffer) {
    if b.is_null() {
        return;
    }
    if !chunk_buffers.is_null() {
        let mut c: *mut chunk = chunk_buffers;
        chunk_buffers = (*c).next;
        (*c).mem = b;
        buffer_clear(b);
        if (*b).size as libc::c_ulong == chunk_buf_sz | 1 as libc::c_int as libc::c_ulong {
            (*c).next = chunks;
            chunks = c;
        } else if (*b).size as libc::c_ulong > chunk_buf_sz {
            chunk_push_oversized(c, (*b).size as size_t);
        } else {
            chunk_free(c);
        }
    } else {
        buffer_free(b);
    };
}
#[no_mangle]
pub unsafe extern "C" fn chunk_buffer_yield(mut b: *mut buffer) {
    if (*b).size as libc::c_ulong == chunk_buf_sz | 1 as libc::c_int as libc::c_ulong {
        return;
    }
    let cb: *mut buffer = chunk_buffer_acquire_sz(chunk_buf_sz);
    let mut tb: buffer = *b;
    *b = *cb;
    *cb = tb;
    chunk_buffer_release(cb);
}
#[no_mangle]
pub unsafe extern "C" fn chunk_buffer_prepare_append(b: *mut buffer, mut sz: size_t) -> size_t {
    if sz > buffer_string_space(b) as libc::c_ulong {
        sz = (sz as libc::c_ulong).wrapping_add(
            (if (*b).used != 0 {
                (*b).used
            } else {
                1 as libc::c_int as libc::c_uint
            }) as libc::c_ulong,
        ) as size_t as size_t;
        let cb: *mut buffer = chunk_buffer_acquire_sz(sz);
        let mut tb: buffer = *b;
        *b = *cb;
        *cb = tb;
        (*b).used = tb.used;
        if (*b).used != 0 {
            memcpy(
                (*b).ptr as *mut libc::c_void,
                tb.ptr as *const libc::c_void,
                tb.used as libc::c_ulong,
            );
        }
        chunk_buffer_release(cb);
    }
    return buffer_string_space(b) as size_t;
}
unsafe extern "C" fn chunk_acquire(mut sz: size_t) -> *mut chunk {
    if sz <= chunk_buf_sz | 1 as libc::c_int as libc::c_ulong {
        if !chunks.is_null() {
            let mut c: *mut chunk = chunks;
            chunks = (*c).next;
            return c;
        }
        sz = chunk_buf_sz;
    } else {
        sz = sz.wrapping_add(chunk_buf_sz.wrapping_sub(1 as libc::c_int as libc::c_ulong))
            & !chunk_buf_sz.wrapping_sub(1 as libc::c_int as libc::c_ulong);
        let mut c_0: *mut chunk = chunk_pop_oversized(sz);
        if !c_0.is_null() {
            return c_0;
        }
    }
    return chunk_init_sz(sz);
}
unsafe extern "C" fn chunk_release(mut c: *mut chunk) {
    let sz: size_t = (*(*c).mem).size as size_t;
    if sz == chunk_buf_sz | 1 as libc::c_int as libc::c_ulong {
        chunk_reset(c);
        (*c).next = chunks;
        chunks = c;
    } else if sz > chunk_buf_sz {
        chunk_reset(c);
        chunk_push_oversized(c, sz);
    } else if (*c).type_0 as libc::c_uint == FILE_CHUNK as libc::c_int as libc::c_uint {
        chunk_reset(c);
        (*c).next = chunks_filechunk;
        chunks_filechunk = c;
    } else {
        chunk_free(c);
    };
}
unsafe extern "C" fn chunk_acquire_filechunk() -> *mut chunk {
    if !chunks_filechunk.is_null() {
        let mut c: *mut chunk = chunks_filechunk;
        chunks_filechunk = (*c).next;
        return c;
    }
    return chunk_init();
}
#[no_mangle]
pub unsafe extern "C" fn chunkqueue_chunk_pool_clear() {
    let mut next: *mut chunk = 0 as *mut chunk;
    let mut c: *mut chunk = chunks;
    while !c.is_null() {
        next = (*c).next;
        chunk_free(c);
        c = next;
    }
    chunks = 0 as *mut chunk;
    let mut next_0: *mut chunk = 0 as *mut chunk;
    let mut c_0: *mut chunk = chunks_oversized;
    while !c_0.is_null() {
        next_0 = (*c_0).next;
        chunk_free(c_0);
        c_0 = next_0;
    }
    chunks_oversized = 0 as *mut chunk;
    chunks_oversized_n = 0 as libc::c_int;
    let mut next_1: *mut chunk = 0 as *mut chunk;
    let mut c_1: *mut chunk = chunks_filechunk;
    while !c_1.is_null() {
        next_1 = (*c_1).next;
        chunk_free(c_1);
        c_1 = next_1;
    }
    chunks_filechunk = 0 as *mut chunk;
}
#[no_mangle]
pub unsafe extern "C" fn chunkqueue_chunk_pool_free() {
    chunkqueue_chunk_pool_clear();
    let mut next: *mut chunk = 0 as *mut chunk;
    let mut c: *mut chunk = chunk_buffers;
    while !c.is_null() {
        next = (*c).next;
        free(c as *mut libc::c_void);
        c = next;
    }
    chunk_buffers = 0 as *mut chunk;
}
unsafe extern "C" fn chunk_remaining_length(mut c: *const chunk) -> off_t {
    return (if (*c).type_0 as libc::c_uint == MEM_CHUNK as libc::c_int as libc::c_uint {
        buffer_clen((*c).mem) as off_t
    } else {
        (*c).file.length
    }) - (*c).offset;
}
unsafe extern "C" fn chunkqueue_release_chunks(mut cq: *mut chunkqueue) {
    (*cq).last = 0 as *mut chunk;
    let mut c: *mut chunk = 0 as *mut chunk;
    loop {
        c = (*cq).first;
        if c.is_null() {
            break;
        }
        (*cq).first = (*c).next;
        chunk_release(c);
    }
}
#[no_mangle]
#[cold]
pub unsafe extern "C" fn chunkqueue_free(mut cq: *mut chunkqueue) {
    if cq.is_null() {
        return;
    }
    chunkqueue_release_chunks(cq);
    free(cq as *mut libc::c_void);
}
unsafe extern "C" fn chunkqueue_prepend_chunk(cq: *mut chunkqueue, c: *mut chunk) {
    (*c).next = (*cq).first;
    if ((*c).next).is_null() {
        (*cq).last = c;
    }
    (*cq).first = c;
}
unsafe extern "C" fn chunkqueue_append_chunk(cq: *mut chunkqueue, c: *mut chunk) {
    (*c).next = 0 as *mut chunk;
    let ref mut fresh182 = *if !((*cq).last).is_null() {
        &mut (*(*cq).last).next
    } else {
        &mut (*cq).first
    };
    *fresh182 = c;
    (*cq).last = c;
}
unsafe extern "C" fn chunkqueue_prepend_mem_chunk(
    mut cq: *mut chunkqueue,
    mut sz: size_t,
) -> *mut chunk {
    let mut c: *mut chunk = chunk_acquire(sz);
    chunkqueue_prepend_chunk(cq, c);
    return c;
}
unsafe extern "C" fn chunkqueue_append_mem_chunk(
    mut cq: *mut chunkqueue,
    mut sz: size_t,
) -> *mut chunk {
    let mut c: *mut chunk = chunk_acquire(sz);
    chunkqueue_append_chunk(cq, c);
    return c;
}
unsafe extern "C" fn chunkqueue_append_file_chunk(
    cq: *mut chunkqueue,
    fn_0: *const buffer,
    mut offset: off_t,
    mut len: off_t,
) -> *mut chunk {
    let c: *mut chunk = chunk_acquire_filechunk();
    chunkqueue_append_chunk(cq, c);
    (*c).type_0 = FILE_CHUNK;
    (*c).offset = offset;
    (*c).file.length = offset + len;
    (*cq).bytes_in += len;
    buffer_copy_buffer((*c).mem, fn_0);
    return c;
}
#[no_mangle]
pub unsafe extern "C" fn chunkqueue_reset(mut cq: *mut chunkqueue) {
    chunkqueue_release_chunks(cq);
    (*cq).bytes_in = 0 as libc::c_int as off_t;
    (*cq).bytes_out = 0 as libc::c_int as off_t;
    (*cq).tempdir_idx = 0 as libc::c_int as libc::c_uint;
}
#[no_mangle]
pub unsafe extern "C" fn chunkqueue_append_file_fd(
    cq: *mut chunkqueue,
    fn_0: *const buffer,
    mut fd: libc::c_int,
    mut offset: off_t,
    mut len: off_t,
) {
    if len > 0 as libc::c_int as libc::c_long {
        (*chunkqueue_append_file_chunk(cq, fn_0, offset, len))
            .file
            .fd = fd;
    } else {
        close(fd);
    };
}
#[no_mangle]
pub unsafe extern "C" fn chunkqueue_append_file(
    cq: *mut chunkqueue,
    fn_0: *const buffer,
    mut offset: off_t,
    mut len: off_t,
) {
    if len > 0 as libc::c_int as libc::c_long {
        chunkqueue_append_file_chunk(cq, fn_0, offset, len);
    }
}
unsafe extern "C" fn chunkqueue_append_mem_extend_chunk(
    cq: *mut chunkqueue,
    mem: *const libc::c_char,
    mut len: size_t,
) -> libc::c_int {
    let mut c: *mut chunk = (*cq).last;
    if 0 as libc::c_int as libc::c_ulong == len {
        return 1 as libc::c_int;
    }
    if !c.is_null()
        && (*c).type_0 as libc::c_uint == MEM_CHUNK as libc::c_int as libc::c_uint
        && buffer_string_space((*c).mem) as libc::c_ulong >= len
    {
        buffer_append_string_len((*c).mem, mem, len);
        (*cq).bytes_in = ((*cq).bytes_in as libc::c_ulong).wrapping_add(len) as off_t as off_t;
        return 1 as libc::c_int;
    }
    return 0 as libc::c_int;
}
#[no_mangle]
pub unsafe extern "C" fn chunkqueue_append_buffer(cq: *mut chunkqueue, mem: *mut buffer) {
    let mut c: *mut chunk = 0 as *mut chunk;
    let len: size_t = buffer_clen(mem) as size_t;
    if len < 1024 as libc::c_int as libc::c_ulong
        && chunkqueue_append_mem_extend_chunk(cq, (*mem).ptr, len) != 0
    {
        buffer_clear(mem);
        return;
    }
    c = chunkqueue_append_mem_chunk(cq, chunk_buf_sz);
    (*cq).bytes_in = ((*cq).bytes_in as libc::c_ulong).wrapping_add(len) as off_t as off_t;
    buffer_move((*c).mem, mem);
}
#[no_mangle]
pub unsafe extern "C" fn chunkqueue_append_mem(
    cq: *mut chunkqueue,
    mem: *const libc::c_char,
    mut len: size_t,
) {
    let mut c: *mut chunk = 0 as *mut chunk;
    if len < chunk_buf_sz && chunkqueue_append_mem_extend_chunk(cq, mem, len) != 0 {
        return;
    }
    c = chunkqueue_append_mem_chunk(cq, len.wrapping_add(1 as libc::c_int as libc::c_ulong));
    (*cq).bytes_in = ((*cq).bytes_in as libc::c_ulong).wrapping_add(len) as off_t as off_t;
    buffer_copy_string_len((*c).mem, mem, len);
}
#[no_mangle]
pub unsafe extern "C" fn chunkqueue_append_mem_min(
    cq: *mut chunkqueue,
    mem: *const libc::c_char,
    mut len: size_t,
) {
    let mut c: *mut chunk = 0 as *mut chunk;
    if len < chunk_buf_sz && chunkqueue_append_mem_extend_chunk(cq, mem, len) != 0 {
        return;
    }
    c = chunk_init_sz(len.wrapping_add(1 as libc::c_int as libc::c_ulong));
    chunkqueue_append_chunk(cq, c);
    (*cq).bytes_in = ((*cq).bytes_in as libc::c_ulong).wrapping_add(len) as off_t as off_t;
    buffer_copy_string_len((*c).mem, mem, len);
}
#[no_mangle]
pub unsafe extern "C" fn chunkqueue_append_chunkqueue(cq: *mut chunkqueue, src: *mut chunkqueue) {
    if ((*src).first).is_null() {
        return;
    }
    if ((*cq).first).is_null() {
        (*cq).first = (*src).first;
    } else {
        (*(*cq).last).next = (*src).first;
    }
    (*cq).last = (*src).last;
    (*cq).bytes_in += chunkqueue_length(src);
    (*src).first = 0 as *mut chunk;
    (*src).last = 0 as *mut chunk;
    (*src).bytes_out = (*src).bytes_in;
}
#[no_mangle]
pub unsafe extern "C" fn chunkqueue_prepend_buffer_open_sz(
    mut cq: *mut chunkqueue,
    mut sz: size_t,
) -> *mut buffer {
    let c: *mut chunk = chunkqueue_prepend_mem_chunk(cq, sz);
    return (*c).mem;
}
#[no_mangle]
pub unsafe extern "C" fn chunkqueue_prepend_buffer_open(mut cq: *mut chunkqueue) -> *mut buffer {
    return chunkqueue_prepend_buffer_open_sz(cq, chunk_buf_sz);
}
#[no_mangle]
pub unsafe extern "C" fn chunkqueue_prepend_buffer_commit(mut cq: *mut chunkqueue) {
    (*cq).bytes_in += buffer_clen((*(*cq).first).mem) as libc::c_long;
}
#[no_mangle]
pub unsafe extern "C" fn chunkqueue_append_buffer_open_sz(
    mut cq: *mut chunkqueue,
    mut sz: size_t,
) -> *mut buffer {
    let c: *mut chunk = chunkqueue_append_mem_chunk(cq, sz);
    return (*c).mem;
}
#[no_mangle]
pub unsafe extern "C" fn chunkqueue_append_buffer_open(mut cq: *mut chunkqueue) -> *mut buffer {
    return chunkqueue_append_buffer_open_sz(cq, chunk_buf_sz);
}
#[no_mangle]
pub unsafe extern "C" fn chunkqueue_append_buffer_commit(mut cq: *mut chunkqueue) {
    (*cq).bytes_in += buffer_clen((*(*cq).last).mem) as libc::c_long;
}
#[no_mangle]
pub unsafe extern "C" fn chunkqueue_get_memory(
    cq: *mut chunkqueue,
    len: *mut size_t,
) -> *mut libc::c_char {
    let mut sz: size_t = if *len != 0 {
        *len
    } else {
        chunk_buf_sz >> 1 as libc::c_int
    };
    let mut b: *mut buffer = 0 as *mut buffer;
    let mut c: *mut chunk = (*cq).last;
    if !c.is_null() && MEM_CHUNK as libc::c_int as libc::c_uint == (*c).type_0 as libc::c_uint {
        let mut avail: size_t = buffer_string_space((*c).mem) as size_t;
        if avail >= sz {
            *len = avail;
            b = (*c).mem;
            return ((*b).ptr).offset(buffer_clen(b) as isize);
        }
    }
    b = chunkqueue_append_buffer_open_sz(cq, sz);
    *len = buffer_string_space(b) as size_t;
    return (*b).ptr;
}
#[no_mangle]
pub unsafe extern "C" fn chunkqueue_use_memory(
    cq: *mut chunkqueue,
    mut ckpt: *mut chunk,
    mut len: size_t,
) {
    let mut b: *mut buffer = (*(*cq).last).mem;
    if len > 0 as libc::c_int as libc::c_ulong {
        buffer_commit(b, len);
        (*cq).bytes_in = ((*cq).bytes_in as libc::c_ulong).wrapping_add(len) as off_t as off_t;
        if (*cq).last == ckpt
            || ckpt.is_null()
            || MEM_CHUNK as libc::c_int as libc::c_uint != (*ckpt).type_0 as libc::c_uint
            || len > buffer_string_space((*ckpt).mem) as libc::c_ulong
        {
            return;
        }
        buffer_append_buffer((*ckpt).mem, b);
    } else if buffer_is_blank(b) == 0 {
        return;
    }
    chunk_release((*cq).last);
    (*cq).last = ckpt;
    let ref mut fresh183 = *if !ckpt.is_null() {
        &mut (*ckpt).next
    } else {
        &mut (*cq).first
    };
    *fresh183 = 0 as *mut chunk;
}
#[no_mangle]
pub unsafe extern "C" fn chunkqueue_update_file(
    cq: *mut chunkqueue,
    mut c: *mut chunk,
    mut len: off_t,
) {
    (*c).file.length += len;
    (*cq).bytes_in += len;
    if 0 as libc::c_int as libc::c_long == chunk_remaining_length(c) {
        chunkqueue_remove_empty_chunks(cq);
    }
}
#[no_mangle]
#[cold]
pub unsafe extern "C" fn chunkqueue_set_tempdirs_default(
    mut tempdirs: *const array,
    mut upload_temp_file_size: off_t,
) {
    if upload_temp_file_size == 0 as libc::c_int as libc::c_long {
        upload_temp_file_size =
            (1 as libc::c_int * 1024 as libc::c_int * 1024 as libc::c_int) as off_t;
    }
    chunkqueue_default_tempdirs = tempdirs;
    chunkqueue_default_tempfile_size = upload_temp_file_size;
}
#[no_mangle]
pub unsafe extern "C" fn chunkqueue_append_cq_range(
    dst: *mut chunkqueue,
    src: *const chunkqueue,
    mut offset: off_t,
    mut len: off_t,
) {
    let mut c: *const chunk = (*src).first;
    while len > 0 as libc::c_int as libc::c_long && !c.is_null() {
        let mut clen: off_t = chunk_remaining_length(c);
        if offset >= clen {
            offset -= clen;
        } else {
            clen -= offset;
            if len < clen {
                clen = len;
            }
            len -= clen;
            if (*c).type_0 as libc::c_uint == FILE_CHUNK as libc::c_int as libc::c_uint {
                chunkqueue_append_file(dst, (*c).mem, (*c).offset + offset, clen);
                chunkqueue_dup_file_chunk_fd((*dst).last, c);
            } else {
                chunkqueue_append_mem(
                    dst,
                    ((*(*c).mem).ptr)
                        .offset((*c).offset as isize)
                        .offset(offset as isize),
                    clen as size_t,
                );
            }
            offset = 0 as libc::c_int as off_t;
        }
        c = (*c).next;
    }
}
#[no_mangle]
pub unsafe extern "C" fn chunkqueue_read_squash(
    cq: *mut chunkqueue,
    errh: *mut log_error_st,
) -> *mut buffer {
    let mut cqlen: off_t = chunkqueue_length(cq);
    if cqlen >= 4294967295 as libc::c_uint as libc::c_long {
        return 0 as *mut buffer;
    }
    if !((*cq).first).is_null()
        && ((*(*cq).first).next).is_null()
        && (*(*cq).first).type_0 as libc::c_uint == MEM_CHUNK as libc::c_int as libc::c_uint
    {
        return (*(*cq).first).mem;
    }
    let c: *mut chunk =
        chunk_acquire((cqlen as uint32_t).wrapping_add(1 as libc::c_int as libc::c_uint) as size_t);
    let mut data: *mut libc::c_char = (*(*c).mem).ptr;
    let mut dlen: uint32_t = cqlen as uint32_t;
    let mut rc: libc::c_int = chunkqueue_peek_data(cq, &mut data, &mut dlen, errh);
    if rc < 0 as libc::c_int {
        chunk_release(c);
        return 0 as *mut buffer;
    }
    buffer_truncate((*c).mem, dlen);
    chunkqueue_release_chunks(cq);
    chunkqueue_append_chunk(cq, c);
    return (*c).mem;
}
#[no_mangle]
pub unsafe extern "C" fn chunkqueue_read_data(
    cq: *mut chunkqueue,
    data: *mut libc::c_char,
    dlen: uint32_t,
    errh: *mut log_error_st,
) -> libc::c_int {
    let mut ptr: *mut libc::c_char = data;
    let mut len: uint32_t = dlen;
    if chunkqueue_peek_data(cq, &mut ptr, &mut len, errh) < 0 as libc::c_int || len != dlen {
        return -(1 as libc::c_int);
    }
    if data != ptr {
        memcpy(
            data as *mut libc::c_void,
            ptr as *const libc::c_void,
            len as libc::c_ulong,
        );
    }
    chunkqueue_mark_written(cq, len as off_t);
    return 0 as libc::c_int;
}
#[no_mangle]
pub unsafe extern "C" fn chunkqueue_write_chunk_to_pipe(
    fd: libc::c_int,
    cq: *mut chunkqueue,
    errh: *mut log_error_st,
) -> ssize_t {
    let c: *mut chunk = (*cq).first;
    if (*c).type_0 as libc::c_uint == FILE_CHUNK as libc::c_int as libc::c_uint {
        let mut abs_offset: loff_t = (*c).offset;
        return if 0 as libc::c_int == chunk_open_file_chunk(c, errh) {
            splice(
                (*c).file.fd,
                &mut abs_offset,
                fd,
                0 as *mut __off64_t,
                ((*c).file.length - (*c).offset) as size_t,
                2 as libc::c_int as libc::c_uint,
            )
        } else {
            -(1 as libc::c_int) as libc::c_long
        };
    }
    return chunkqueue_write_chunk(fd, cq, errh);
}
unsafe extern "C" fn chunkqueue_write_chunk_mem(fd: libc::c_int, c: *const chunk) -> ssize_t {
    let buf: *const libc::c_void =
        ((*(*c).mem).ptr).offset((*c).offset as isize) as *const libc::c_void;
    let count: size_t =
        (buffer_clen((*c).mem) as libc::c_ulong).wrapping_sub((*c).offset as size_t);
    let mut wr: ssize_t = 0;
    loop {
        wr = write(fd, buf, count);
        if !(-(1 as libc::c_int) as libc::c_long == wr && *__errno_location() == 4 as libc::c_int) {
            break;
        }
    }
    return wr;
}
#[no_mangle]
pub unsafe extern "C" fn chunkqueue_set_tempdirs(
    cq: *mut chunkqueue,
    tempdirs: *const array,
    mut upload_temp_file_size: off_t,
) {
    if upload_temp_file_size == 0 as libc::c_int as libc::c_long {
        upload_temp_file_size = chunkqueue_default_tempfile_size;
    }
    (*cq).tempdirs = tempdirs;
    (*cq).upload_temp_file_size = upload_temp_file_size;
    (*cq).tempdir_idx = 0 as libc::c_int as libc::c_uint;
}
#[no_mangle]
pub unsafe extern "C" fn chunkqueue_append_mem_to_tempfile(
    dest: *mut chunkqueue,
    mut mem: *const libc::c_char,
    mut len: size_t,
    errh: *mut log_error_st,
) -> libc::c_int {
    let mut dst_c: *mut chunk = (*dest).first;
    if !dst_c.is_null()
        && (*dst_c).type_0 as libc::c_uint == MEM_CHUNK as libc::c_int as libc::c_uint
        && 0 as libc::c_int != chunkqueue_to_tempfiles(dest, errh)
    {
        return -(1 as libc::c_int);
    }
    loop {
        dst_c = chunkqueue_get_append_tempfile(dest, errh);
        if dst_c.is_null() {
            return -(1 as libc::c_int);
        }
        let written: ssize_t = pwrite(
            (*dst_c).file.fd,
            mem as *const libc::c_void,
            len,
            (*dst_c).file.length,
        );
        if written as size_t == len {
            (*dst_c).file.length =
                ((*dst_c).file.length as libc::c_ulong).wrapping_add(len) as off_t as off_t;
            (*dest).bytes_in =
                ((*dest).bytes_in as libc::c_ulong).wrapping_add(len) as off_t as off_t;
            return 0 as libc::c_int;
        } else {
            if written >= 0 as libc::c_int as libc::c_long {
                (*dest).bytes_in += written;
                mem = mem.offset(written as isize);
                len = (len as libc::c_ulong).wrapping_sub(written as size_t) as size_t as size_t;
                (*dst_c).file.length = ((*dst_c).file.length as libc::c_ulong)
                    .wrapping_add(written as size_t) as off_t
                    as off_t;
            } else if chunkqueue_append_tempfile_err(dest, errh, dst_c) == 0 {
                break;
            }
            if !(len != 0) {
                break;
            }
        }
    }
    return -(1 as libc::c_int);
}
#[cold]
unsafe extern "C" fn chunkqueue_append_tempfile_err(
    cq: *mut chunkqueue,
    errh: *mut log_error_st,
    c: *mut chunk,
) -> libc::c_int {
    let errnum: libc::c_int = *__errno_location();
    if errnum == 4 as libc::c_int {
        return 1 as libc::c_int;
    }
    let mut retry: libc::c_int = (errnum == 28 as libc::c_int && !((*cq).tempdirs).is_null() && {
        (*cq).tempdir_idx = ((*cq).tempdir_idx).wrapping_add(1);
        (*cq).tempdir_idx < (*(*cq).tempdirs).used
    }) as libc::c_int;
    if retry == 0 {
        log_perror(
            errh,
            b"/home/kkysen/work/rust/lighttpd/src/chunk.c\0" as *const u8 as *const libc::c_char,
            716 as libc::c_int as libc::c_uint,
            b"write() temp-file %s failed\0" as *const u8 as *const libc::c_char,
            (*(*c).mem).ptr,
        );
    }
    if 0 as libc::c_int as libc::c_long == chunk_remaining_length(c) {
        chunkqueue_remove_empty_chunks(cq);
    } else {
        if ((*c).file.refchg).is_some() {
            ck_assert_failed(
                b"/home/kkysen/work/rust/lighttpd/src/chunk.c\0" as *const u8
                    as *const libc::c_char,
                724 as libc::c_int as libc::c_uint,
                b"0 == c->file.refchg\0" as *const u8 as *const libc::c_char,
            );
        }
        let mut rc: libc::c_int = close((*c).file.fd);
        (*c).file.fd = -(1 as libc::c_int);
        if 0 as libc::c_int != rc {
            log_perror(
                errh,
                b"/home/kkysen/work/rust/lighttpd/src/chunk.c\0" as *const u8
                    as *const libc::c_char,
                728 as libc::c_int as libc::c_uint,
                b"close() temp-file %s failed\0" as *const u8 as *const libc::c_char,
                (*(*c).mem).ptr,
            );
            retry = 0 as libc::c_int;
        }
    }
    return retry;
}
#[no_mangle]
#[cold]
pub unsafe extern "C" fn chunkqueue_remove_empty_chunks(mut cq: *mut chunkqueue) {
    let mut c: *mut chunk = 0 as *mut chunk;
    chunkqueue_remove_finished_chunks(cq);
    c = (*cq).first;
    while !c.is_null() && !((*c).next).is_null() {
        if 0 as libc::c_int as libc::c_long == chunk_remaining_length((*c).next) {
            let mut empty: *mut chunk = (*c).next;
            (*c).next = (*empty).next;
            if empty == (*cq).last {
                (*cq).last = c;
            }
            chunk_release(empty);
        }
        c = (*c).next;
    }
}
#[no_mangle]
pub unsafe extern "C" fn chunkqueue_remove_finished_chunks(mut cq: *mut chunkqueue) {
    let mut c: *mut chunk = 0 as *mut chunk;
    loop {
        c = (*cq).first;
        if !(!c.is_null() && 0 as libc::c_int as libc::c_long == chunk_remaining_length(c)) {
            break;
        }
        (*cq).first = (*c).next;
        if ((*cq).first).is_null() {
            (*cq).last = 0 as *mut chunk;
        }
        chunk_release(c);
    }
}
unsafe extern "C" fn chunkqueue_get_append_tempfile(
    cq: *mut chunkqueue,
    errh: *mut log_error_st,
) -> *mut chunk {
    let c: *mut chunk = (*cq).last;
    if !c.is_null() && (*c).file.is_temp != 0 && (*c).file.fd >= 0 as libc::c_int {
        if (*c).file.length < (*cq).upload_temp_file_size {
            return c;
        }
        if ((*c).file.refchg).is_some() {
            ck_assert_failed(
                b"/home/kkysen/work/rust/lighttpd/src/chunk.c\0" as *const u8
                    as *const libc::c_char,
                696 as libc::c_int as libc::c_uint,
                b"0 == c->file.refchg\0" as *const u8 as *const libc::c_char,
            );
        }
        let mut rc: libc::c_int = close((*c).file.fd);
        (*c).file.fd = -(1 as libc::c_int);
        if 0 as libc::c_int != rc {
            log_perror(
                errh,
                b"/home/kkysen/work/rust/lighttpd/src/chunk.c\0" as *const u8
                    as *const libc::c_char,
                700 as libc::c_int as libc::c_uint,
                b"close() temp-file %s failed\0" as *const u8 as *const libc::c_char,
                (*(*c).mem).ptr,
            );
            return 0 as *mut chunk;
        }
    }
    return chunkqueue_get_append_newtempfile(cq, errh);
}
unsafe extern "C" fn chunkqueue_get_append_newtempfile(
    cq: *mut chunkqueue,
    errh: *mut log_error_st,
) -> *mut chunk {
    static mut emptyb: buffer = {
        let mut init = buffer {
            ptr: b"\0" as *const u8 as *const libc::c_char as *mut libc::c_char,
            used: 0 as libc::c_int as uint32_t,
            size: 0 as libc::c_int as uint32_t,
        };
        init
    };
    let last: *mut chunk = (*cq).last;
    let c: *mut chunk = chunkqueue_append_file_chunk(
        cq,
        &emptyb,
        0 as libc::c_int as off_t,
        0 as libc::c_int as off_t,
    );
    let template: *mut buffer = (*c).mem;
    (*c).file.is_temp = 1 as libc::c_int;
    if !((*cq).tempdirs).is_null() && (*(*cq).tempdirs).used != 0 {
        *__errno_location() = 5 as libc::c_int;
        while (*cq).tempdir_idx < (*(*cq).tempdirs).used {
            let mut ds: *mut data_string =
                *((*(*cq).tempdirs).data).offset((*cq).tempdir_idx as isize) as *mut data_string;
            (*c).file.fd = chunkqueue_get_append_mkstemp(
                template,
                (*ds).value.ptr,
                buffer_clen(&mut (*ds).value),
            );
            if -(1 as libc::c_int) != (*c).file.fd {
                return c;
            }
            (*cq).tempdir_idx = ((*cq).tempdir_idx).wrapping_add(1);
        }
    } else {
        (*c).file.fd = chunkqueue_get_append_mkstemp(
            template,
            b"/var/tmp\0" as *const u8 as *const libc::c_char,
            (::core::mem::size_of::<[libc::c_char; 9]>() as libc::c_ulong as uint32_t)
                .wrapping_sub(1 as libc::c_int as libc::c_uint),
        );
        if -(1 as libc::c_int) != (*c).file.fd {
            return c;
        }
    }
    log_perror(
        errh,
        b"/home/kkysen/work/rust/lighttpd/src/chunk.c\0" as *const u8 as *const libc::c_char,
        668 as libc::c_int as libc::c_uint,
        b"opening temp-file failed: %s\0" as *const u8 as *const libc::c_char,
        (*template).ptr,
    );
    (*c).file.is_temp = 0 as libc::c_int;
    (*cq).last = last;
    if !((*cq).last).is_null() {
        (*last).next = 0 as *mut chunk;
    } else {
        (*cq).first = 0 as *mut chunk;
    }
    chunk_release(c);
    return 0 as *mut chunk;
}
unsafe extern "C" fn chunkqueue_get_append_mkstemp(
    b: *mut buffer,
    mut path: *const libc::c_char,
    len: uint32_t,
) -> libc::c_int {
    buffer_copy_path_len2(
        b,
        path,
        len as size_t,
        b"lighttpd-upload-XXXXXX\0" as *const u8 as *const libc::c_char,
        (::core::mem::size_of::<[libc::c_char; 23]>() as libc::c_ulong as uint32_t)
            .wrapping_sub(1 as libc::c_int as libc::c_uint) as size_t,
    );
    return fdevent_mkostemp((*b).ptr, 0 as libc::c_int);
}
unsafe extern "C" fn mmap_align_offset(mut start: off_t) -> off_t {
    static mut pagemask: off_t = 0 as libc::c_int as off_t;
    if 0 as libc::c_int as libc::c_long == pagemask {
        let mut pagesize: libc::c_long = sysconf(_SC_PAGESIZE as libc::c_int);
        if -(1 as libc::c_int) as libc::c_long == pagesize {
            pagesize = 4096 as libc::c_int as libc::c_long;
        }
        pagemask = !(pagesize - 1 as libc::c_int as libc::c_long);
    }
    return start & pagemask;
}
#[cold]
#[inline(never)]
unsafe extern "C" fn chunkqueue_to_tempfiles(
    dest: *mut chunkqueue,
    errh: *mut log_error_st,
) -> libc::c_int {
    let cqlen: off_t = chunkqueue_length(dest);
    let mut src: chunkqueue = *dest;
    (*dest).last = 0 as *mut chunk;
    (*dest).first = (*dest).last;
    (*dest).bytes_in -= cqlen;
    if 0 as libc::c_int == chunkqueue_steal_with_tempfiles(dest, &mut src, cqlen, errh) {
        return 0 as libc::c_int;
    } else {
        let errnum: libc::c_int = *__errno_location();
        chunkqueue_release_chunks(&mut src);
        return -errnum;
    };
}
#[no_mangle]
pub unsafe extern "C" fn chunkqueue_steal_with_tempfiles(
    dest: *mut chunkqueue,
    src: *mut chunkqueue,
    mut len: off_t,
    errh: *mut log_error_st,
) -> libc::c_int {
    let mut clen: off_t = 0;
    while len > 0 as libc::c_int as libc::c_long {
        let c: *mut chunk = (*src).first;
        if (0 as *mut libc::c_void as *mut chunk == c) as libc::c_int as libc::c_long != 0 {
            break;
        }
        if (*c).type_0 as libc::c_uint == MEM_CHUNK as libc::c_int as libc::c_uint {
            clen = chunkqueue_append_cqmem_to_tempfile(dest, src, len, errh);
            if (clen < 0 as libc::c_int as libc::c_long) as libc::c_int as libc::c_long != 0 {
                return -(1 as libc::c_int);
            }
            chunkqueue_mark_written(src, clen);
        } else {
            clen = chunk_remaining_length(c);
            if len < clen {
                clen = len;
            }
            chunkqueue_steal(dest, src, clen);
        }
        len -= clen;
    }
    return 0 as libc::c_int;
}
#[no_mangle]
pub unsafe extern "C" fn chunkqueue_steal(
    dest: *mut chunkqueue,
    src: *mut chunkqueue,
    mut len: off_t,
) {
    let mut clen: off_t = 0;
    while len > 0 as libc::c_int as libc::c_long {
        let c: *mut chunk = (*src).first;
        if (0 as *mut libc::c_void as *mut chunk == c) as libc::c_int as libc::c_long != 0 {
            break;
        }
        clen = chunk_remaining_length(c);
        if len >= clen {
            (*src).first = (*c).next;
            if c == (*src).last {
                (*src).last = 0 as *mut chunk;
            }
            if (0 as libc::c_int as libc::c_long != clen) as libc::c_int as libc::c_long != 0 {
                chunkqueue_append_chunk(dest, c);
                (*dest).bytes_in += clen;
            } else {
                chunk_release(c);
            }
        } else {
            match (*c).type_0 as libc::c_uint {
                0 => {
                    chunkqueue_append_mem(
                        dest,
                        ((*(*c).mem).ptr).offset((*c).offset as isize),
                        len as size_t,
                    );
                }
                1 => {
                    chunkqueue_steal_partial_file_chunk(dest, c, len);
                }
                _ => {}
            }
            (*c).offset += len;
            clen = len;
        }
        (*src).bytes_out += clen;
        len -= clen;
    }
}
#[inline(never)]
unsafe extern "C" fn chunkqueue_steal_partial_file_chunk(
    dest: *mut chunkqueue,
    c: *const chunk,
    len: off_t,
) {
    chunkqueue_append_file(dest, (*c).mem, (*c).offset, len);
    chunkqueue_dup_file_chunk_fd((*dest).last, c);
}
#[inline(never)]
unsafe extern "C" fn chunkqueue_dup_file_chunk_fd(d: *mut chunk, c: *const chunk) {
    if (*c).file.fd >= 0 as libc::c_int {
        if ((*c).file.refchg).is_some() {
            (*d).file.fd = (*c).file.fd;
            (*d).file.ref_0 = (*c).file.ref_0;
            (*d).file.refchg = (*c).file.refchg;
            ((*d).file.refchg).expect("non-null function pointer")(
                (*d).file.ref_0,
                1 as libc::c_int,
            );
        } else {
            (*d).file.fd = fdevent_dup_cloexec((*c).file.fd);
        }
    }
}
#[no_mangle]
pub unsafe extern "C" fn chunkqueue_mark_written(mut cq: *mut chunkqueue, mut len: off_t) {
    (*cq).bytes_out += len;
    let mut c: *mut chunk = (*cq).first;
    while !c.is_null() {
        let mut c_len: off_t = chunk_remaining_length(c);
        if len >= c_len {
            let x: *mut chunk = c;
            c = (*c).next;
            len -= c_len;
            chunk_release(x);
        } else {
            (*c).offset += len;
            (*cq).first = c;
            return;
        }
    }
    (*cq).last = 0 as *mut chunk;
    (*cq).first = (*cq).last;
}
unsafe extern "C" fn chunkqueue_append_cqmem_to_tempfile(
    dest: *mut chunkqueue,
    src: *mut chunkqueue,
    mut len: off_t,
    errh: *mut log_error_st,
) -> ssize_t {
    let mut iovcnt: libc::c_uint = 0 as libc::c_int as libc::c_uint;
    let mut iov: [iovec; 16] = [iovec {
        iov_base: 0 as *mut libc::c_void,
        iov_len: 0,
    }; 16];
    let mut dlen: off_t = 0 as libc::c_int as off_t;
    let mut c: *mut chunk = 0 as *mut chunk;
    c = (*dest).first;
    while !c.is_null() && (*c).type_0 as libc::c_uint == MEM_CHUNK as libc::c_int as libc::c_uint {
        let clen: off_t = chunk_remaining_length(c);
        iov[iovcnt as usize].iov_base =
            ((*(*c).mem).ptr).offset((*c).offset as isize) as *mut libc::c_void;
        iov[iovcnt as usize].iov_len = clen as size_t;
        dlen += clen;
        iovcnt = iovcnt.wrapping_add(1);
        if (iovcnt as libc::c_ulong
            == (::core::mem::size_of::<[iovec; 16]>() as libc::c_ulong)
                .wrapping_div(::core::mem::size_of::<iovec>() as libc::c_ulong))
            as libc::c_int as libc::c_long
            != 0
        {
            break;
        }
        c = (*c).next;
    }
    if (c != 0 as *mut libc::c_void as *mut chunk) as libc::c_int as libc::c_long != 0
        && (*(*dest).first).type_0 as libc::c_uint == MEM_CHUNK as libc::c_int as libc::c_uint
    {
        if 0 as libc::c_int != chunkqueue_to_tempfiles(dest, errh) {
            return -(1 as libc::c_int) as ssize_t;
        }
        dlen = 0 as libc::c_int as off_t;
        iovcnt = 0 as libc::c_int as libc::c_uint;
    }
    if ((iovcnt as libc::c_ulong)
        < (::core::mem::size_of::<[iovec; 16]>() as libc::c_ulong)
            .wrapping_div(::core::mem::size_of::<iovec>() as libc::c_ulong)) as libc::c_int
        as libc::c_long
        != 0
    {
        c = (*src).first;
        while !c.is_null()
            && (*c).type_0 as libc::c_uint == MEM_CHUNK as libc::c_int as libc::c_uint
        {
            let mut clen_0: off_t = chunk_remaining_length(c);
            if clen_0 > len {
                clen_0 = len;
            }
            iov[iovcnt as usize].iov_base =
                ((*(*c).mem).ptr).offset((*c).offset as isize) as *mut libc::c_void;
            iov[iovcnt as usize].iov_len = clen_0 as size_t;
            len -= clen_0;
            iovcnt = iovcnt.wrapping_add(1);
            if 0 as libc::c_int as libc::c_long == len {
                break;
            }
            if (iovcnt as libc::c_ulong
                == (::core::mem::size_of::<[iovec; 16]>() as libc::c_ulong)
                    .wrapping_div(::core::mem::size_of::<iovec>() as libc::c_ulong))
                as libc::c_int as libc::c_long
                != 0
            {
                break;
            }
            c = (*c).next;
        }
    }
    if (0 as libc::c_int as libc::c_uint == iovcnt) as libc::c_int as libc::c_long != 0 {
        return 0 as libc::c_int as ssize_t;
    }
    c = chunkqueue_get_append_tempfile(dest, errh);
    if c.is_null() {
        return -(1 as libc::c_int) as ssize_t;
    }
    let mut wr: ssize_t = pwritev(
        (*c).file.fd,
        iov.as_mut_ptr(),
        iovcnt as libc::c_int,
        (*c).file.length,
    );
    if wr >= 0 as libc::c_int as libc::c_long {
        (*c).file.length += wr;
        (*dest).bytes_in += wr;
        if dlen != 0 {
            if (wr < dlen) as libc::c_int as libc::c_long != 0 {
                return chunkqueue_append_cqmem_to_tempfile_partial(dest, c, wr, errh);
            }
            wr -= dlen;
            (*dest).bytes_in -= dlen;
            (*dest).bytes_out -= dlen;
            chunkqueue_mark_written(dest, dlen);
        }
    }
    return wr;
}
#[cold]
#[inline(never)]
unsafe extern "C" fn chunkqueue_append_cqmem_to_tempfile_partial(
    dest: *mut chunkqueue,
    c: *mut chunk,
    mut wr: ssize_t,
    errh: *mut log_error_st,
) -> ssize_t {
    let mut ckpt: *mut chunk = (*dest).first;
    while (*ckpt).next != c {
        ckpt = (*ckpt).next;
    }
    (*ckpt).next = 0 as *mut chunk;
    (*dest).last = ckpt;
    (*dest).bytes_in -= wr;
    (*dest).bytes_out -= wr;
    chunkqueue_mark_written(dest, wr);
    (*c).next = (*dest).first;
    (*dest).first = c;
    return (if 0 as libc::c_int == chunkqueue_to_tempfiles(dest, errh) {
        0 as libc::c_int
    } else {
        -(1 as libc::c_int)
    }) as ssize_t;
}
#[no_mangle]
pub unsafe extern "C" fn chunkqueue_append_splice_pipe_tempfile(
    cq: *mut chunkqueue,
    fd: libc::c_int,
    mut len: libc::c_uint,
    errh: *mut log_error_st,
) -> ssize_t {
    if !((*cq).first).is_null()
        && (*(*cq).first).type_0 as libc::c_uint == MEM_CHUNK as libc::c_int as libc::c_uint
    {
        let mut rc: libc::c_int = chunkqueue_to_tempfiles(cq, errh);
        if (0 as libc::c_int != rc) as libc::c_int as libc::c_long != 0 {
            return rc as ssize_t;
        }
    }
    let mut total: ssize_t = 0 as libc::c_int as ssize_t;
    loop {
        let c: *mut chunk = chunkqueue_get_append_tempfile(cq, errh);
        if (0 as *mut libc::c_void as *mut chunk == c) as libc::c_int as libc::c_long != 0 {
            return -*__errno_location() as ssize_t;
        }
        let mut off: loff_t = (*c).file.length;
        let mut wr: ssize_t = splice(
            fd,
            0 as *mut __off64_t,
            (*c).file.fd,
            &mut off,
            len as size_t,
            (1 as libc::c_int | 2 as libc::c_int) as libc::c_uint,
        );
        if (wr as size_t == len as libc::c_ulong) as libc::c_int as libc::c_long != 0 {
            (*c).file.length += len as libc::c_long;
            (*cq).bytes_in += len as libc::c_long;
            return total + len as libc::c_long;
        } else {
            if wr >= 0 as libc::c_int as libc::c_long {
                (*cq).bytes_in += wr;
                total += wr;
                len = (len as libc::c_ulong).wrapping_sub(wr as size_t) as libc::c_uint
                    as libc::c_uint;
                (*c).file.length = ((*c).file.length as libc::c_ulong).wrapping_add(wr as size_t)
                    as off_t as off_t;
            } else {
                let errnum: libc::c_int = *__errno_location();
                match errnum {
                    11 => {
                        if 0 as libc::c_int as libc::c_long == chunk_remaining_length(c) {
                            chunkqueue_remove_empty_chunks(cq);
                        }
                        return total;
                    }
                    22 => {
                        wr = chunkqueue_append_drain_pipe_tempfile(cq, fd, len, errh);
                        return if 0 as libc::c_int as libc::c_long == wr {
                            total + len as ssize_t
                        } else {
                            wr
                        };
                    }
                    _ => {
                        if chunkqueue_append_tempfile_err(cq, errh, c) == 0 {
                            return -errnum as ssize_t;
                        }
                    }
                }
            }
        }
        if !(len != 0) {
            break;
        }
    }
    return -(5 as libc::c_int) as ssize_t;
}
#[no_mangle]
pub unsafe extern "C" fn chunkqueue_append_splice_sock_tempfile(
    cq: *mut chunkqueue,
    fd: libc::c_int,
    mut len: libc::c_uint,
    errh: *mut log_error_st,
) -> ssize_t {
    let pipes: *mut libc::c_int = cqpipes.as_mut_ptr();
    if -(1 as libc::c_int) == *pipes.offset(1 as libc::c_int as isize) {
        return -(22 as libc::c_int) as ssize_t;
    }
    let mut wr: ssize_t = splice(
        fd,
        0 as *mut __off64_t,
        *pipes.offset(1 as libc::c_int as isize),
        0 as *mut __off64_t,
        len as size_t,
        (1 as libc::c_int | 2 as libc::c_int) as libc::c_uint,
    );
    if (wr <= 0 as libc::c_int as libc::c_long) as libc::c_int as libc::c_long != 0 {
        return -(22 as libc::c_int) as ssize_t;
    }
    len = wr as libc::c_uint;
    wr = chunkqueue_append_splice_pipe_tempfile(
        cq,
        *pipes.offset(0 as libc::c_int as isize),
        len,
        errh,
    );
    if wr < 0 as libc::c_int as libc::c_long {
        chunkqueue_pipe_read_discard();
    }
    return wr;
}
#[inline(never)]
unsafe extern "C" fn chunkqueue_mmap_chunk_len(c: *mut chunk, mut len: off_t) -> *mut libc::c_char {
    if -(1 as libc::c_int) as *mut libc::c_void == (*c).file.mmap.start as *mut libc::c_void
        || (*c).offset < (*c).file.mmap.offset
        || (*c).offset + len
            > ((*c).file.mmap.offset as libc::c_ulong).wrapping_add((*c).file.mmap.length) as off_t
    {
        if -(1 as libc::c_int) as *mut libc::c_void != (*c).file.mmap.start as *mut libc::c_void {
            munmap(
                (*c).file.mmap.start as *mut libc::c_void,
                (*c).file.mmap.length,
            );
        }
        (*c).file.mmap.offset = mmap_align_offset((*c).offset);
        (*c).file.mmap.length = ((*c).file.length - (*c).file.mmap.offset) as size_t;
        (*c).file.mmap.start = mmap(
            0 as *mut libc::c_void,
            (*c).file.mmap.length,
            0x1 as libc::c_int,
            0x2 as libc::c_int,
            (*c).file.fd,
            (*c).file.mmap.offset,
        ) as *mut libc::c_char;
        if -(1 as libc::c_int) as *mut libc::c_void == (*c).file.mmap.start as *mut libc::c_void {
            return 0 as *mut libc::c_char;
        }
    }
    return ((*c).file.mmap.start)
        .offset((*c).offset as isize)
        .offset(-((*c).file.mmap.offset as isize));
}
#[no_mangle]
pub unsafe extern "C" fn chunkqueue_peek_data(
    cq: *mut chunkqueue,
    data: *mut *mut libc::c_char,
    dlen: *mut uint32_t,
    errh: *mut log_error_st,
) -> libc::c_int {
    let data_in: *mut libc::c_char = *data;
    let data_insz: uint32_t = *dlen;
    *dlen = 0 as libc::c_int as uint32_t;
    let mut c: *mut chunk = (*cq).first;
    while !c.is_null() {
        let mut space: uint32_t = data_insz.wrapping_sub(*dlen);
        match (*c).type_0 as libc::c_uint {
            0 => {
                let mut have: uint32_t =
                    (buffer_clen((*c).mem)).wrapping_sub((*c).offset as uint32_t);
                if have > space {
                    have = space;
                }
                if *dlen != 0 {
                    memcpy(
                        data_in.offset(*dlen as isize) as *mut libc::c_void,
                        ((*(*c).mem).ptr).offset((*c).offset as isize) as *const libc::c_void,
                        have as libc::c_ulong,
                    );
                } else {
                    *data = ((*(*c).mem).ptr).offset((*c).offset as isize);
                }
                *dlen = (*dlen as libc::c_uint).wrapping_add(have) as uint32_t as uint32_t;
            }
            1 => {
                if (*c).file.fd >= 0 as libc::c_int
                    || 0 as libc::c_int == chunk_open_file_chunk(c, errh)
                {
                    let mut offset: off_t = (*c).offset;
                    let mut len: off_t = (*c).file.length - (*c).offset;
                    if len > space as off_t {
                        len = space as off_t;
                    }
                    if !(0 as libc::c_int as libc::c_long == len) {
                        let mut rd: ssize_t = 0;
                        loop {
                            rd = pread(
                                (*c).file.fd,
                                data_in.offset(*dlen as isize) as *mut libc::c_void,
                                len as size_t,
                                offset,
                            );
                            if !(-(1 as libc::c_int) as libc::c_long == rd
                                && *__errno_location() == 4 as libc::c_int)
                            {
                                break;
                            }
                        }
                        if rd <= 0 as libc::c_int as libc::c_long {
                            log_perror(
                                errh,
                                b"/home/kkysen/work/rust/lighttpd/src/chunk.c\0" as *const u8
                                    as *const libc::c_char,
                                1604 as libc::c_int as libc::c_uint,
                                b"read(\"%s\")\0" as *const u8 as *const libc::c_char,
                                (*(*c).mem).ptr,
                            );
                            return -(1 as libc::c_int);
                        }
                        *dlen = (*dlen as libc::c_uint).wrapping_add(rd as uint32_t) as uint32_t
                            as uint32_t;
                    }
                } else {
                    return -(1 as libc::c_int);
                }
            }
            _ => return -(1 as libc::c_int),
        }
        if *dlen == data_insz {
            break;
        }
        c = (*c).next;
        if c.is_null() {
            break;
        }
        if *dlen != 0 && *data != data_in {
            memcpy(
                data_in as *mut libc::c_void,
                *data as *const libc::c_void,
                *dlen as libc::c_ulong,
            );
            *data = data_in;
        }
    }
    return 0 as libc::c_int;
}
unsafe extern "C" fn chunkqueue_write_data(
    fd: libc::c_int,
    mut buf: *const libc::c_void,
    mut count: size_t,
) -> ssize_t {
    let mut wr: ssize_t = 0;
    loop {
        wr = write(fd, buf, count);
        if !(-(1 as libc::c_int) as libc::c_long == wr && *__errno_location() == 4 as libc::c_int) {
            break;
        }
    }
    return wr;
}
#[cold]
#[inline(never)]
unsafe extern "C" fn chunkqueue_write_chunk_file_intermed(
    fd: libc::c_int,
    c: *mut chunk,
    errh: *mut log_error_st,
) -> ssize_t {
    let mut buf: [libc::c_char; 16384] = [0; 16384];
    let mut data: *mut libc::c_char = buf.as_mut_ptr();
    let count: off_t = (*c).file.length - (*c).offset;
    let mut dlen: uint32_t =
        (if count < ::core::mem::size_of::<[libc::c_char; 16384]>() as libc::c_ulong as off_t {
            count as uint32_t as libc::c_ulong
        } else {
            ::core::mem::size_of::<[libc::c_char; 16384]>() as libc::c_ulong
        }) as uint32_t;
    let mut cq: chunkqueue = {
        let mut init = chunkqueue {
            first: c,
            last: c,
            bytes_in: 0 as libc::c_int as off_t,
            bytes_out: 0 as libc::c_int as off_t,
            tempdirs: 0 as *const array,
            upload_temp_file_size: 0 as libc::c_int as off_t,
            tempdir_idx: 0 as libc::c_int as libc::c_uint,
        };
        init
    };
    if 0 as libc::c_int != chunkqueue_peek_data(&mut cq, &mut data, &mut dlen, errh)
        && 0 as libc::c_int as libc::c_uint == dlen
    {
        return -(1 as libc::c_int) as ssize_t;
    }
    return chunkqueue_write_data(fd, data as *const libc::c_void, dlen as size_t);
}
static mut cqpipes: [libc::c_int; 2] = [-(1 as libc::c_int), -(1 as libc::c_int)];
#[cold]
#[inline(never)]
unsafe extern "C" fn chunkqueue_pipe_read_discard() {
    let mut buf: [libc::c_char; 16384] = [0; 16384];
    let mut rd: ssize_t = 0;
    loop {
        rd = read(
            cqpipes[0 as libc::c_int as usize],
            buf.as_mut_ptr() as *mut libc::c_void,
            ::core::mem::size_of::<[libc::c_char; 16384]>() as libc::c_ulong,
        );
        if !(rd > 0 as libc::c_int as libc::c_long
            || rd < 0 as libc::c_int as libc::c_long && *__errno_location() == 4 as libc::c_int)
        {
            break;
        }
    }
    if rd < 0 as libc::c_int as libc::c_long && *__errno_location() != 11 as libc::c_int {
        chunkqueue_internal_pipes(1 as libc::c_int);
    }
}
#[no_mangle]
#[cold]
#[inline(never)]
pub unsafe extern "C" fn chunkqueue_internal_pipes(mut init: libc::c_int) {
    if -(1 as libc::c_int) != cqpipes[0 as libc::c_int as usize] {
        close(cqpipes[0 as libc::c_int as usize]);
        cqpipes[0 as libc::c_int as usize] = -(1 as libc::c_int);
    }
    if -(1 as libc::c_int) != cqpipes[1 as libc::c_int as usize] {
        close(cqpipes[1 as libc::c_int as usize]);
        cqpipes[1 as libc::c_int as usize] = -(1 as libc::c_int);
    }
    if init != 0 {
        0 as libc::c_int
            != fdevent_pipe_cloexec(cqpipes.as_mut_ptr(), 262144 as libc::c_int as libc::c_uint);
    }
}
#[cold]
#[inline(never)]
unsafe extern "C" fn chunkqueue_append_drain_pipe_tempfile(
    cq: *mut chunkqueue,
    fd: libc::c_int,
    mut len: libc::c_uint,
    errh: *mut log_error_st,
) -> ssize_t {
    let mut buf: [libc::c_char; 16384] = [0; 16384];
    let mut rd: ssize_t = 0;
    loop {
        loop {
            rd = read(
                fd,
                buf.as_mut_ptr() as *mut libc::c_void,
                ::core::mem::size_of::<[libc::c_char; 16384]>() as libc::c_ulong,
            );
            if !(rd < 0 as libc::c_int as libc::c_long && *__errno_location() == 4 as libc::c_int) {
                break;
            }
        }
        if rd < 0 as libc::c_int as libc::c_long {
            break;
        }
        if 0 as libc::c_int
            != chunkqueue_append_mem_to_tempfile(cq, buf.as_mut_ptr(), rd as size_t, errh)
        {
            break;
        }
        len = len.wrapping_sub(rd as libc::c_uint);
        if !(len != 0) {
            break;
        }
    }
    if 0 as libc::c_int as libc::c_uint == len {
        return 0 as libc::c_int as ssize_t;
    } else {
        let errnum: libc::c_int = *__errno_location();
        if !((*cq).last).is_null()
            && 0 as libc::c_int as libc::c_long == chunk_remaining_length((*cq).last)
        {
            chunkqueue_remove_empty_chunks(cq);
        }
        return -errnum as ssize_t;
    };
}
#[no_mangle]
pub unsafe extern "C" fn chunkqueue_open_file_chunk(
    cq: *mut chunkqueue,
    errh: *mut log_error_st,
) -> libc::c_int {
    return chunk_open_file_chunk((*cq).first, errh);
}
unsafe extern "C" fn chunk_open_file_chunk(c: *mut chunk, errh: *mut log_error_st) -> libc::c_int {
    if -(1 as libc::c_int) == (*c).file.fd {
        (*c).file.fd = fdevent_open_cloexec(
            (*(*c).mem).ptr,
            1 as libc::c_int,
            0 as libc::c_int,
            0 as libc::c_int as mode_t,
        );
        if -(1 as libc::c_int) == (*c).file.fd {
            log_perror(
                errh,
                b"/home/kkysen/work/rust/lighttpd/src/chunk.c\0" as *const u8
                    as *const libc::c_char,
                1252 as libc::c_int as libc::c_uint,
                b"open failed: %s\0" as *const u8 as *const libc::c_char,
                (*(*c).mem).ptr,
            );
            return -(1 as libc::c_int);
        }
    }
    if (*c).file.is_temp != 0 {
        return 0 as libc::c_int;
    }
    let mut st: stat = stat {
        st_dev: 0,
        st_ino: 0,
        st_nlink: 0,
        st_mode: 0,
        st_uid: 0,
        st_gid: 0,
        __pad0: 0,
        st_rdev: 0,
        st_size: 0,
        st_blksize: 0,
        st_blocks: 0,
        st_atim: timespec {
            tv_sec: 0,
            tv_nsec: 0,
        },
        st_mtim: timespec {
            tv_sec: 0,
            tv_nsec: 0,
        },
        st_ctim: timespec {
            tv_sec: 0,
            tv_nsec: 0,
        },
        __glibc_reserved: [0; 3],
    };
    if -(1 as libc::c_int) == fstat((*c).file.fd, &mut st) {
        log_perror(
            errh,
            b"/home/kkysen/work/rust/lighttpd/src/chunk.c\0" as *const u8 as *const libc::c_char,
            1262 as libc::c_int as libc::c_uint,
            b"fstat failed\0" as *const u8 as *const libc::c_char,
        );
        return -(1 as libc::c_int);
    }
    let offset: off_t = (*c).offset;
    let len: off_t = (*c).file.length - (*c).offset;
    if !(offset >= 0 as libc::c_int as libc::c_long && len >= 0 as libc::c_int as libc::c_long) {
        ck_assert_failed(
            b"/home/kkysen/work/rust/lighttpd/src/chunk.c\0" as *const u8 as *const libc::c_char,
            1268 as libc::c_int as libc::c_uint,
            b"offset >= 0 && len >= 0\0" as *const u8 as *const libc::c_char,
        );
    }
    if offset > st.st_size - len {
        log_error(
            errh,
            b"/home/kkysen/work/rust/lighttpd/src/chunk.c\0" as *const u8 as *const libc::c_char,
            1270 as libc::c_int as libc::c_uint,
            b"file shrunk: %s\0" as *const u8 as *const libc::c_char,
            (*(*c).mem).ptr,
        );
        return -(1 as libc::c_int);
    }
    return 0 as libc::c_int;
}
#[no_mangle]
pub unsafe extern "C" fn chunkqueue_compact_mem_offset(cq: *mut chunkqueue) {
    let c: *mut chunk = (*cq).first;
    if 0 as libc::c_int as libc::c_long == (*c).offset {
        return;
    }
    if (*c).type_0 as libc::c_uint != MEM_CHUNK as libc::c_int as libc::c_uint {
        return;
    }
    let b: *mut buffer = (*c).mem;
    let mut len: size_t = (buffer_clen(b) as libc::c_long - (*c).offset) as size_t;
    memmove(
        (*b).ptr as *mut libc::c_void,
        ((*b).ptr).offset((*c).offset as isize) as *const libc::c_void,
        len,
    );
    (*c).offset = 0 as libc::c_int as off_t;
    buffer_truncate(b, len as uint32_t);
}
#[no_mangle]
pub unsafe extern "C" fn chunkqueue_compact_mem(mut cq: *mut chunkqueue, mut clen: size_t) {
    let mut c: *mut chunk = (*cq).first;
    let mut b: *mut buffer = (*c).mem;
    let mut len: size_t = (buffer_clen(b) as libc::c_long - (*c).offset) as size_t;
    if len >= clen {
        return;
    }
    if (*b).size as libc::c_ulong > clen {
        if (buffer_string_space(b) as libc::c_ulong) < clen.wrapping_sub(len) {
            chunkqueue_compact_mem_offset(cq);
        }
    } else {
        b = chunkqueue_prepend_buffer_open_sz(
            cq,
            clen.wrapping_add(1 as libc::c_int as libc::c_ulong),
        );
        buffer_append_string_len(b, ((*(*c).mem).ptr).offset((*c).offset as isize), len);
        (*(*cq).first).next = (*c).next;
        if ((*c).next).is_null() {
            (*cq).last = (*cq).first;
        }
        chunk_release(c);
        c = (*cq).first;
    }
    let mut fc: *mut chunk = c;
    loop {
        clen = (clen as libc::c_ulong).wrapping_sub(len) as size_t as size_t;
        if !(clen != 0 && {
            c = (*fc).next;
            !c.is_null()
        }) {
            break;
        }
        len = (buffer_clen((*c).mem) as libc::c_long - (*c).offset) as size_t;
        if len > clen {
            buffer_append_string_len(b, ((*(*c).mem).ptr).offset((*c).offset as isize), clen);
            (*c).offset = ((*c).offset as libc::c_ulong).wrapping_add(clen) as off_t as off_t;
            break;
        } else {
            buffer_append_string_len(b, ((*(*c).mem).ptr).offset((*c).offset as isize), len);
            (*fc).next = (*c).next;
            if ((*c).next).is_null() {
                (*cq).last = fc;
            }
            chunk_release(c);
        }
    }
}
#[no_mangle]
pub unsafe extern "C" fn chunkqueue_small_resp_optim(cq: *mut chunkqueue) {
    let mut c: *mut chunk = (*cq).first;
    let filec: *mut chunk = (*c).next;
    if filec != (*cq).last
        || (*filec).type_0 as libc::c_uint != FILE_CHUNK as libc::c_int as libc::c_uint
        || (*filec).file.fd < 0 as libc::c_int
    {
        return;
    }
    let mut len: off_t = (*filec).file.length - (*filec).offset;
    if len as size_t > buffer_string_space((*c).mem) as libc::c_ulong {
        (*c).next = chunk_acquire((len as size_t).wrapping_add(1 as libc::c_int as libc::c_ulong));
        c = (*c).next;
    }
    (*c).next = 0 as *mut chunk;
    (*cq).last = c;
    let mut rd: ssize_t = 0;
    let mut offset: off_t = 0 as libc::c_int as off_t;
    let ptr: *mut libc::c_char = buffer_extend((*c).mem, len as size_t);
    loop {
        rd = pread(
            (*filec).file.fd,
            ptr.offset(offset as isize) as *mut libc::c_void,
            len as size_t,
            (*filec).offset + offset,
        );
        if !(if rd > 0 as libc::c_int as libc::c_long {
            offset += rd;
            len -= rd;
            len
        } else {
            (*__errno_location() == 4 as libc::c_int) as libc::c_int as libc::c_long
        } != 0)
        {
            break;
        }
    }
    if (0 as libc::c_int as libc::c_long == len) as libc::c_int as libc::c_long != 0 {
        chunk_release(filec);
    } else {
        buffer_truncate(
            (*c).mem,
            ptr.offset(offset as isize).offset_from((*(*c).mem).ptr) as libc::c_long as uint32_t,
        );
        (*c).next = filec;
        (*cq).last = (*c).next;
        if offset != 0 {
            (*filec).offset += offset;
        } else if ((*cq).first != c) as libc::c_int as libc::c_long != 0 {
            (*(*cq).first).next = filec;
            chunk_release(c);
        }
    };
}
#[no_mangle]
pub unsafe extern "C" fn chunkqueue_write_chunk(
    fd: libc::c_int,
    cq: *mut chunkqueue,
    errh: *mut log_error_st,
) -> ssize_t {
    let c: *mut chunk = (*cq).first;
    match (*c).type_0 as libc::c_uint {
        0 => return chunkqueue_write_chunk_mem(fd, c),
        1 => return chunkqueue_write_chunk_file(fd, c, errh),
        _ => {
            *__errno_location() = 22 as libc::c_int;
            return -(1 as libc::c_int) as ssize_t;
        }
    };
}
unsafe extern "C" fn chunkqueue_write_chunk_file(
    fd: libc::c_int,
    c: *mut chunk,
    errh: *mut log_error_st,
) -> ssize_t {
    if 0 as libc::c_int != chunk_open_file_chunk(c, errh) {
        return -(1 as libc::c_int) as ssize_t;
    }
    let count: off_t = (*c).file.length - (*c).offset;
    if 0 as libc::c_int as libc::c_long == count {
        return 0 as libc::c_int as ssize_t;
    }
    let mut offset: off_t = (*c).offset;
    let wr: ssize_t = sendfile(
        fd,
        (*c).file.fd,
        &mut offset,
        (if count < 2147483647 as libc::c_int as libc::c_long {
            count
        } else {
            2147483647 as libc::c_int as libc::c_long
        }) as size_t,
    );
    if (wr >= 0 as libc::c_int as libc::c_long) as libc::c_int as libc::c_long != 0
        || *__errno_location() != 22 as libc::c_int && *__errno_location() != 38 as libc::c_int
    {
        return wr;
    }
    let data: *const libc::c_char = chunkqueue_mmap_chunk_len(c, count);
    if !data.is_null() {
        return chunkqueue_write_data(fd, data as *const libc::c_void, count as size_t);
    }
    return chunkqueue_write_chunk_file_intermed(fd, c, errh);
}
#[inline(never)]
unsafe extern "C" fn http_chunk_len_append(cq: *mut chunkqueue, mut len: uintmax_t) {
    let mut buf: [libc::c_char; 24] = [0; 24];
    let mut i: libc::c_int =
        ::core::mem::size_of::<[libc::c_char; 24]>() as libc::c_ulong as libc::c_int;
    i -= 1;
    buf[i as usize] = '\n' as i32 as libc::c_char;
    i -= 1;
    buf[i as usize] = '\r' as i32 as libc::c_char;
    loop {
        i -= 1;
        buf[i as usize] =
            (*::core::mem::transmute::<&[u8; 17], &[libc::c_char; 17]>(b"0123456789abcdef\0"))
                [(len & 0xf as libc::c_int as libc::c_ulong) as usize];
        len >>= 4 as libc::c_int;
        if !(len != 0) {
            break;
        }
    }
    chunkqueue_append_mem(
        cq,
        buf.as_mut_ptr().offset(i as isize),
        (::core::mem::size_of::<[libc::c_char; 24]>() as libc::c_ulong)
            .wrapping_sub(i as libc::c_ulong),
    );
}
#[inline(never)]
unsafe extern "C" fn http_chunk_len_append_tempfile(
    cq: *mut chunkqueue,
    mut len: uintmax_t,
    errh: *mut log_error_st,
) -> libc::c_int {
    let mut buf: [libc::c_char; 24] = [0; 24];
    let mut i: libc::c_int =
        ::core::mem::size_of::<[libc::c_char; 24]>() as libc::c_ulong as libc::c_int;
    i -= 1;
    buf[i as usize] = '\n' as i32 as libc::c_char;
    i -= 1;
    buf[i as usize] = '\r' as i32 as libc::c_char;
    loop {
        i -= 1;
        buf[i as usize] =
            (*::core::mem::transmute::<&[u8; 17], &[libc::c_char; 17]>(b"0123456789abcdef\0"))
                [(len & 0xf as libc::c_int as libc::c_ulong) as usize];
        len >>= 4 as libc::c_int;
        if !(len != 0) {
            break;
        }
    }
    return chunkqueue_append_mem_to_tempfile(
        cq,
        buf.as_mut_ptr().offset(i as isize),
        (::core::mem::size_of::<[libc::c_char; 24]>() as libc::c_ulong)
            .wrapping_sub(i as libc::c_ulong),
        errh,
    );
}
#[inline(never)]
unsafe extern "C" fn http_chunk_append_read_fd_range(
    r: *mut request_st,
    fn_0: *const buffer,
    fd: libc::c_int,
    mut offset: off_t,
    mut len: off_t,
) -> libc::c_int {
    let cq: *mut chunkqueue = &mut (*r).write_queue;
    if (*r).resp_send_chunked != 0 {
        http_chunk_len_append(cq, len as uintmax_t);
    }
    let b: *mut buffer = chunkqueue_append_buffer_open_sz(
        cq,
        (len + 2 as libc::c_int as libc::c_long + 1 as libc::c_int as libc::c_long) as size_t,
    );
    let mut rd: ssize_t = 0;
    let foff: off_t = offset;
    offset = 0 as libc::c_int as off_t;
    loop {
        rd = pread(
            fd,
            ((*b).ptr).offset(offset as isize) as *mut libc::c_void,
            (len - offset) as size_t,
            foff + offset,
        );
        if !(if rd > 0 as libc::c_int as libc::c_long {
            offset += rd;
            (offset != len) as libc::c_int
        } else {
            (*__errno_location() == 4 as libc::c_int) as libc::c_int
        } != 0)
        {
            break;
        }
    }
    buffer_commit(b, offset as size_t);
    if (*r).resp_send_chunked != 0 {
        buffer_append_string_len(
            b,
            b"\r\n\0" as *const u8 as *const libc::c_char,
            (::core::mem::size_of::<[libc::c_char; 3]>() as libc::c_ulong as uint32_t)
                .wrapping_sub(1 as libc::c_int as libc::c_uint) as size_t,
        );
    }
    chunkqueue_append_buffer_commit(cq);
    return if rd >= 0 as libc::c_int as libc::c_long {
        0 as libc::c_int
    } else {
        -(1 as libc::c_int)
    };
}
#[no_mangle]
#[inline(never)]
pub unsafe extern "C" fn http_chunk_append_file_ref_range(
    r: *mut request_st,
    sce: *mut stat_cache_entry,
    offset: off_t,
    mut len: off_t,
) {
    let cq: *mut chunkqueue = &mut (*r).write_queue;
    if (*sce).st.st_size - offset < len {
        len = (*sce).st.st_size - offset;
    }
    if len <= 0 as libc::c_int as libc::c_long {
        return;
    }
    if (*r).resp_send_chunked != 0 {
        http_chunk_len_append(cq, len as uintmax_t);
    }
    let fn_0: *const buffer = &mut (*sce).name;
    let fd: libc::c_int = (*sce).fd;
    chunkqueue_append_file_fd(cq, fn_0, fd, offset, len);
    if fd >= 0 as libc::c_int {
        let d: *mut chunk = (*cq).last;
        (*d).file.ref_0 = sce as *mut libc::c_void;
        (*d).file.refchg = Some(
            stat_cache_entry_refchg as unsafe extern "C" fn(*mut libc::c_void, libc::c_int) -> (),
        );
        stat_cache_entry_refchg(sce as *mut libc::c_void, 1 as libc::c_int);
    }
    if (*r).resp_send_chunked != 0 {
        chunkqueue_append_mem(
            cq,
            b"\r\n\0" as *const u8 as *const libc::c_char,
            (::core::mem::size_of::<[libc::c_char; 3]>() as libc::c_ulong as uint32_t)
                .wrapping_sub(1 as libc::c_int as libc::c_uint) as size_t,
        );
    }
}
#[no_mangle]
#[inline(never)]
pub unsafe extern "C" fn http_chunk_append_file_fd_range(
    r: *mut request_st,
    fn_0: *const buffer,
    fd: libc::c_int,
    offset: off_t,
    len: off_t,
) {
    let cq: *mut chunkqueue = &mut (*r).write_queue;
    if (*r).resp_send_chunked != 0 {
        http_chunk_len_append(cq, len as uintmax_t);
    }
    chunkqueue_append_file_fd(cq, fn_0, fd, offset, len);
    if (*r).resp_send_chunked != 0 {
        chunkqueue_append_mem(
            cq,
            b"\r\n\0" as *const u8 as *const libc::c_char,
            (::core::mem::size_of::<[libc::c_char; 3]>() as libc::c_ulong as uint32_t)
                .wrapping_sub(1 as libc::c_int as libc::c_uint) as size_t,
        );
    }
}
#[no_mangle]
pub unsafe extern "C" fn http_chunk_append_file_fd(
    r: *mut request_st,
    fn_0: *const buffer,
    fd: libc::c_int,
    sz: off_t,
) -> libc::c_int {
    if sz > 32768 as libc::c_int as libc::c_long || (*r).resp_send_chunked == 0 {
        http_chunk_append_file_fd_range(r, fn_0, fd, 0 as libc::c_int as off_t, sz);
        return 0 as libc::c_int;
    }
    let mut rc: libc::c_int = if 0 as libc::c_int as libc::c_long != sz {
        http_chunk_append_read_fd_range(r, fn_0, fd, 0 as libc::c_int as off_t, sz)
    } else {
        0 as libc::c_int
    };
    close(fd);
    return rc;
}
#[no_mangle]
pub unsafe extern "C" fn http_chunk_append_file_ref(
    r: *mut request_st,
    sce: *mut stat_cache_entry,
) -> libc::c_int {
    let sz: off_t = (*sce).st.st_size;
    if sz > 32768 as libc::c_int as libc::c_long || (*r).resp_send_chunked == 0 {
        http_chunk_append_file_ref_range(r, sce, 0 as libc::c_int as off_t, sz);
        return 0 as libc::c_int;
    }
    let fn_0: *const buffer = &mut (*sce).name;
    let fd: libc::c_int = (*sce).fd;
    let mut rc: libc::c_int = if 0 as libc::c_int as libc::c_long != sz {
        http_chunk_append_read_fd_range(r, fn_0, fd, 0 as libc::c_int as off_t, sz)
    } else {
        0 as libc::c_int
    };
    return rc;
}
#[inline(never)]
unsafe extern "C" fn http_chunk_append_to_tempfile(
    r: *mut request_st,
    mem: *const libc::c_char,
    len: size_t,
) -> libc::c_int {
    let cq: *mut chunkqueue = &mut (*r).write_queue;
    let errh: *mut log_error_st = (*r).conf.errh;
    if (*r).resp_send_chunked as libc::c_int != 0
        && 0 as libc::c_int != http_chunk_len_append_tempfile(cq, len, errh)
    {
        return -(1 as libc::c_int);
    }
    if 0 as libc::c_int != chunkqueue_append_mem_to_tempfile(cq, mem, len, errh) {
        return -(1 as libc::c_int);
    }
    if (*r).resp_send_chunked as libc::c_int != 0
        && 0 as libc::c_int
            != chunkqueue_append_mem_to_tempfile(
                cq,
                b"\r\n\0" as *const u8 as *const libc::c_char,
                (::core::mem::size_of::<[libc::c_char; 3]>() as libc::c_ulong as uint32_t)
                    .wrapping_sub(1 as libc::c_int as libc::c_uint) as size_t,
                errh,
            )
    {
        return -(1 as libc::c_int);
    }
    return 0 as libc::c_int;
}
#[inline(never)]
unsafe extern "C" fn http_chunk_append_cq_to_tempfile(
    r: *mut request_st,
    src: *mut chunkqueue,
    len: size_t,
) -> libc::c_int {
    let cq: *mut chunkqueue = &mut (*r).write_queue;
    let errh: *mut log_error_st = (*r).conf.errh;
    if (*r).resp_send_chunked as libc::c_int != 0
        && 0 as libc::c_int != http_chunk_len_append_tempfile(cq, len, errh)
    {
        return -(1 as libc::c_int);
    }
    if 0 as libc::c_int != chunkqueue_steal_with_tempfiles(cq, src, len as off_t, errh) {
        return -(1 as libc::c_int);
    }
    if (*r).resp_send_chunked as libc::c_int != 0
        && 0 as libc::c_int
            != chunkqueue_append_mem_to_tempfile(
                cq,
                b"\r\n\0" as *const u8 as *const libc::c_char,
                (::core::mem::size_of::<[libc::c_char; 3]>() as libc::c_ulong as uint32_t)
                    .wrapping_sub(1 as libc::c_int as libc::c_uint) as size_t,
                errh,
            )
    {
        return -(1 as libc::c_int);
    }
    return 0 as libc::c_int;
}
unsafe extern "C" fn http_chunk_uses_tempfile(cq: *const chunkqueue, len: size_t) -> libc::c_int {
    let c: *const chunk = (*cq).last;
    return (!c.is_null()
        && (*c).type_0 as libc::c_uint == FILE_CHUNK as libc::c_int as libc::c_uint
        && (*c).file.is_temp != 0
        || (chunkqueue_length(cq) as libc::c_ulong).wrapping_add(len)
            > 65536 as libc::c_int as libc::c_ulong) as libc::c_int;
}
#[no_mangle]
#[inline(never)]
pub unsafe extern "C" fn http_chunk_append_buffer(
    r: *mut request_st,
    mem: *mut buffer,
) -> libc::c_int {
    let mut len: size_t = (if !mem.is_null() {
        buffer_clen(mem)
    } else {
        0 as libc::c_int as libc::c_uint
    }) as size_t;
    if 0 as libc::c_int as libc::c_ulong == len {
        return 0 as libc::c_int;
    }
    let cq: *mut chunkqueue = &mut (*r).write_queue;
    if http_chunk_uses_tempfile(cq, len) != 0 {
        let mut rc: libc::c_int = http_chunk_append_to_tempfile(r, (*mem).ptr, len);
        buffer_clear(mem);
        return rc;
    }
    if (*r).resp_send_chunked != 0 {
        http_chunk_len_append(cq, len);
    }
    chunkqueue_append_buffer(cq, mem);
    if (*r).resp_send_chunked != 0 {
        chunkqueue_append_mem(
            cq,
            b"\r\n\0" as *const u8 as *const libc::c_char,
            (::core::mem::size_of::<[libc::c_char; 3]>() as libc::c_ulong as uint32_t)
                .wrapping_sub(1 as libc::c_int as libc::c_uint) as size_t,
        );
    }
    return 0 as libc::c_int;
}
#[no_mangle]
#[inline(never)]
pub unsafe extern "C" fn http_chunk_append_mem(
    r: *mut request_st,
    mem: *const libc::c_char,
    len: size_t,
) -> libc::c_int {
    if 0 as libc::c_int as libc::c_ulong == len {
        return 0 as libc::c_int;
    }
    if mem.is_null() {
        ck_assert_failed(
            b"/home/kkysen/work/rust/lighttpd/src/http_chunk.c\0" as *const u8
                as *const libc::c_char,
            246 as libc::c_int as libc::c_uint,
            b"((void*)0) != mem\0" as *const u8 as *const libc::c_char,
        );
    }
    let cq: *mut chunkqueue = &mut (*r).write_queue;
    if http_chunk_uses_tempfile(cq, len) != 0 {
        return http_chunk_append_to_tempfile(r, mem, len);
    }
    if (*r).resp_send_chunked != 0 {
        http_chunk_len_append(cq, len);
    }
    chunkqueue_append_mem(cq, mem, len);
    if (*r).resp_send_chunked != 0 {
        chunkqueue_append_mem(
            cq,
            b"\r\n\0" as *const u8 as *const libc::c_char,
            (::core::mem::size_of::<[libc::c_char; 3]>() as libc::c_ulong as uint32_t)
                .wrapping_sub(1 as libc::c_int as libc::c_uint) as size_t,
        );
    }
    return 0 as libc::c_int;
}
#[no_mangle]
pub unsafe extern "C" fn http_chunk_transfer_cqlen(
    r: *mut request_st,
    src: *mut chunkqueue,
    len: size_t,
) -> libc::c_int {
    if 0 as libc::c_int as libc::c_ulong == len {
        return 0 as libc::c_int;
    }
    let cq: *mut chunkqueue = &mut (*r).write_queue;
    if http_chunk_uses_tempfile(cq, len) != 0 {
        return http_chunk_append_cq_to_tempfile(r, src, len);
    }
    if (*r).resp_send_chunked != 0 {
        http_chunk_len_append(cq, len);
    }
    chunkqueue_steal(cq, src, len as off_t);
    if (*r).resp_send_chunked != 0 {
        chunkqueue_append_mem(
            cq,
            b"\r\n\0" as *const u8 as *const libc::c_char,
            (::core::mem::size_of::<[libc::c_char; 3]>() as libc::c_ulong as uint32_t)
                .wrapping_sub(1 as libc::c_int as libc::c_uint) as size_t,
        );
    }
    return 0 as libc::c_int;
}
#[no_mangle]
pub unsafe extern "C" fn http_chunk_close(r: *mut request_st) {
    if (*r).resp_send_chunked == 0 {
        return;
    }
    if !((*r).gw_dechunk).is_null() {
        if (*(*r).gw_dechunk).done == 0 {
            (*r).keep_alive = 0 as libc::c_int as int8_t;
        }
    } else {
        chunkqueue_append_mem(
            &mut (*r).write_queue,
            b"0\r\n\r\n\0" as *const u8 as *const libc::c_char,
            (::core::mem::size_of::<[libc::c_char; 6]>() as libc::c_ulong as uint32_t)
                .wrapping_sub(1 as libc::c_int as libc::c_uint) as size_t,
        );
    };
}
unsafe extern "C" fn http_chunk_decode_append_data(
    r: *mut request_st,
    mut mem: *const libc::c_char,
    mut len: off_t,
) -> libc::c_int {
    if (*(*r).gw_dechunk).done != 0 {
        return -(1 as libc::c_int);
    }
    let h: *mut buffer = &mut (*(*r).gw_dechunk).b;
    let mut te_chunked: off_t = (*(*r).gw_dechunk).gw_chunked;
    while len != 0 {
        if 0 as libc::c_int as libc::c_long == te_chunked {
            let mut p: *const libc::c_char = 0 as *const libc::c_char;
            let mut s: *mut libc::c_uchar = mem as *mut libc::c_uchar;
            let mut hsz: off_t = 0;
            if buffer_is_blank(h) != 0 {
                p = memchr(mem as *const libc::c_void, '\n' as i32, len as size_t)
                    as *const libc::c_char;
                if !p.is_null() {
                    p = p.offset(1);
                    hsz = p.offset_from(mem) as libc::c_long;
                } else {
                    if len >= 1024 as libc::c_int as libc::c_long {
                        log_error(
                            (*r).conf.errh,
                            b"/home/kkysen/work/rust/lighttpd/src/http_chunk.c\0" as *const u8
                                as *const libc::c_char,
                            313 as libc::c_int as libc::c_uint,
                            b"chunked header line too long\0" as *const u8 as *const libc::c_char,
                        );
                        return -(1 as libc::c_int);
                    }
                    buffer_append_string_len(h, mem, len as uint32_t as size_t);
                    break;
                }
            } else {
                let mut hlen: uint32_t = buffer_clen(h);
                p = strchr((*h).ptr, '\n' as i32);
                if !p.is_null() {
                    p = p.offset(1);
                    hsz = p.offset_from((*h).ptr) as libc::c_long;
                } else {
                    p = memchr(mem as *const libc::c_void, '\n' as i32, len as size_t)
                        as *const libc::c_char;
                    hsz = if !p.is_null() {
                        p = p.offset(1);
                        p.offset_from(mem) as libc::c_long
                    } else {
                        len
                    };
                    if ((1024 as libc::c_int as libc::c_uint).wrapping_sub(hlen) as off_t) < hsz {
                        log_error(
                            (*r).conf.errh,
                            b"/home/kkysen/work/rust/lighttpd/src/http_chunk.c\0" as *const u8
                                as *const libc::c_char,
                            330 as libc::c_int as libc::c_uint,
                            b"chunked header line too long\0" as *const u8 as *const libc::c_char,
                        );
                        return -(1 as libc::c_int);
                    }
                    buffer_append_string_len(h, mem, hsz as size_t);
                    if p.is_null() {
                        break;
                    }
                    mem = mem.offset(hsz as isize);
                    len -= hsz;
                    hsz = 0 as libc::c_int as off_t;
                }
                s = (*h).ptr as *mut libc::c_uchar;
            }
            let mut u: libc::c_uchar = 0;
            loop {
                u = hex2int(*s) as libc::c_uchar;
                if !(u as libc::c_int != 0xff as libc::c_int) {
                    break;
                }
                if te_chunked
                    > ((1 as libc::c_ulonglong)
                        << (8 as libc::c_int as libc::c_ulong)
                            .wrapping_mul(::core::mem::size_of::<off_t>() as libc::c_ulong)
                            .wrapping_sub(5 as libc::c_int as libc::c_ulong))
                        as off_t
                        - 1 as libc::c_int as libc::c_long
                        - 2 as libc::c_int as libc::c_long
                {
                    log_error(
                        (*r).conf.errh,
                        b"/home/kkysen/work/rust/lighttpd/src/http_chunk.c\0" as *const u8
                            as *const libc::c_char,
                        345 as libc::c_int as libc::c_uint,
                        b"chunked data size too large\0" as *const u8 as *const libc::c_char,
                    );
                    return -(1 as libc::c_int);
                }
                te_chunked <<= 4 as libc::c_int;
                te_chunked |= u as libc::c_long;
                s = s.offset(1);
            }
            if s as *mut libc::c_char == mem as *mut libc::c_char
                || s as *mut libc::c_char == (*h).ptr
            {
                return -(1 as libc::c_int);
            }
            while *s as libc::c_int == ' ' as i32 || *s as libc::c_int == '\t' as i32 {
                s = s.offset(1);
            }
            if *s as libc::c_int != '\r' as i32 && *s as libc::c_int != ';' as i32 {
                log_error(
                    (*r).conf.errh,
                    b"/home/kkysen/work/rust/lighttpd/src/http_chunk.c\0" as *const u8
                        as *const libc::c_char,
                    355 as libc::c_int as libc::c_uint,
                    b"chunked header invalid chars\0" as *const u8 as *const libc::c_char,
                );
                return -(1 as libc::c_int);
            }
            if 0 as libc::c_int as libc::c_long == te_chunked {
                if len - hsz >= 2 as libc::c_int as libc::c_long
                    && *p.offset(0 as libc::c_int as isize) as libc::c_int == '\r' as i32
                    && *p.offset(1 as libc::c_int as isize) as libc::c_int == '\n' as i32
                {
                    if len - hsz > 2 as libc::c_int as libc::c_long {
                        return -(1 as libc::c_int);
                    }
                    buffer_clear(h);
                    (*(*r).gw_dechunk).done = (*r).http_status;
                    break;
                } else {
                    let mut mlen: uint32_t = buffer_clen(h);
                    mlen = if (*r).conf.max_request_field_size > mlen {
                        ((*r).conf.max_request_field_size).wrapping_sub(mlen)
                    } else {
                        0 as libc::c_int as libc::c_uint
                    };
                    if (mlen as off_t) < len {
                        if (*r).resp_send_chunked != 0 {
                            (*r).keep_alive = 0 as libc::c_int as int8_t;
                        }
                        (*(*r).gw_dechunk).done = (*r).http_status;
                        buffer_append_string_len(h, mem, mlen as size_t);
                        p = strrchr((*h).ptr, '\n' as i32);
                        if !p.is_null() {
                            buffer_truncate(
                                h,
                                p.offset(1 as libc::c_int as isize).offset_from((*h).ptr)
                                    as libc::c_long as uint32_t,
                            );
                            if *p.offset(-(1 as libc::c_int) as isize) as libc::c_int != '\r' as i32
                            {
                                buffer_append_string_len(
                                    h,
                                    b"\r\n\0" as *const u8 as *const libc::c_char,
                                    (::core::mem::size_of::<[libc::c_char; 3]>() as libc::c_ulong
                                        as uint32_t)
                                        .wrapping_sub(1 as libc::c_int as libc::c_uint)
                                        as size_t,
                                );
                            }
                        } else {
                            buffer_clear(h);
                            buffer_append_string_len(
                                h,
                                b"0\r\n\0" as *const u8 as *const libc::c_char,
                                (::core::mem::size_of::<[libc::c_char; 4]>() as libc::c_ulong
                                    as uint32_t)
                                    .wrapping_sub(1 as libc::c_int as libc::c_uint)
                                    as size_t,
                            );
                        }
                        buffer_append_string_len(
                            h,
                            b"\r\n\0" as *const u8 as *const libc::c_char,
                            (::core::mem::size_of::<[libc::c_char; 3]>() as libc::c_ulong
                                as uint32_t)
                                .wrapping_sub(1 as libc::c_int as libc::c_uint)
                                as size_t,
                        );
                        break;
                    } else {
                        buffer_append_string_len(h, mem, len as uint32_t as size_t);
                        p = strstr((*h).ptr, b"\r\n\r\n\0" as *const u8 as *const libc::c_char);
                        if !p.is_null() {
                            (*(*r).gw_dechunk).done = (*r).http_status;
                            if *p.offset(4 as libc::c_int as isize) as libc::c_int != '\0' as i32 {
                                return -(1 as libc::c_int);
                            }
                        }
                        break;
                    }
                }
            } else {
                mem = mem.offset(hsz as isize);
                len -= hsz;
                te_chunked += 2 as libc::c_int as libc::c_long;
                buffer_clear(h);
                if 0 as libc::c_int as libc::c_long == len {
                    break;
                }
            }
        }
        if te_chunked >= 2 as libc::c_int as libc::c_long {
            let mut clen: off_t = te_chunked - 2 as libc::c_int as libc::c_long;
            if clen > len {
                clen = len;
            }
            if (*r).resp_send_chunked == 0
                && 0 as libc::c_int != http_chunk_append_mem(r, mem, clen as size_t)
            {
                return -(1 as libc::c_int);
            }
            mem = mem.offset(clen as isize);
            len -= clen;
            te_chunked -= clen;
            if !(te_chunked == 2 as libc::c_int as libc::c_long) {
                continue;
            }
            if len >= 2 as libc::c_int as libc::c_long {
                if *mem.offset(0 as libc::c_int as isize) as libc::c_int != '\r' as i32
                    || *mem.offset(1 as libc::c_int as isize) as libc::c_int != '\n' as i32
                {
                    return -(1 as libc::c_int);
                }
                mem = mem.offset(2 as libc::c_int as isize);
                len -= 2 as libc::c_int as libc::c_long;
                te_chunked = 0 as libc::c_int as off_t;
            } else {
                if !(len == 1 as libc::c_int as libc::c_long) {
                    continue;
                }
                if *mem.offset(0 as libc::c_int as isize) as libc::c_int != '\r' as i32 {
                    return -(1 as libc::c_int);
                }
                te_chunked = 1 as libc::c_int as off_t;
                break;
            }
        } else if 1 as libc::c_int as libc::c_long == te_chunked {
            if *mem.offset(0 as libc::c_int as isize) as libc::c_int != '\n' as i32 {
                return -(1 as libc::c_int);
            }
            mem = mem.offset(1);
            len -= 1;
            te_chunked = 0 as libc::c_int as off_t;
        }
    }
    if (*(*r).gw_dechunk).done != 0 {
        (*r).resp_body_finished = 1 as libc::c_int as libc::c_char;
    }
    (*(*r).gw_dechunk).gw_chunked = te_chunked;
    return 0 as libc::c_int;
}
#[no_mangle]
pub unsafe extern "C" fn http_chunk_decode_append_buffer(
    r: *mut request_st,
    mem: *mut buffer,
) -> libc::c_int {
    if 0 as libc::c_int != http_chunk_decode_append_data(r, (*mem).ptr, buffer_clen(mem) as off_t) {
        return -(1 as libc::c_int);
    }
    if (*r).resp_send_chunked != 0 {
        (*r).resp_send_chunked = 0 as libc::c_int as libc::c_char;
        let mut rc: libc::c_int = http_chunk_append_buffer(r, mem);
        (*r).resp_send_chunked = 1 as libc::c_int as libc::c_char;
        return rc;
    } else {
        buffer_clear(mem);
    }
    return 0 as libc::c_int;
}
#[no_mangle]
pub unsafe extern "C" fn http_chunk_decode_append_mem(
    r: *mut request_st,
    mem: *const libc::c_char,
    mut len: size_t,
) -> libc::c_int {
    if 0 as libc::c_int != http_chunk_decode_append_data(r, mem, len as off_t) {
        return -(1 as libc::c_int);
    }
    if (*r).resp_send_chunked != 0 {
        (*r).resp_send_chunked = 0 as libc::c_int as libc::c_char;
        let mut rc: libc::c_int = http_chunk_append_mem(r, mem, len);
        (*r).resp_send_chunked = 1 as libc::c_int as libc::c_char;
        return rc;
    }
    return 0 as libc::c_int;
}
static mut use_sock_cloexec: libc::c_int = 0;
static mut use_sock_nonblock: libc::c_int = 0;
#[no_mangle]
#[cold]
pub unsafe extern "C" fn fdevent_socket_nb_cloexec_init() {
    let mut fd: libc::c_int = socket(
        2 as libc::c_int,
        SOCK_STREAM as libc::c_int | SOCK_CLOEXEC as libc::c_int | SOCK_NONBLOCK as libc::c_int,
        0 as libc::c_int,
    );
    if fd >= 0 as libc::c_int {
        let mut flags: libc::c_int = fcntl(fd, 3 as libc::c_int, 0 as libc::c_int);
        use_sock_nonblock =
            (-(1 as libc::c_int) != flags && flags & 0o4000 as libc::c_int != 0) as libc::c_int;
        use_sock_cloexec = 1 as libc::c_int;
        close(fd);
    }
}
#[no_mangle]
pub unsafe extern "C" fn fdevent_setfd_cloexec(mut fd: libc::c_int) {
    if fd < 0 as libc::c_int {
        return;
    }
    if !(-(1 as libc::c_int) != fcntl(fd, 2 as libc::c_int, 1 as libc::c_int)) {
        ck_assert_failed(
            b"/home/kkysen/work/rust/lighttpd/src/fdevent.c\0" as *const u8 as *const libc::c_char,
            60 as libc::c_int as libc::c_uint,
            b"-1 != fcntl(fd, 2, 1)\0" as *const u8 as *const libc::c_char,
        );
    }
}
#[no_mangle]
pub unsafe extern "C" fn fdevent_clrfd_cloexec(mut fd: libc::c_int) {
    if fd >= 0 as libc::c_int {
        if !(-(1 as libc::c_int) != fcntl(fd, 2 as libc::c_int, 0 as libc::c_int)) {
            ck_assert_failed(
                b"/home/kkysen/work/rust/lighttpd/src/fdevent.c\0" as *const u8
                    as *const libc::c_char,
                68 as libc::c_int as libc::c_uint,
                b"-1 != fcntl(fd, 2, 0)\0" as *const u8 as *const libc::c_char,
            );
        }
    }
}
#[no_mangle]
pub unsafe extern "C" fn fdevent_fcntl_set_nb(mut fd: libc::c_int) -> libc::c_int {
    return fcntl(
        fd,
        4 as libc::c_int,
        0o4000 as libc::c_int | 0o2 as libc::c_int,
    );
}
#[no_mangle]
pub unsafe extern "C" fn fdevent_fcntl_set_nb_cloexec(mut fd: libc::c_int) -> libc::c_int {
    fdevent_setfd_cloexec(fd);
    return fdevent_fcntl_set_nb(fd);
}
#[no_mangle]
pub unsafe extern "C" fn fdevent_fcntl_set_nb_cloexec_sock(mut fd: libc::c_int) -> libc::c_int {
    if use_sock_cloexec != 0 && use_sock_nonblock != 0 {
        return 0 as libc::c_int;
    }
    return fdevent_fcntl_set_nb_cloexec(fd);
}
#[no_mangle]
pub unsafe extern "C" fn fdevent_socket_cloexec(
    mut domain: libc::c_int,
    mut type_0: libc::c_int,
    mut protocol: libc::c_int,
) -> libc::c_int {
    let mut fd: libc::c_int = 0;
    if use_sock_cloexec != 0 {
        return socket(domain, type_0 | SOCK_CLOEXEC as libc::c_int, protocol);
    }
    fd = socket(domain, type_0, protocol);
    if -(1 as libc::c_int) != fd {
        if !(-(1 as libc::c_int) != fcntl(fd, 2 as libc::c_int, 1 as libc::c_int)) {
            ck_assert_failed(
                b"/home/kkysen/work/rust/lighttpd/src/fdevent.c\0" as *const u8
                    as *const libc::c_char,
                104 as libc::c_int as libc::c_uint,
                b"-1 != fcntl(fd, 2, 1)\0" as *const u8 as *const libc::c_char,
            );
        }
    }
    return fd;
}
#[no_mangle]
pub unsafe extern "C" fn fdevent_socket_nb_cloexec(
    mut domain: libc::c_int,
    mut type_0: libc::c_int,
    mut protocol: libc::c_int,
) -> libc::c_int {
    let mut fd: libc::c_int = 0;
    if use_sock_cloexec != 0 && use_sock_nonblock != 0 {
        return socket(
            domain,
            type_0 | SOCK_CLOEXEC as libc::c_int | SOCK_NONBLOCK as libc::c_int,
            protocol,
        );
    }
    fd = socket(domain, type_0, protocol);
    if -(1 as libc::c_int) != fd {
        if !(-(1 as libc::c_int) != fcntl(fd, 2 as libc::c_int, 1 as libc::c_int)) {
            ck_assert_failed(
                b"/home/kkysen/work/rust/lighttpd/src/fdevent.c\0" as *const u8
                    as *const libc::c_char,
                128 as libc::c_int as libc::c_uint,
                b"-1 != fcntl(fd, 2, 1)\0" as *const u8 as *const libc::c_char,
            );
        }
        if !(-(1 as libc::c_int)
            != fcntl(
                fd,
                4 as libc::c_int,
                0o4000 as libc::c_int | 0o2 as libc::c_int,
            ))
        {
            ck_assert_failed(
                b"/home/kkysen/work/rust/lighttpd/src/fdevent.c\0" as *const u8
                    as *const libc::c_char,
                131 as libc::c_int as libc::c_uint,
                b"-1 != fcntl(fd, 4, 04000 | 02)\0" as *const u8 as *const libc::c_char,
            );
        }
    }
    return fd;
}
#[no_mangle]
pub unsafe extern "C" fn fdevent_dup_cloexec(mut fd: libc::c_int) -> libc::c_int {
    return fcntl(fd, 1030 as libc::c_int, 3 as libc::c_int);
}
#[no_mangle]
pub unsafe extern "C" fn fdevent_open_cloexec(
    mut pathname: *const libc::c_char,
    mut symlinks: libc::c_int,
    mut flags: libc::c_int,
    mut mode: mode_t,
) -> libc::c_int {
    if symlinks == 0 {
        flags |= 0o400000 as libc::c_int;
    }
    return open(
        pathname,
        flags
            | 0o2000000 as libc::c_int
            | (0 as libc::c_int | 0 as libc::c_int | 0o400 as libc::c_int | 0o4000 as libc::c_int),
        mode,
    );
}
#[no_mangle]
pub unsafe extern "C" fn fdevent_open_devnull() -> libc::c_int {
    return fdevent_open_cloexec(
        b"/dev/null\0" as *const u8 as *const libc::c_char,
        0 as libc::c_int,
        0o2 as libc::c_int,
        0 as libc::c_int as mode_t,
    );
}
#[no_mangle]
pub unsafe extern "C" fn fdevent_open_dirname(
    mut path: *mut libc::c_char,
    mut symlinks: libc::c_int,
) -> libc::c_int {
    let c: *mut libc::c_char = strrchr(path, '/' as i32);
    let dname: *const libc::c_char = if !c.is_null() {
        if c == path {
            b"/\0" as *const u8 as *const libc::c_char
        } else {
            path as *const libc::c_char
        }
    } else {
        b".\0" as *const u8 as *const libc::c_char
    };
    let mut dfd: libc::c_int = 0;
    let mut flags: libc::c_int = 0 as libc::c_int;
    flags |= 0o200000 as libc::c_int;
    if !c.is_null() {
        *c = '\0' as i32 as libc::c_char;
    }
    dfd = fdevent_open_cloexec(dname, symlinks, flags, 0 as libc::c_int as mode_t);
    if !c.is_null() {
        *c = '/' as i32 as libc::c_char;
    }
    return dfd;
}
#[no_mangle]
pub unsafe extern "C" fn fdevent_pipe_cloexec(
    fds: *mut libc::c_int,
    bufsz_hint: libc::c_uint,
) -> libc::c_int {
    if 0 as libc::c_int != pipe2(fds, 0o2000000 as libc::c_int) {
        if 0 as libc::c_int != pipe(fds)
            || 0 as libc::c_int
                != fcntl(
                    *fds.offset(0 as libc::c_int as isize),
                    2 as libc::c_int,
                    1 as libc::c_int,
                )
            || 0 as libc::c_int
                != fcntl(
                    *fds.offset(1 as libc::c_int as isize),
                    2 as libc::c_int,
                    1 as libc::c_int,
                )
        {
            return -(1 as libc::c_int);
        }
    }
    if bufsz_hint > 65536 as libc::c_int as libc::c_uint {
        0 as libc::c_int
            != fcntl(
                *fds.offset(1 as libc::c_int as isize),
                1031 as libc::c_int,
                bufsz_hint,
            );
    }
    return 0 as libc::c_int;
}
#[no_mangle]
pub unsafe extern "C" fn fdevent_mkostemp(
    mut path: *mut libc::c_char,
    mut flags: libc::c_int,
) -> libc::c_int {
    return mkostemp(path, 0o2000000 as libc::c_int | flags);
}
#[no_mangle]
pub unsafe extern "C" fn fdevent_accept_listenfd(
    mut listenfd: libc::c_int,
    mut addr: *mut sockaddr,
    mut addrlen: *mut size_t,
) -> libc::c_int {
    let mut fd: libc::c_int = 0;
    let mut len: socklen_t = *addrlen as socklen_t;
    let mut sock_cloexec: libc::c_int = use_sock_cloexec;
    if sock_cloexec != 0 {
        fd = accept4(
            listenfd,
            __SOCKADDR_ARG { __sockaddr__: addr },
            &mut len,
            SOCK_CLOEXEC as libc::c_int | SOCK_NONBLOCK as libc::c_int,
        );
        if fd >= 0 as libc::c_int {
            if use_sock_nonblock == 0 {
                if 0 as libc::c_int != fdevent_fcntl_set_nb(fd) {
                    close(fd);
                    fd = -(1 as libc::c_int);
                }
            }
        } else {
            match *__errno_location() {
                38 | 95 | 1 => {
                    fd = accept(listenfd, __SOCKADDR_ARG { __sockaddr__: addr }, &mut len);
                    sock_cloexec = 0 as libc::c_int;
                }
                _ => {}
            }
        }
    } else {
        fd = accept(listenfd, __SOCKADDR_ARG { __sockaddr__: addr }, &mut len);
    }
    if fd >= 0 as libc::c_int {
        *addrlen = len as size_t;
        if sock_cloexec == 0 && 0 as libc::c_int != fdevent_fcntl_set_nb_cloexec(fd) {
            close(fd);
            fd = -(1 as libc::c_int);
        }
    }
    return fd;
}
#[no_mangle]
pub unsafe extern "C" fn fdevent_environ() -> *mut *mut libc::c_char {
    return environ;
}
unsafe extern "C" fn fdevent_dup2_close_clrfd_cloexec(
    mut oldfd: libc::c_int,
    mut newfd: libc::c_int,
) -> libc::c_int {
    if oldfd >= 0 as libc::c_int {
        if oldfd != newfd {
            if !(oldfd > 2 as libc::c_int) {
                ck_assert_failed(
                    b"/home/kkysen/work/rust/lighttpd/src/fdevent.c\0" as *const u8
                        as *const libc::c_char,
                    348 as libc::c_int as libc::c_uint,
                    b"oldfd > 2\0" as *const u8 as *const libc::c_char,
                );
            }
            if newfd != dup2(oldfd, newfd) {
                return -(1 as libc::c_int);
            }
        } else {
            fdevent_clrfd_cloexec(newfd);
        }
    }
    return newfd;
}
#[no_mangle]
pub unsafe extern "C" fn fdevent_set_stdin_stdout_stderr(
    mut fdin: libc::c_int,
    mut fdout: libc::c_int,
    mut fderr: libc::c_int,
) -> libc::c_int {
    if 0 as libc::c_int != fdevent_dup2_close_clrfd_cloexec(fdin, 0 as libc::c_int) {
        return -(1 as libc::c_int);
    }
    if 1 as libc::c_int != fdevent_dup2_close_clrfd_cloexec(fdout, 1 as libc::c_int) {
        return -(1 as libc::c_int);
    }
    if 2 as libc::c_int != fdevent_dup2_close_clrfd_cloexec(fderr, 2 as libc::c_int) {
        return -(1 as libc::c_int);
    }
    return 0 as libc::c_int;
}
#[no_mangle]
pub unsafe extern "C" fn fdevent_rename(
    mut oldpath: *const libc::c_char,
    mut newpath: *const libc::c_char,
) -> libc::c_int {
    return rename(oldpath, newpath);
}
#[no_mangle]
pub unsafe extern "C" fn fdevent_fork_execve(
    mut name: *const libc::c_char,
    mut argv: *mut *mut libc::c_char,
    mut envp: *mut *mut libc::c_char,
    mut fdin: libc::c_int,
    mut fdout: libc::c_int,
    mut fderr: libc::c_int,
    mut dfd: libc::c_int,
) -> pid_t {
    let mut pid: pid_t = fork();
    if 0 as libc::c_int != pid {
        return pid;
    }
    if -(1 as libc::c_int) != dfd {
        if 0 as libc::c_int != fchdir(dfd) {
            _exit(*__errno_location());
        }
        close(dfd);
    }
    if 0 as libc::c_int != fdevent_set_stdin_stdout_stderr(fdin, fdout, fderr) {
        _exit(*__errno_location());
    }
    signal(22 as libc::c_int, None);
    signal(21 as libc::c_int, None);
    signal(20 as libc::c_int, None);
    signal(13 as libc::c_int, None);
    execve(
        name,
        argv as *const *mut libc::c_char,
        (if !envp.is_null() { envp } else { environ }) as *const *mut libc::c_char,
    );
    let mut errnum: libc::c_int = *__errno_location();
    let mut argnum: libc::c_int = if 0 as libc::c_int
        == strcmp(
            *argv.offset(0 as libc::c_int as isize),
            b"/bin/sh\0" as *const u8 as *const libc::c_char,
        )
        && !(*argv.offset(1 as libc::c_int as isize)).is_null()
        && 0 as libc::c_int
            == strcmp(
                *argv.offset(1 as libc::c_int as isize),
                b"-c\0" as *const u8 as *const libc::c_char,
            ) {
        2 as libc::c_int
    } else {
        0 as libc::c_int
    };
    perror(*argv.offset(argnum as isize));
    _exit(errnum);
}
#[no_mangle]
pub unsafe extern "C" fn fdevent_waitpid(
    mut pid: pid_t,
    status: *mut libc::c_int,
    mut nb: libc::c_int,
) -> libc::c_int {
    let flags: libc::c_int = if nb != 0 {
        1 as libc::c_int
    } else {
        0 as libc::c_int
    };
    let mut rv: pid_t = 0;
    loop {
        rv = waitpid(pid, status, flags);
        if !(-(1 as libc::c_int) == rv && *__errno_location() == 4 as libc::c_int) {
            break;
        }
    }
    return rv;
}
#[no_mangle]
pub unsafe extern "C" fn fdevent_waitpid_intr(
    mut pid: pid_t,
    status: *mut libc::c_int,
) -> libc::c_int {
    return waitpid(pid, status, 0 as libc::c_int);
}
#[no_mangle]
pub unsafe extern "C" fn fdevent_socket_read_discard(
    mut fd: libc::c_int,
    mut buf: *mut libc::c_char,
    mut sz: size_t,
    mut family: libc::c_int,
    mut so_type: libc::c_int,
) -> ssize_t {
    if (family == 2 as libc::c_int || family == 10 as libc::c_int)
        && so_type == SOCK_STREAM as libc::c_int
    {
        let mut len: ssize_t = recv(
            fd,
            buf as *mut libc::c_void,
            sz,
            MSG_TRUNC as libc::c_int | MSG_DONTWAIT as libc::c_int | MSG_NOSIGNAL as libc::c_int,
        );
        if len >= 0 as libc::c_int as libc::c_long || *__errno_location() != 22 as libc::c_int {
            return len;
        }
    }
    return read(fd, buf as *mut libc::c_void, sz);
}
#[no_mangle]
pub unsafe extern "C" fn fdevent_ioctl_fionread(
    mut fd: libc::c_int,
    mut fdfmt: libc::c_int,
    mut toread: *mut libc::c_int,
) -> libc::c_int {
    return ioctl(fd, 0x541b as libc::c_int as libc::c_ulong, toread);
}
#[no_mangle]
pub unsafe extern "C" fn fdevent_connect_status(mut fd: libc::c_int) -> libc::c_int {
    let mut opt: libc::c_int = 0;
    let mut len: socklen_t = ::core::mem::size_of::<libc::c_int>() as libc::c_ulong as socklen_t;
    return if 0 as libc::c_int
        == getsockopt(
            fd,
            1 as libc::c_int,
            4 as libc::c_int,
            &mut opt as *mut libc::c_int as *mut libc::c_void,
            &mut len,
        ) {
        opt
    } else {
        *__errno_location()
    };
}
#[no_mangle]
pub unsafe extern "C" fn fdevent_is_tcp_half_closed(mut fd: libc::c_int) -> libc::c_int {
    let mut tcpi: tcp_info = tcp_info {
        tcpi_state: 0,
        tcpi_ca_state: 0,
        tcpi_retransmits: 0,
        tcpi_probes: 0,
        tcpi_backoff: 0,
        tcpi_options: 0,
        tcpi_snd_wscale_tcpi_rcv_wscale: [0; 1],
        c2rust_padding: [0; 1],
        tcpi_rto: 0,
        tcpi_ato: 0,
        tcpi_snd_mss: 0,
        tcpi_rcv_mss: 0,
        tcpi_unacked: 0,
        tcpi_sacked: 0,
        tcpi_lost: 0,
        tcpi_retrans: 0,
        tcpi_fackets: 0,
        tcpi_last_data_sent: 0,
        tcpi_last_ack_sent: 0,
        tcpi_last_data_recv: 0,
        tcpi_last_ack_recv: 0,
        tcpi_pmtu: 0,
        tcpi_rcv_ssthresh: 0,
        tcpi_rtt: 0,
        tcpi_rttvar: 0,
        tcpi_snd_ssthresh: 0,
        tcpi_snd_cwnd: 0,
        tcpi_advmss: 0,
        tcpi_reordering: 0,
        tcpi_rcv_rtt: 0,
        tcpi_rcv_space: 0,
        tcpi_total_retrans: 0,
    };
    let mut tlen: socklen_t = ::core::mem::size_of::<tcp_info>() as libc::c_ulong as socklen_t;
    return (0 as libc::c_int
        == getsockopt(
            fd,
            6 as libc::c_int,
            11 as libc::c_int,
            &mut tcpi as *mut tcp_info as *mut libc::c_void,
            &mut tlen,
        )
        && tcpi.tcpi_state as libc::c_int == TCP_CLOSE_WAIT as libc::c_int)
        as libc::c_int;
}
#[no_mangle]
pub unsafe extern "C" fn fdevent_set_tcp_nodelay(fd: libc::c_int, opt: libc::c_int) -> libc::c_int {
    return setsockopt(
        fd,
        IPPROTO_TCP as libc::c_int,
        1 as libc::c_int,
        &opt as *const libc::c_int as *const libc::c_void,
        ::core::mem::size_of::<libc::c_int>() as libc::c_ulong as socklen_t,
    );
}
#[no_mangle]
pub unsafe extern "C" fn fdevent_set_so_reuseaddr(
    fd: libc::c_int,
    opt: libc::c_int,
) -> libc::c_int {
    return setsockopt(
        fd,
        1 as libc::c_int,
        2 as libc::c_int,
        &opt as *const libc::c_int as *const libc::c_void,
        ::core::mem::size_of::<libc::c_int>() as libc::c_ulong as socklen_t,
    );
}
#[no_mangle]
#[cold]
pub unsafe extern "C" fn fdevent_load_file(
    fn_0: *const libc::c_char,
    mut lim: *mut off_t,
    mut errh: *mut log_error_st,
    mut malloc_fn: Option<unsafe extern "C" fn(size_t) -> *mut libc::c_void>,
    mut free_fn: Option<unsafe extern "C" fn(*mut libc::c_void) -> ()>,
) -> *mut libc::c_char {
    let mut fd: libc::c_int = 0;
    let mut sz: off_t = 0 as libc::c_int as off_t;
    let mut buf: *mut libc::c_char = 0 as *mut libc::c_char;
    let mut current_block_12: u64;
    fd = fdevent_open_cloexec(
        fn_0,
        1 as libc::c_int,
        0 as libc::c_int,
        0 as libc::c_int as mode_t,
    );
    if !(fd < 0 as libc::c_int) {
        let mut st: stat = stat {
            st_dev: 0,
            st_ino: 0,
            st_nlink: 0,
            st_mode: 0,
            st_uid: 0,
            st_gid: 0,
            __pad0: 0,
            st_rdev: 0,
            st_size: 0,
            st_blksize: 0,
            st_blocks: 0,
            st_atim: timespec {
                tv_sec: 0,
                tv_nsec: 0,
            },
            st_mtim: timespec {
                tv_sec: 0,
                tv_nsec: 0,
            },
            st_ctim: timespec {
                tv_sec: 0,
                tv_nsec: 0,
            },
            __glibc_reserved: [0; 3],
        };
        if !(0 as libc::c_int != fstat(fd, &mut st)) {
            if ::core::mem::size_of::<off_t>() as libc::c_ulong
                > ::core::mem::size_of::<size_t>() as libc::c_ulong
                && st.st_size >= !(0 as libc::c_uint as size_t) as off_t
                || *lim != 0 as libc::c_int as libc::c_long && st.st_size >= *lim
            {
                *__errno_location() = 75 as libc::c_int;
            } else {
                sz = st.st_size;
                buf = malloc_fn.expect("non-null function pointer")(
                    (sz as size_t).wrapping_add(1 as libc::c_int as libc::c_ulong),
                ) as *mut libc::c_char;
                if !buf.is_null() {
                    if sz != 0 {
                        let mut rd: ssize_t = 0 as libc::c_int as ssize_t;
                        let mut off: off_t = 0 as libc::c_int as off_t;
                        loop {
                            rd = read(
                                fd,
                                buf.offset(off as isize) as *mut libc::c_void,
                                (sz - off) as size_t,
                            );
                            if !(if rd > 0 as libc::c_int as libc::c_long {
                                off += rd;
                                (off != sz) as libc::c_int
                            } else {
                                (rd < 0 as libc::c_int as libc::c_long
                                    && *__errno_location() == 4 as libc::c_int)
                                    as libc::c_int
                            } != 0)
                            {
                                break;
                            }
                        }
                        if off != sz {
                            if rd >= 0 as libc::c_int as libc::c_long {
                                *__errno_location() = 5 as libc::c_int;
                            }
                            current_block_12 = 7175849428784450219;
                        } else {
                            current_block_12 = 5143058163439228106;
                        }
                    } else {
                        current_block_12 = 5143058163439228106;
                    }
                    match current_block_12 {
                        7175849428784450219 => {}
                        _ => {
                            *buf.offset(sz as isize) = '\0' as i32 as libc::c_char;
                            *lim = sz;
                            close(fd);
                            return buf;
                        }
                    }
                }
            }
        }
    }
    let mut errnum: libc::c_int = *__errno_location();
    if !errh.is_null() {
        log_perror(
            errh,
            b"/home/kkysen/work/rust/lighttpd/src/fdevent.c\0" as *const u8 as *const libc::c_char,
            623 as libc::c_int as libc::c_uint,
            b"%s() %s\0" as *const u8 as *const libc::c_char,
            (*::core::mem::transmute::<&[u8; 18], &[libc::c_char; 18]>(b"fdevent_load_file\0"))
                .as_ptr(),
            fn_0,
        );
    }
    if fd >= 0 as libc::c_int {
        close(fd);
    }
    if !buf.is_null() {
        ck_memzero(buf as *mut libc::c_void, sz as size_t);
        free_fn.expect("non-null function pointer")(buf as *mut libc::c_void);
    }
    *lim = 0 as libc::c_int as off_t;
    *__errno_location() = errnum;
    return 0 as *mut libc::c_char;
}
#[no_mangle]
pub unsafe extern "C" fn fdevent_load_file_bytes(
    buf: *mut libc::c_char,
    sz: off_t,
    mut off: off_t,
    fn_0: *const libc::c_char,
    mut errh: *mut log_error_st,
) -> libc::c_int {
    let mut fd: libc::c_int = 0;
    fd = fdevent_open_cloexec(
        fn_0,
        1 as libc::c_int,
        0 as libc::c_int,
        0 as libc::c_int as mode_t,
    );
    if !(fd < 0 as libc::c_int) {
        if !(0 as libc::c_int as libc::c_long != off
            && -(1 as libc::c_int) as off_t == lseek(fd, off, 0 as libc::c_int))
        {
            off = 0 as libc::c_int as off_t;
            let mut rd: ssize_t = 0 as libc::c_int as ssize_t;
            loop {
                rd = read(
                    fd,
                    buf.offset(off as isize) as *mut libc::c_void,
                    (sz - off) as size_t,
                );
                if !(if rd > 0 as libc::c_int as libc::c_long {
                    off += rd;
                    (off != sz) as libc::c_int
                } else {
                    (rd < 0 as libc::c_int as libc::c_long
                        && *__errno_location() == 4 as libc::c_int)
                        as libc::c_int
                } != 0)
                {
                    break;
                }
            }
            if off != sz {
                if rd >= 0 as libc::c_int as libc::c_long {
                    *__errno_location() = 5 as libc::c_int;
                }
            } else {
                close(fd);
                return 0 as libc::c_int;
            }
        }
    }
    let mut errnum: libc::c_int = *__errno_location();
    if !errh.is_null() {
        log_perror(
            errh,
            b"/home/kkysen/work/rust/lighttpd/src/fdevent.c\0" as *const u8 as *const libc::c_char,
            660 as libc::c_int as libc::c_uint,
            b"%s() %s\0" as *const u8 as *const libc::c_char,
            (*::core::mem::transmute::<&[u8; 24], &[libc::c_char; 24]>(
                b"fdevent_load_file_bytes\0",
            ))
            .as_ptr(),
            fn_0,
        );
    }
    if fd >= 0 as libc::c_int {
        close(fd);
    }
    ck_memzero(buf as *mut libc::c_void, sz as size_t);
    *__errno_location() = errnum;
    return -(1 as libc::c_int);
}
unsafe extern "C" fn fdnode_init() -> *mut fdnode {
    let fdn: *mut fdnode = calloc(
        1 as libc::c_int as libc::c_ulong,
        ::core::mem::size_of::<fdnode>() as libc::c_ulong,
    ) as *mut fdnode;
    if fdn.is_null() {
        ck_assert_failed(
            b"/home/kkysen/work/rust/lighttpd/src/fdevent_fdnode.c\0" as *const u8
                as *const libc::c_char,
            17 as libc::c_int as libc::c_uint,
            b"((void*)0) != fdn\0" as *const u8 as *const libc::c_char,
        );
    }
    return fdn;
}
unsafe extern "C" fn fdnode_free(mut fdn: *mut fdnode) {
    free(fdn as *mut libc::c_void);
}
#[no_mangle]
pub unsafe extern "C" fn fdevent_register(
    mut ev: *mut fdevents,
    mut fd: libc::c_int,
    mut handler: fdevent_handler,
    mut ctx: *mut libc::c_void,
) -> *mut fdnode {
    let ref mut fresh184 = *((*ev).fdarray).offset(fd as isize);
    *fresh184 = fdnode_init();
    let mut fdn: *mut fdnode = *fresh184;
    (*fdn).handler = handler;
    (*fdn).fd = fd;
    (*fdn).ctx = ctx;
    (*fdn).events = 0 as libc::c_int;
    (*fdn).fde_ndx = -(1 as libc::c_int);
    return fdn;
}
#[no_mangle]
pub unsafe extern "C" fn fdevent_unregister(mut ev: *mut fdevents, mut fd: libc::c_int) {
    let mut fdn: *mut fdnode = *((*ev).fdarray).offset(fd as isize);
    if fdn as uintptr_t & 0x3 as libc::c_int as libc::c_ulong != 0 {
        return;
    }
    let ref mut fresh185 = *((*ev).fdarray).offset(fd as isize);
    *fresh185 = 0 as *mut fdnode;
    fdnode_free(fdn);
}
#[no_mangle]
pub unsafe extern "C" fn fdevent_sched_close(
    mut ev: *mut fdevents,
    mut fd: libc::c_int,
    mut issock: libc::c_int,
) {
    let mut fdn: *mut fdnode = *((*ev).fdarray).offset(fd as isize);
    if fdn as uintptr_t & 0x3 as libc::c_int as libc::c_ulong != 0 {
        return;
    }
    let ref mut fresh186 = *((*ev).fdarray).offset(fd as isize);
    *fresh186 = (fdn as uintptr_t
        | (if issock != 0 {
            0x1 as libc::c_int
        } else {
            0x2 as libc::c_int
        }) as libc::c_ulong) as *mut fdnode;
    (*fdn).handler =
        ::core::mem::transmute::<*mut libc::c_void, fdevent_handler>(0 as *mut libc::c_void);
    (*fdn).ctx = (*ev).pendclose as *mut libc::c_void;
    (*ev).pendclose = fdn;
}
#[cold]
#[inline(never)]
unsafe extern "C" fn fdevent_fdnode_event_unsetter_retry(
    mut ev: *mut fdevents,
    mut fdn: *mut fdnode,
) -> libc::c_int {
    loop {
        match *__errno_location() {
            11 | 4 => {}
            _ => {
                log_perror(
                    (*ev).errh,
                    b"/home/kkysen/work/rust/lighttpd/src/fdevent_fdnode.c\0" as *const u8
                        as *const libc::c_char,
                    81 as libc::c_int as libc::c_uint,
                    b"fdevent event_del failed on fd %d\0" as *const u8 as *const libc::c_char,
                    (*fdn).fd,
                );
                return 0 as libc::c_int;
            }
        }
        if !(0 as libc::c_int != ((*ev).event_del).expect("non-null function pointer")(ev, fdn)) {
            break;
        }
    }
    return 1 as libc::c_int;
}
unsafe extern "C" fn fdevent_fdnode_event_unsetter(mut ev: *mut fdevents, mut fdn: *mut fdnode) {
    if -(1 as libc::c_int) == (*fdn).fde_ndx {
        return;
    }
    if 0 as libc::c_int != ((*ev).event_del).expect("non-null function pointer")(ev, fdn) {
        fdevent_fdnode_event_unsetter_retry(ev, fdn);
    }
    (*fdn).fde_ndx = -(1 as libc::c_int);
    (*fdn).events = 0 as libc::c_int;
}
#[cold]
#[inline(never)]
unsafe extern "C" fn fdevent_fdnode_event_setter_retry(
    mut ev: *mut fdevents,
    mut fdn: *mut fdnode,
    mut events: libc::c_int,
) -> libc::c_int {
    loop {
        match *__errno_location() {
            11 | 4 => {}
            _ => {
                log_perror(
                    (*ev).errh,
                    b"/home/kkysen/work/rust/lighttpd/src/fdevent_fdnode.c\0" as *const u8
                        as *const libc::c_char,
                    118 as libc::c_int as libc::c_uint,
                    b"fdevent event_set failed on fd %d\0" as *const u8 as *const libc::c_char,
                    (*fdn).fd,
                );
                return 0 as libc::c_int;
            }
        }
        if !(0 as libc::c_int
            != ((*ev).event_set).expect("non-null function pointer")(ev, fdn, events))
        {
            break;
        }
    }
    return 1 as libc::c_int;
}
unsafe extern "C" fn fdevent_fdnode_event_setter(
    mut ev: *mut fdevents,
    mut fdn: *mut fdnode,
    mut events: libc::c_int,
) {
    if (*fdn).events == events {
        return;
    }
    if 0 as libc::c_int == ((*ev).event_set).expect("non-null function pointer")(ev, fdn, events)
        || fdevent_fdnode_event_setter_retry(ev, fdn, events) != 0
    {
        (*fdn).events = events;
    }
}
#[no_mangle]
pub unsafe extern "C" fn fdevent_fdnode_event_del(mut ev: *mut fdevents, mut fdn: *mut fdnode) {
    if !fdn.is_null() {
        fdevent_fdnode_event_unsetter(ev, fdn);
    }
}
#[no_mangle]
pub unsafe extern "C" fn fdevent_fdnode_event_set(
    mut ev: *mut fdevents,
    mut fdn: *mut fdnode,
    mut events: libc::c_int,
) {
    if !fdn.is_null() {
        fdevent_fdnode_event_setter(ev, fdn, events);
    }
}
#[no_mangle]
pub unsafe extern "C" fn fdevent_fdnode_event_add(
    mut ev: *mut fdevents,
    mut fdn: *mut fdnode,
    mut event: libc::c_int,
) {
    if !fdn.is_null() {
        fdevent_fdnode_event_setter(ev, fdn, (*fdn).events | event);
    }
}
#[no_mangle]
pub unsafe extern "C" fn fdevent_fdnode_event_clr(
    mut ev: *mut fdevents,
    mut fdn: *mut fdnode,
    mut event: libc::c_int,
) {
    if !fdn.is_null() {
        fdevent_fdnode_event_setter(ev, fdn, (*fdn).events & !event);
    }
}
#[inline(never)]
unsafe extern "C" fn gw_status_get_counter(
    mut host: *mut gw_host,
    mut proc_0: *mut gw_proc,
    mut tag: *const libc::c_char,
    mut tlen: size_t,
) -> *mut libc::c_int {
    let mut label: [libc::c_char; 288] = [0; 288];
    let mut llen: size_t = (::core::mem::size_of::<[libc::c_char; 12]>() as libc::c_ulong)
        .wrapping_sub(1 as libc::c_int as libc::c_ulong);
    let mut len: size_t = 0;
    memcpy(
        label.as_mut_ptr() as *mut libc::c_void,
        b"gw.backend.\0" as *const u8 as *const libc::c_char as *const libc::c_void,
        llen,
    );
    len = buffer_clen((*host).id) as size_t;
    if len != 0 {
        if !(len
            < (::core::mem::size_of::<[libc::c_char; 288]>() as libc::c_ulong).wrapping_sub(llen))
        {
            ck_assert_failed(
                b"/home/kkysen/work/rust/lighttpd/src/gw_backend.c\0" as *const u8
                    as *const libc::c_char,
                56 as libc::c_int as libc::c_uint,
                b"len < sizeof(label) - llen\0" as *const u8 as *const libc::c_char,
            );
        }
        memcpy(
            label.as_mut_ptr().offset(llen as isize) as *mut libc::c_void,
            (*(*host).id).ptr as *const libc::c_void,
            len,
        );
        llen = (llen as libc::c_ulong).wrapping_add(len) as size_t as size_t;
    }
    if !proc_0.is_null() {
        if !(llen
            < (::core::mem::size_of::<[libc::c_char; 288]>() as libc::c_ulong).wrapping_sub(
                (2 as libc::c_int as libc::c_ulong)
                    .wrapping_add(
                        (8 as libc::c_int as libc::c_ulong)
                            .wrapping_mul(::core::mem::size_of::<intmax_t>() as libc::c_ulong)
                            .wrapping_mul(31 as libc::c_int as libc::c_ulong)
                            .wrapping_add(99 as libc::c_int as libc::c_ulong)
                            .wrapping_div(100 as libc::c_int as libc::c_ulong),
                    )
                    .wrapping_add(1 as libc::c_int as libc::c_ulong),
            ))
        {
            ck_assert_failed(
                b"/home/kkysen/work/rust/lighttpd/src/gw_backend.c\0" as *const u8
                    as *const libc::c_char,
                62 as libc::c_int as libc::c_uint,
                b"llen < sizeof(label) - ((2 + (8 * sizeof(intmax_t) * 31 + 99) / 100) + 1)\0"
                    as *const u8 as *const libc::c_char,
            );
        }
        let fresh187 = llen;
        llen = llen.wrapping_add(1);
        label[fresh187 as usize] = '.' as i32 as libc::c_char;
        len = li_utostrn(
            label.as_mut_ptr().offset(llen as isize),
            (2 as libc::c_int as libc::c_ulong).wrapping_add(
                (8 as libc::c_int as libc::c_ulong)
                    .wrapping_mul(::core::mem::size_of::<intmax_t>() as libc::c_ulong)
                    .wrapping_mul(31 as libc::c_int as libc::c_ulong)
                    .wrapping_add(99 as libc::c_int as libc::c_ulong)
                    .wrapping_div(100 as libc::c_int as libc::c_ulong),
            ),
            (*proc_0).id as uintmax_t,
        );
        llen = (llen as libc::c_ulong).wrapping_add(len) as size_t as size_t;
    }
    if !(tlen < (::core::mem::size_of::<[libc::c_char; 288]>() as libc::c_ulong).wrapping_sub(llen))
    {
        ck_assert_failed(
            b"/home/kkysen/work/rust/lighttpd/src/gw_backend.c\0" as *const u8
                as *const libc::c_char,
            68 as libc::c_int as libc::c_uint,
            b"tlen < sizeof(label) - llen\0" as *const u8 as *const libc::c_char,
        );
    }
    memcpy(
        label.as_mut_ptr().offset(llen as isize) as *mut libc::c_void,
        tag as *const libc::c_void,
        tlen,
    );
    llen = (llen as libc::c_ulong).wrapping_add(tlen) as size_t as size_t;
    label[llen as usize] = '\0' as i32 as libc::c_char;
    return status_counter_get_counter(label.as_mut_ptr(), llen);
}
unsafe extern "C" fn gw_proc_tag_inc(
    mut host: *mut gw_host,
    mut proc_0: *mut gw_proc,
    mut tag: *const libc::c_char,
    mut len: size_t,
) {
    let ref mut fresh188 = *gw_status_get_counter(host, proc_0, tag, len);
    *fresh188 += 1;
}
unsafe extern "C" fn gw_proc_connected_inc(mut host: *mut gw_host, mut proc_0: *mut gw_proc) {
    *(*proc_0).stats_connected += 1;
}
unsafe extern "C" fn gw_proc_load_inc(mut host: *mut gw_host, mut proc_0: *mut gw_proc) {
    (*proc_0).load = ((*proc_0).load).wrapping_add(1);
    *(*proc_0).stats_load = (*proc_0).load as libc::c_int;
    *(*host).stats_global_active += 1;
}
unsafe extern "C" fn gw_proc_load_dec(mut host: *mut gw_host, mut proc_0: *mut gw_proc) {
    (*proc_0).load = ((*proc_0).load).wrapping_sub(1);
    *(*proc_0).stats_load = (*proc_0).load as libc::c_int;
    *(*host).stats_global_active -= 1;
}
unsafe extern "C" fn gw_host_assign(mut host: *mut gw_host) {
    (*host).load += 1;
    *(*host).stats_load = (*host).load;
}
unsafe extern "C" fn gw_host_reset(mut host: *mut gw_host) {
    (*host).load -= 1;
    *(*host).stats_load = (*host).load;
}
unsafe extern "C" fn gw_status_init_proc(mut host: *mut gw_host, mut proc_0: *mut gw_proc) {
    *gw_status_get_counter(
        host,
        proc_0,
        b".disabled\0" as *const u8 as *const libc::c_char,
        (::core::mem::size_of::<[libc::c_char; 10]>() as libc::c_ulong as uint32_t)
            .wrapping_sub(1 as libc::c_int as libc::c_uint) as size_t,
    ) = 0 as libc::c_int;
    *gw_status_get_counter(
        host,
        proc_0,
        b".died\0" as *const u8 as *const libc::c_char,
        (::core::mem::size_of::<[libc::c_char; 6]>() as libc::c_ulong as uint32_t)
            .wrapping_sub(1 as libc::c_int as libc::c_uint) as size_t,
    ) = 0 as libc::c_int;
    *gw_status_get_counter(
        host,
        proc_0,
        b".overloaded\0" as *const u8 as *const libc::c_char,
        (::core::mem::size_of::<[libc::c_char; 12]>() as libc::c_ulong as uint32_t)
            .wrapping_sub(1 as libc::c_int as libc::c_uint) as size_t,
    ) = 0 as libc::c_int;
    (*proc_0).stats_connected = gw_status_get_counter(
        host,
        proc_0,
        b".connected\0" as *const u8 as *const libc::c_char,
        (::core::mem::size_of::<[libc::c_char; 11]>() as libc::c_ulong as uint32_t)
            .wrapping_sub(1 as libc::c_int as libc::c_uint) as size_t,
    );
    *(*proc_0).stats_connected = 0 as libc::c_int;
    (*proc_0).stats_load = gw_status_get_counter(
        host,
        proc_0,
        b".load\0" as *const u8 as *const libc::c_char,
        (::core::mem::size_of::<[libc::c_char; 6]>() as libc::c_ulong as uint32_t)
            .wrapping_sub(1 as libc::c_int as libc::c_uint) as size_t,
    );
    *(*proc_0).stats_load = 0 as libc::c_int;
}
unsafe extern "C" fn gw_status_init_host(mut host: *mut gw_host) {
    (*host).stats_load = gw_status_get_counter(
        host,
        0 as *mut gw_proc,
        b".load\0" as *const u8 as *const libc::c_char,
        (::core::mem::size_of::<[libc::c_char; 6]>() as libc::c_ulong as uint32_t)
            .wrapping_sub(1 as libc::c_int as libc::c_uint) as size_t,
    );
    *(*host).stats_load = 0 as libc::c_int;
    (*host).stats_global_active = status_counter_get_counter(
        b"gw.active-requests\0" as *const u8 as *const libc::c_char,
        (::core::mem::size_of::<[libc::c_char; 19]>() as libc::c_ulong as uint32_t)
            .wrapping_sub(1 as libc::c_int as libc::c_uint) as size_t,
    );
}
#[cold]
unsafe extern "C" fn gw_proc_set_state(
    mut host: *mut gw_host,
    mut proc_0: *mut gw_proc,
    mut state: libc::c_int,
) {
    if (*proc_0).state as libc::c_int == state {
        return;
    }
    if (*proc_0).state as libc::c_uint == PROC_STATE_RUNNING as libc::c_int as libc::c_uint {
        (*host).active_procs = ((*host).active_procs).wrapping_sub(1);
    } else if state == PROC_STATE_RUNNING as libc::c_int {
        (*host).active_procs = ((*host).active_procs).wrapping_add(1);
    }
    (*proc_0).state = state as C2RustUnnamed_50;
}
#[cold]
#[inline(never)]
unsafe extern "C" fn gw_proc_init_portpath(mut host: *mut gw_host, mut proc_0: *mut gw_proc) {
    if ((*host).unixsocket).is_null() {
        (*proc_0).port =
            ((*host).port as libc::c_uint).wrapping_add((*proc_0).id) as libc::c_ushort;
        return;
    }
    if ((*proc_0).unixsocket).is_null() {
        (*proc_0).unixsocket = buffer_init();
    }
    if ((*host).bin_path).is_null() {
        buffer_copy_buffer((*proc_0).unixsocket, (*host).unixsocket);
    } else {
        buffer_clear((*proc_0).unixsocket);
        buffer_append_str2(
            (*proc_0).unixsocket,
            (*(*host).unixsocket).ptr,
            buffer_clen((*host).unixsocket) as size_t,
            b"-\0" as *const u8 as *const libc::c_char,
            (::core::mem::size_of::<[libc::c_char; 2]>() as libc::c_ulong as uint32_t)
                .wrapping_sub(1 as libc::c_int as libc::c_uint) as size_t,
        );
        buffer_append_int((*proc_0).unixsocket, (*proc_0).id as intmax_t);
    };
}
#[cold]
#[inline(never)]
unsafe extern "C" fn gw_proc_init(mut host: *mut gw_host) -> *mut gw_proc {
    let mut proc_0: *mut gw_proc = calloc(
        1 as libc::c_int as libc::c_ulong,
        ::core::mem::size_of::<gw_proc>() as libc::c_ulong,
    ) as *mut gw_proc;
    if proc_0.is_null() {
        ck_assert_failed(
            b"/home/kkysen/work/rust/lighttpd/src/gw_backend.c\0" as *const u8
                as *const libc::c_char,
            164 as libc::c_int as libc::c_uint,
            b"proc\0" as *const u8 as *const libc::c_char,
        );
    }
    (*proc_0).connection_name = buffer_init();
    (*proc_0).prev = 0 as *mut gw_proc;
    (*proc_0).next = 0 as *mut gw_proc;
    (*proc_0).state = PROC_STATE_DIED;
    let fresh189 = (*host).max_id;
    (*host).max_id = ((*host).max_id).wrapping_add(1);
    (*proc_0).id = fresh189;
    gw_status_init_proc(host, proc_0);
    gw_proc_init_portpath(host, proc_0);
    return proc_0;
}
unsafe extern "C" fn gw_proc_free(mut proc_0: *mut gw_proc) {
    if proc_0.is_null() {
        return;
    }
    gw_proc_free((*proc_0).next);
    buffer_free((*proc_0).unixsocket);
    buffer_free((*proc_0).connection_name);
    free((*proc_0).saddr as *mut libc::c_void);
    free(proc_0 as *mut libc::c_void);
}
unsafe extern "C" fn gw_host_init() -> *mut gw_host {
    let mut f: *mut gw_host = calloc(
        1 as libc::c_int as libc::c_ulong,
        ::core::mem::size_of::<gw_host>() as libc::c_ulong,
    ) as *mut gw_host;
    if f.is_null() {
        ck_assert_failed(
            b"/home/kkysen/work/rust/lighttpd/src/gw_backend.c\0" as *const u8
                as *const libc::c_char,
            196 as libc::c_int as libc::c_uint,
            b"f\0" as *const u8 as *const libc::c_char,
        );
    }
    return f;
}
unsafe extern "C" fn gw_host_free(mut h: *mut gw_host) {
    if h.is_null() {
        return;
    }
    if (*h).refcount != 0 {
        (*h).refcount -= 1;
        return;
    }
    gw_proc_free((*h).first);
    gw_proc_free((*h).unused_procs);
    let mut i: uint32_t = 0 as libc::c_int as uint32_t;
    while i < (*h).args.used {
        free(*((*h).args.ptr).offset(i as isize) as *mut libc::c_void);
        i = i.wrapping_add(1);
    }
    free((*h).args.ptr as *mut libc::c_void);
    free(h as *mut libc::c_void);
}
unsafe extern "C" fn gw_extensions_init() -> *mut gw_exts {
    let mut f: *mut gw_exts = calloc(
        1 as libc::c_int as libc::c_ulong,
        ::core::mem::size_of::<gw_exts>() as libc::c_ulong,
    ) as *mut gw_exts;
    if f.is_null() {
        ck_assert_failed(
            b"/home/kkysen/work/rust/lighttpd/src/gw_backend.c\0" as *const u8
                as *const libc::c_char,
            219 as libc::c_int as libc::c_uint,
            b"f\0" as *const u8 as *const libc::c_char,
        );
    }
    return f;
}
unsafe extern "C" fn gw_extensions_free(mut f: *mut gw_exts) {
    if f.is_null() {
        return;
    }
    let mut i: uint32_t = 0 as libc::c_int as uint32_t;
    while i < (*f).used {
        let mut fe: *mut gw_extension = ((*f).exts).offset(i as isize);
        let mut j: uint32_t = 0 as libc::c_int as uint32_t;
        while j < (*fe).used {
            gw_host_free(*((*fe).hosts).offset(j as isize));
            j = j.wrapping_add(1);
        }
        free((*fe).hosts as *mut libc::c_void);
        i = i.wrapping_add(1);
    }
    free((*f).exts as *mut libc::c_void);
    free(f as *mut libc::c_void);
}
unsafe extern "C" fn gw_extension_insert(
    mut ext: *mut gw_exts,
    mut key: *const buffer,
    mut fh: *mut gw_host,
) -> libc::c_int {
    let mut fe: *mut gw_extension = 0 as *mut gw_extension;
    let mut i: uint32_t = 0 as libc::c_int as uint32_t;
    while i < (*ext).used {
        if buffer_is_equal(key, &(*((*ext).exts).offset(i as isize)).key) != 0 {
            fe = ((*ext).exts).offset(i as isize);
            break;
        } else {
            i = i.wrapping_add(1);
        }
    }
    if fe.is_null() {
        if (*ext).used == (*ext).size {
            (*ext).size = ((*ext).size as libc::c_uint)
                .wrapping_add(8 as libc::c_int as libc::c_uint)
                as uint32_t as uint32_t;
            (*ext).exts = realloc(
                (*ext).exts as *mut libc::c_void,
                ((*ext).size as libc::c_ulong)
                    .wrapping_mul(::core::mem::size_of::<gw_extension>() as libc::c_ulong),
            ) as *mut gw_extension;
            if ((*ext).exts).is_null() {
                ck_assert_failed(
                    b"/home/kkysen/work/rust/lighttpd/src/gw_backend.c\0" as *const u8
                        as *const libc::c_char,
                    249 as libc::c_int as libc::c_uint,
                    b"ext->exts\0" as *const u8 as *const libc::c_char,
                );
            }
            memset(
                ((*ext).exts).offset((*ext).used as isize) as *mut libc::c_void,
                0 as libc::c_int,
                (8 as libc::c_int as libc::c_ulong)
                    .wrapping_mul(::core::mem::size_of::<gw_extension>() as libc::c_ulong),
            );
        }
        let fresh190 = (*ext).used;
        (*ext).used = ((*ext).used).wrapping_add(1);
        fe = ((*ext).exts).offset(fresh190 as isize);
        (*fe).last_used_ndx = -(1 as libc::c_int);
        let mut b: *mut buffer = 0 as *mut buffer;
        let ref mut fresh191 = *(&mut b as *mut *mut buffer as *mut *const buffer);
        *fresh191 = &(*fe).key;
        memcpy(
            b as *mut libc::c_void,
            key as *const libc::c_void,
            ::core::mem::size_of::<buffer>() as libc::c_ulong,
        );
    }
    if (*fe).size == (*fe).used {
        (*fe).size = ((*fe).size as libc::c_uint).wrapping_add(4 as libc::c_int as libc::c_uint)
            as uint32_t as uint32_t;
        (*fe).hosts = realloc(
            (*fe).hosts as *mut libc::c_void,
            ((*fe).size as libc::c_ulong)
                .wrapping_mul(::core::mem::size_of::<*mut gw_host>() as libc::c_ulong),
        ) as *mut *mut gw_host;
        if ((*fe).hosts).is_null() {
            ck_assert_failed(
                b"/home/kkysen/work/rust/lighttpd/src/gw_backend.c\0" as *const u8
                    as *const libc::c_char,
                262 as libc::c_int as libc::c_uint,
                b"fe->hosts\0" as *const u8 as *const libc::c_char,
            );
        }
    }
    let fresh192 = (*fe).used;
    (*fe).used = ((*fe).used).wrapping_add(1);
    let ref mut fresh193 = *((*fe).hosts).offset(fresh192 as isize);
    *fresh193 = fh;
    return 0 as libc::c_int;
}
unsafe extern "C" fn gw_proc_connect_success(
    mut host: *mut gw_host,
    mut proc_0: *mut gw_proc,
    mut debug: libc::c_int,
    r: *mut request_st,
) {
    gw_proc_connected_inc(host, proc_0);
    (*proc_0).last_used = log_monotonic_secs;
    if debug != 0 {
        log_error(
            (*r).conf.errh,
            b"/home/kkysen/work/rust/lighttpd/src/gw_backend.c\0" as *const u8
                as *const libc::c_char,
            274 as libc::c_int as libc::c_uint,
            b"got proc: pid: %d socket: %s load: %d\0" as *const u8 as *const libc::c_char,
            (*proc_0).pid,
            (*(*proc_0).connection_name).ptr,
            (*proc_0).load,
        );
    }
}
#[cold]
unsafe extern "C" fn gw_proc_connect_error(
    r: *mut request_st,
    mut host: *mut gw_host,
    mut proc_0: *mut gw_proc,
    mut pid: pid_t,
    mut errnum: libc::c_int,
    mut debug: libc::c_int,
) {
    let cur_ts: unix_time64_t = log_monotonic_secs;
    let errh: *mut log_error_st = (*r).conf.errh;
    *__errno_location() = errnum;
    log_perror(
        errh,
        b"/home/kkysen/work/rust/lighttpd/src/gw_backend.c\0" as *const u8 as *const libc::c_char,
        285 as libc::c_int as libc::c_uint,
        b"establishing connection failed: socket: %s\0" as *const u8 as *const libc::c_char,
        (*(*proc_0).connection_name).ptr,
    );
    if (*proc_0).is_local == 0 {
        (*proc_0).disabled_until = cur_ts + (*host).disable_time as libc::c_long;
        gw_proc_set_state(host, proc_0, PROC_STATE_OVERLOADED as libc::c_int);
    } else if (*proc_0).pid == pid
        && (*proc_0).state as libc::c_uint == PROC_STATE_RUNNING as libc::c_int as libc::c_uint
    {
        log_error(
            errh,
            b"/home/kkysen/work/rust/lighttpd/src/gw_backend.c\0" as *const u8
                as *const libc::c_char,
            301 as libc::c_int as libc::c_uint,
            b"backend error; we'll disable for %dsecs and send the request to another backend instead:load: %d\0"
                as *const u8 as *const libc::c_char,
            (*host).disable_time as libc::c_int,
            (*host).load,
        );
        if 11 as libc::c_int == errnum {
            log_error(
                errh,
                b"/home/kkysen/work/rust/lighttpd/src/gw_backend.c\0" as *const u8
                    as *const libc::c_char,
                308 as libc::c_int as libc::c_uint,
                b"If this happened on Linux: You have run out of local ports. Check the manual, section Performance how to handle this.\0"
                    as *const u8 as *const libc::c_char,
            );
            if debug != 0 {
                log_error(
                    errh,
                    b"/home/kkysen/work/rust/lighttpd/src/gw_backend.c\0" as *const u8
                        as *const libc::c_char,
                    313 as libc::c_int as libc::c_uint,
                    b"This means that you have more incoming requests than your FastCGI backend can handle in parallel.  It might help to spawn more FastCGI backends or PHP children; if not, decrease server.max-connections.  The load for this FastCGI backend %s is %d\0"
                        as *const u8 as *const libc::c_char,
                    (*(*proc_0).connection_name).ptr,
                    (*proc_0).load,
                );
            }
            (*proc_0).disabled_until = cur_ts + (*host).disable_time as libc::c_long;
            gw_proc_set_state(host, proc_0, PROC_STATE_OVERLOADED as libc::c_int);
        } else {
            (*proc_0).disabled_until = cur_ts + (*host).disable_time as libc::c_long;
            gw_proc_set_state(host, proc_0, PROC_STATE_OVERLOADED as libc::c_int);
        }
    }
    if 11 as libc::c_int == errnum {
        gw_proc_tag_inc(
            host,
            proc_0,
            b".overloaded\0" as *const u8 as *const libc::c_char,
            (::core::mem::size_of::<[libc::c_char; 12]>() as libc::c_ulong as uint32_t)
                .wrapping_sub(1 as libc::c_int as libc::c_uint) as size_t,
        );
    } else {
        gw_proc_tag_inc(
            host,
            proc_0,
            b".died\0" as *const u8 as *const libc::c_char,
            (::core::mem::size_of::<[libc::c_char; 6]>() as libc::c_ulong as uint32_t)
                .wrapping_sub(1 as libc::c_int as libc::c_uint) as size_t,
        );
    };
}
unsafe extern "C" fn gw_proc_release(
    mut host: *mut gw_host,
    mut proc_0: *mut gw_proc,
    mut debug: libc::c_int,
    mut errh: *mut log_error_st,
) {
    gw_proc_load_dec(host, proc_0);
    if debug != 0 {
        log_error(
            errh,
            b"/home/kkysen/work/rust/lighttpd/src/gw_backend.c\0" as *const u8
                as *const libc::c_char,
            349 as libc::c_int as libc::c_uint,
            b"released proc: pid: %d socket: %s load: %u\0" as *const u8 as *const libc::c_char,
            (*proc_0).pid,
            (*(*proc_0).connection_name).ptr,
            (*proc_0).load,
        );
    }
}
#[cold]
unsafe extern "C" fn gw_proc_check_enable(
    host: *mut gw_host,
    proc_0: *mut gw_proc,
    errh: *mut log_error_st,
) {
    if log_monotonic_secs <= (*proc_0).disabled_until {
        return;
    }
    if (*proc_0).state as libc::c_uint != PROC_STATE_OVERLOADED as libc::c_int as libc::c_uint {
        return;
    }
    gw_proc_set_state(host, proc_0, PROC_STATE_RUNNING as libc::c_int);
    log_error(
        errh,
        b"/home/kkysen/work/rust/lighttpd/src/gw_backend.c\0" as *const u8 as *const libc::c_char,
        362 as libc::c_int as libc::c_uint,
        b"gw-server re-enabled: %s %s %hu %s\0" as *const u8 as *const libc::c_char,
        (*(*proc_0).connection_name).ptr,
        if !((*host).host).is_null() {
            (*(*host).host).ptr as *const libc::c_char
        } else {
            b"\0" as *const u8 as *const libc::c_char
        },
        (*host).port as libc::c_int,
        if !((*host).unixsocket).is_null() {
            (*(*host).unixsocket).ptr as *const libc::c_char
        } else {
            b"\0" as *const u8 as *const libc::c_char
        },
    );
}
#[cold]
unsafe extern "C" fn gw_proc_waitpid_log(
    host: *const gw_host,
    proc_0: *const gw_proc,
    errh: *mut log_error_st,
    status: libc::c_int,
) {
    if status & 0x7f as libc::c_int == 0 as libc::c_int {
        if (*proc_0).state as libc::c_uint != PROC_STATE_KILLED as libc::c_int as libc::c_uint {
            log_error(
                errh,
                b"/home/kkysen/work/rust/lighttpd/src/gw_backend.c\0" as *const u8
                    as *const libc::c_char,
                373 as libc::c_int as libc::c_uint,
                b"child exited: %d %s\0" as *const u8 as *const libc::c_char,
                (status & 0xff00 as libc::c_int) >> 8 as libc::c_int,
                (*(*proc_0).connection_name).ptr,
            );
        }
    } else if ((status & 0x7f as libc::c_int) + 1 as libc::c_int) as libc::c_schar as libc::c_int
        >> 1 as libc::c_int
        > 0 as libc::c_int
    {
        if status & 0x7f as libc::c_int != 15 as libc::c_int
            && status & 0x7f as libc::c_int != 2 as libc::c_int
            && status & 0x7f as libc::c_int != (*host).kill_signal as libc::c_int
        {
            log_error(
                errh,
                b"/home/kkysen/work/rust/lighttpd/src/gw_backend.c\0" as *const u8
                    as *const libc::c_char,
                380 as libc::c_int as libc::c_uint,
                b"child signalled: %d\0" as *const u8 as *const libc::c_char,
                status & 0x7f as libc::c_int,
            );
        }
    } else {
        log_error(
            errh,
            b"/home/kkysen/work/rust/lighttpd/src/gw_backend.c\0" as *const u8
                as *const libc::c_char,
            384 as libc::c_int as libc::c_uint,
            b"child died somehow: %d\0" as *const u8 as *const libc::c_char,
            status,
        );
    };
}
unsafe extern "C" fn gw_proc_waitpid(
    mut host: *mut gw_host,
    mut proc_0: *mut gw_proc,
    mut errh: *mut log_error_st,
) -> libc::c_int {
    let mut rc: libc::c_int = 0;
    let mut status: libc::c_int = 0;
    if (*proc_0).is_local == 0 {
        return 0 as libc::c_int;
    }
    if (*proc_0).pid <= 0 as libc::c_int {
        return 0 as libc::c_int;
    }
    rc = fdevent_waitpid((*proc_0).pid, &mut status, 1 as libc::c_int);
    if 0 as libc::c_int == rc {
        return 0 as libc::c_int;
    }
    if -(1 as libc::c_int) == rc {
        log_perror(
            errh,
            b"/home/kkysen/work/rust/lighttpd/src/gw_backend.c\0" as *const u8
                as *const libc::c_char,
            402 as libc::c_int as libc::c_uint,
            b"pid %d %d not found\0" as *const u8 as *const libc::c_char,
            (*proc_0).pid,
            (*proc_0).state as libc::c_uint,
        );
    } else {
        gw_proc_waitpid_log(host, proc_0, errh, status);
    }
    (*proc_0).pid = 0 as libc::c_int;
    if (*proc_0).state as libc::c_uint != PROC_STATE_KILLED as libc::c_int as libc::c_uint {
        (*proc_0).disabled_until = log_monotonic_secs;
    }
    gw_proc_set_state(host, proc_0, PROC_STATE_DIED as libc::c_int);
    return 1 as libc::c_int;
}
#[cold]
unsafe extern "C" fn gw_proc_sockaddr_init(
    host: *mut gw_host,
    proc_0: *mut gw_proc,
    errh: *mut log_error_st,
) -> libc::c_int {
    let mut addr: sock_addr = sock_addr {
        ipv6: sockaddr_in6 {
            sin6_family: 0,
            sin6_port: 0,
            sin6_flowinfo: 0,
            sin6_addr: in6_addr {
                __in6_u: C2RustUnnamed_0 {
                    __u6_addr8: [0; 16],
                },
            },
            sin6_scope_id: 0,
        },
    };
    let mut addrlen: socklen_t = 0;
    if !((*proc_0).unixsocket).is_null() {
        if 1 as libc::c_int
            != sock_addr_from_str_hints(
                &mut addr,
                &mut addrlen,
                (*(*proc_0).unixsocket).ptr,
                1 as libc::c_int,
                0 as libc::c_int as libc::c_ushort,
                errh,
            )
        {
            *__errno_location() = 22 as libc::c_int;
            return -(1 as libc::c_int);
        }
        buffer_clear((*proc_0).connection_name);
        buffer_append_str2(
            (*proc_0).connection_name,
            b"unix:\0" as *const u8 as *const libc::c_char,
            (::core::mem::size_of::<[libc::c_char; 6]>() as libc::c_ulong as uint32_t)
                .wrapping_sub(1 as libc::c_int as libc::c_uint) as size_t,
            (*(*proc_0).unixsocket).ptr,
            buffer_clen((*proc_0).unixsocket) as size_t,
        );
    } else {
        if 1 as libc::c_int
            != sock_addr_from_str_hints(
                &mut addr,
                &mut addrlen,
                (*(*host).host).ptr,
                0 as libc::c_int,
                (*proc_0).port,
                errh,
            )
        {
            *__errno_location() = 22 as libc::c_int;
            return -(1 as libc::c_int);
        } else {
            if (*(*host).host).size != 0 {
                let mut h: *mut buffer = 0 as *mut buffer;
                let ref mut fresh194 = *(&mut h as *mut *mut buffer as *mut *const buffer);
                *fresh194 = (*host).host;
                sock_addr_inet_ntop_copy_buffer(h, &mut addr);
                (*host).family = sock_addr_get_family(&mut addr) as libc::c_ushort;
            }
        }
        buffer_clear((*proc_0).connection_name);
        buffer_append_str3(
            (*proc_0).connection_name,
            b"tcp:\0" as *const u8 as *const libc::c_char,
            (::core::mem::size_of::<[libc::c_char; 5]>() as libc::c_ulong as uint32_t)
                .wrapping_sub(1 as libc::c_int as libc::c_uint) as size_t,
            (*(*host).host).ptr,
            buffer_clen((*host).host) as size_t,
            b":\0" as *const u8 as *const libc::c_char,
            (::core::mem::size_of::<[libc::c_char; 2]>() as libc::c_ulong as uint32_t)
                .wrapping_sub(1 as libc::c_int as libc::c_uint) as size_t,
        );
        buffer_append_int((*proc_0).connection_name, (*proc_0).port as intmax_t);
    }
    if !((*proc_0).saddr).is_null() && (*proc_0).saddrlen < addrlen {
        free((*proc_0).saddr as *mut libc::c_void);
        (*proc_0).saddr = 0 as *mut sockaddr;
    }
    if ((*proc_0).saddr).is_null() {
        (*proc_0).saddr = malloc(addrlen as libc::c_ulong) as *mut sockaddr;
        if ((*proc_0).saddr).is_null() {
            ck_assert_failed(
                b"/home/kkysen/work/rust/lighttpd/src/gw_backend.c\0" as *const u8
                    as *const libc::c_char,
                465 as libc::c_int as libc::c_uint,
                b"proc->saddr\0" as *const u8 as *const libc::c_char,
            );
        }
    }
    (*proc_0).saddrlen = addrlen;
    memcpy(
        (*proc_0).saddr as *mut libc::c_void,
        &mut addr as *mut sock_addr as *const libc::c_void,
        addrlen as libc::c_ulong,
    );
    return 0 as libc::c_int;
}
unsafe extern "C" fn env_add(
    mut env: *mut char_array,
    mut key: *const libc::c_char,
    mut key_len: size_t,
    mut val: *const libc::c_char,
    mut val_len: size_t,
) -> libc::c_int {
    let mut dst: *mut libc::c_char = 0 as *mut libc::c_char;
    if key.is_null() || val.is_null() {
        return -(1 as libc::c_int);
    }
    dst = malloc(
        key_len
            .wrapping_add(val_len)
            .wrapping_add(3 as libc::c_int as libc::c_ulong),
    ) as *mut libc::c_char;
    if dst.is_null() {
        ck_assert_failed(
            b"/home/kkysen/work/rust/lighttpd/src/gw_backend.c\0" as *const u8
                as *const libc::c_char,
            478 as libc::c_int as libc::c_uint,
            b"dst\0" as *const u8 as *const libc::c_char,
        );
    }
    memcpy(
        dst as *mut libc::c_void,
        key as *const libc::c_void,
        key_len,
    );
    *dst.offset(key_len as isize) = '=' as i32 as libc::c_char;
    memcpy(
        dst.offset(key_len as isize)
            .offset(1 as libc::c_int as isize) as *mut libc::c_void,
        val as *const libc::c_void,
        val_len.wrapping_add(1 as libc::c_int as libc::c_ulong),
    );
    let mut i: uint32_t = 0 as libc::c_int as uint32_t;
    while i < (*env).used {
        if 0 as libc::c_int
            == strncmp(
                dst,
                *((*env).ptr).offset(i as isize),
                key_len.wrapping_add(1 as libc::c_int as libc::c_ulong),
            )
        {
            free(*((*env).ptr).offset(i as isize) as *mut libc::c_void);
            let ref mut fresh195 = *((*env).ptr).offset(i as isize);
            *fresh195 = dst;
            return 0 as libc::c_int;
        }
        i = i.wrapping_add(1);
    }
    if (*env).size <= ((*env).used).wrapping_add(1 as libc::c_int as libc::c_uint) {
        (*env).size = ((*env).size as libc::c_uint).wrapping_add(16 as libc::c_int as libc::c_uint)
            as uint32_t as uint32_t;
        (*env).ptr = realloc(
            (*env).ptr as *mut libc::c_void,
            ((*env).size as libc::c_ulong)
                .wrapping_mul(::core::mem::size_of::<*mut libc::c_char>() as libc::c_ulong),
        ) as *mut *mut libc::c_char;
        if ((*env).ptr).is_null() {
            ck_assert_failed(
                b"/home/kkysen/work/rust/lighttpd/src/gw_backend.c\0" as *const u8
                    as *const libc::c_char,
                497 as libc::c_int as libc::c_uint,
                b"env->ptr\0" as *const u8 as *const libc::c_char,
            );
        }
    }
    let fresh196 = (*env).used;
    (*env).used = ((*env).used).wrapping_add(1);
    let ref mut fresh197 = *((*env).ptr).offset(fresh196 as isize);
    *fresh197 = dst;
    return 0 as libc::c_int;
}
#[cold]
unsafe extern "C" fn gw_spawn_connection(
    host: *mut gw_host,
    proc_0: *mut gw_proc,
    errh: *mut log_error_st,
    mut debug: libc::c_int,
) -> libc::c_int {
    let mut gw_fd: libc::c_int = 0;
    let mut status: libc::c_int = 0;
    if debug != 0 {
        log_error(
            errh,
            b"/home/kkysen/work/rust/lighttpd/src/gw_backend.c\0" as *const u8
                as *const libc::c_char,
            514 as libc::c_int as libc::c_uint,
            b"new proc, socket: %hu %s\0" as *const u8 as *const libc::c_char,
            (*proc_0).port as libc::c_int,
            if !((*proc_0).unixsocket).is_null() {
                (*(*proc_0).unixsocket).ptr as *const libc::c_char
            } else {
                b"\0" as *const u8 as *const libc::c_char
            },
        );
    }
    gw_fd = fdevent_socket_cloexec(
        (*(*proc_0).saddr).sa_family as libc::c_int,
        SOCK_STREAM as libc::c_int,
        0 as libc::c_int,
    );
    if -(1 as libc::c_int) == gw_fd {
        log_perror(
            errh,
            b"/home/kkysen/work/rust/lighttpd/src/gw_backend.c\0" as *const u8
                as *const libc::c_char,
            521 as libc::c_int as libc::c_uint,
            b"socket()\0" as *const u8 as *const libc::c_char,
        );
        return -(1 as libc::c_int);
    }
    loop {
        status = connect(
            gw_fd,
            __CONST_SOCKADDR_ARG {
                __sockaddr__: (*proc_0).saddr,
            },
            (*proc_0).saddrlen,
        );
        if !(-(1 as libc::c_int) == status && *__errno_location() == 4 as libc::c_int) {
            break;
        }
    }
    if -(1 as libc::c_int) == status
        && *__errno_location() != 2 as libc::c_int
        && !((*proc_0).unixsocket).is_null()
    {
        log_perror(
            errh,
            b"/home/kkysen/work/rust/lighttpd/src/gw_backend.c\0" as *const u8
                as *const libc::c_char,
            530 as libc::c_int as libc::c_uint,
            b"connect %s\0" as *const u8 as *const libc::c_char,
            (*(*proc_0).unixsocket).ptr,
        );
        unlink((*(*proc_0).unixsocket).ptr);
    }
    close(gw_fd);
    if -(1 as libc::c_int) == status {
        let mut env: char_array = char_array {
            ptr: 0 as *mut *mut libc::c_char,
            size: 0,
            used: 0,
        };
        let mut i: uint32_t = 0;
        gw_fd = fdevent_socket_cloexec(
            (*(*proc_0).saddr).sa_family as libc::c_int,
            SOCK_STREAM as libc::c_int,
            0 as libc::c_int,
        );
        if -(1 as libc::c_int) == gw_fd {
            log_perror(
                errh,
                b"/home/kkysen/work/rust/lighttpd/src/gw_backend.c\0" as *const u8
                    as *const libc::c_char,
                545 as libc::c_int as libc::c_uint,
                b"socket()\0" as *const u8 as *const libc::c_char,
            );
            return -(1 as libc::c_int);
        }
        if fdevent_set_so_reuseaddr(gw_fd, 1 as libc::c_int) < 0 as libc::c_int {
            log_perror(
                errh,
                b"/home/kkysen/work/rust/lighttpd/src/gw_backend.c\0" as *const u8
                    as *const libc::c_char,
                550 as libc::c_int as libc::c_uint,
                b"socketsockopt()\0" as *const u8 as *const libc::c_char,
            );
            close(gw_fd);
            return -(1 as libc::c_int);
        }
        if -(1 as libc::c_int)
            == bind(
                gw_fd,
                __CONST_SOCKADDR_ARG {
                    __sockaddr__: (*proc_0).saddr,
                },
                (*proc_0).saddrlen,
            )
        {
            log_perror(
                errh,
                b"/home/kkysen/work/rust/lighttpd/src/gw_backend.c\0" as *const u8
                    as *const libc::c_char,
                557 as libc::c_int as libc::c_uint,
                b"bind failed for: %s\0" as *const u8 as *const libc::c_char,
                (*(*proc_0).connection_name).ptr,
            );
            close(gw_fd);
            return -(1 as libc::c_int);
        }
        if -(1 as libc::c_int) == listen(gw_fd, (*host).listen_backlog) {
            log_perror(
                errh,
                b"/home/kkysen/work/rust/lighttpd/src/gw_backend.c\0" as *const u8
                    as *const libc::c_char,
                564 as libc::c_int as libc::c_uint,
                b"listen()\0" as *const u8 as *const libc::c_char,
            );
            close(gw_fd);
            return -(1 as libc::c_int);
        }
        env.ptr = 0 as *mut *mut libc::c_char;
        env.size = 0 as libc::c_int as uint32_t;
        env.used = 0 as libc::c_int as uint32_t;
        if !((*host).bin_env_copy).is_null() && (*(*host).bin_env_copy).used != 0 {
            i = 0 as libc::c_int as uint32_t;
            while i < (*(*host).bin_env_copy).used {
                let mut ds: *mut data_string =
                    *((*(*host).bin_env_copy).data).offset(i as isize) as *mut data_string;
                let mut ge: *mut libc::c_char = 0 as *mut libc::c_char;
                ge = getenv((*ds).value.ptr);
                if !ge.is_null() {
                    env_add(
                        &mut env,
                        (*ds).value.ptr,
                        buffer_clen(&mut (*ds).value) as size_t,
                        ge,
                        strlen(ge),
                    );
                }
                i = i.wrapping_add(1);
            }
        } else {
            let e: *mut *mut libc::c_char = fdevent_environ();
            i = 0 as libc::c_int as uint32_t;
            while !(*e.offset(i as isize)).is_null() {
                let mut eq: *mut libc::c_char = 0 as *mut libc::c_char;
                eq = strchr(*e.offset(i as isize), '=' as i32);
                if !eq.is_null() {
                    env_add(
                        &mut env,
                        *e.offset(i as isize),
                        eq.offset_from(*e.offset(i as isize)) as libc::c_long as size_t,
                        eq.offset(1 as libc::c_int as isize),
                        strlen(eq.offset(1 as libc::c_int as isize)),
                    );
                }
                i = i.wrapping_add(1);
            }
        }
        if !((*host).bin_env).is_null() {
            i = 0 as libc::c_int as uint32_t;
            while i < (*(*host).bin_env).used {
                let mut ds_0: *mut data_string =
                    *((*(*host).bin_env).data).offset(i as isize) as *mut data_string;
                env_add(
                    &mut env,
                    (*ds_0).key.ptr,
                    buffer_clen(&mut (*ds_0).key) as size_t,
                    (*ds_0).value.ptr,
                    buffer_clen(&mut (*ds_0).value) as size_t,
                );
                i = i.wrapping_add(1);
            }
        }
        i = 0 as libc::c_int as uint32_t;
        while i < env.used {
            if 0 as libc::c_int
                == strncmp(
                    *(env.ptr).offset(i as isize),
                    b"PHP_FCGI_CHILDREN=\0" as *const u8 as *const libc::c_char,
                    (::core::mem::size_of::<[libc::c_char; 19]>() as libc::c_ulong)
                        .wrapping_sub(1 as libc::c_int as libc::c_ulong),
                )
            {
                break;
            }
            i = i.wrapping_add(1);
        }
        if i == env.used {
            env_add(
                &mut env,
                b"PHP_FCGI_CHILDREN\0" as *const u8 as *const libc::c_char,
                (::core::mem::size_of::<[libc::c_char; 18]>() as libc::c_ulong as uint32_t)
                    .wrapping_sub(1 as libc::c_int as libc::c_uint) as size_t,
                b"1\0" as *const u8 as *const libc::c_char,
                (::core::mem::size_of::<[libc::c_char; 2]>() as libc::c_ulong as uint32_t)
                    .wrapping_sub(1 as libc::c_int as libc::c_uint) as size_t,
            );
        }
        let ref mut fresh198 = *(env.ptr).offset(env.used as isize);
        *fresh198 = 0 as *mut libc::c_char;
        let mut dfd: libc::c_int = fdevent_open_dirname(
            *((*host).args.ptr).offset(0 as libc::c_int as isize),
            1 as libc::c_int,
        );
        if -(1 as libc::c_int) == dfd {
            log_perror(
                errh,
                b"/home/kkysen/work/rust/lighttpd/src/gw_backend.c\0" as *const u8
                    as *const libc::c_char,
                624 as libc::c_int as libc::c_uint,
                b"open dirname failed: %s\0" as *const u8 as *const libc::c_char,
                *((*host).args.ptr).offset(0 as libc::c_int as isize),
            );
        }
        (*proc_0).pid = if dfd >= 0 as libc::c_int {
            fdevent_fork_execve(
                *((*host).args.ptr).offset(0 as libc::c_int as isize),
                (*host).args.ptr,
                env.ptr,
                gw_fd,
                -(1 as libc::c_int),
                -(1 as libc::c_int),
                dfd,
            )
        } else {
            -(1 as libc::c_int)
        };
        i = 0 as libc::c_int as uint32_t;
        while i < env.used {
            free(*(env.ptr).offset(i as isize) as *mut libc::c_void);
            i = i.wrapping_add(1);
        }
        free(env.ptr as *mut libc::c_void);
        if -(1 as libc::c_int) != dfd {
            close(dfd);
        }
        close(gw_fd);
        if -(1 as libc::c_int) == (*proc_0).pid {
            log_error(
                errh,
                b"/home/kkysen/work/rust/lighttpd/src/gw_backend.c\0" as *const u8
                    as *const libc::c_char,
                640 as libc::c_int as libc::c_uint,
                b"gw-backend failed to start: %s\0" as *const u8 as *const libc::c_char,
                (*(*host).bin_path).ptr,
            );
            (*proc_0).pid = 0 as libc::c_int;
            (*proc_0).disabled_until = log_monotonic_secs;
            return -(1 as libc::c_int);
        }
        (*proc_0).last_used = log_monotonic_secs;
        (*proc_0).is_local = 1 as libc::c_int;
        let mut tv: timeval = {
            let mut init = timeval {
                tv_sec: 0 as libc::c_int as __time_t,
                tv_usec: 1000 as libc::c_int as __suseconds_t,
            };
            init
        };
        select(
            0 as libc::c_int,
            0 as *mut fd_set,
            0 as *mut fd_set,
            0 as *mut fd_set,
            &mut tv,
        );
        if 0 as libc::c_int != gw_proc_waitpid(host, proc_0, errh) {
            log_error(
                errh,
                b"/home/kkysen/work/rust/lighttpd/src/gw_backend.c\0" as *const u8
                    as *const libc::c_char,
                656 as libc::c_int as libc::c_uint,
                b"gw-backend failed to start: %s\0" as *const u8 as *const libc::c_char,
                (*(*host).bin_path).ptr,
            );
            log_error(
                errh,
                b"/home/kkysen/work/rust/lighttpd/src/gw_backend.c\0" as *const u8
                    as *const libc::c_char,
                658 as libc::c_int as libc::c_uint,
                b"If you're trying to run your app as a FastCGI backend, make sure you're using the FastCGI-enabled version.  If this is PHP on Gentoo, add 'fastcgi' to the USE flags.  If this is PHP, try removing the bytecode caches for now and try again.\0"
                    as *const u8 as *const libc::c_char,
            );
            return -(1 as libc::c_int);
        }
    } else {
        (*proc_0).is_local = 0 as libc::c_int;
        (*proc_0).pid = 0 as libc::c_int;
        if debug != 0 {
            log_error(
                errh,
                b"/home/kkysen/work/rust/lighttpd/src/gw_backend.c\0" as *const u8
                    as *const libc::c_char,
                670 as libc::c_int as libc::c_uint,
                b"(debug) socket is already used; won't spawn: %s\0" as *const u8
                    as *const libc::c_char,
                (*(*proc_0).connection_name).ptr,
            );
        }
    }
    gw_proc_set_state(host, proc_0, PROC_STATE_RUNNING as libc::c_int);
    return 0 as libc::c_int;
}
#[cold]
unsafe extern "C" fn gw_proc_spawn(
    host: *mut gw_host,
    errh: *mut log_error_st,
    debug: libc::c_int,
) {
    let mut proc_0: *mut gw_proc = 0 as *mut gw_proc;
    proc_0 = (*host).unused_procs;
    while !proc_0.is_null() {
        if (*proc_0).pid > 0 as libc::c_int {
            proc_0 = (*proc_0).next;
        } else {
            if (*proc_0).disabled_until >= log_monotonic_secs {
                return;
            }
            break;
        }
    }
    if !proc_0.is_null() {
        if proc_0 == (*host).unused_procs {
            (*host).unused_procs = (*proc_0).next;
        } else {
            (*(*proc_0).prev).next = (*proc_0).next;
        }
        if !((*proc_0).next).is_null() {
            (*(*proc_0).next).prev = (*proc_0).prev;
            (*proc_0).next = 0 as *mut gw_proc;
        }
        (*proc_0).prev = 0 as *mut gw_proc;
        gw_proc_init_portpath(host, proc_0);
    } else {
        proc_0 = gw_proc_init(host);
    }
    if 0 as libc::c_int != gw_proc_sockaddr_init(host, proc_0, errh) {
        log_error(
            errh,
            b"/home/kkysen/work/rust/lighttpd/src/gw_backend.c\0" as *const u8
                as *const libc::c_char,
            710 as libc::c_int as libc::c_uint,
            b"ERROR: spawning backend failed.\0" as *const u8 as *const libc::c_char,
        );
        if (*proc_0).id == ((*host).max_id).wrapping_sub(1 as libc::c_int as libc::c_uint) {
            (*host).max_id = ((*host).max_id).wrapping_sub(1);
        }
        gw_proc_free(proc_0);
    } else if gw_spawn_connection(host, proc_0, errh, debug) != 0 {
        log_error(
            errh,
            b"/home/kkysen/work/rust/lighttpd/src/gw_backend.c\0" as *const u8
                as *const libc::c_char,
            715 as libc::c_int as libc::c_uint,
            b"ERROR: spawning backend failed.\0" as *const u8 as *const libc::c_char,
        );
        (*proc_0).next = (*host).unused_procs;
        if !((*host).unused_procs).is_null() {
            (*(*host).unused_procs).prev = proc_0;
        }
        (*host).unused_procs = proc_0;
    } else {
        (*proc_0).next = (*host).first;
        if !((*host).first).is_null() {
            (*(*host).first).prev = proc_0;
        }
        (*host).first = proc_0;
        (*host).num_procs = ((*host).num_procs).wrapping_add(1);
    };
}
#[cold]
unsafe extern "C" fn gw_proc_kill(mut host: *mut gw_host, mut proc_0: *mut gw_proc) {
    if !((*proc_0).next).is_null() {
        (*(*proc_0).next).prev = (*proc_0).prev;
    }
    if !((*proc_0).prev).is_null() {
        (*(*proc_0).prev).next = (*proc_0).next;
    } else {
        (*host).first = (*proc_0).next;
    }
    (*host).num_procs = ((*host).num_procs).wrapping_sub(1);
    (*proc_0).prev = 0 as *mut gw_proc;
    (*proc_0).next = (*host).unused_procs;
    (*proc_0).disabled_until = 0 as libc::c_int as unix_time64_t;
    if !((*host).unused_procs).is_null() {
        (*(*host).unused_procs).prev = proc_0;
    }
    (*host).unused_procs = proc_0;
    kill((*proc_0).pid, (*host).kill_signal as libc::c_int);
    gw_proc_set_state(host, proc_0, PROC_STATE_KILLED as libc::c_int);
}
unsafe extern "C" fn unixsocket_is_dup(
    mut p: *mut gw_plugin_data,
    mut unixsocket: *const buffer,
) -> *mut gw_host {
    if ((*p).cvlist).is_null() {
        return 0 as *mut gw_host;
    }
    let mut i: libc::c_int = ((*((*p).cvlist).offset(0 as libc::c_int as isize)).v.u2
        [1 as libc::c_int as usize]
        == 0) as libc::c_int;
    let mut used: libc::c_int = (*p).nconfig;
    while i < used {
        let mut cpv: *mut config_plugin_value_t = ((*p).cvlist)
            .offset((*((*p).cvlist).offset(i as isize)).v.u2[0 as libc::c_int as usize] as isize);
        let mut conf: *mut gw_plugin_config = 0 as *mut gw_plugin_config;
        while -(1 as libc::c_int) != (*cpv).k_id {
            match (*cpv).k_id {
                0 => {
                    if (*cpv).vtype as libc::c_uint == T_CONFIG_LOCAL as libc::c_int as libc::c_uint
                    {
                        conf = (*cpv).v.v as *mut gw_plugin_config;
                    }
                }
                _ => {}
            }
            cpv = cpv.offset(1);
        }
        if !(conf.is_null() || ((*conf).exts).is_null()) {
            let mut exts: *mut gw_exts = (*conf).exts;
            let mut j: uint32_t = 0 as libc::c_int as uint32_t;
            while j < (*exts).used {
                let mut ex: *mut gw_extension = ((*exts).exts).offset(j as isize);
                let mut n: uint32_t = 0 as libc::c_int as uint32_t;
                while n < (*ex).used {
                    let mut host: *mut gw_host = *((*ex).hosts).offset(n as isize);
                    if !((*host).unixsocket).is_null()
                        && buffer_is_equal((*host).unixsocket, unixsocket) != 0
                        && !((*host).bin_path).is_null()
                    {
                        return host;
                    }
                    n = n.wrapping_add(1);
                }
                j = j.wrapping_add(1);
            }
        }
        i += 1;
    }
    return 0 as *mut gw_host;
}
unsafe extern "C" fn parse_binpath(mut env: *mut char_array, mut b: *const buffer) -> libc::c_int {
    let mut start: *mut libc::c_char = (*b).ptr;
    let mut c: libc::c_char = 0;
    let mut i: size_t = 0 as libc::c_int as size_t;
    let mut used: size_t = buffer_clen(b) as size_t;
    while i < used {
        match *((*b).ptr).offset(i as isize) as libc::c_int {
            32 | 9 => {
                if (*env).size == (*env).used {
                    (*env).size = ((*env).size as libc::c_uint)
                        .wrapping_add(16 as libc::c_int as libc::c_uint)
                        as uint32_t as uint32_t;
                    (*env).ptr = realloc(
                        (*env).ptr as *mut libc::c_void,
                        ((*env).size as libc::c_ulong)
                            .wrapping_mul(
                                ::core::mem::size_of::<*mut libc::c_char>() as libc::c_ulong
                            ),
                    ) as *mut *mut libc::c_char;
                    if ((*env).ptr).is_null() {
                        ck_assert_failed(
                            b"/home/kkysen/work/rust/lighttpd/src/gw_backend.c\0" as *const u8
                                as *const libc::c_char,
                            798 as libc::c_int as libc::c_uint,
                            b"env->ptr\0" as *const u8 as *const libc::c_char,
                        );
                    }
                }
                c = *((*b).ptr).offset(i as isize);
                *((*b).ptr).offset(i as isize) = '\0' as i32 as libc::c_char;
                let fresh199 = (*env).used;
                (*env).used = ((*env).used).wrapping_add(1);
                let ref mut fresh200 = *((*env).ptr).offset(fresh199 as isize);
                *fresh200 = strdup(start);
                *((*b).ptr).offset(i as isize) = c;
                start = ((*b).ptr)
                    .offset(i as isize)
                    .offset(1 as libc::c_int as isize);
            }
            _ => {}
        }
        i = i.wrapping_add(1);
    }
    if (*env).size == (*env).used {
        (*env).size = ((*env).size as libc::c_uint).wrapping_add(16 as libc::c_int as libc::c_uint)
            as uint32_t as uint32_t;
        (*env).ptr = realloc(
            (*env).ptr as *mut libc::c_void,
            ((*env).size as libc::c_ulong)
                .wrapping_mul(::core::mem::size_of::<*mut libc::c_char>() as libc::c_ulong),
        ) as *mut *mut libc::c_char;
    }
    let fresh201 = (*env).used;
    (*env).used = ((*env).used).wrapping_add(1);
    let ref mut fresh202 = *((*env).ptr).offset(fresh201 as isize);
    *fresh202 = strdup(start);
    if (*env).size == (*env).used {
        (*env).size = ((*env).size as libc::c_uint).wrapping_add(16 as libc::c_int as libc::c_uint)
            as uint32_t as uint32_t;
        (*env).ptr = realloc(
            (*env).ptr as *mut libc::c_void,
            ((*env).size as libc::c_ulong)
                .wrapping_mul(::core::mem::size_of::<*mut libc::c_char>() as libc::c_ulong),
        ) as *mut *mut libc::c_char;
    }
    let fresh203 = (*env).used;
    (*env).used = ((*env).used).wrapping_add(1);
    let ref mut fresh204 = *((*env).ptr).offset(fresh203 as isize);
    *fresh204 = 0 as *mut libc::c_char;
    return 0 as libc::c_int;
}
#[inline(never)]
unsafe extern "C" fn gw_hash(
    mut str: *const libc::c_char,
    len: uint32_t,
    mut hash: uint32_t,
) -> uint32_t {
    return djbhash(str, len, hash);
}
unsafe extern "C" fn gw_host_get(
    r: *mut request_st,
    mut extension: *mut gw_extension,
    mut balance: libc::c_int,
    mut debug: libc::c_int,
) -> *mut gw_host {
    let mut ndx: libc::c_int = -(1 as libc::c_int);
    let ext_used: libc::c_int = (*extension).used as libc::c_int;
    if ext_used <= 1 as libc::c_int {
        if 1 as libc::c_int == ext_used
            && (**((*extension).hosts).offset(0 as libc::c_int as isize)).active_procs
                > 0 as libc::c_int as libc::c_uint
        {
            ndx = 0 as libc::c_int;
        }
    } else {
        match balance {
            2 => {
                let base_hash: uint32_t = gw_hash(
                    (*r).uri.authority.ptr,
                    buffer_clen(&mut (*r).uri.authority),
                    gw_hash(
                        (*r).uri.path.ptr,
                        buffer_clen(&mut (*r).uri.path),
                        5381 as libc::c_int as uint32_t,
                    ),
                );
                let mut last_max: uint32_t = 4294967295 as libc::c_uint;
                let mut k: libc::c_int = 0 as libc::c_int;
                while k < ext_used {
                    let host: *const gw_host = *((*extension).hosts).offset(k as isize);
                    if !(0 as libc::c_int as libc::c_uint == (*host).active_procs) {
                        let cur_max: uint32_t = base_hash ^ (*host).gw_hash;
                        if last_max < cur_max || last_max == 4294967295 as libc::c_uint {
                            last_max = cur_max;
                            ndx = k;
                        }
                    }
                    k += 1;
                }
            }
            0 => {
                let mut k_0: libc::c_int = 0 as libc::c_int;
                let mut max_usage: libc::c_int = 2147483647 as libc::c_int;
                while k_0 < ext_used {
                    let host_0: *const gw_host = *((*extension).hosts).offset(k_0 as isize);
                    if !(0 as libc::c_int as libc::c_uint == (*host_0).active_procs) {
                        if (*host_0).load < max_usage {
                            max_usage = (*host_0).load;
                            ndx = k_0;
                        }
                    }
                    k_0 += 1;
                }
            }
            1 => {
                let mut host_1: *const gw_host =
                    *((*extension).hosts).offset(0 as libc::c_int as isize);
                let mut k_1: libc::c_int = (*extension).last_used_ndx;
                ndx = k_1 + 1 as libc::c_int;
                if ndx < 0 as libc::c_int {
                    ndx = 0 as libc::c_int;
                }
                while ndx < ext_used && {
                    host_1 = *((*extension).hosts).offset(ndx as isize);
                    0 as libc::c_int as libc::c_uint == (*host_1).active_procs
                } {
                    ndx += 1;
                }
                if ndx >= ext_used {
                    ndx = 0 as libc::c_int;
                    while ndx <= k_1 {
                        host_1 = *((*extension).hosts).offset(ndx as isize);
                        if 0 as libc::c_int as libc::c_uint != (*host_1).active_procs {
                            break;
                        }
                        ndx += 1;
                    }
                    if 0 as libc::c_int as libc::c_uint == (*host_1).active_procs {
                        ndx = -(1 as libc::c_int);
                    }
                }
                (*extension).last_used_ndx = ndx;
            }
            3 => {
                let dst_addr_buf: *const buffer = &mut (*(*r).con).dst_addr_buf;
                let base_hash_0: uint32_t = gw_hash(
                    (*dst_addr_buf).ptr,
                    buffer_clen(dst_addr_buf),
                    5381 as libc::c_int as uint32_t,
                );
                let mut last_max_0: uint32_t = 4294967295 as libc::c_uint;
                let mut k_2: libc::c_int = 0 as libc::c_int;
                while k_2 < ext_used {
                    let host_2: *const gw_host = *((*extension).hosts).offset(k_2 as isize);
                    if !(0 as libc::c_int as libc::c_uint == (*host_2).active_procs) {
                        let cur_max_0: uint32_t =
                            base_hash_0 ^ (*host_2).gw_hash ^ (*host_2).port as libc::c_uint;
                        if last_max_0 < cur_max_0 || last_max_0 == 4294967295 as libc::c_uint {
                            last_max_0 = cur_max_0;
                            ndx = k_2;
                        }
                    }
                    k_2 += 1;
                }
            }
            _ => {}
        }
    }
    if (-(1 as libc::c_int) != ndx) as libc::c_int as libc::c_long != 0 {
        if debug != 0 {
            let host_3: *mut gw_host = *((*extension).hosts).offset(ndx as isize);
            log_error(
                (*r).conf.errh,
                b"/home/kkysen/work/rust/lighttpd/src/gw_backend.c\0" as *const u8
                    as *const libc::c_char,
                969 as libc::c_int as libc::c_uint,
                b"gw - found a host %s %hu\0" as *const u8 as *const libc::c_char,
                if !((*host_3).host).is_null() {
                    (*(*host_3).host).ptr as *const libc::c_char
                } else {
                    b"\0" as *const u8 as *const libc::c_char
                },
                (*host_3).port as libc::c_int,
            );
            return host_3;
        }
        return *((*extension).hosts).offset(ndx as isize);
    } else {
        if 0 as libc::c_int == (*(*(*r).con).srv).srvconf.max_worker as libc::c_int {
            let mut k_3: libc::c_int = 0 as libc::c_int;
            while k_3 < ext_used {
                let host_4: *mut gw_host = *((*extension).hosts).offset(k_3 as isize);
                if 0 as libc::c_int == (*host_4).min_procs as libc::c_int
                    && 0 as libc::c_int as libc::c_uint == (*host_4).num_procs
                    && !((*host_4).bin_path).is_null()
                {
                    gw_proc_spawn(host_4, (*(*(*r).con).srv).errh, debug);
                    if (*host_4).num_procs != 0 {
                        return host_4;
                    }
                }
                k_3 += 1;
            }
        }
    }
    (*r).http_status = 503 as libc::c_int;
    (*r).handler_module = 0 as *const plugin;
    if (*extension).note_is_sent == 0 {
        (*extension).note_is_sent = 1 as libc::c_int;
        log_error(
            (*r).conf.errh,
            b"/home/kkysen/work/rust/lighttpd/src/gw_backend.c\0" as *const u8
                as *const libc::c_char,
            995 as libc::c_int as libc::c_uint,
            b"all handlers for %s?%.*s on %s are down.\0" as *const u8 as *const libc::c_char,
            (*r).uri.path.ptr,
            buffer_clen(&mut (*r).uri.query) as libc::c_int,
            (*r).uri.query.ptr,
            (*extension).key.ptr,
        );
    }
    return 0 as *mut gw_host;
}
unsafe extern "C" fn gw_establish_connection(
    r: *mut request_st,
    mut host: *mut gw_host,
    mut proc_0: *mut gw_proc,
    mut pid: pid_t,
    mut gw_fd: libc::c_int,
    mut debug: libc::c_int,
) -> libc::c_int {
    if -(1 as libc::c_int)
        == connect(
            gw_fd,
            __CONST_SOCKADDR_ARG {
                __sockaddr__: (*proc_0).saddr,
            },
            (*proc_0).saddrlen,
        )
    {
        let mut errnum: libc::c_int = *__errno_location();
        if errnum == 115 as libc::c_int
            || errnum == 114 as libc::c_int
            || errnum == 4 as libc::c_int
            || errnum == 11 as libc::c_int && !((*host).unixsocket).is_null()
        {
            if debug > 2 as libc::c_int {
                log_error(
                    (*r).conf.errh,
                    b"/home/kkysen/work/rust/lighttpd/src/gw_backend.c\0" as *const u8
                        as *const libc::c_char,
                    1010 as libc::c_int as libc::c_uint,
                    b"connect delayed; will continue later: %s\0" as *const u8
                        as *const libc::c_char,
                    (*(*proc_0).connection_name).ptr,
                );
            }
            return 1 as libc::c_int;
        } else {
            gw_proc_connect_error(r, host, proc_0, pid, errnum, debug);
            return -(1 as libc::c_int);
        }
    }
    if debug > 1 as libc::c_int {
        log_error(
            (*r).conf.errh,
            b"/home/kkysen/work/rust/lighttpd/src/gw_backend.c\0" as *const u8
                as *const libc::c_char,
            1023 as libc::c_int as libc::c_uint,
            b"connect succeeded: %d\0" as *const u8 as *const libc::c_char,
            gw_fd,
        );
    }
    return 0 as libc::c_int;
}
#[cold]
#[inline(never)]
unsafe extern "C" fn gw_restart_dead_proc(
    host: *mut gw_host,
    errh: *mut log_error_st,
    debug: libc::c_int,
    trigger: libc::c_int,
    proc_0: *mut gw_proc,
) {
    let mut current_block_15: u64;
    match (*proc_0).state as libc::c_uint {
        1 => {
            gw_proc_check_enable(host, proc_0, errh);
            current_block_15 = 5601891728916014340;
        }
        4 => {
            if trigger != 0 && {
                (*proc_0).disabled_until += 1;
                (*proc_0).disabled_until > 4 as libc::c_int as libc::c_long
            } {
                let mut sig: libc::c_int =
                    if (*proc_0).disabled_until <= 8 as libc::c_int as libc::c_long {
                        (*host).kill_signal as libc::c_int
                    } else if (*proc_0).disabled_until <= 16 as libc::c_int as libc::c_long {
                        15 as libc::c_int
                    } else {
                        9 as libc::c_int
                    };
                kill((*proc_0).pid, sig);
            }
            current_block_15 = 5601891728916014340;
        }
        2 => {
            if 0 as libc::c_int == gw_proc_waitpid(host, proc_0, errh) {
                gw_proc_check_enable(host, proc_0, errh);
            }
            if (*proc_0).state as libc::c_uint != PROC_STATE_DIED as libc::c_int as libc::c_uint {
                current_block_15 = 5601891728916014340;
            } else {
                current_block_15 = 1538395035467134769;
            }
        }
        3 => {
            current_block_15 = 1538395035467134769;
        }
        0 | _ => {
            current_block_15 = 5601891728916014340;
        }
    }
    match current_block_15 {
        1538395035467134769 => {
            if !((*host).bin_path).is_null() {
                if !((*proc_0).load != 0 as libc::c_int as libc::c_uint) {
                    if !((*proc_0).disabled_until >= log_monotonic_secs) {
                        if debug != 0 {
                            log_error(
                                errh,
                                b"/home/kkysen/work/rust/lighttpd/src/gw_backend.c\0" as *const u8
                                    as *const libc::c_char,
                                1075 as libc::c_int as libc::c_uint,
                                b"--- gw spawning\n\tsocket %s\n\tcurrent: 1 / %u\0" as *const u8
                                    as *const libc::c_char,
                                (*(*proc_0).connection_name).ptr,
                                (*host).max_procs as libc::c_int,
                            );
                        }
                        if gw_spawn_connection(host, proc_0, errh, debug) != 0 {
                            log_error(
                                errh,
                                b"/home/kkysen/work/rust/lighttpd/src/gw_backend.c\0" as *const u8
                                    as *const libc::c_char,
                                1083 as libc::c_int as libc::c_uint,
                                b"ERROR: spawning gw failed.\0" as *const u8 as *const libc::c_char,
                            );
                        }
                    }
                }
            } else {
                gw_proc_check_enable(host, proc_0, errh);
            }
        }
        _ => {}
    };
}
unsafe extern "C" fn gw_restart_dead_procs(
    host: *mut gw_host,
    errh: *mut log_error_st,
    debug: libc::c_int,
    trigger: libc::c_int,
) {
    let mut proc_0: *mut gw_proc = (*host).first;
    while !proc_0.is_null() {
        if debug > 2 as libc::c_int {
            log_error(
                errh,
                b"/home/kkysen/work/rust/lighttpd/src/gw_backend.c\0" as *const u8
                    as *const libc::c_char,
                1096 as libc::c_int as libc::c_uint,
                b"proc: %s %d %d %d %d\0" as *const u8 as *const libc::c_char,
                (*(*proc_0).connection_name).ptr,
                (*proc_0).state as libc::c_uint,
                (*proc_0).is_local,
                (*proc_0).load,
                (*proc_0).pid,
            );
        }
        if (*proc_0).state as libc::c_uint != PROC_STATE_RUNNING as libc::c_int as libc::c_uint {
            gw_restart_dead_proc(host, errh, debug, trigger, proc_0);
        }
        proc_0 = (*proc_0).next;
    }
}
unsafe extern "C" fn handler_ctx_init(mut sz: size_t) -> *mut gw_handler_ctx {
    let mut hctx: *mut gw_handler_ctx = calloc(
        1 as libc::c_int as libc::c_ulong,
        if 0 as libc::c_int as libc::c_ulong == sz {
            ::core::mem::size_of::<gw_handler_ctx>() as libc::c_ulong
        } else {
            sz
        },
    ) as *mut gw_handler_ctx;
    if hctx.is_null() {
        ck_assert_failed(
            b"/home/kkysen/work/rust/lighttpd/src/gw_backend.c\0" as *const u8
                as *const libc::c_char,
            1120 as libc::c_int as libc::c_uint,
            b"hctx\0" as *const u8 as *const libc::c_char,
        );
    }
    (*hctx).request_id = 0 as libc::c_int;
    (*hctx).gw_mode = 1 as libc::c_int as libc::c_ushort;
    (*hctx).state = GW_STATE_INIT;
    (*hctx).proc_0 = 0 as *mut gw_proc;
    (*hctx).fd = -(1 as libc::c_int);
    (*hctx).reconnects = 0 as libc::c_int;
    (*hctx).send_content_body = 1 as libc::c_int;
    chunkqueue_init(&mut (*hctx).wb);
    (*hctx).wb_reqlen = 0 as libc::c_int as off_t;
    return hctx;
}
unsafe extern "C" fn handler_ctx_free(mut hctx: *mut gw_handler_ctx) {
    if ((*hctx).handler_ctx_free).is_some() {
        ((*hctx).handler_ctx_free).expect("non-null function pointer")(hctx as *mut libc::c_void);
    }
    chunk_buffer_release((*hctx).response);
    if !((*hctx).rb).is_null() {
        chunkqueue_free((*hctx).rb);
    }
    chunkqueue_reset(&mut (*hctx).wb);
    free(hctx as *mut libc::c_void);
}
unsafe extern "C" fn handler_ctx_clear(mut hctx: *mut gw_handler_ctx) {
    (*hctx).proc_0 = 0 as *mut gw_proc;
    (*hctx).host = 0 as *mut gw_host;
    (*hctx).ext = 0 as *mut gw_extension;
    (*hctx).gw_mode = 1 as libc::c_int as libc::c_ushort;
    (*hctx).state = GW_STATE_INIT;
    if !((*hctx).rb).is_null() {
        chunkqueue_reset((*hctx).rb);
    }
    chunkqueue_reset(&mut (*hctx).wb);
    (*hctx).wb_reqlen = 0 as libc::c_int as off_t;
    if !((*hctx).response).is_null() {
        buffer_clear((*hctx).response);
    }
    (*hctx).fd = -(1 as libc::c_int);
    (*hctx).reconnects = 0 as libc::c_int;
    (*hctx).request_id = 0 as libc::c_int;
    (*hctx).send_content_body = 1 as libc::c_int;
}
#[no_mangle]
#[cold]
pub unsafe extern "C" fn gw_init() -> *mut libc::c_void {
    return calloc(
        1 as libc::c_int as libc::c_ulong,
        ::core::mem::size_of::<gw_plugin_data>() as libc::c_ulong,
    );
}
#[no_mangle]
#[cold]
pub unsafe extern "C" fn gw_plugin_config_free(mut s: *mut gw_plugin_config) {
    let mut exts: *mut gw_exts = (*s).exts;
    if !exts.is_null() {
        let mut j: uint32_t = 0 as libc::c_int as uint32_t;
        while j < (*exts).used {
            let mut ex: *mut gw_extension = ((*exts).exts).offset(j as isize);
            let mut n: uint32_t = 0 as libc::c_int as uint32_t;
            while n < (*ex).used {
                let mut proc_0: *mut gw_proc = 0 as *mut gw_proc;
                let mut host: *mut gw_host = *((*ex).hosts).offset(n as isize);
                proc_0 = (*host).first;
                while !proc_0.is_null() {
                    if (*proc_0).pid > 0 as libc::c_int {
                        kill((*proc_0).pid, (*host).kill_signal as libc::c_int);
                    }
                    if (*proc_0).is_local != 0 && !((*proc_0).unixsocket).is_null() {
                        unlink((*(*proc_0).unixsocket).ptr);
                    }
                    proc_0 = (*proc_0).next;
                }
                proc_0 = (*host).unused_procs;
                while !proc_0.is_null() {
                    if (*proc_0).pid > 0 as libc::c_int {
                        kill((*proc_0).pid, (*host).kill_signal as libc::c_int);
                    }
                    if (*proc_0).is_local != 0 && !((*proc_0).unixsocket).is_null() {
                        unlink((*(*proc_0).unixsocket).ptr);
                    }
                    proc_0 = (*proc_0).next;
                }
                n = n.wrapping_add(1);
            }
            j = j.wrapping_add(1);
        }
        gw_extensions_free((*s).exts);
        gw_extensions_free((*s).exts_auth);
        gw_extensions_free((*s).exts_resp);
    }
    free(s as *mut libc::c_void);
}
#[no_mangle]
#[cold]
pub unsafe extern "C" fn gw_free(mut p_d: *mut libc::c_void) {
    let p: *mut gw_plugin_data = p_d as *mut gw_plugin_data;
    if ((*p).cvlist).is_null() {
        return;
    }
    let mut i: libc::c_int = ((*((*p).cvlist).offset(0 as libc::c_int as isize)).v.u2
        [1 as libc::c_int as usize]
        == 0) as libc::c_int;
    let mut used: libc::c_int = (*p).nconfig;
    while i < used {
        let mut cpv: *mut config_plugin_value_t = ((*p).cvlist)
            .offset((*((*p).cvlist).offset(i as isize)).v.u2[0 as libc::c_int as usize] as isize);
        while -(1 as libc::c_int) != (*cpv).k_id {
            match (*cpv).k_id {
                0 => {
                    if (*cpv).vtype as libc::c_uint == T_CONFIG_LOCAL as libc::c_int as libc::c_uint
                    {
                        gw_plugin_config_free((*cpv).v.v as *mut gw_plugin_config);
                    }
                }
                _ => {}
            }
            cpv = cpv.offset(1);
        }
        i += 1;
    }
}
#[no_mangle]
#[cold]
pub unsafe extern "C" fn gw_exts_clear_check_local(mut exts: *mut gw_exts) {
    let mut j: uint32_t = 0 as libc::c_int as uint32_t;
    while j < (*exts).used {
        let mut ex: *mut gw_extension = ((*exts).exts).offset(j as isize);
        let mut n: uint32_t = 0 as libc::c_int as uint32_t;
        while n < (*ex).used {
            (**((*ex).hosts).offset(n as isize)).check_local = 0 as libc::c_int as libc::c_ushort;
            n = n.wrapping_add(1);
        }
        j = j.wrapping_add(1);
    }
}
static mut cpk_2: [config_plugin_keys_t; 27] = [config_plugin_keys_t {
    k: 0 as *const libc::c_char,
    klen: 0,
    ktype: 0,
    scope: 0,
}; 27];
static mut lhost: buffer = buffer {
    ptr: 0 as *const libc::c_char as *mut libc::c_char,
    used: 0,
    size: 0,
};
#[no_mangle]
#[cold]
pub unsafe extern "C" fn gw_set_defaults_backend(
    mut srv: *mut server,
    mut p: *mut gw_plugin_data,
    mut a: *const array,
    mut s: *mut gw_plugin_config,
    mut sh_exec: libc::c_int,
    mut cpkkey: *const libc::c_char,
) -> libc::c_int {
    let mut current_block: u64;
    let mut host: *mut gw_host = 0 as *mut gw_host;
    let mut graceful_restart_bg: libc::c_int = config_feature_bool(
        srv,
        b"server.graceful-restart-bg\0" as *const u8 as *const libc::c_char,
        0 as libc::c_int,
    );
    (*p).srv_pid = (*srv).pid;
    (*s).exts = gw_extensions_init();
    (*s).exts_auth = gw_extensions_init();
    (*s).exts_resp = gw_extensions_init();
    let mut j: uint32_t = 0 as libc::c_int as uint32_t;
    's_20: loop {
        if !(j < (*a).used) {
            current_block = 13257343756837063659;
            break;
        }
        let mut da_ext: *mut data_array = *((*a).data).offset(j as isize) as *mut data_array;
        let mut n: uint32_t = 0 as libc::c_int as uint32_t;
        while n < (*da_ext).value.used {
            let da_host: *mut data_array =
                *((*da_ext).value.data).offset(n as isize) as *mut data_array;
            if (*da_host).type_0 as libc::c_uint != TYPE_ARRAY as libc::c_int as libc::c_uint
                || array_is_kvany(&mut (*da_host).value) == 0
            {
                log_error(
                    (*srv).errh,
                    b"/home/kkysen/work/rust/lighttpd/src/gw_backend.c\0" as *const u8
                        as *const libc::c_char,
                    1378 as libc::c_int as libc::c_uint,
                    b"unexpected value for gw.server near [%s](string); expected ( \"ext\" => ( \"backend-label\" => ( \"key\" => \"value\" )))\0"
                        as *const u8 as *const libc::c_char,
                    if !((*da_host).key.ptr).is_null() {
                        (*da_host).key.ptr as *const libc::c_char
                    } else {
                        b"\0" as *const u8 as *const libc::c_char
                    },
                );
                current_block = 8397040453240005869;
                break 's_20;
            } else {
                let mut cvlist: [config_plugin_value_t; 28] = [config_plugin_value_t {
                    k_id: 0,
                    vtype: T_CONFIG_UNSET,
                    v: v_u {
                        v: 0 as *mut libc::c_void,
                    },
                }; 28];
                memset(
                    cvlist.as_mut_ptr() as *mut libc::c_void,
                    0 as libc::c_int,
                    ::core::mem::size_of::<[config_plugin_value_t; 28]>() as libc::c_ulong,
                );
                let mut ca: *mut array = &mut (*da_host).value;
                if config_plugin_values_init_block(
                    srv,
                    ca,
                    cpk_2.as_ptr(),
                    cpkkey,
                    cvlist.as_mut_ptr(),
                ) == 0
                {
                    current_block = 8397040453240005869;
                    break 's_20;
                }
                let mut host_mode: libc::c_ushort = 1 as libc::c_int as libc::c_ushort;
                host = gw_host_init();
                (*host).id = &mut (*da_host).key;
                (*host).check_local = 1 as libc::c_int as libc::c_ushort;
                (*host).min_procs = 4 as libc::c_int as libc::c_ushort;
                (*host).max_procs = 4 as libc::c_int as libc::c_ushort;
                (*host).max_load_per_proc = 1 as libc::c_int as libc::c_ushort;
                (*host).idle_timeout = 60 as libc::c_int as libc::c_ushort;
                (*host).connect_timeout = 8 as libc::c_int as libc::c_ushort;
                (*host).disable_time = 1 as libc::c_int as libc::c_ushort;
                (*host).break_scriptfilename_for_php = 0 as libc::c_int as libc::c_ushort;
                (*host).kill_signal = 15 as libc::c_int as libc::c_ushort;
                (*host).fix_root_path_name = 0 as libc::c_int as libc::c_ushort;
                (*host).listen_backlog = 1024 as libc::c_int;
                (*host).xsendfile_allow = 0 as libc::c_int as libc::c_ushort;
                (*host).refcount = 0 as libc::c_int;
                let mut cpv: *mut config_plugin_value_t = cvlist.as_mut_ptr();
                while -(1 as libc::c_int) != (*cpv).k_id {
                    match (*cpv).k_id {
                        0 => {
                            if buffer_is_blank((*cpv).v.b) == 0 {
                                (*host).host = (*cpv).v.b;
                            }
                        }
                        1 => {
                            (*host).port = (*cpv).v.shrt;
                        }
                        2 => {
                            if buffer_is_blank((*cpv).v.b) == 0 {
                                (*host).unixsocket = (*cpv).v.b;
                            }
                        }
                        3 => {
                            (*host).listen_backlog = (*cpv).v.u as libc::c_int;
                        }
                        4 => {
                            if buffer_is_blank((*cpv).v.b) == 0 {
                                (*host).bin_path = (*cpv).v.b;
                            }
                        }
                        5 => {
                            (*host).kill_signal = (*cpv).v.shrt;
                        }
                        6 => {
                            (*host).check_local = (0 as libc::c_int as libc::c_uint != (*cpv).v.u)
                                as libc::c_int
                                as libc::c_ushort;
                        }
                        7 => {
                            if buffer_is_blank((*cpv).v.b) == 0 {
                                let mut b: *const buffer = (*cpv).v.b;
                                if buffer_eq_slen(
                                    b,
                                    b"responder\0" as *const u8 as *const libc::c_char,
                                    (::core::mem::size_of::<[libc::c_char; 10]>() as libc::c_ulong
                                        as uint32_t)
                                        .wrapping_sub(1 as libc::c_int as libc::c_uint)
                                        as size_t,
                                ) != 0
                                {
                                    host_mode = 1 as libc::c_int as libc::c_ushort;
                                } else if buffer_eq_slen(
                                    b,
                                    b"authorizer\0" as *const u8 as *const libc::c_char,
                                    (::core::mem::size_of::<[libc::c_char; 11]>() as libc::c_ulong
                                        as uint32_t)
                                        .wrapping_sub(1 as libc::c_int as libc::c_uint)
                                        as size_t,
                                ) != 0
                                {
                                    host_mode = 2 as libc::c_int as libc::c_ushort;
                                } else {
                                    log_error(
                                        (*srv).errh,
                                        b"/home/kkysen/work/rust/lighttpd/src/gw_backend.c\0"
                                            as *const u8 as *const libc::c_char,
                                        1446 as libc::c_int as libc::c_uint,
                                        b"WARNING: unknown gw mode: %s (ignored, mode set to responder)\0"
                                            as *const u8 as *const libc::c_char,
                                        (*b).ptr,
                                    );
                                }
                            }
                        }
                        8 => {
                            if buffer_is_blank((*cpv).v.b) == 0 {
                                (*host).docroot = (*cpv).v.b;
                            }
                        }
                        9 => {
                            (*host).min_procs = (*cpv).v.shrt;
                        }
                        10 => {
                            (*host).max_procs = (*cpv).v.shrt;
                        }
                        11 => {
                            (*host).max_load_per_proc = (*cpv).v.shrt;
                        }
                        12 => {
                            (*host).idle_timeout = (*cpv).v.shrt;
                        }
                        13 => {
                            (*host).disable_time = (*cpv).v.shrt;
                        }
                        14 => {
                            (*host).bin_env = (*cpv).v.a;
                        }
                        15 => {
                            (*host).bin_env_copy = (*cpv).v.a;
                        }
                        16 => {
                            (*host).break_scriptfilename_for_php =
                                (0 as libc::c_int as libc::c_uint != (*cpv).v.u) as libc::c_int
                                    as libc::c_ushort;
                        }
                        17 => {
                            (*host).strip_request_uri = (*cpv).v.b;
                            if buffer_has_slash_suffix((*host).strip_request_uri) != 0 {
                                let mut b_0: *mut buffer = 0 as *mut buffer;
                                let ref mut fresh205 =
                                    *(&mut b_0 as *mut *mut buffer as *mut *const buffer);
                                *fresh205 = (*host).strip_request_uri;
                                buffer_truncate(
                                    b_0,
                                    (buffer_clen(b_0))
                                        .wrapping_sub(1 as libc::c_int as libc::c_uint),
                                );
                            }
                        }
                        18 => {
                            (*host).fix_root_path_name =
                                (0 as libc::c_int as libc::c_uint != (*cpv).v.u) as libc::c_int
                                    as libc::c_ushort;
                        }
                        19 => {
                            (*host).xsendfile_allow =
                                (0 as libc::c_int as libc::c_uint != (*cpv).v.u) as libc::c_int
                                    as libc::c_ushort;
                        }
                        20 => {
                            (*host).xsendfile_allow =
                                (0 as libc::c_int as libc::c_uint != (*cpv).v.u) as libc::c_int
                                    as libc::c_ushort;
                        }
                        21 => {
                            (*host).xsendfile_docroot = (*cpv).v.a;
                            if (*(*cpv).v.a).used != 0 {
                                let mut k: uint32_t = 0 as libc::c_int as uint32_t;
                                while k < (*(*cpv).v.a).used {
                                    let mut ds: *mut data_string = *((*(*cpv).v.a).data)
                                        .offset(k as isize)
                                        as *mut data_string;
                                    if (*ds).type_0 as libc::c_uint
                                        != TYPE_STRING as libc::c_int as libc::c_uint
                                    {
                                        log_error(
                                            (*srv).errh,
                                            b"/home/kkysen/work/rust/lighttpd/src/gw_backend.c\0"
                                                as *const u8 as *const libc::c_char,
                                            1502 as libc::c_int as libc::c_uint,
                                            b"unexpected type for x-sendfile-docroot; expected: \"x-sendfile-docroot\" => ( \"/allowed/path\", ... )\0"
                                                as *const u8 as *const libc::c_char,
                                        );
                                        current_block = 8397040453240005869;
                                        break 's_20;
                                    } else if *((*ds).value.ptr).offset(0 as libc::c_int as isize)
                                        as libc::c_int
                                        != '/' as i32
                                    {
                                        log_error(
                                            (*srv).errh,
                                            b"/home/kkysen/work/rust/lighttpd/src/gw_backend.c\0"
                                                as *const u8 as *const libc::c_char,
                                            1509 as libc::c_int as libc::c_uint,
                                            b"x-sendfile-docroot paths must begin with '/'; invalid: \"%s\"\0"
                                                as *const u8 as *const libc::c_char,
                                            (*ds).value.ptr,
                                        );
                                        current_block = 8397040453240005869;
                                        break 's_20;
                                    } else {
                                        buffer_path_simplify(&mut (*ds).value);
                                        buffer_append_slash(&mut (*ds).value);
                                        k = k.wrapping_add(1);
                                    }
                                }
                            }
                        }
                        22 => {
                            (*host).tcp_fin_propagate =
                                (0 as libc::c_int as libc::c_uint != (*cpv).v.u) as libc::c_int
                                    as libc::c_ushort;
                        }
                        23 => {
                            (*host).connect_timeout = (*cpv).v.u as libc::c_ushort;
                        }
                        24 => {
                            (*host).write_timeout = (*cpv).v.u as libc::c_ushort;
                        }
                        25 => {
                            (*host).read_timeout = (*cpv).v.u as libc::c_ushort;
                        }
                        _ => {}
                    }
                    cpv = cpv.offset(1);
                }
                let mut m: uint32_t = 0 as libc::c_int as uint32_t;
                while m < (*da_host).value.used {
                    if !(strchr(
                        (**((*da_host).value.data).offset(m as isize)).key.ptr,
                        '_' as i32,
                    ))
                    .is_null()
                    {
                        log_error(
                            (*srv).errh,
                            b"/home/kkysen/work/rust/lighttpd/src/gw_backend.c\0"
                                as *const u8 as *const libc::c_char,
                            1538 as libc::c_int as libc::c_uint,
                            b"incorrect directive contains underscore ('_') instead of dash ('-'): %s\0"
                                as *const u8 as *const libc::c_char,
                            (**((*da_host).value.data).offset(m as isize)).key.ptr,
                        );
                    }
                    m = m.wrapping_add(1);
                }
                if (!((*host).host).is_null() || (*host).port as libc::c_int != 0)
                    && !((*host).unixsocket).is_null()
                {
                    log_error(
                        (*srv).errh,
                        b"/home/kkysen/work/rust/lighttpd/src/gw_backend.c\0" as *const u8
                            as *const libc::c_char,
                        1545 as libc::c_int as libc::c_uint,
                        b"either host/port or socket have to be set in: %s = (%s => (%s ( ...\0"
                            as *const u8 as *const libc::c_char,
                        cpkkey,
                        (*da_ext).key.ptr,
                        (*da_host).key.ptr,
                    );
                    current_block = 8397040453240005869;
                    break 's_20;
                } else {
                    if !((*host).host).is_null()
                        && *(*(*host).host).ptr as libc::c_int == '/' as i32
                        && ((*host).unixsocket).is_null()
                    {
                        (*host).unixsocket = (*host).host;
                    }
                    if !((*host).unixsocket).is_null() {
                        let mut un: sockaddr_un = sockaddr_un {
                            sun_family: 0,
                            sun_path: [0; 108],
                        };
                        if (buffer_clen((*host).unixsocket))
                            .wrapping_add(1 as libc::c_int as libc::c_uint)
                            as libc::c_ulong
                            > (::core::mem::size_of::<[libc::c_char; 108]>() as libc::c_ulong)
                                .wrapping_sub(2 as libc::c_int as libc::c_ulong)
                        {
                            log_error(
                                (*srv).errh,
                                b"/home/kkysen/work/rust/lighttpd/src/gw_backend.c\0" as *const u8
                                    as *const libc::c_char,
                                1562 as libc::c_int as libc::c_uint,
                                b"unixsocket is too long in: %s = (%s => (%s ( ...\0" as *const u8
                                    as *const libc::c_char,
                                cpkkey,
                                (*da_ext).key.ptr,
                                (*da_host).key.ptr,
                            );
                            current_block = 8397040453240005869;
                            break 's_20;
                        } else {
                            if !((*host).bin_path).is_null() {
                                let mut duplicate: *mut gw_host =
                                    unixsocket_is_dup(p, (*host).unixsocket);
                                if !duplicate.is_null() {
                                    if buffer_is_equal((*host).bin_path, (*duplicate).bin_path) == 0
                                    {
                                        log_error(
                                            (*srv).errh,
                                            b"/home/kkysen/work/rust/lighttpd/src/gw_backend.c\0"
                                                as *const u8
                                                as *const libc::c_char,
                                            1573 as libc::c_int as libc::c_uint,
                                            b"duplicate unixsocket path: %s\0" as *const u8
                                                as *const libc::c_char,
                                            (*(*host).unixsocket).ptr,
                                        );
                                        current_block = 8397040453240005869;
                                        break 's_20;
                                    } else {
                                        gw_host_free(host);
                                        host = duplicate;
                                        (*host).refcount += 1;
                                    }
                                }
                            }
                            (*host).family = 1 as libc::c_int as libc::c_ushort;
                        }
                    } else if ((*host).host).is_null() && ((*host).bin_path).is_null() {
                        log_error(
                            (*srv).errh,
                            b"/home/kkysen/work/rust/lighttpd/src/gw_backend.c\0" as *const u8
                                as *const libc::c_char,
                            1589 as libc::c_int as libc::c_uint,
                            b"host or bin-path have to be set in: %s = (%s => (%s ( ...\0"
                                as *const u8 as *const libc::c_char,
                            cpkkey,
                            (*da_ext).key.ptr,
                            (*da_host).key.ptr,
                        );
                        current_block = 8397040453240005869;
                        break 's_20;
                    } else {
                        if 0 as libc::c_int == (*host).port as libc::c_int {
                            (*host).port = 80 as libc::c_int as libc::c_ushort;
                        }
                        if ((*host).host).is_null() {
                            (*host).host = &lhost;
                        }
                        (*host).family = (if !(strchr((*(*host).host).ptr, ':' as i32)).is_null() {
                            10 as libc::c_int
                        } else {
                            2 as libc::c_int
                        }) as libc::c_ushort;
                    }
                    if (*host).refcount == 0 {
                        gw_status_init_host(host);
                    }
                    if !((*host).refcount != 0) {
                        if !((*host).bin_path).is_null() {
                            let mut st: stat = stat {
                                st_dev: 0,
                                st_ino: 0,
                                st_nlink: 0,
                                st_mode: 0,
                                st_uid: 0,
                                st_gid: 0,
                                __pad0: 0,
                                st_rdev: 0,
                                st_size: 0,
                                st_blksize: 0,
                                st_blocks: 0,
                                st_atim: timespec {
                                    tv_sec: 0,
                                    tv_nsec: 0,
                                },
                                st_mtim: timespec {
                                    tv_sec: 0,
                                    tv_nsec: 0,
                                },
                                st_ctim: timespec {
                                    tv_sec: 0,
                                    tv_nsec: 0,
                                },
                                __glibc_reserved: [0; 3],
                            };
                            parse_binpath(&mut (*host).args, (*host).bin_path);
                            if 0 as libc::c_int
                                != stat(
                                    *((*host).args.ptr).offset(0 as libc::c_int as isize),
                                    &mut st,
                                )
                                || !(st.st_mode & 0o170000 as libc::c_int as libc::c_uint
                                    == 0o100000 as libc::c_int as libc::c_uint)
                                || st.st_mode
                                    & (0o100 as libc::c_int
                                        | 0o100 as libc::c_int >> 3 as libc::c_int
                                        | 0o100 as libc::c_int
                                            >> 3 as libc::c_int
                                            >> 3 as libc::c_int)
                                        as libc::c_uint
                                    == 0
                            {
                                log_error(
                                    (*srv).errh,
                                    b"/home/kkysen/work/rust/lighttpd/src/gw_backend.c\0"
                                        as *const u8 as *const libc::c_char,
                                    1619 as libc::c_int as libc::c_uint,
                                    b"invalid \"bin-path\" => \"%s\" (check that file exists, is regular file, and is executable by lighttpd)\0"
                                        as *const u8 as *const libc::c_char,
                                    (*(*host).bin_path).ptr,
                                );
                            }
                            if sh_exec != 0 {
                                let mut m_0: uint32_t = 0 as libc::c_int as uint32_t;
                                while m_0 < (*host).args.used {
                                    free(*((*host).args.ptr).offset(m_0 as isize)
                                        as *mut libc::c_void);
                                    m_0 = m_0.wrapping_add(1);
                                }
                                free((*host).args.ptr as *mut libc::c_void);
                                (*host).args.ptr = calloc(
                                    4 as libc::c_int as libc::c_ulong,
                                    ::core::mem::size_of::<*mut libc::c_char>() as libc::c_ulong,
                                )
                                    as *mut *mut libc::c_char;
                                if ((*host).args.ptr).is_null() {
                                    ck_assert_failed(
                                        b"/home/kkysen/work/rust/lighttpd/src/gw_backend.c\0"
                                            as *const u8
                                            as *const libc::c_char,
                                        1634 as libc::c_int as libc::c_uint,
                                        b"host->args.ptr\0" as *const u8 as *const libc::c_char,
                                    );
                                }
                                (*host).args.used = 3 as libc::c_int as uint32_t;
                                (*host).args.size = 4 as libc::c_int as uint32_t;
                                let ref mut fresh206 =
                                    *((*host).args.ptr).offset(0 as libc::c_int as isize);
                                *fresh206 =
                                    malloc(::core::mem::size_of::<[libc::c_char; 8]>()
                                        as libc::c_ulong)
                                        as *mut libc::c_char;
                                if (*((*host).args.ptr).offset(0 as libc::c_int as isize)).is_null()
                                {
                                    ck_assert_failed(
                                        b"/home/kkysen/work/rust/lighttpd/src/gw_backend.c\0"
                                            as *const u8
                                            as *const libc::c_char,
                                        1638 as libc::c_int as libc::c_uint,
                                        b"host->args.ptr[0]\0" as *const u8 as *const libc::c_char,
                                    );
                                }
                                memcpy(
                                    *((*host).args.ptr).offset(0 as libc::c_int as isize)
                                        as *mut libc::c_void,
                                    b"/bin/sh\0" as *const u8 as *const libc::c_char
                                        as *const libc::c_void,
                                    ::core::mem::size_of::<[libc::c_char; 8]>() as libc::c_ulong,
                                );
                                let ref mut fresh207 =
                                    *((*host).args.ptr).offset(1 as libc::c_int as isize);
                                *fresh207 =
                                    malloc(::core::mem::size_of::<[libc::c_char; 3]>()
                                        as libc::c_ulong)
                                        as *mut libc::c_char;
                                if (*((*host).args.ptr).offset(1 as libc::c_int as isize)).is_null()
                                {
                                    ck_assert_failed(
                                        b"/home/kkysen/work/rust/lighttpd/src/gw_backend.c\0"
                                            as *const u8
                                            as *const libc::c_char,
                                        1641 as libc::c_int as libc::c_uint,
                                        b"host->args.ptr[1]\0" as *const u8 as *const libc::c_char,
                                    );
                                }
                                memcpy(
                                    *((*host).args.ptr).offset(1 as libc::c_int as isize)
                                        as *mut libc::c_void,
                                    b"-c\0" as *const u8 as *const libc::c_char
                                        as *const libc::c_void,
                                    ::core::mem::size_of::<[libc::c_char; 3]>() as libc::c_ulong,
                                );
                                let ref mut fresh208 =
                                    *((*host).args.ptr).offset(2 as libc::c_int as isize);
                                *fresh208 =
                                    malloc(
                                        (::core::mem::size_of::<[libc::c_char; 6]>()
                                            as libc::c_ulong)
                                            .wrapping_sub(1 as libc::c_int as libc::c_ulong)
                                            .wrapping_add(
                                                buffer_clen((*host).bin_path) as libc::c_ulong
                                            )
                                            .wrapping_add(1 as libc::c_int as libc::c_ulong),
                                    ) as *mut libc::c_char;
                                if (*((*host).args.ptr).offset(2 as libc::c_int as isize)).is_null()
                                {
                                    ck_assert_failed(
                                        b"/home/kkysen/work/rust/lighttpd/src/gw_backend.c\0"
                                            as *const u8
                                            as *const libc::c_char,
                                        1645 as libc::c_int as libc::c_uint,
                                        b"host->args.ptr[2]\0" as *const u8 as *const libc::c_char,
                                    );
                                }
                                memcpy(
                                    *((*host).args.ptr).offset(2 as libc::c_int as isize)
                                        as *mut libc::c_void,
                                    b"exec \0" as *const u8 as *const libc::c_char
                                        as *const libc::c_void,
                                    (::core::mem::size_of::<[libc::c_char; 6]>() as libc::c_ulong)
                                        .wrapping_sub(1 as libc::c_int as libc::c_ulong),
                                );
                                memcpy(
                                    (*((*host).args.ptr).offset(2 as libc::c_int as isize))
                                        .offset(::core::mem::size_of::<[libc::c_char; 6]>()
                                            as libc::c_ulong
                                            as isize)
                                        .offset(-(1 as libc::c_int as isize))
                                        as *mut libc::c_void,
                                    (*(*host).bin_path).ptr as *const libc::c_void,
                                    (buffer_clen((*host).bin_path))
                                        .wrapping_add(1 as libc::c_int as libc::c_uint)
                                        as libc::c_ulong,
                                );
                                let ref mut fresh209 =
                                    *((*host).args.ptr).offset(3 as libc::c_int as isize);
                                *fresh209 = 0 as *mut libc::c_char;
                            }
                            if (*host).min_procs as libc::c_int > (*host).max_procs as libc::c_int {
                                (*host).min_procs = (*host).max_procs;
                            }
                            if (*host).min_procs as libc::c_int != (*host).max_procs as libc::c_int
                                && 0 as libc::c_int != (*srv).srvconf.max_worker as libc::c_int
                            {
                                (*host).min_procs = (*host).max_procs;
                                log_error(
                                    (*srv).errh,
                                    b"/home/kkysen/work/rust/lighttpd/src/gw_backend.c\0"
                                        as *const u8 as *const libc::c_char,
                                    1657 as libc::c_int as libc::c_uint,
                                    b"adaptive backend spawning disabled (server.max_worker is non-zero)\0"
                                        as *const u8 as *const libc::c_char,
                                );
                            }
                            if ((*host).max_load_per_proc as libc::c_int) < 1 as libc::c_int {
                                (*host).max_load_per_proc = 0 as libc::c_int as libc::c_ushort;
                            }
                            if (*s).debug != 0 {
                                log_error(
                                    (*srv).errh,
                                    b"/home/kkysen/work/rust/lighttpd/src/gw_backend.c\0"
                                        as *const u8 as *const libc::c_char,
                                    1665 as libc::c_int as libc::c_uint,
                                    b"--- gw spawning local\n\tproc: %s\n\tport: %hu\n\tsocket %s\n\tmin-procs: %d\n\tmax-procs: %d\0"
                                        as *const u8 as *const libc::c_char,
                                    (*(*host).bin_path).ptr,
                                    (*host).port as libc::c_int,
                                    if !((*host).unixsocket).is_null() {
                                        (*(*host).unixsocket).ptr as *const libc::c_char
                                    } else {
                                        b"\0" as *const u8 as *const libc::c_char
                                    },
                                    (*host).min_procs as libc::c_int,
                                    (*host).max_procs as libc::c_int,
                                );
                            }
                            let mut pno: uint32_t = 0 as libc::c_int as uint32_t;
                            while pno < (*host).min_procs as libc::c_uint {
                                let proc_0: *mut gw_proc = gw_proc_init(host);
                                if (*s).debug != 0 {
                                    log_error(
                                        (*srv).errh,
                                        b"/home/kkysen/work/rust/lighttpd/src/gw_backend.c\0"
                                            as *const u8 as *const libc::c_char,
                                        1683 as libc::c_int as libc::c_uint,
                                        b"--- gw spawning\n\tport: %hu\n\tsocket %s\n\tcurrent: %u / %u\0"
                                            as *const u8 as *const libc::c_char,
                                        (*host).port as libc::c_int,
                                        if !((*host).unixsocket).is_null() {
                                            (*(*host).unixsocket).ptr as *const libc::c_char
                                        } else {
                                            b"\0" as *const u8 as *const libc::c_char
                                        },
                                        pno,
                                        (*host).max_procs as libc::c_int,
                                    );
                                }
                                if 0 as libc::c_int
                                    != gw_proc_sockaddr_init(host, proc_0, (*srv).errh)
                                {
                                    gw_proc_free(proc_0);
                                    current_block = 8397040453240005869;
                                    break 's_20;
                                } else if (*srv).srvconf.preflight_check == 0
                                    && gw_spawn_connection(host, proc_0, (*srv).errh, (*s).debug)
                                        != 0
                                {
                                    log_error(
                                        (*srv).errh,
                                        b"/home/kkysen/work/rust/lighttpd/src/gw_backend.c\0"
                                            as *const u8
                                            as *const libc::c_char,
                                        1700 as libc::c_int as libc::c_uint,
                                        b"[ERROR]: spawning gw failed.\0" as *const u8
                                            as *const libc::c_char,
                                    );
                                    gw_proc_free(proc_0);
                                    current_block = 8397040453240005869;
                                    break 's_20;
                                } else {
                                    (*proc_0).next = (*host).first;
                                    if !((*host).first).is_null() {
                                        (*(*host).first).prev = proc_0;
                                    }
                                    (*host).first = proc_0;
                                    (*host).num_procs = ((*host).num_procs).wrapping_add(1);
                                    pno = pno.wrapping_add(1);
                                }
                            }
                            if graceful_restart_bg != 0 {
                                graceful_restart_bg = 0 as libc::c_int;
                                log_error(
                                    (*srv).errh,
                                    b"/home/kkysen/work/rust/lighttpd/src/gw_backend.c\0"
                                        as *const u8 as *const libc::c_char,
                                    1715 as libc::c_int as libc::c_uint,
                                    b"server.graceful-restart-bg disabled (incompatible with %s.server \"bin-path\")\0"
                                        as *const u8 as *const libc::c_char,
                                    (*(*p).self_0).name,
                                );
                                let du: *mut data_unset = array_get_data_unset(
                                    (*srv).srvconf.feature_flags,
                                    b"server.graceful-restart-bg\0" as *const u8
                                        as *const libc::c_char,
                                    (::core::mem::size_of::<[libc::c_char; 27]>() as libc::c_ulong
                                        as uint32_t)
                                        .wrapping_sub(1 as libc::c_int as libc::c_uint),
                                );
                                if (*du).type_0 as libc::c_uint
                                    == TYPE_STRING as libc::c_int as libc::c_uint
                                {
                                    buffer_copy_string_len(
                                        &mut (*(du as *mut data_string)).value,
                                        b"false\0" as *const u8 as *const libc::c_char,
                                        (::core::mem::size_of::<[libc::c_char; 6]>()
                                            as libc::c_ulong
                                            as uint32_t)
                                            .wrapping_sub(1 as libc::c_int as libc::c_uint)
                                            as size_t,
                                    );
                                } else {
                                    (*(du as *mut data_integer)).value = 0 as libc::c_int;
                                }
                            }
                        } else {
                            let proc_1: *mut gw_proc = gw_proc_init(host);
                            (*host).first = proc_1;
                            (*host).num_procs = ((*host).num_procs).wrapping_add(1);
                            (*host).min_procs = 1 as libc::c_int as libc::c_ushort;
                            (*host).max_procs = 1 as libc::c_int as libc::c_ushort;
                            if 0 as libc::c_int != gw_proc_sockaddr_init(host, proc_1, (*srv).errh)
                            {
                                current_block = 8397040453240005869;
                                break 's_20;
                            }
                            gw_proc_set_state(host, proc_1, PROC_STATE_RUNNING as libc::c_int);
                        }
                    }
                    let h: *const buffer = if !((*host).host).is_null() {
                        (*host).host
                    } else {
                        (*host).unixsocket
                    };
                    (*host).gw_hash =
                        gw_hash((*h).ptr, buffer_clen(h), 5381 as libc::c_int as uint32_t);
                    gw_extension_insert((*s).exts, &mut (*da_ext).key, host);
                    if host_mode as libc::c_int == 2 as libc::c_int {
                        (*host).refcount += 1;
                        gw_extension_insert((*s).exts_auth, &mut (*da_ext).key, host);
                    } else if host_mode as libc::c_int == 1 as libc::c_int {
                        (*host).refcount += 1;
                        gw_extension_insert((*s).exts_resp, &mut (*da_ext).key, host);
                    }
                    host = 0 as *mut gw_host;
                    n = n.wrapping_add(1);
                }
            }
        }
        j = j.wrapping_add(1);
    }
    match current_block {
        13257343756837063659 => return 1 as libc::c_int,
        _ => {
            if !host.is_null() {
                gw_host_free(host);
            }
            return 0 as libc::c_int;
        }
    };
}
#[no_mangle]
#[cold]
pub unsafe extern "C" fn gw_get_defaults_balance(
    mut srv: *mut server,
    mut b: *const buffer,
) -> libc::c_int {
    if b.is_null() || buffer_is_blank(b) != 0 {
        return GW_BALANCE_LEAST_CONNECTION as libc::c_int;
    }
    if buffer_eq_slen(
        b,
        b"fair\0" as *const u8 as *const libc::c_char,
        (::core::mem::size_of::<[libc::c_char; 5]>() as libc::c_ulong as uint32_t)
            .wrapping_sub(1 as libc::c_int as libc::c_uint) as size_t,
    ) != 0
    {
        return GW_BALANCE_LEAST_CONNECTION as libc::c_int;
    }
    if buffer_eq_slen(
        b,
        b"least-connection\0" as *const u8 as *const libc::c_char,
        (::core::mem::size_of::<[libc::c_char; 17]>() as libc::c_ulong as uint32_t)
            .wrapping_sub(1 as libc::c_int as libc::c_uint) as size_t,
    ) != 0
    {
        return GW_BALANCE_LEAST_CONNECTION as libc::c_int;
    }
    if buffer_eq_slen(
        b,
        b"round-robin\0" as *const u8 as *const libc::c_char,
        (::core::mem::size_of::<[libc::c_char; 12]>() as libc::c_ulong as uint32_t)
            .wrapping_sub(1 as libc::c_int as libc::c_uint) as size_t,
    ) != 0
    {
        return GW_BALANCE_RR as libc::c_int;
    }
    if buffer_eq_slen(
        b,
        b"hash\0" as *const u8 as *const libc::c_char,
        (::core::mem::size_of::<[libc::c_char; 5]>() as libc::c_ulong as uint32_t)
            .wrapping_sub(1 as libc::c_int as libc::c_uint) as size_t,
    ) != 0
    {
        return GW_BALANCE_HASH as libc::c_int;
    }
    if buffer_eq_slen(
        b,
        b"sticky\0" as *const u8 as *const libc::c_char,
        (::core::mem::size_of::<[libc::c_char; 7]>() as libc::c_ulong as uint32_t)
            .wrapping_sub(1 as libc::c_int as libc::c_uint) as size_t,
    ) != 0
    {
        return GW_BALANCE_STICKY as libc::c_int;
    }
    log_error(
        (*srv).errh,
        b"/home/kkysen/work/rust/lighttpd/src/gw_backend.c\0" as *const u8
            as *const libc::c_char,
        1789 as libc::c_int as libc::c_uint,
        b"xxxxx.balance has to be one of: least-connection, round-robin, hash, sticky, but not: %s\0"
            as *const u8 as *const libc::c_char,
        (*b).ptr,
    );
    return GW_BALANCE_LEAST_CONNECTION as libc::c_int;
}
unsafe extern "C" fn gw_set_state(mut hctx: *mut gw_handler_ctx, mut state: gw_connection_state_t) {
    (*hctx).state = state;
}
#[no_mangle]
pub unsafe extern "C" fn gw_set_transparent(mut hctx: *mut gw_handler_ctx) {
    if 1 as libc::c_int != (*(*hctx).host).family as libc::c_int {
        -(1 as libc::c_int) == fdevent_set_tcp_nodelay((*hctx).fd, 1 as libc::c_int);
    }
    (*hctx).wb_reqlen = -(1 as libc::c_int) as off_t;
    gw_set_state(hctx, GW_STATE_WRITE);
}
unsafe extern "C" fn gw_host_hctx_enq(hctx: *mut gw_handler_ctx) {
    let host: *mut gw_host = (*hctx).host;
    (*hctx).prev = 0 as *mut gw_handler_ctx;
    (*hctx).next = (*host).hctxs;
    if !((*hctx).next).is_null() {
        (*(*hctx).next).prev = hctx;
    }
    (*host).hctxs = hctx;
}
unsafe extern "C" fn gw_host_hctx_deq(hctx: *mut gw_handler_ctx) {
    if !((*hctx).prev).is_null() {
        (*(*hctx).prev).next = (*hctx).next;
    } else {
        (*(*hctx).host).hctxs = (*hctx).next;
    }
    if !((*hctx).next).is_null() {
        (*(*hctx).next).prev = (*hctx).prev;
    }
    (*hctx).next = 0 as *mut gw_handler_ctx;
    (*hctx).prev = 0 as *mut gw_handler_ctx;
}
unsafe extern "C" fn gw_backend_close(hctx: *mut gw_handler_ctx, r: *mut request_st) {
    if (*hctx).fd >= 0 as libc::c_int {
        fdevent_fdnode_event_del((*hctx).ev, (*hctx).fdn);
        fdevent_sched_close((*hctx).ev, (*hctx).fd, 1 as libc::c_int);
        (*hctx).fdn = 0 as *mut fdnode;
        (*hctx).fd = -(1 as libc::c_int);
        gw_host_hctx_deq(hctx);
    }
    if !((*hctx).host).is_null() {
        if !((*hctx).proc_0).is_null() {
            gw_proc_release(
                (*hctx).host,
                (*hctx).proc_0,
                (*hctx).conf.debug,
                (*r).conf.errh,
            );
            (*hctx).proc_0 = 0 as *mut gw_proc;
        }
        gw_host_reset((*hctx).host);
        (*hctx).host = 0 as *mut gw_host;
    }
}
unsafe extern "C" fn gw_connection_close(hctx: *mut gw_handler_ctx, r: *mut request_st) {
    let mut p: *mut gw_plugin_data = (*hctx).plugin_data;
    gw_backend_close(hctx, r);
    handler_ctx_free(hctx);
    let ref mut fresh210 = *((*r).plugin_ctx).offset((*p).id as isize);
    *fresh210 = 0 as *mut libc::c_void;
    if (*r).handler_module == (*p).self_0 as *const plugin {
        http_response_backend_done(r);
    }
}
unsafe extern "C" fn gw_reconnect(hctx: *mut gw_handler_ctx, r: *mut request_st) -> handler_t {
    gw_backend_close(hctx, r);
    (*hctx).host = gw_host_get(r, (*hctx).ext, (*hctx).conf.balance, (*hctx).conf.debug);
    if ((*hctx).host).is_null() {
        return HANDLER_FINISHED;
    }
    gw_host_assign((*hctx).host);
    (*hctx).request_id = 0 as libc::c_int;
    (*hctx).opts.xsendfile_allow = (*(*hctx).host).xsendfile_allow as uint8_t;
    (*hctx).opts.xsendfile_docroot = (*(*hctx).host).xsendfile_docroot;
    gw_set_state(hctx, GW_STATE_INIT);
    return HANDLER_COMEBACK;
}
#[no_mangle]
pub unsafe extern "C" fn gw_handle_request_reset(
    r: *mut request_st,
    mut p_d: *mut libc::c_void,
) -> handler_t {
    let mut p: *mut gw_plugin_data = p_d as *mut gw_plugin_data;
    let mut hctx: *mut gw_handler_ctx =
        *((*r).plugin_ctx).offset((*p).id as isize) as *mut gw_handler_ctx;
    if !hctx.is_null() {
        gw_connection_close(hctx, r);
    }
    return HANDLER_GO_ON;
}
#[cold]
unsafe extern "C" fn gw_conditional_tcp_fin(hctx: *mut gw_handler_ctx, r: *mut request_st) {
    if chunkqueue_is_empty(&mut (*hctx).wb) == 0 {
        return;
    }
    if (*(*hctx).host).tcp_fin_propagate == 0 {
        return;
    }
    if (*hctx).gw_mode as libc::c_int == 2 as libc::c_int {
        return;
    }
    if (*r).conf.stream_request_body as libc::c_int & (1 as libc::c_int) << 14 as libc::c_int != 0 {
        return;
    }
    (*r).conf.stream_request_body = ((*r).conf.stream_request_body as libc::c_int
        | (1 as libc::c_int) << 14 as libc::c_int)
        as libc::c_ushort;
    (*r).conf.stream_request_body = ((*r).conf.stream_request_body as libc::c_int
        & !((1 as libc::c_int) << 15 as libc::c_int))
        as libc::c_ushort;
    (*(*r).con).is_readable = 0 as libc::c_int as libc::c_schar;
    shutdown((*hctx).fd, SHUT_WR as libc::c_int);
    fdevent_fdnode_event_clr((*hctx).ev, (*hctx).fdn, 0x4 as libc::c_int);
}
unsafe extern "C" fn gw_write_request(hctx: *mut gw_handler_ctx, r: *mut request_st) -> handler_t {
    let mut current_block_94: u64;
    match (*hctx).state as libc::c_uint {
        0 => {
            (*hctx).proc_0 = 0 as *mut gw_proc;
            let mut proc_0: *mut gw_proc = (*(*hctx).host).first;
            while !proc_0.is_null() {
                if (*proc_0).state as libc::c_uint
                    == PROC_STATE_RUNNING as libc::c_int as libc::c_uint
                {
                    (*hctx).proc_0 = proc_0;
                    break;
                } else {
                    proc_0 = (*proc_0).next;
                }
            }
            if ((*hctx).proc_0).is_null() {
                return HANDLER_ERROR;
            }
            let mut proc_1: *mut gw_proc = (*(*hctx).proc_0).next;
            while !proc_1.is_null() {
                if !((*proc_1).state as libc::c_uint
                    != PROC_STATE_RUNNING as libc::c_int as libc::c_uint)
                {
                    if (*proc_1).load < (*(*hctx).proc_0).load {
                        (*hctx).proc_0 = proc_1;
                    }
                }
                proc_1 = (*proc_1).next;
            }
            gw_proc_load_inc((*hctx).host, (*hctx).proc_0);
            (*hctx).fd = fdevent_socket_nb_cloexec(
                (*(*hctx).host).family as libc::c_int,
                SOCK_STREAM as libc::c_int,
                0 as libc::c_int,
            );
            if -(1 as libc::c_int) == (*hctx).fd {
                log_perror(
                    (*r).conf.errh,
                    b"/home/kkysen/work/rust/lighttpd/src/gw_backend.c\0" as *const u8
                        as *const libc::c_char,
                    1944 as libc::c_int as libc::c_uint,
                    b"socket() failed (cur_fds:%d) (max_fds:%d)\0" as *const u8
                        as *const libc::c_char,
                    (*(*(*r).con).srv).cur_fds,
                    (*(*(*r).con).srv).max_fds,
                );
                return HANDLER_ERROR;
            }
            (*(*(*r).con).srv).cur_fds += 1;
            (*hctx).fdn = fdevent_register(
                (*hctx).ev,
                (*hctx).fd,
                Some(
                    gw_handle_fdevent
                        as unsafe extern "C" fn(*mut libc::c_void, libc::c_int) -> handler_t,
                ),
                hctx as *mut libc::c_void,
            );
            if (*(*hctx).proc_0).is_local != 0 {
                (*hctx).pid = (*(*hctx).proc_0).pid;
            }
            (*hctx).write_ts = log_monotonic_secs;
            gw_host_hctx_enq(hctx);
            match gw_establish_connection(
                r,
                (*hctx).host,
                (*hctx).proc_0,
                (*hctx).pid,
                (*hctx).fd,
                (*hctx).conf.debug,
            ) {
                1 => {
                    fdevent_fdnode_event_set((*hctx).ev, (*hctx).fdn, 0x4 as libc::c_int);
                    gw_set_state(hctx, GW_STATE_CONNECT_DELAYED);
                    return HANDLER_WAIT_FOR_EVENT;
                }
                -1 => return HANDLER_ERROR,
                0 => {
                    (*hctx).reconnects = 0 as libc::c_int;
                }
                _ => {}
            }
            current_block_94 = 8145037607638107563;
        }
        1 => {
            current_block_94 = 8145037607638107563;
        }
        2 => {
            current_block_94 = 6036916031263781354;
        }
        3 => {
            current_block_94 = 12078813031401261177;
        }
        4 => return HANDLER_WAIT_FOR_EVENT,
        _ => {
            log_error(
                (*r).conf.errh,
                b"/home/kkysen/work/rust/lighttpd/src/gw_backend.c\0" as *const u8
                    as *const libc::c_char,
                2091 as libc::c_int as libc::c_uint,
                b"(debug) unknown state\0" as *const u8 as *const libc::c_char,
            );
            return HANDLER_ERROR;
        }
    }
    match current_block_94 {
        8145037607638107563 => {
            if (*hctx).state as libc::c_uint
                == GW_STATE_CONNECT_DELAYED as libc::c_int as libc::c_uint
            {
                let mut socket_error: libc::c_int = fdevent_connect_status((*hctx).fd);
                if socket_error != 0 as libc::c_int {
                    gw_proc_connect_error(
                        r,
                        (*hctx).host,
                        (*hctx).proc_0,
                        (*hctx).pid,
                        socket_error,
                        (*hctx).conf.debug,
                    );
                    return HANDLER_ERROR;
                }
                (*hctx).write_ts = log_monotonic_secs;
            }
            gw_proc_connect_success((*hctx).host, (*hctx).proc_0, (*hctx).conf.debug, r);
            gw_set_state(hctx, GW_STATE_PREPARE_WRITE);
            current_block_94 = 6036916031263781354;
        }
        _ => {}
    }
    match current_block_94 {
        6036916031263781354 => {
            let mut rc: handler_t = ((*hctx).create_env).expect("non-null function pointer")(hctx);
            if HANDLER_GO_ON as libc::c_int as libc::c_uint != rc as libc::c_uint {
                if HANDLER_FINISHED as libc::c_int as libc::c_uint != rc as libc::c_uint
                    && HANDLER_ERROR as libc::c_int as libc::c_uint != rc as libc::c_uint
                {
                    fdevent_fdnode_event_clr((*hctx).ev, (*hctx).fdn, 0x4 as libc::c_int);
                }
                return rc;
            }
            if 1 as libc::c_int != (*(*hctx).host).family as libc::c_int {
                if (*r).reqbody_length < 0 as libc::c_int as libc::c_long {
                    -(1 as libc::c_int) == fdevent_set_tcp_nodelay((*hctx).fd, 1 as libc::c_int);
                }
            }
            (*hctx).read_ts = log_monotonic_secs;
            fdevent_fdnode_event_add(
                (*hctx).ev,
                (*hctx).fdn,
                0x1 as libc::c_int | 0x2000 as libc::c_int,
            );
            gw_set_state(hctx, GW_STATE_WRITE);
        }
        _ => {}
    }
    if chunkqueue_is_empty(&mut (*hctx).wb) == 0 {
        let errh: *mut log_error_st = (*r).conf.errh;
        let mut bytes_out: off_t = (*hctx).wb.bytes_out;
        if ((*(*(*r).con).srv).network_backend_write).expect("non-null function pointer")(
            (*hctx).fd,
            &mut (*hctx).wb,
            (256 as libc::c_int * 1024 as libc::c_int) as off_t,
            errh,
        ) < 0 as libc::c_int
        {
            match *__errno_location() {
                32 | 107 | 104 => {
                    log_error(
                        errh,
                        b"/home/kkysen/work/rust/lighttpd/src/gw_backend.c\0"
                            as *const u8 as *const libc::c_char,
                        2035 as libc::c_int as libc::c_uint,
                        b"connection was dropped after accept() (perhaps the gw process died), write-offset: %lld socket: %s\0"
                            as *const u8 as *const libc::c_char,
                        (*hctx).wb.bytes_out as libc::c_longlong,
                        (*(*(*hctx).proc_0).connection_name).ptr,
                    );
                    return HANDLER_ERROR;
                }
                _ => {
                    log_perror(
                        errh,
                        b"/home/kkysen/work/rust/lighttpd/src/gw_backend.c\0" as *const u8
                            as *const libc::c_char,
                        2043 as libc::c_int as libc::c_uint,
                        b"write failed\0" as *const u8 as *const libc::c_char,
                    );
                    return HANDLER_ERROR;
                }
            }
        } else {
            if (*hctx).wb.bytes_out > bytes_out {
                (*(*hctx).proc_0).last_used = log_monotonic_secs;
                (*hctx).write_ts = (*(*hctx).proc_0).last_used;
                if ((*hctx).stdin_append).is_some()
                    && chunkqueue_length(&mut (*hctx).wb)
                        < (65536 as libc::c_int - 16384 as libc::c_int) as libc::c_long
                    && chunkqueue_is_empty(&mut (*r).reqbody_queue) == 0
                {
                    let mut rc_0: handler_t =
                        ((*hctx).stdin_append).expect("non-null function pointer")(hctx);
                    if HANDLER_GO_ON as libc::c_int as libc::c_uint != rc_0 as libc::c_uint {
                        return rc_0;
                    }
                }
            }
        }
    }
    if (*hctx).wb.bytes_out == (*hctx).wb_reqlen {
        fdevent_fdnode_event_clr((*hctx).ev, (*hctx).fdn, 0x4 as libc::c_int);
        gw_set_state(hctx, GW_STATE_READ);
    } else {
        let mut wblen: off_t = chunkqueue_length(&mut (*hctx).wb);
        if ((*hctx).wb.bytes_in < (*hctx).wb_reqlen
            || (*hctx).wb_reqlen < 0 as libc::c_int as libc::c_long)
            && wblen < (65536 as libc::c_int - 16384 as libc::c_int) as libc::c_long
        {
            if (*r).conf.stream_request_body as libc::c_int
                & (1 as libc::c_int) << 15 as libc::c_int
                == 0
            {
                (*r).conf.stream_request_body = ((*r).conf.stream_request_body as libc::c_int
                    | (1 as libc::c_int) << 15 as libc::c_int)
                    as libc::c_ushort;
                (*(*r).con).is_readable = 1 as libc::c_int as libc::c_schar;
            }
        }
        if 0 as libc::c_int as libc::c_long == wblen {
            fdevent_fdnode_event_clr((*hctx).ev, (*hctx).fdn, 0x4 as libc::c_int);
        } else if (if !((*hctx).fdn).is_null() {
            (*(*hctx).fdn).events
        } else {
            0 as libc::c_int
        }) & 0x4 as libc::c_int
            == 0
        {
            (*hctx).write_ts = log_monotonic_secs;
            fdevent_fdnode_event_add((*hctx).ev, (*hctx).fdn, 0x4 as libc::c_int);
        }
    }
    if (*r).conf.stream_request_body as libc::c_int & (1 as libc::c_int) << 13 as libc::c_int != 0 {
        gw_conditional_tcp_fin(hctx, r);
    }
    return HANDLER_WAIT_FOR_EVENT;
}
#[cold]
#[inline(never)]
unsafe extern "C" fn gw_backend_error(hctx: *mut gw_handler_ctx, r: *mut request_st) -> handler_t {
    if ((*hctx).backend_error).is_some() {
        ((*hctx).backend_error).expect("non-null function pointer")(hctx);
    }
    http_response_backend_error(r);
    gw_connection_close(hctx, r);
    return HANDLER_FINISHED;
}
#[cold]
unsafe extern "C" fn gw_write_error(hctx: *mut gw_handler_ctx, r: *mut request_st) -> handler_t {
    if (*hctx).state as libc::c_uint == GW_STATE_INIT as libc::c_int as libc::c_uint
        || (*hctx).state as libc::c_uint == GW_STATE_CONNECT_DELAYED as libc::c_int as libc::c_uint
    {
        if !((*hctx).proc_0).is_null() && (*(*hctx).proc_0).is_local != 0 {
            let srv: *mut server = (*(*r).con).srv;
            if 0 as libc::c_int == (*srv).srvconf.max_worker as libc::c_int {
                gw_restart_dead_procs(
                    (*hctx).host,
                    (*srv).errh,
                    (*hctx).conf.debug,
                    0 as libc::c_int,
                );
            }
        }
        let fresh211 = (*hctx).reconnects;
        (*hctx).reconnects = (*hctx).reconnects + 1;
        if fresh211 < 5 as libc::c_int {
            return gw_reconnect(hctx, r);
        }
    } else {
        let mut rc: handler_t = gw_recv_response(hctx, r);
        if rc as libc::c_uint != HANDLER_GO_ON as libc::c_int as libc::c_uint {
            return rc;
        }
    }
    if (*r).resp_body_started == 0
        && (*r).http_status < 500 as libc::c_int
        && (*r).http_status != 400 as libc::c_int
    {
        (*r).http_status = 503 as libc::c_int;
    }
    return gw_backend_error(hctx, r);
}
unsafe extern "C" fn gw_send_request(hctx: *mut gw_handler_ctx, r: *mut request_st) -> handler_t {
    let mut rc: handler_t = gw_write_request(hctx, r);
    return (if HANDLER_ERROR as libc::c_int as libc::c_uint != rc as libc::c_uint {
        rc as libc::c_uint
    } else {
        gw_write_error(hctx, r) as libc::c_uint
    }) as handler_t;
}
#[no_mangle]
pub unsafe extern "C" fn gw_handle_subrequest(
    r: *mut request_st,
    mut p_d: *mut libc::c_void,
) -> handler_t {
    let mut p: *mut gw_plugin_data = p_d as *mut gw_plugin_data;
    let mut hctx: *mut gw_handler_ctx =
        *((*r).plugin_ctx).offset((*p).id as isize) as *mut gw_handler_ctx;
    if hctx.is_null() {
        return HANDLER_GO_ON;
    }
    let revents: libc::c_int = (*hctx).revents;
    if revents != 0 {
        (*hctx).revents = 0 as libc::c_int;
        let mut rc: handler_t = gw_process_fdevent(hctx, r, revents);
        if rc as libc::c_uint != HANDLER_GO_ON as libc::c_int as libc::c_uint
            && rc as libc::c_uint != HANDLER_WAIT_FOR_EVENT as libc::c_int as libc::c_uint
        {
            return rc;
        }
    }
    if (*r).conf.stream_response_body as libc::c_int & (1 as libc::c_int) << 1 as libc::c_int != 0
        && (*r).resp_body_started as libc::c_int != 0
    {
        if chunkqueue_length(&mut (*r).write_queue)
            > (65536 as libc::c_int - 4096 as libc::c_int) as libc::c_long
        {
            fdevent_fdnode_event_clr((*hctx).ev, (*hctx).fdn, 0x1 as libc::c_int);
        } else if (if !((*hctx).fdn).is_null() {
            (*(*hctx).fdn).events
        } else {
            0 as libc::c_int
        }) & 0x1 as libc::c_int
            == 0
        {
            let mut rc_0: handler_t = HANDLER_GO_ON;
            rc_0 = gw_recv_response(hctx, r);
            if rc_0 as libc::c_uint != HANDLER_GO_ON as libc::c_int as libc::c_uint {
                return rc_0;
            }
            (*hctx).read_ts = log_monotonic_secs;
            fdevent_fdnode_event_add((*hctx).ev, (*hctx).fdn, 0x1 as libc::c_int);
        }
    }
    if (*hctx).gw_mode as libc::c_int != 2 as libc::c_int
        && (if 0 as libc::c_int as libc::c_long == (*hctx).wb.bytes_in {
            ((*r).state as libc::c_uint == CON_STATE_READ_POST as libc::c_int as libc::c_uint
                || -(1 as libc::c_int) as libc::c_long == (*hctx).wb_reqlen)
                as libc::c_int
        } else {
            ((*hctx).wb.bytes_in < (*hctx).wb_reqlen
                || (*hctx).wb_reqlen < 0 as libc::c_int as libc::c_long) as libc::c_int
        }) != 0
    {
        if chunkqueue_length(&mut (*hctx).wb)
            > (65536 as libc::c_int - 4096 as libc::c_int) as libc::c_long
        {
            if (*r).conf.stream_request_body as libc::c_int & (1 as libc::c_int) << 1 as libc::c_int
                != 0
            {
                (*r).conf.stream_request_body = ((*r).conf.stream_request_body as libc::c_int
                    & !((1 as libc::c_int) << 15 as libc::c_int))
                    as libc::c_ushort;
            }
            if 0 as libc::c_int as libc::c_long != (*hctx).wb.bytes_in {
                return HANDLER_WAIT_FOR_EVENT;
            }
        } else {
            let mut rc_1: handler_t =
                ((*(*r).con).reqbody_read).expect("non-null function pointer")(r);
            if -(1 as libc::c_int) as libc::c_long == (*r).reqbody_length
                && (*hctx).opts.backend != BACKEND_PROXY as libc::c_int
            {
                return (if (*r).conf.stream_request_body as libc::c_int
                    & (1 as libc::c_int) << 0 as libc::c_int
                    != 0
                {
                    http_response_reqbody_read_error(r, 411 as libc::c_int) as libc::c_uint
                } else {
                    HANDLER_WAIT_FOR_EVENT as libc::c_int as libc::c_uint
                }) as handler_t;
            }
            if (*hctx).wb_reqlen < -(1 as libc::c_int) as libc::c_long
                && (*r).reqbody_length >= 0 as libc::c_int as libc::c_long
            {
                (*hctx).wb_reqlen = -(*hctx).wb_reqlen;
                if ((*hctx).stdin_append).is_some() {
                    let mut rca: handler_t =
                        ((*hctx).stdin_append).expect("non-null function pointer")(hctx);
                    if HANDLER_GO_ON as libc::c_int as libc::c_uint != rca as libc::c_uint {
                        return rca;
                    }
                }
            }
            if (0 as libc::c_int as libc::c_long != (*hctx).wb.bytes_in
                || -(1 as libc::c_int) as libc::c_long == (*hctx).wb_reqlen)
                && chunkqueue_is_empty(&mut (*r).reqbody_queue) == 0
            {
                if ((*hctx).stdin_append).is_some() {
                    if chunkqueue_length(&mut (*hctx).wb)
                        < (65536 as libc::c_int - 16384 as libc::c_int) as libc::c_long
                    {
                        let mut rca_0: handler_t =
                            ((*hctx).stdin_append).expect("non-null function pointer")(hctx);
                        if HANDLER_GO_ON as libc::c_int as libc::c_uint != rca_0 as libc::c_uint {
                            return rca_0;
                        }
                    }
                } else {
                    chunkqueue_append_chunkqueue(&mut (*hctx).wb, &mut (*r).reqbody_queue);
                }
                if (if !((*hctx).fdn).is_null() {
                    (*(*hctx).fdn).events
                } else {
                    0 as libc::c_int
                }) & 0x4 as libc::c_int
                    != 0
                {
                    return (if rc_1 as libc::c_uint == HANDLER_GO_ON as libc::c_int as libc::c_uint
                    {
                        HANDLER_WAIT_FOR_EVENT as libc::c_int as libc::c_uint
                    } else {
                        rc_1 as libc::c_uint
                    }) as handler_t;
                }
            }
            if rc_1 as libc::c_uint != HANDLER_GO_ON as libc::c_int as libc::c_uint {
                return rc_1;
            }
        }
    }
    let mut rc_2: handler_t = (if (0 as libc::c_int as libc::c_long == (*hctx).wb.bytes_in
        || chunkqueue_is_empty(&mut (*hctx).wb) == 0)
        && (*hctx).state as libc::c_uint != GW_STATE_CONNECT_DELAYED as libc::c_int as libc::c_uint
    {
        gw_send_request(hctx, r) as libc::c_uint
    } else {
        HANDLER_WAIT_FOR_EVENT as libc::c_int as libc::c_uint
    }) as handler_t;
    if HANDLER_WAIT_FOR_EVENT as libc::c_int as libc::c_uint != rc_2 as libc::c_uint {
        return rc_2;
    }
    if (*r).conf.stream_request_body as libc::c_int & (1 as libc::c_int) << 13 as libc::c_int != 0 {
        gw_conditional_tcp_fin(hctx, r);
    }
    return HANDLER_WAIT_FOR_EVENT;
}
unsafe extern "C" fn gw_authorizer_ok(hctx: *mut gw_handler_ctx, r: *mut request_st) -> handler_t {
    let mut physpath: *mut libc::c_char = 0 as *mut libc::c_char;
    let host: *mut gw_host = (*hctx).host;
    if !((*host).docroot).is_null() {
        buffer_copy_buffer(&mut (*r).physical.doc_root, (*host).docroot);
        buffer_copy_buffer(&mut (*r).physical.basedir, (*host).docroot);
        buffer_copy_path_len2(
            &mut (*r).physical.path,
            (*(*host).docroot).ptr,
            buffer_clen((*host).docroot) as size_t,
            (*r).uri.path.ptr,
            buffer_clen(&mut (*r).uri.path) as size_t,
        );
        physpath = (*r).physical.path.ptr;
    }
    (*r).conf.stream_response_body = ((*r).conf.stream_response_body as libc::c_int
        | (*hctx).opts.authorizer >> 1 as libc::c_int)
        as libc::c_ushort;
    gw_backend_close(hctx, r);
    handler_ctx_clear(hctx);
    (*r).loops_per_request += 1;
    if (*r).loops_per_request as libc::c_int > 5 as libc::c_int {
        log_error(
            (*r).conf.errh,
            b"/home/kkysen/work/rust/lighttpd/src/gw_backend.c\0" as *const u8
                as *const libc::c_char,
            2292 as libc::c_int as libc::c_uint,
            b"too many loops while processing request: %s\0" as *const u8 as *const libc::c_char,
            (*r).target_orig.ptr,
        );
        (*r).http_status = 500 as libc::c_int;
        (*r).handler_module = 0 as *const plugin;
        return HANDLER_FINISHED;
    }
    if !physpath.is_null() {
        (*r).physical.path.ptr = 0 as *mut libc::c_char;
    }
    http_response_reset(r);
    if !physpath.is_null() {
        (*r).physical.path.ptr = physpath;
    }
    (*r).handler_module = 0 as *const plugin;
    return HANDLER_COMEBACK;
}
unsafe extern "C" fn gw_recv_response(hctx: *mut gw_handler_ctx, r: *mut request_st) -> handler_t {
    let mut b: *mut buffer = if (*hctx).opts.backend == BACKEND_FASTCGI as libc::c_int
        || (*hctx).opts.backend == BACKEND_AJP13 as libc::c_int
    {
        chunk_buffer_acquire()
    } else {
        (*hctx).response
    };
    let bytes_in: off_t = (*r).write_queue.bytes_in;
    let mut rc: handler_t = http_response_read(r, &mut (*hctx).opts, b, (*hctx).fdn);
    if b != (*hctx).response {
        chunk_buffer_release(b);
    }
    let proc_0: *mut gw_proc = (*hctx).proc_0;
    match rc as libc::c_uint {
        1 => {
            (*proc_0).last_used = log_monotonic_secs;
            if (*hctx).gw_mode as libc::c_int == 2 as libc::c_int
                && (200 as libc::c_int == (*r).http_status || 0 as libc::c_int == (*r).http_status)
            {
                return gw_authorizer_ok(hctx, r);
            }
            gw_connection_close(hctx, r);
            return HANDLER_FINISHED;
        }
        2 | 4 => return gw_recv_response_error(hctx, r, proc_0),
        _ => {
            if (*r).write_queue.bytes_in > bytes_in {
                (*proc_0).last_used = log_monotonic_secs;
                (*hctx).read_ts = (*proc_0).last_used;
            }
            return HANDLER_GO_ON;
        }
    };
}
#[cold]
unsafe extern "C" fn gw_recv_response_error(
    hctx: *mut gw_handler_ctx,
    r: *mut request_st,
    proc_0: *mut gw_proc,
) -> handler_t {
    if (*proc_0).is_local != 0
        && 1 as libc::c_int as libc::c_uint == (*proc_0).load
        && (*proc_0).pid == (*hctx).pid
        && (*proc_0).state as libc::c_uint != PROC_STATE_DIED as libc::c_int as libc::c_uint
        && 0 as libc::c_int == (*(*(*r).con).srv).srvconf.max_worker as libc::c_int
    {
        let host: *mut gw_host = (*hctx).host;
        let errh: *mut log_error_st = (*(*(*r).con).srv).errh;
        if (*proc_0).disabled_until < log_monotonic_secs
            && 0 as libc::c_int != gw_proc_waitpid(host, proc_0, errh)
        {
            if (*hctx).conf.debug != 0 {
                log_error(
                    errh,
                    b"/home/kkysen/work/rust/lighttpd/src/gw_backend.c\0" as *const u8
                        as *const libc::c_char,
                    2373 as libc::c_int as libc::c_uint,
                    b"--- gw spawning\n\tsocket %s\n\tcurrent: 1/%d\0" as *const u8
                        as *const libc::c_char,
                    (*(*proc_0).connection_name).ptr,
                    (*host).num_procs,
                );
            }
            if gw_spawn_connection(host, proc_0, errh, (*hctx).conf.debug) != 0 {
                log_error(
                    errh,
                    b"/home/kkysen/work/rust/lighttpd/src/gw_backend.c\0" as *const u8
                        as *const libc::c_char,
                    2379 as libc::c_int as libc::c_uint,
                    b"respawning failed, will retry later\0" as *const u8 as *const libc::c_char,
                );
            }
        }
    }
    if (*r).resp_body_started as libc::c_int == 0 as libc::c_int {
        if (*hctx).wb.bytes_out == 0 as libc::c_int as libc::c_long && {
            let fresh212 = (*hctx).reconnects;
            (*hctx).reconnects = (*hctx).reconnects + 1;
            fresh212 < 5 as libc::c_int
        } {
            log_error(
                (*r).conf.errh,
                b"/home/kkysen/work/rust/lighttpd/src/gw_backend.c\0" as *const u8
                    as *const libc::c_char,
                2389 as libc::c_int as libc::c_uint,
                b"response not received, request not sent on socket: %s for %s?%.*s, reconnecting\0"
                    as *const u8 as *const libc::c_char,
                (*(*proc_0).connection_name).ptr,
                (*r).uri.path.ptr,
                buffer_clen(&mut (*r).uri.query) as libc::c_int,
                (*r).uri.query.ptr,
            );
            return gw_reconnect(hctx, r);
        }
        log_error(
            (*r).conf.errh,
            b"/home/kkysen/work/rust/lighttpd/src/gw_backend.c\0" as *const u8
                as *const libc::c_char,
            2398 as libc::c_int as libc::c_uint,
            b"response not received, request sent: %lld on socket: %s for %s?%.*s, closing connection\0"
                as *const u8 as *const libc::c_char,
            (*hctx).wb.bytes_out as libc::c_longlong,
            (*(*proc_0).connection_name).ptr,
            (*r).uri.path.ptr,
            buffer_clen(&mut (*r).uri.query) as libc::c_int,
            (*r).uri.query.ptr,
        );
    } else if (*r).resp_htags & (1 as libc::c_ulong) << HTTP_HEADER_UPGRADE as libc::c_int == 0 {
        log_error(
            (*r).conf.errh,
            b"/home/kkysen/work/rust/lighttpd/src/gw_backend.c\0" as *const u8
                as *const libc::c_char,
            2404 as libc::c_int as libc::c_uint,
            b"response already sent out, but backend returned error on socket: %s for %s?%.*s, terminating connection\0"
                as *const u8 as *const libc::c_char,
            (*(*proc_0).connection_name).ptr,
            (*r).uri.path.ptr,
            buffer_clen(&mut (*r).uri.query) as libc::c_int,
            (*r).uri.query.ptr,
        );
    }
    return gw_backend_error(hctx, r);
}
unsafe extern "C" fn gw_handle_fdevent(
    mut ctx: *mut libc::c_void,
    mut revents: libc::c_int,
) -> handler_t {
    let mut hctx: *mut gw_handler_ctx = ctx as *mut gw_handler_ctx;
    (*hctx).revents |= revents;
    connection_jq_append((*hctx).con);
    return HANDLER_FINISHED;
}
unsafe extern "C" fn gw_process_fdevent(
    hctx: *mut gw_handler_ctx,
    r: *mut request_st,
    mut revents: libc::c_int,
) -> handler_t {
    if revents & 0x1 as libc::c_int != 0 {
        let mut rc: handler_t = gw_recv_response(hctx, r);
        if rc as libc::c_uint != HANDLER_GO_ON as libc::c_int as libc::c_uint {
            return rc;
        }
    }
    if revents & 0x4 as libc::c_int != 0 {
        return gw_send_request(hctx, r);
    }
    if revents & (0x10 as libc::c_int | 0x2000 as libc::c_int) != 0 {
        if (*hctx).state as libc::c_uint == GW_STATE_CONNECT_DELAYED as libc::c_int as libc::c_uint
        {
            return gw_send_request(hctx, r);
        } else if (*r).resp_body_started != 0 {
            let mut rc_0: handler_t = HANDLER_GO_ON;
            let flags: libc::c_ushort = (*r).conf.stream_response_body;
            (*r).conf.stream_response_body = ((*r).conf.stream_response_body as libc::c_int
                & !((1 as libc::c_int) << 1 as libc::c_int))
                as libc::c_ushort;
            (*r).conf.stream_response_body = ((*r).conf.stream_response_body as libc::c_int
                | (1 as libc::c_int) << 15 as libc::c_int)
                as libc::c_ushort;
            loop {
                rc_0 = gw_recv_response(hctx, r);
                if !(rc_0 as libc::c_uint == HANDLER_GO_ON as libc::c_int as libc::c_uint) {
                    break;
                }
            }
            (*r).conf.stream_response_body = flags;
            return rc_0;
        } else {
            let mut proc_0: *mut gw_proc = (*hctx).proc_0;
            log_error(
                (*r).conf.errh,
                b"/home/kkysen/work/rust/lighttpd/src/gw_backend.c\0" as *const u8
                    as *const libc::c_char,
                2453 as libc::c_int as libc::c_uint,
                b"error: unexpected close of gw connection for %s?%.*s (no gw process on socket: %s ?) %d\0"
                    as *const u8 as *const libc::c_char,
                (*r).uri.path.ptr,
                buffer_clen(&mut (*r).uri.query) as libc::c_int,
                (*r).uri.query.ptr,
                (*(*proc_0).connection_name).ptr,
                (*hctx).state as libc::c_uint,
            );
            gw_connection_close(hctx, r);
            return HANDLER_FINISHED;
        }
    } else {
        if revents & 0x8 as libc::c_int != 0 {
            log_error(
                (*r).conf.errh,
                b"/home/kkysen/work/rust/lighttpd/src/gw_backend.c\0" as *const u8
                    as *const libc::c_char,
                2463 as libc::c_int as libc::c_uint,
                b"gw: got a FDEVENT_ERR. Don't know why.\0" as *const u8 as *const libc::c_char,
            );
            return gw_backend_error(hctx, r);
        }
    }
    return HANDLER_GO_ON;
}
#[no_mangle]
pub unsafe extern "C" fn gw_check_extension(
    r: *mut request_st,
    p: *mut gw_plugin_data,
    mut uri_path_handler: libc::c_int,
    mut hctx_sz: size_t,
) -> handler_t {
    let mut fn_0: *mut buffer = if uri_path_handler != 0 {
        &mut (*r).uri.path
    } else {
        &mut (*r).physical.path
    };
    let s_len: size_t = buffer_clen(fn_0) as size_t;
    let mut extension: *mut gw_extension = 0 as *mut gw_extension;
    let mut host: *mut gw_host = 0 as *mut gw_host;
    let mut hctx: *mut gw_handler_ctx = 0 as *mut gw_handler_ctx;
    let mut gw_mode: libc::c_ushort = 0;
    if 0 as libc::c_int as libc::c_ulong == s_len {
        return HANDLER_GO_ON;
    }
    hctx = *((*r).plugin_ctx).offset((*p).id as isize) as *mut gw_handler_ctx;
    gw_mode = (if hctx.is_null() || ((*hctx).ext_auth).is_null() {
        0 as libc::c_int
    } else {
        2 as libc::c_int
    }) as libc::c_ushort;
    loop {
        let mut exts: *mut gw_exts = 0 as *mut gw_exts;
        if 0 as libc::c_int == gw_mode as libc::c_int {
            gw_mode = 2 as libc::c_int as libc::c_ushort;
            exts = (*p).conf.exts_auth;
        } else {
            gw_mode = 1 as libc::c_int as libc::c_ushort;
            exts = (*p).conf.exts_resp;
        }
        if !(0 as libc::c_int as libc::c_uint == (*exts).used) {
            if !((*p).conf.ext_mapping).is_null() {
                let mut ds: *mut data_string =
                    array_match_key_suffix((*p).conf.ext_mapping, fn_0) as *mut data_string;
                if !ds.is_null() {
                    let mut k: uint32_t = 0;
                    k = 0 as libc::c_int as uint32_t;
                    while k < (*exts).used {
                        extension = ((*exts).exts).offset(k as isize);
                        if buffer_is_equal(&mut (*ds).value, &(*extension).key) != 0 {
                            break;
                        }
                        k = k.wrapping_add(1);
                    }
                    if k == (*exts).used {
                        extension = 0 as *mut gw_extension;
                    }
                }
            }
            if extension.is_null() {
                let mut uri_path_len: size_t = buffer_clen(&mut (*r).uri.path) as size_t;
                let mut k_0: uint32_t = 0 as libc::c_int as uint32_t;
                while k_0 < (*exts).used {
                    let mut ext: *mut gw_extension = ((*exts).exts).offset(k_0 as isize);
                    let mut ct_len: size_t = buffer_clen(&(*ext).key) as size_t;
                    if *((*ext).key.ptr).offset(0 as libc::c_int as isize) as libc::c_int
                        == '/' as i32
                    {
                        if ct_len <= uri_path_len
                            && 0 as libc::c_int
                                == memcmp(
                                    (*r).uri.path.ptr as *const libc::c_void,
                                    (*ext).key.ptr as *const libc::c_void,
                                    ct_len,
                                )
                        {
                            extension = ext;
                            break;
                        }
                    } else if ct_len <= s_len
                        && 0 as libc::c_int
                            == memcmp(
                                ((*fn_0).ptr)
                                    .offset(s_len as isize)
                                    .offset(-(ct_len as isize))
                                    as *const libc::c_void,
                                (*ext).key.ptr as *const libc::c_void,
                                ct_len,
                            )
                    {
                        extension = ext;
                        break;
                    }
                    k_0 = k_0.wrapping_add(1);
                }
            }
        }
        if !(extension.is_null() && gw_mode as libc::c_int != 1 as libc::c_int) {
            break;
        }
    }
    if extension.is_null() {
        return HANDLER_GO_ON;
    }
    host = gw_host_get(r, extension, (*p).conf.balance, (*p).conf.debug);
    if host.is_null() {
        return HANDLER_FINISHED;
    }
    (*extension).note_is_sent = 0 as libc::c_int;
    if uri_path_handler != 0 {
        if (*host).check_local != 0 {
            return HANDLER_GO_ON;
        }
        if *((*extension).key.ptr).offset(0 as libc::c_int as isize) as libc::c_int == '/' as i32
            && gw_mode as libc::c_int != 2 as libc::c_int
        {
            let mut elen: uint32_t = buffer_clen(&(*extension).key);
            let mut pathinfo: *const libc::c_char = 0 as *const libc::c_char;
            if 1 as libc::c_int as libc::c_uint == elen
                && (*host).fix_root_path_name as libc::c_int != 0
            {
                buffer_copy_buffer(&mut (*r).pathinfo, &mut (*r).uri.path);
                buffer_truncate(&mut (*r).uri.path, 0 as libc::c_int as uint32_t);
            } else if s_len > elen as libc::c_ulong && {
                pathinfo = strchr(((*r).uri.path.ptr).offset(elen as isize), '/' as i32);
                !pathinfo.is_null()
            } {
                let plen: uint32_t = ((*r).uri.path.ptr)
                    .offset(s_len as isize)
                    .offset_from(pathinfo) as libc::c_long
                    as uint32_t;
                buffer_copy_string_len(&mut (*r).pathinfo, pathinfo, plen as size_t);
                buffer_truncate(
                    &mut (*r).uri.path,
                    s_len.wrapping_sub(plen as libc::c_ulong) as uint32_t,
                );
            }
        }
    }
    if hctx.is_null() {
        hctx = handler_ctx_init(hctx_sz);
    }
    (*hctx).ev = (*(*(*r).con).srv).ev;
    (*hctx).r = r;
    (*hctx).con = (*r).con;
    (*hctx).plugin_data = p;
    (*hctx).host = host;
    (*hctx).proc_0 = 0 as *mut gw_proc;
    (*hctx).ext = extension;
    gw_host_assign(host);
    (*hctx).gw_mode = gw_mode;
    if gw_mode as libc::c_int == 2 as libc::c_int {
        (*hctx).ext_auth = (*hctx).ext;
    }
    (*hctx).conf.balance = (*p).conf.balance;
    (*hctx).conf.proto = (*p).conf.proto;
    (*hctx).conf.debug = (*p).conf.debug;
    (*hctx).opts.max_per_read = (if (*r).conf.stream_response_body as libc::c_int
        & ((1 as libc::c_int) << 0 as libc::c_int | (1 as libc::c_int) << 1 as libc::c_int)
        == 0
    {
        262144 as libc::c_int
    } else if (*r).conf.stream_response_body as libc::c_int & (1 as libc::c_int) << 1 as libc::c_int
        != 0
    {
        16384 as libc::c_int
    } else {
        65536 as libc::c_int
    }) as uint32_t;
    (*hctx).opts.fdfmt = 0o140000 as libc::c_int;
    (*hctx).opts.authorizer = (gw_mode as libc::c_int == 2 as libc::c_int) as libc::c_int;
    (*hctx).opts.local_redir = 0 as libc::c_int as uint8_t;
    (*hctx).opts.xsendfile_allow = (*host).xsendfile_allow as uint8_t;
    (*hctx).opts.xsendfile_docroot = (*host).xsendfile_docroot;
    let ref mut fresh213 = *((*r).plugin_ctx).offset((*p).id as isize);
    *fresh213 = hctx as *mut libc::c_void;
    (*r).handler_module = (*p).self_0;
    if (*r).conf.log_request_handling != 0 {
        log_error(
            (*r).conf.errh,
            b"/home/kkysen/work/rust/lighttpd/src/gw_backend.c\0" as *const u8
                as *const libc::c_char,
            2682 as libc::c_int as libc::c_uint,
            b"handling the request using %s\0" as *const u8 as *const libc::c_char,
            (*(*p).self_0).name,
        );
    }
    return HANDLER_GO_ON;
}
#[cold]
#[inline(never)]
unsafe extern "C" fn gw_handle_trigger_hctx_timeout(
    hctx: *mut gw_handler_ctx,
    msg: *const libc::c_char,
) {
    let r: *mut request_st = (*hctx).r;
    connection_jq_append((*r).con);
    if *msg as libc::c_int == 'c' as i32 {
        gw_proc_connect_error(
            r,
            (*hctx).host,
            (*hctx).proc_0,
            (*hctx).pid,
            110 as libc::c_int,
            (*hctx).conf.debug,
        );
        let fresh214 = (*hctx).reconnects;
        (*hctx).reconnects = (*hctx).reconnects + 1;
        if fresh214 < 1 as libc::c_int {
            gw_reconnect(hctx, r);
            return;
        }
        (*r).http_status = 503 as libc::c_int;
    } else {
        log_error(
            (*r).conf.errh,
            b"/home/kkysen/work/rust/lighttpd/src/gw_backend.c\0" as *const u8
                as *const libc::c_char,
            2716 as libc::c_int as libc::c_uint,
            b"%s timeout on socket: %s (fd: %d)\0" as *const u8 as *const libc::c_char,
            msg,
            (*(*(*hctx).proc_0).connection_name).ptr,
            (*hctx).fd,
        );
        if *msg as libc::c_int == 'w' as i32 {
            gw_write_error(hctx, r);
            if (*r).http_status == 503 as libc::c_int {
                (*r).http_status = 504 as libc::c_int;
            }
            return;
        }
    }
    gw_backend_error(hctx, r);
    if (*r).http_status == 500 as libc::c_int
        && (*r).resp_body_started == 0
        && ((*r).handler_module).is_null()
    {
        (*r).http_status = 504 as libc::c_int;
    }
}
#[inline(never)]
unsafe extern "C" fn gw_handle_trigger_host_timeouts(host: *mut gw_host) {
    if ((*host).hctxs).is_null() {
        return;
    }
    let rsecs: unix_time64_t = (*host).read_timeout as unix_time64_t;
    let wsecs: unix_time64_t = (*host).write_timeout as unix_time64_t;
    let csecs: unix_time64_t = (*host).connect_timeout as unix_time64_t;
    if rsecs == 0 && wsecs == 0 && csecs == 0 {
        return;
    }
    let mono: unix_time64_t = log_monotonic_secs;
    let mut hctx: *mut gw_handler_ctx = (*host).hctxs;
    let mut next: *mut gw_handler_ctx = 0 as *mut gw_handler_ctx;
    while !hctx.is_null() {
        next = (*hctx).next;
        if (*hctx).state as libc::c_uint == GW_STATE_CONNECT_DELAYED as libc::c_int as libc::c_uint
        {
            if mono - (*hctx).write_ts > csecs && csecs != 0 {
                gw_handle_trigger_hctx_timeout(
                    hctx,
                    b"connect\0" as *const u8 as *const libc::c_char,
                );
            }
        } else {
            let events: libc::c_int = if !((*hctx).fdn).is_null() {
                (*(*hctx).fdn).events
            } else {
                0 as libc::c_int
            };
            if events & 0x1 as libc::c_int != 0 && mono - (*hctx).read_ts > rsecs && rsecs != 0 {
                gw_handle_trigger_hctx_timeout(hctx, b"read\0" as *const u8 as *const libc::c_char);
            } else if events & 0x4 as libc::c_int != 0
                && mono - (*hctx).write_ts > wsecs
                && wsecs != 0
            {
                gw_handle_trigger_hctx_timeout(
                    hctx,
                    b"write\0" as *const u8 as *const libc::c_char,
                );
            }
        }
        hctx = next;
    }
}
#[no_mangle]
pub unsafe extern "C" fn gw_handle_waitpid_cb(
    mut srv: *mut server,
    mut p_d: *mut libc::c_void,
    mut pid: pid_t,
    mut status: libc::c_int,
) -> handler_t {
    let p: *mut gw_plugin_data = p_d as *mut gw_plugin_data;
    if 0 as libc::c_int != (*srv).srvconf.max_worker as libc::c_int && (*p).srv_pid != (*srv).pid {
        return HANDLER_GO_ON;
    }
    let errh: *mut log_error_st = (*srv).errh;
    let mut global_debug: libc::c_int = 0 as libc::c_int;
    if ((*p).cvlist).is_null() {
        return HANDLER_GO_ON;
    }
    let mut i: libc::c_int = ((*((*p).cvlist).offset(0 as libc::c_int as isize)).v.u2
        [1 as libc::c_int as usize]
        == 0) as libc::c_int;
    let mut used: libc::c_int = (*p).nconfig;
    while i < used {
        let mut cpv: *mut config_plugin_value_t = ((*p).cvlist)
            .offset((*((*p).cvlist).offset(i as isize)).v.u2[0 as libc::c_int as usize] as isize);
        let mut conf: *mut gw_plugin_config = 0 as *mut gw_plugin_config;
        let mut debug: libc::c_int = global_debug;
        while -(1 as libc::c_int) != (*cpv).k_id {
            match (*cpv).k_id {
                0 => {
                    if (*cpv).vtype as libc::c_uint == T_CONFIG_LOCAL as libc::c_int as libc::c_uint
                    {
                        conf = (*cpv).v.v as *mut gw_plugin_config;
                    }
                }
                2 => {
                    debug = (*cpv).v.u as libc::c_int;
                    if 0 as libc::c_int == i {
                        global_debug = (*cpv).v.u as libc::c_int;
                    }
                }
                _ => {}
            }
            cpv = cpv.offset(1);
        }
        if !(conf.is_null() || ((*conf).exts).is_null()) {
            let cur_ts: unix_time64_t = log_monotonic_secs;
            let mut exts: *mut gw_exts = (*conf).exts;
            let mut j: uint32_t = 0 as libc::c_int as uint32_t;
            while j < (*exts).used {
                let mut ex: *mut gw_extension = ((*exts).exts).offset(j as isize);
                let mut n: uint32_t = 0 as libc::c_int as uint32_t;
                while n < (*ex).used {
                    let mut host: *mut gw_host = *((*ex).hosts).offset(n as isize);
                    let mut proc_0: *mut gw_proc = 0 as *mut gw_proc;
                    proc_0 = (*host).first;
                    while !proc_0.is_null() {
                        if (*proc_0).is_local == 0 || (*proc_0).pid != pid {
                            proc_0 = (*proc_0).next;
                        } else {
                            gw_proc_waitpid_log(host, proc_0, errh, status);
                            gw_proc_set_state(host, proc_0, PROC_STATE_DIED as libc::c_int);
                            (*proc_0).pid = 0 as libc::c_int;
                            if (*proc_0).disabled_until < cur_ts {
                                if (*proc_0).state as libc::c_uint
                                    != PROC_STATE_KILLED as libc::c_int as libc::c_uint
                                {
                                    (*proc_0).disabled_until = cur_ts;
                                }
                                if gw_spawn_connection(host, proc_0, errh, debug) != 0 {
                                    log_error(
                                        errh,
                                        b"/home/kkysen/work/rust/lighttpd/src/gw_backend.c\0"
                                            as *const u8
                                            as *const libc::c_char,
                                        2947 as libc::c_int as libc::c_uint,
                                        b"ERROR: spawning gw failed.\0" as *const u8
                                            as *const libc::c_char,
                                    );
                                }
                            }
                            return HANDLER_FINISHED;
                        }
                    }
                    proc_0 = (*host).unused_procs;
                    while !proc_0.is_null() {
                        if (*proc_0).is_local == 0 || (*proc_0).pid != pid {
                            proc_0 = (*proc_0).next;
                        } else {
                            gw_proc_waitpid_log(host, proc_0, errh, status);
                            if (*proc_0).state as libc::c_uint
                                != PROC_STATE_KILLED as libc::c_int as libc::c_uint
                            {
                                (*proc_0).disabled_until = cur_ts;
                            }
                            gw_proc_set_state(host, proc_0, PROC_STATE_DIED as libc::c_int);
                            (*proc_0).pid = 0 as libc::c_int;
                            return HANDLER_FINISHED;
                        }
                    }
                    n = n.wrapping_add(1);
                }
                j = j.wrapping_add(1);
            }
        }
        i += 1;
    }
    return HANDLER_GO_ON;
}
unsafe extern "C" fn gw_handle_trigger_exts_wkr(
    mut exts: *mut gw_exts,
    mut errh: *mut log_error_st,
) {
    let mut j: uint32_t = 0 as libc::c_int as uint32_t;
    while j < (*exts).used {
        let ex: *mut gw_extension = ((*exts).exts).offset(j as isize);
        let mut n: uint32_t = 0 as libc::c_int as uint32_t;
        while n < (*ex).used {
            let host: *mut gw_host = *((*ex).hosts).offset(n as isize);
            gw_handle_trigger_host_timeouts(host);
            let mut proc_0: *mut gw_proc = (*host).first;
            while !proc_0.is_null() {
                if (*proc_0).state as libc::c_uint
                    == PROC_STATE_OVERLOADED as libc::c_int as libc::c_uint
                {
                    gw_proc_check_enable(host, proc_0, errh);
                }
                proc_0 = (*proc_0).next;
            }
            n = n.wrapping_add(1);
        }
        j = j.wrapping_add(1);
    }
}
unsafe extern "C" fn gw_handle_trigger_exts(
    exts: *mut gw_exts,
    errh: *mut log_error_st,
    debug: libc::c_int,
) {
    let mut j: uint32_t = 0 as libc::c_int as uint32_t;
    while j < (*exts).used {
        let mut ex: *mut gw_extension = ((*exts).exts).offset(j as isize);
        let mut n: uint32_t = 0 as libc::c_int as uint32_t;
        while n < (*ex).used {
            gw_handle_trigger_host(*((*ex).hosts).offset(n as isize), errh, debug);
            n = n.wrapping_add(1);
        }
        j = j.wrapping_add(1);
    }
}
#[no_mangle]
pub unsafe extern "C" fn gw_handle_trigger(
    mut srv: *mut server,
    mut p_d: *mut libc::c_void,
) -> handler_t {
    let p: *mut gw_plugin_data = p_d as *mut gw_plugin_data;
    let mut wkr: libc::c_int = (0 as libc::c_int != (*srv).srvconf.max_worker as libc::c_int
        && (*p).srv_pid != (*srv).pid) as libc::c_int;
    let errh: *mut log_error_st = (*srv).errh;
    let mut global_debug: libc::c_int = 0 as libc::c_int;
    if ((*p).cvlist).is_null() {
        return HANDLER_GO_ON;
    }
    let mut i: libc::c_int = ((*((*p).cvlist).offset(0 as libc::c_int as isize)).v.u2
        [1 as libc::c_int as usize]
        == 0) as libc::c_int;
    let mut used: libc::c_int = (*p).nconfig;
    while i < used {
        let mut cpv: *mut config_plugin_value_t = ((*p).cvlist)
            .offset((*((*p).cvlist).offset(i as isize)).v.u2[0 as libc::c_int as usize] as isize);
        let mut conf: *mut gw_plugin_config = 0 as *mut gw_plugin_config;
        let mut debug: libc::c_int = global_debug;
        while -(1 as libc::c_int) != (*cpv).k_id {
            match (*cpv).k_id {
                0 => {
                    if (*cpv).vtype as libc::c_uint == T_CONFIG_LOCAL as libc::c_int as libc::c_uint
                    {
                        conf = (*cpv).v.v as *mut gw_plugin_config;
                    }
                }
                2 => {
                    debug = (*cpv).v.u as libc::c_int;
                    if 0 as libc::c_int == i {
                        global_debug = (*cpv).v.u as libc::c_int;
                    }
                }
                _ => {}
            }
            cpv = cpv.offset(1);
        }
        if !(conf.is_null() || ((*conf).exts).is_null()) {
            if wkr != 0 {
                gw_handle_trigger_exts_wkr((*conf).exts, errh);
            } else {
                gw_handle_trigger_exts((*conf).exts, errh, debug);
            };
        }
        i += 1;
    }
    return HANDLER_GO_ON;
}
#[inline]
unsafe extern "C" fn status_counter_get_counter(
    mut s: *const libc::c_char,
    mut len: size_t,
) -> *mut libc::c_int {
    return array_get_int_ptr(&mut plugin_stats, s, len as uint32_t);
}
unsafe extern "C" fn gw_handle_trigger_host(
    host: *mut gw_host,
    errh: *mut log_error_st,
    debug: libc::c_int,
) {
    gw_handle_trigger_host_timeouts(host);
    let mut proc_0: *mut gw_proc = 0 as *mut gw_proc;
    let mut idle_timestamp: unix_time64_t = 0;
    let mut overload: libc::c_int = 1 as libc::c_int;
    gw_restart_dead_procs(host, errh, debug, 1 as libc::c_int);
    if (*host).min_procs as libc::c_int == (*host).max_procs as libc::c_int {
        return;
    }
    if ((*host).bin_path).is_null() {
        return;
    }
    proc_0 = (*host).first;
    while !proc_0.is_null() {
        if (*proc_0).load <= (*host).max_load_per_proc as libc::c_uint {
            overload = 0 as libc::c_int;
            break;
        } else {
            proc_0 = (*proc_0).next;
        }
    }
    if overload != 0
        && (*host).num_procs != 0
        && (*host).num_procs < (*host).max_procs as libc::c_uint
    {
        if debug != 0 {
            log_error(
                errh,
                b"/home/kkysen/work/rust/lighttpd/src/gw_backend.c\0" as *const u8
                    as *const libc::c_char,
                2798 as libc::c_int as libc::c_uint,
                b"overload detected, spawning a new child\0" as *const u8 as *const libc::c_char,
            );
        }
        gw_proc_spawn(host, errh, debug);
    }
    idle_timestamp = log_monotonic_secs - (*host).idle_timeout as libc::c_long;
    proc_0 = (*host).first;
    while !proc_0.is_null() {
        if (*host).num_procs <= (*host).min_procs as libc::c_uint {
            break;
        }
        if !(0 as libc::c_int as libc::c_uint != (*proc_0).load) {
            if !((*proc_0).pid <= 0 as libc::c_int) {
                if !((*proc_0).last_used >= idle_timestamp) {
                    if debug != 0 {
                        log_error(
                            errh,
                            b"/home/kkysen/work/rust/lighttpd/src/gw_backend.c\0" as *const u8
                                as *const libc::c_char,
                            2814 as libc::c_int as libc::c_uint,
                            b"idle-timeout reached, terminating child: socket: %s pid %d\0"
                                as *const u8 as *const libc::c_char,
                            if !((*proc_0).unixsocket).is_null() {
                                (*(*proc_0).unixsocket).ptr as *const libc::c_char
                            } else {
                                b"\0" as *const u8 as *const libc::c_char
                            },
                            (*proc_0).pid,
                        );
                    }
                    gw_proc_kill(host, proc_0);
                    break;
                }
            }
        }
        proc_0 = (*proc_0).next;
    }
}
#[inline]
unsafe extern "C" fn djbhash(
    mut str: *const libc::c_char,
    len: uint32_t,
    mut hash: uint32_t,
) -> uint32_t {
    let s: *const libc::c_uchar = str as *const libc::c_uchar;
    let mut i: uint32_t = 0 as libc::c_int as uint32_t;
    while i < len {
        hash =
            (hash << 5 as libc::c_int).wrapping_add(hash) ^ *s.offset(i as isize) as libc::c_uint;
        i = i.wrapping_add(1);
    }
    return hash;
}
#[inline]
unsafe extern "C" fn dekhash(
    mut str: *const libc::c_char,
    len: uint32_t,
    mut hash: uint32_t,
) -> uint32_t {
    let s: *const libc::c_uchar = str as *const libc::c_uchar;
    let mut i: uint32_t = 0 as libc::c_int as uint32_t;
    while i < len {
        hash = hash << 5 as libc::c_int
            ^ hash >> 27 as libc::c_int
            ^ *s.offset(i as isize) as libc::c_uint;
        i = i.wrapping_add(1);
    }
    return hash;
}
unsafe extern "C" fn fam_dir_monitor(
    mut scf: *mut stat_cache_fam,
    mut fn_0: *mut libc::c_char,
    mut dirlen: uint32_t,
    mut st: *mut stat,
) -> *mut fam_dir_entry {
    if ((*scf).fdn).is_null() {
        return 0 as *mut fam_dir_entry;
    }
    let fn_is_dir: libc::c_int = ((*st).st_mode & 0o170000 as libc::c_int as libc::c_uint
        == 0o40000 as libc::c_int as libc::c_uint) as libc::c_int;
    if *fn_0.offset(dirlen.wrapping_sub(1 as libc::c_int as libc::c_uint) as isize) as libc::c_int
        == '/' as i32
    {
        dirlen = dirlen.wrapping_sub(1);
    }
    if 0 as libc::c_int as libc::c_uint == dirlen {
        dirlen = 1 as libc::c_int as uint32_t;
    }
    if fn_is_dir == 0 {
        loop {
            dirlen = dirlen.wrapping_sub(1);
            if !(*fn_0.offset(dirlen as isize) as libc::c_int != '/' as i32) {
                break;
            }
        }
        if 0 as libc::c_int as libc::c_uint == dirlen {
            dirlen = 1 as libc::c_int as uint32_t;
        }
    }
    let mut dir_ndx: libc::c_int = splaytree_djbhash(fn_0, dirlen);
    let mut fam_dir: *mut fam_dir_entry = 0 as *mut fam_dir_entry;
    (*scf).dirs = splaytree_splay((*scf).dirs, dir_ndx);
    if !((*scf).dirs).is_null() && (*(*scf).dirs).key == dir_ndx {
        fam_dir = (*(*scf).dirs).data as *mut fam_dir_entry;
        if buffer_eq_slen(&mut (*fam_dir).name, fn_0, dirlen as size_t) == 0 {
            return 0 as *mut fam_dir_entry;
        }
    }
    let cur_ts: unix_time64_t = log_monotonic_secs;
    let mut lst: stat = stat {
        st_dev: 0,
        st_ino: 0,
        st_nlink: 0,
        st_mode: 0,
        st_uid: 0,
        st_gid: 0,
        __pad0: 0,
        st_rdev: 0,
        st_size: 0,
        st_blksize: 0,
        st_blocks: 0,
        st_atim: timespec {
            tv_sec: 0,
            tv_nsec: 0,
        },
        st_mtim: timespec {
            tv_sec: 0,
            tv_nsec: 0,
        },
        st_ctim: timespec {
            tv_sec: 0,
            tv_nsec: 0,
        },
        __glibc_reserved: [0; 3],
    };
    let mut ck_dir: libc::c_int = fn_is_dir;
    if fn_is_dir == 0
        && (fam_dir.is_null() || cur_ts - (*fam_dir).stat_ts >= 16 as libc::c_int as libc::c_long)
    {
        ck_dir = 1 as libc::c_int;
        *fn_0.offset(dirlen as isize) = '\0' as i32 as libc::c_char;
        if 0 as libc::c_int != lstat(fn_0, &mut lst) {
            *fn_0.offset(dirlen as isize) = '/' as i32 as libc::c_char;
            return 0 as *mut fam_dir_entry;
        }
        if !(lst.st_mode & 0o170000 as libc::c_int as libc::c_uint
            == 0o120000 as libc::c_int as libc::c_uint)
        {
            st = &mut lst;
        } else if 0 as libc::c_int != stat(fn_0, st) {
            *fn_0.offset(dirlen as isize) = '/' as i32 as libc::c_char;
            return 0 as *mut fam_dir_entry;
        }
        *fn_0.offset(dirlen as isize) = '/' as i32 as libc::c_char;
    }
    let mut ck_lnk: libc::c_int =
        (0 as *mut libc::c_void as *mut fam_dir_entry == fam_dir) as libc::c_int;
    if ck_dir != 0 && !fam_dir.is_null() {
        if (*st).st_dev != (*fam_dir).st_dev || (*st).st_ino != (*fam_dir).st_ino {
            ck_lnk = 1 as libc::c_int;
            if !((*scf).dirs).is_null() {
                fam_dir_invalidate_tree((*scf).dirs, fn_0, dirlen as size_t);
            }
            if fn_is_dir == 0 {
                stat_cache_update_entry(fn_0, dirlen, st, 0 as *const buffer);
            }
            stat_cache_invalidate_dir_tree(fn_0, dirlen as size_t);
            (*scf).wds = splaytree_delete((*scf).wds, (*fam_dir).req);
            if 0 as libc::c_int != inotify_rm_watch((*scf).fd, (*fam_dir).req) || {
                (*fam_dir).req = inotify_add_watch(
                    (*scf).fd,
                    (*fam_dir).name.ptr,
                    (0x4 as libc::c_int
                        | 0x100 as libc::c_int
                        | 0x200 as libc::c_int
                        | 0x400 as libc::c_int
                        | 0x2 as libc::c_int
                        | 0x800 as libc::c_int
                        | 0x40 as libc::c_int
                        | 0x4000000 as libc::c_int
                        | 0x1000000 as libc::c_int) as uint32_t,
                );
                0 as libc::c_int != ((*fam_dir).req < 0 as libc::c_int) as libc::c_int
            } {
                (*fam_dir).stat_ts = 0 as libc::c_int as unix_time64_t;
                return 0 as *mut fam_dir_entry;
            }
            (*fam_dir).st_dev = (*st).st_dev;
            (*fam_dir).st_ino = (*st).st_ino;
            (*scf).wds = splaytree_insert((*scf).wds, (*fam_dir).req, fam_dir as *mut libc::c_void);
        }
        (*fam_dir).stat_ts = cur_ts;
    }
    if fam_dir.is_null() {
        fam_dir = fam_dir_entry_init(fn_0, dirlen as size_t);
        (*fam_dir).req = inotify_add_watch(
            (*scf).fd,
            (*fam_dir).name.ptr,
            (0x4 as libc::c_int
                | 0x100 as libc::c_int
                | 0x200 as libc::c_int
                | 0x400 as libc::c_int
                | 0x2 as libc::c_int
                | 0x800 as libc::c_int
                | 0x40 as libc::c_int
                | 0x4000000 as libc::c_int
                | 0x1000000 as libc::c_int) as uint32_t,
        );
        if 0 as libc::c_int != ((*fam_dir).req < 0 as libc::c_int) as libc::c_int {
            log_perror(
                (*scf).errh,
                b"/home/kkysen/work/rust/lighttpd/src/stat_cache.c\0" as *const u8
                    as *const libc::c_char,
                745 as libc::c_int as libc::c_uint,
                b"monitoring dir failed: %s file: %s\0" as *const u8 as *const libc::c_char,
                (*fam_dir).name.ptr,
                fn_0,
            );
            fam_dir_entry_free(fam_dir);
            return 0 as *mut fam_dir_entry;
        }
        (*scf).dirs = splaytree_insert((*scf).dirs, dir_ndx, fam_dir as *mut libc::c_void);
        (*scf).wds = splaytree_insert((*scf).wds, (*fam_dir).req, fam_dir as *mut libc::c_void);
        (*fam_dir).stat_ts = cur_ts;
        (*fam_dir).st_dev = (*st).st_dev;
        (*fam_dir).st_ino = (*st).st_ino;
    }
    if ck_lnk != 0 {
        if fn_is_dir != 0 {
            let mut e: libc::c_char = *fn_0.offset(dirlen as isize);
            *fn_0.offset(dirlen as isize) = '\0' as i32 as libc::c_char;
            if 0 as libc::c_int != lstat(fn_0, &mut lst) {
                *fn_0.offset(dirlen as isize) = e;
                return 0 as *mut fam_dir_entry;
            }
            *fn_0.offset(dirlen as isize) = e;
        }
        if !((*fam_dir).fam_parent).is_null() {
            (*(*fam_dir).fam_parent).refcnt -= 1;
            (*fam_dir).fam_parent = 0 as *mut fam_dir_entry;
        }
        if lst.st_mode & 0o170000 as libc::c_int as libc::c_uint
            == 0o120000 as libc::c_int as libc::c_uint
        {
            (*fam_dir).fam_parent = fam_dir_monitor(scf, fn_0, dirlen, &mut lst);
        }
    }
    (*fam_dir).refcnt += 1;
    return fam_dir;
}
unsafe extern "C" fn stat_cache_free_fam(mut scf: *mut stat_cache_fam) {
    if scf.is_null() {
        return;
    }
    while !((*scf).wds).is_null() {
        let mut node: *mut splay_tree = (*scf).wds;
        (*scf).wds = splaytree_delete((*scf).wds, (*node).key);
    }
    while !((*scf).dirs).is_null() {
        let mut node_0: *mut splay_tree = (*scf).dirs;
        fam_dir_entry_free((*node_0).data as *mut fam_dir_entry);
        (*scf).dirs = splaytree_delete((*scf).dirs, (*node_0).key);
    }
    if -(1 as libc::c_int) != (*scf).fd {
        close((*scf).fd);
    }
    free(scf as *mut libc::c_void);
}
unsafe extern "C" fn fam_dir_tag_refcnt(
    mut t: *mut splay_tree,
    mut keys: *mut libc::c_int,
    mut ndx: *mut libc::c_int,
) {
    if *ndx == 512 as libc::c_int {
        return;
    }
    if !((*t).left).is_null() {
        fam_dir_tag_refcnt((*t).left, keys, ndx);
    }
    if !((*t).right).is_null() {
        fam_dir_tag_refcnt((*t).right, keys, ndx);
    }
    if *ndx == 512 as libc::c_int {
        return;
    }
    let fam_dir: *mut fam_dir_entry = (*t).data as *mut fam_dir_entry;
    if 0 as libc::c_int == (*fam_dir).refcnt {
        fam_dir_invalidate_node(fam_dir);
        let fresh215 = *ndx;
        *ndx = *ndx + 1;
        *keys.offset(fresh215 as isize) = (*t).key;
    }
}
#[inline(never)]
unsafe extern "C" fn fam_dir_periodic_cleanup() {
    let scf: *mut stat_cache_fam = sc.scf;
    let mut max_ndx: libc::c_int = 0;
    let mut i: libc::c_int = 0;
    let mut keys: [libc::c_int; 512] = [0; 512];
    while !((*scf).dirs).is_null() {
        max_ndx = 0 as libc::c_int;
        fam_dir_tag_refcnt((*scf).dirs, keys.as_mut_ptr(), &mut max_ndx);
        i = 0 as libc::c_int;
        while i < max_ndx {
            let ndx: libc::c_int = keys[i as usize];
            (*scf).dirs = splaytree_splay((*scf).dirs, ndx);
            let mut node: *mut splay_tree = (*scf).dirs;
            if !node.is_null() && (*node).key == ndx {
                let mut fam_dir: *mut fam_dir_entry = (*node).data as *mut fam_dir_entry;
                (*scf).dirs = splaytree_delete((*scf).dirs, ndx);
                (*scf).wds = splaytree_delete((*scf).wds, (*fam_dir).req);
                inotify_rm_watch((*scf).fd, (*fam_dir).req);
                fam_dir_entry_free(fam_dir);
            }
            i += 1;
        }
        if !(max_ndx as libc::c_ulong
            == (::core::mem::size_of::<[libc::c_int; 512]>() as libc::c_ulong)
                .wrapping_div(::core::mem::size_of::<libc::c_int>() as libc::c_ulong))
        {
            break;
        }
    }
}
unsafe extern "C" fn stat_cache_handle_fdevent_fn(
    scf: *mut stat_cache_fam,
    mut fam_dir: *mut fam_dir_entry,
    fn_0: *const libc::c_char,
    fnlen: uint32_t,
    mut code: libc::c_int,
) {
    if fnlen != 0 {
        let n: *mut buffer = &mut (*fam_dir).name;
        let mut fam_link: *mut fam_dir_entry = 0 as *mut fam_dir_entry;
        let mut len: uint32_t = 0;
        match code {
            5 => return,
            1 | 2 | 6 => {
                len = buffer_clen(n);
                buffer_append_path_len(n, fn_0, fnlen as size_t);
                stat_cache_invalidate_entry((*n).ptr, buffer_clen(n));
                fam_link = stat_cache_sptree_find(&mut (*scf).dirs, (*n).ptr, buffer_clen(n))
                    as *mut fam_dir_entry;
                if !fam_link.is_null() && buffer_is_equal(&mut (*fam_link).name, n) == 0 {
                    fam_link = 0 as *mut fam_dir_entry;
                }
                buffer_truncate(n, len);
                if !fam_link.is_null() {
                    stat_cache_invalidate_entry((*n).ptr, len);
                    code = FAMDeleted as libc::c_int;
                    fam_dir = fam_link;
                } else {
                    return;
                }
            }
            _ => return,
        }
    }
    match code {
        1 => {
            stat_cache_invalidate_entry((*fam_dir).name.ptr, buffer_clen(&mut (*fam_dir).name));
        }
        2 | 6 => {
            stat_cache_delete_tree((*fam_dir).name.ptr, buffer_clen(&mut (*fam_dir).name));
            fam_dir_invalidate_node(fam_dir);
            if !((*scf).dirs).is_null() {
                fam_dir_invalidate_tree(
                    (*scf).dirs,
                    (*fam_dir).name.ptr,
                    buffer_clen(&mut (*fam_dir).name) as size_t,
                );
            }
            fam_dir_periodic_cleanup();
        }
        _ => {}
    };
}
unsafe extern "C" fn stat_cache_handle_fdevent_in(mut scf: *mut stat_cache_fam) {
    let mut buf: [libc::c_char; 4096] = [0; 4096];
    let mut rd: libc::c_int = 0;
    loop {
        rd = read(
            (*scf).fd,
            buf.as_mut_ptr() as *mut libc::c_void,
            ::core::mem::size_of::<[libc::c_char; 4096]>() as libc::c_ulong,
        ) as libc::c_int;
        if rd <= 0 as libc::c_int {
            if -(1 as libc::c_int) == rd
                && *__errno_location() != 4 as libc::c_int
                && *__errno_location() != 11 as libc::c_int
            {
                log_perror(
                    (*scf).errh,
                    b"/home/kkysen/work/rust/lighttpd/src/stat_cache.c\0" as *const u8
                        as *const libc::c_char,
                    370 as libc::c_int as libc::c_uint,
                    b"inotify error\0" as *const u8 as *const libc::c_char,
                );
            }
            break;
        } else {
            let mut i: libc::c_int = 0 as libc::c_int;
            while i < rd {
                let in_0: *mut inotify_event = (buf.as_mut_ptr() as uintptr_t)
                    .wrapping_add(i as libc::c_ulong)
                    as *mut inotify_event;
                let mut len: uint32_t = (*in_0).len;
                if len as libc::c_ulong
                    > ::core::mem::size_of::<[libc::c_char; 4096]>() as libc::c_ulong
                {
                    break;
                }
                i = (i as libc::c_ulong).wrapping_add(
                    (::core::mem::size_of::<inotify_event>() as libc::c_ulong)
                        .wrapping_add(len as libc::c_ulong),
                ) as libc::c_int as libc::c_int;
                if i > rd {
                    break;
                }
                if (*in_0).mask & 0x100 as libc::c_int as libc::c_uint != 0 {
                    continue;
                }
                if (*in_0).mask & 0x4000 as libc::c_int as libc::c_uint != 0 {
                    log_error(
                        (*scf).errh,
                        b"/home/kkysen/work/rust/lighttpd/src/stat_cache.c\0" as *const u8
                            as *const libc::c_char,
                        385 as libc::c_int as libc::c_uint,
                        b"inotify queue overflow\0" as *const u8 as *const libc::c_char,
                    );
                } else {
                    (*scf).wds = splaytree_splay((*scf).wds, (*in_0).wd);
                    if ((*scf).wds).is_null() || (*(*scf).wds).key != (*in_0).wd {
                        continue;
                    }
                    let mut fam_dir: *mut fam_dir_entry = (*(*scf).wds).data as *mut fam_dir_entry;
                    if fam_dir.is_null() {
                        continue;
                    }
                    if (*fam_dir).req != (*in_0).wd {
                        continue;
                    }
                    let mut code: libc::c_int = 0 as libc::c_int;
                    if (*in_0).mask & (0x4 as libc::c_int | 0x2 as libc::c_int) as libc::c_uint != 0
                    {
                        code = FAMChanged as libc::c_int;
                    } else if (*in_0).mask
                        & (0x200 as libc::c_int | 0x400 as libc::c_int | 0x2000 as libc::c_int)
                            as libc::c_uint
                        != 0
                    {
                        code = FAMDeleted as libc::c_int;
                    } else if (*in_0).mask
                        & (0x800 as libc::c_int | 0x40 as libc::c_int) as libc::c_uint
                        != 0
                    {
                        code = FAMMoved as libc::c_int;
                    }
                    if len != 0 {
                        loop {
                            len = len.wrapping_sub(1);
                            if !(len != 0
                                && *((*in_0).name).as_mut_ptr().offset(
                                    len.wrapping_sub(1 as libc::c_int as libc::c_uint) as isize,
                                ) as libc::c_int
                                    == '\0' as i32)
                            {
                                break;
                            }
                        }
                    }
                    stat_cache_handle_fdevent_fn(
                        scf,
                        fam_dir,
                        ((*in_0).name).as_mut_ptr(),
                        len,
                        code,
                    );
                }
            }
            if !((rd as libc::c_ulong)
                .wrapping_add(::core::mem::size_of::<inotify_event>() as libc::c_ulong)
                .wrapping_add(255 as libc::c_int as libc::c_ulong)
                .wrapping_add(1 as libc::c_int as libc::c_ulong)
                > ::core::mem::size_of::<[libc::c_char; 4096]>() as libc::c_ulong)
            {
                break;
            }
        }
    }
}
unsafe extern "C" fn stat_cache_handle_fdevent(
    mut ctx: *mut libc::c_void,
    mut revent: libc::c_int,
) -> handler_t {
    let scf: *mut stat_cache_fam = ctx as *mut stat_cache_fam;
    if revent & 0x1 as libc::c_int != 0 {
        stat_cache_handle_fdevent_in(scf);
    }
    if revent & (0x10 as libc::c_int | 0x2000 as libc::c_int) != 0 {
        log_error(
            (*scf).errh,
            b"/home/kkysen/work/rust/lighttpd/src/stat_cache.c\0" as *const u8
                as *const libc::c_char,
            556 as libc::c_int as libc::c_uint,
            b"FAM connection closed; disabling stat_cache.\0" as *const u8 as *const libc::c_char,
        );
        fdevent_fdnode_event_del((*scf).ev, (*scf).fdn);
        fdevent_unregister((*scf).ev, (*scf).fd);
        (*scf).fdn = 0 as *mut fdnode;
        close((*scf).fd);
        (*scf).fd = -(1 as libc::c_int);
    }
    return HANDLER_GO_ON;
}
unsafe extern "C" fn stat_cache_init_fam(
    mut ev: *mut fdevents,
    mut errh: *mut log_error_st,
) -> *mut stat_cache_fam {
    let mut scf: *mut stat_cache_fam = calloc(
        1 as libc::c_int as libc::c_ulong,
        ::core::mem::size_of::<stat_cache_fam>() as libc::c_ulong,
    ) as *mut stat_cache_fam;
    if scf.is_null() {
        ck_assert_failed(
            b"/home/kkysen/work/rust/lighttpd/src/stat_cache.c\0" as *const u8
                as *const libc::c_char,
            574 as libc::c_int as libc::c_uint,
            b"scf\0" as *const u8 as *const libc::c_char,
        );
    }
    (*scf).fd = -(1 as libc::c_int);
    (*scf).ev = ev;
    (*scf).errh = errh;
    (*scf).fd = inotify_init1(IN_NONBLOCK as libc::c_int | IN_CLOEXEC as libc::c_int);
    if (*scf).fd < 0 as libc::c_int {
        log_perror(
            errh,
            b"/home/kkysen/work/rust/lighttpd/src/stat_cache.c\0" as *const u8
                as *const libc::c_char,
            582 as libc::c_int as libc::c_uint,
            b"inotify_init1()\0" as *const u8 as *const libc::c_char,
        );
        free(scf as *mut libc::c_void);
        return 0 as *mut stat_cache_fam;
    }
    (*scf).fdn = fdevent_register(
        (*scf).ev,
        (*scf).fd,
        Some(
            stat_cache_handle_fdevent
                as unsafe extern "C" fn(*mut libc::c_void, libc::c_int) -> handler_t,
        ),
        scf as *mut libc::c_void,
    );
    fdevent_fdnode_event_set(
        (*scf).ev,
        (*scf).fdn,
        0x1 as libc::c_int | 0x2000 as libc::c_int,
    );
    return scf;
}
unsafe extern "C" fn fam_dir_invalidate_node(mut fam_dir: *mut fam_dir_entry) {
    (*fam_dir).stat_ts = 0 as libc::c_int as unix_time64_t;
    if !((*fam_dir).fam_parent).is_null() {
        (*(*fam_dir).fam_parent).refcnt -= 1;
        (*fam_dir).fam_parent = 0 as *mut fam_dir_entry;
    }
}
unsafe extern "C" fn fam_dir_invalidate_tree(
    mut t: *mut splay_tree,
    mut name: *const libc::c_char,
    mut len: size_t,
) {
    if !((*t).left).is_null() {
        fam_dir_invalidate_tree((*t).left, name, len);
    }
    if !((*t).right).is_null() {
        fam_dir_invalidate_tree((*t).right, name, len);
    }
    let fam_dir: *mut fam_dir_entry = (*t).data as *mut fam_dir_entry;
    let b: *const buffer = &mut (*fam_dir).name;
    let mut blen: size_t = buffer_clen(b) as size_t;
    if blen > len
        && *((*b).ptr).offset(len as isize) as libc::c_int == '/' as i32
        && 0 as libc::c_int
            == memcmp(
                (*b).ptr as *const libc::c_void,
                name as *const libc::c_void,
                len,
            )
    {
        fam_dir_invalidate_node(fam_dir);
    }
}
unsafe extern "C" fn stat_cache_sptree_find(
    sptree: *mut *mut splay_tree,
    name: *const libc::c_char,
    mut len: uint32_t,
) -> *mut libc::c_void {
    let ndx: libc::c_int = splaytree_djbhash(name, len);
    *sptree = splaytree_splay(*sptree, ndx);
    return if !(*sptree).is_null() && (**sptree).key == ndx {
        (**sptree).data
    } else {
        0 as *mut libc::c_void
    };
}
unsafe extern "C" fn fam_dir_entry_init(
    mut name: *const libc::c_char,
    mut len: size_t,
) -> *mut fam_dir_entry {
    let fam_dir: *mut fam_dir_entry = calloc(
        1 as libc::c_int as libc::c_ulong,
        ::core::mem::size_of::<fam_dir_entry>() as libc::c_ulong,
    ) as *mut fam_dir_entry;
    if fam_dir.is_null() {
        ck_assert_failed(
            b"/home/kkysen/work/rust/lighttpd/src/stat_cache.c\0" as *const u8
                as *const libc::c_char,
            244 as libc::c_int as libc::c_uint,
            b"((void*)0) != fam_dir\0" as *const u8 as *const libc::c_char,
        );
    }
    buffer_copy_string_len(&mut (*fam_dir).name, name, len);
    (*fam_dir).refcnt = 0 as libc::c_int;
    return fam_dir;
}
unsafe extern "C" fn fam_dir_entry_free(mut fam_dir: *mut fam_dir_entry) {
    if fam_dir.is_null() {
        return;
    }
    free((*fam_dir).name.ptr as *mut libc::c_void);
    free(fam_dir as *mut libc::c_void);
}
#[inline]
unsafe extern "C" fn splaytree_djbhash(mut str: *const libc::c_char, len: uint32_t) -> int32_t {
    return (djbhash(str, len, 5381 as libc::c_int as uint32_t)
        & !((1 as libc::c_int as uint32_t) << 31 as libc::c_int)) as int32_t;
}
static mut sc: stat_cache = stat_cache {
    stat_cache_engine: 0,
    files: 0 as *const splay_tree as *mut splay_tree,
    scf: 0 as *const stat_cache_fam as *mut stat_cache_fam,
};
#[no_mangle]
pub unsafe extern "C" fn stat_cache_invalidate_entry(
    mut name: *const libc::c_char,
    mut len: uint32_t,
) {
    let mut sptree: *mut *mut splay_tree = &mut sc.files;
    let mut sce: *mut stat_cache_entry =
        stat_cache_sptree_find(sptree, name, len) as *mut stat_cache_entry;
    if !sce.is_null() && buffer_eq_slen(&mut (*sce).name, name, len as size_t) != 0 {
        (*sce).stat_ts = 0 as libc::c_int as unix_time64_t;
        if !((*sce).fam_dir).is_null() {
            let ref mut fresh216 = (*((*sce).fam_dir as *mut fam_dir_entry)).refcnt;
            *fresh216 -= 1;
            (*sce).fam_dir = 0 as *mut libc::c_void;
        }
    }
}
#[no_mangle]
pub unsafe extern "C" fn stat_cache_etag_get(
    mut sce: *mut stat_cache_entry,
    mut flags: libc::c_int,
) -> *const buffer {
    if buffer_is_blank(&mut (*sce).etag) == 0 {
        return &mut (*sce).etag;
    }
    if (*sce).st.st_mode & 0o170000 as libc::c_int as libc::c_uint
        == 0o100000 as libc::c_int as libc::c_uint
        || (*sce).st.st_mode & 0o170000 as libc::c_int as libc::c_uint
            == 0o40000 as libc::c_int as libc::c_uint
    {
        if 0 as libc::c_int == flags {
            return 0 as *const buffer;
        }
        http_etag_create(&mut (*sce).etag, &mut (*sce).st, flags);
        return &mut (*sce).etag;
    }
    return 0 as *const buffer;
}
#[no_mangle]
#[cold]
pub unsafe extern "C" fn stat_cache_xattrname(mut name: *const libc::c_char) {}
#[no_mangle]
#[cold]
pub unsafe extern "C" fn stat_cache_free() {
    let mut sptree: *mut splay_tree = sc.files;
    while !sptree.is_null() {
        stat_cache_entry_free((*sptree).data);
        sptree = splaytree_delete(sptree, (*sptree).key);
    }
    sc.files = 0 as *mut splay_tree;
    stat_cache_free_fam(sc.scf);
    sc.scf = 0 as *mut stat_cache_fam;
    sc.stat_cache_engine = STAT_CACHE_ENGINE_SIMPLE as libc::c_int;
}
#[no_mangle]
pub unsafe extern "C" fn stat_cache_delete_entry(mut name: *const libc::c_char, mut len: uint32_t) {
    if sc.stat_cache_engine == STAT_CACHE_ENGINE_NONE as libc::c_int {
        return;
    }
    if !(0 as libc::c_int as libc::c_uint != len) {
        ck_assert_failed(
            b"/home/kkysen/work/rust/lighttpd/src/stat_cache.c\0" as *const u8
                as *const libc::c_char,
            1129 as libc::c_int as libc::c_uint,
            b"0 != len\0" as *const u8 as *const libc::c_char,
        );
    }
    if *name.offset(len.wrapping_sub(1 as libc::c_int as libc::c_uint) as isize) as libc::c_int
        == '/' as i32
    {
        len = len.wrapping_sub(1);
        if 0 as libc::c_int as libc::c_uint == len {
            len = 1 as libc::c_int as uint32_t;
        }
    }
    let mut sptree: *mut *mut splay_tree = &mut sc.files;
    let mut sce: *mut stat_cache_entry =
        stat_cache_sptree_find(sptree, name, len) as *mut stat_cache_entry;
    if !sce.is_null() && buffer_eq_slen(&mut (*sce).name, name, len as size_t) != 0 {
        stat_cache_entry_free(sce as *mut libc::c_void);
        *sptree = splaytree_delete(*sptree, (**sptree).key);
    }
}
#[no_mangle]
#[cold]
pub unsafe extern "C" fn stat_cache_init(
    mut ev: *mut fdevents,
    mut errh: *mut log_error_st,
) -> libc::c_int {
    if sc.stat_cache_engine == STAT_CACHE_ENGINE_FAM as libc::c_int {
        sc.scf = stat_cache_init_fam(ev, errh);
        if (sc.scf).is_null() {
            return 0 as libc::c_int;
        }
    }
    return 1 as libc::c_int;
}
#[no_mangle]
#[cold]
pub unsafe extern "C" fn stat_cache_choose_engine(
    mut stat_cache_string: *const buffer,
    mut errh: *mut log_error_st,
) -> libc::c_int {
    if buffer_is_blank(stat_cache_string) != 0 {
        sc.stat_cache_engine = STAT_CACHE_ENGINE_SIMPLE as libc::c_int;
    } else if buffer_eq_slen(
        stat_cache_string,
        b"simple\0" as *const u8 as *const libc::c_char,
        (::core::mem::size_of::<[libc::c_char; 7]>() as libc::c_ulong as uint32_t)
            .wrapping_sub(1 as libc::c_int as libc::c_uint) as size_t,
    ) != 0
    {
        sc.stat_cache_engine = STAT_CACHE_ENGINE_SIMPLE as libc::c_int;
    } else if buffer_eq_slen(
        stat_cache_string,
        b"inotify\0" as *const u8 as *const libc::c_char,
        (::core::mem::size_of::<[libc::c_char; 8]>() as libc::c_ulong as uint32_t)
            .wrapping_sub(1 as libc::c_int as libc::c_uint) as size_t,
    ) != 0
    {
        sc.stat_cache_engine = STAT_CACHE_ENGINE_INOTIFY as libc::c_int;
    } else if buffer_eq_slen(
        stat_cache_string,
        b"fam\0" as *const u8 as *const libc::c_char,
        (::core::mem::size_of::<[libc::c_char; 4]>() as libc::c_ulong as uint32_t)
            .wrapping_sub(1 as libc::c_int as libc::c_uint) as size_t,
    ) != 0
    {
        sc.stat_cache_engine = STAT_CACHE_ENGINE_FAM as libc::c_int;
    } else if buffer_eq_slen(
        stat_cache_string,
        b"disable\0" as *const u8 as *const libc::c_char,
        (::core::mem::size_of::<[libc::c_char; 8]>() as libc::c_ulong as uint32_t)
            .wrapping_sub(1 as libc::c_int as libc::c_uint) as size_t,
    ) != 0
        || buffer_eq_slen(
            stat_cache_string,
            b"none\0" as *const u8 as *const libc::c_char,
            (::core::mem::size_of::<[libc::c_char; 5]>() as libc::c_ulong as uint32_t)
                .wrapping_sub(1 as libc::c_int as libc::c_uint) as size_t,
        ) != 0
    {
        sc.stat_cache_engine = STAT_CACHE_ENGINE_NONE as libc::c_int;
    } else {
        log_error(
            errh,
            b"/home/kkysen/work/rust/lighttpd/src/stat_cache.c\0" as *const u8
                as *const libc::c_char,
            927 as libc::c_int as libc::c_uint,
            b"server.stat-cache-engine can be one of \"disable\", \"simple\", \"inotify\", \"fam\", but not: %s\0"
                as *const u8 as *const libc::c_char,
            (*stat_cache_string).ptr,
        );
        return -(1 as libc::c_int);
    }
    return 0 as libc::c_int;
}
#[no_mangle]
pub unsafe extern "C" fn stat_cache_entry_refchg(
    mut data: *mut libc::c_void,
    mut mod_0: libc::c_int,
) {
    let sce: *mut stat_cache_entry = data as *mut stat_cache_entry;
    if mod_0 < 0 as libc::c_int && 1 as libc::c_int == (*sce).refcnt {
        stat_cache_entry_free(data);
    } else {
        (*sce).refcnt += mod_0;
    };
}
#[no_mangle]
pub unsafe extern "C" fn stat_cache_mimetype_by_ext(
    mimetypes: *const array,
    name: *const libc::c_char,
    nlen: uint32_t,
) -> *const buffer {
    let end: *const libc::c_char = name.offset(nlen as isize);
    let used: uint32_t = (*mimetypes).used;
    if used < 16 as libc::c_int as libc::c_uint {
        let mut i: uint32_t = 0 as libc::c_int as uint32_t;
        while i < used {
            let mut ds: *const data_string =
                *((*mimetypes).data).offset(i as isize) as *mut data_string;
            let klen: size_t = buffer_clen(&(*ds).key) as size_t;
            if klen <= nlen as libc::c_ulong
                && buffer_eq_icase_ssn(end.offset(-(klen as isize)), (*ds).key.ptr, klen) != 0
            {
                return &(*ds).value;
            }
            i = i.wrapping_add(1);
        }
    } else {
        let mut s: *const libc::c_char = 0 as *const libc::c_char;
        let mut ds_0: *const data_string = 0 as *const data_string;
        if nlen != 0 {
            s = end.offset(-(1 as libc::c_int as isize));
            while s != name && *s as libc::c_int != '/' as i32 {
                s = s.offset(-1);
            }
            if *s as libc::c_int == '/' as i32 {
                s = s.offset(1);
            }
        } else {
            s = name;
        }
        ds_0 = array_get_element_klen(mimetypes, s, end.offset_from(s) as libc::c_long as uint32_t)
            as *const data_string;
        if !ds_0.is_null() {
            return &(*ds_0).value;
        }
        loop {
            s = s.offset(1);
            if !(s < end) {
                break;
            }
            while *s as libc::c_int != '.' as i32 && {
                s = s.offset(1);
                s != end
            } {}
            if s == end {
                break;
            }
            ds_0 = array_get_element_klen(
                mimetypes,
                s,
                end.offset_from(s) as libc::c_long as uint32_t,
            ) as *const data_string;
            if !ds_0.is_null() {
                return &(*ds_0).value;
            }
            s = s.offset(1);
            if !(s < end) {
                continue;
            }
            if *s as libc::c_int == '.' as i32 {
                s = s.offset(-1);
            } else {
                ds_0 = array_get_element_klen(
                    mimetypes,
                    s,
                    end.offset_from(s) as libc::c_long as uint32_t,
                ) as *const data_string;
                if !ds_0.is_null() {
                    return &(*ds_0).value;
                }
            }
        }
        ds_0 = array_get_element_klen(
            mimetypes,
            b"\0" as *const u8 as *const libc::c_char,
            (::core::mem::size_of::<[libc::c_char; 1]>() as libc::c_ulong as uint32_t)
                .wrapping_sub(1 as libc::c_int as libc::c_uint),
        ) as *const data_string;
        if !ds_0.is_null() {
            return &(*ds_0).value;
        }
    }
    return 0 as *const buffer;
}
#[no_mangle]
pub unsafe extern "C" fn stat_cache_content_type_get_by_ext(
    mut sce: *mut stat_cache_entry,
    mut mimetypes: *const array,
) -> *const buffer {
    if buffer_is_blank(&mut (*sce).content_type) == 0 {
        return &mut (*sce).content_type;
    }
    if !((*sce).st.st_mode & 0o170000 as libc::c_int as libc::c_uint
        == 0o100000 as libc::c_int as libc::c_uint)
    {
        return 0 as *const buffer;
    }
    let mtype: *const buffer =
        stat_cache_mimetype_by_ext(mimetypes, (*sce).name.ptr, buffer_clen(&mut (*sce).name));
    if !mtype.is_null() {
        (*sce).content_type.ptr = (*mtype).ptr;
        (*sce).content_type.used = (*mtype).used;
    } else {
        buffer_clear(&mut (*sce).content_type);
    }
    return &mut (*sce).content_type;
}
unsafe extern "C" fn stat_cache_entry_free(mut data: *mut libc::c_void) {
    let mut sce: *mut stat_cache_entry = data as *mut stat_cache_entry;
    if sce.is_null() {
        return;
    }
    (*sce).refcnt -= 1;
    if (*sce).refcnt != 0 {
        return;
    }
    if !((*sce).fam_dir).is_null() {
        let ref mut fresh217 = (*((*sce).fam_dir as *mut fam_dir_entry)).refcnt;
        *fresh217 -= 1;
    }
    free((*sce).name.ptr as *mut libc::c_void);
    free((*sce).etag.ptr as *mut libc::c_void);
    if (*sce).content_type.size != 0 {
        free((*sce).content_type.ptr as *mut libc::c_void);
    }
    if (*sce).fd >= 0 as libc::c_int {
        close((*sce).fd);
    }
    free(sce as *mut libc::c_void);
}
unsafe extern "C" fn stat_cache_stat_eq(sta: *const stat, stb: *const stat) -> libc::c_int {
    return ((*sta).st_mtim.tv_nsec == (*stb).st_mtim.tv_nsec
        && (*sta).st_mtim.tv_sec == (*stb).st_mtim.tv_sec
        && (*sta).st_size == (*stb).st_size
        && (*sta).st_ino == (*stb).st_ino
        && (*sta).st_dev == (*stb).st_dev) as libc::c_int;
}
unsafe extern "C" fn stat_cache_entry_init() -> *mut stat_cache_entry {
    let mut sce: *mut stat_cache_entry = calloc(
        1 as libc::c_int as libc::c_ulong,
        ::core::mem::size_of::<stat_cache_entry>() as libc::c_ulong,
    ) as *mut stat_cache_entry;
    if sce.is_null() {
        ck_assert_failed(
            b"/home/kkysen/work/rust/lighttpd/src/stat_cache.c\0" as *const u8
                as *const libc::c_char,
            797 as libc::c_int as libc::c_uint,
            b"((void*)0) != sce\0" as *const u8 as *const libc::c_char,
        );
    }
    (*sce).fd = -(1 as libc::c_int);
    (*sce).refcnt = 1 as libc::c_int;
    return sce;
}
#[no_mangle]
pub unsafe extern "C" fn stat_cache_update_entry(
    mut name: *const libc::c_char,
    mut len: uint32_t,
    mut st: *const stat,
    mut etagb: *const buffer,
) {
    if sc.stat_cache_engine == STAT_CACHE_ENGINE_NONE as libc::c_int {
        return;
    }
    if !(0 as libc::c_int as libc::c_uint != len) {
        ck_assert_failed(
            b"/home/kkysen/work/rust/lighttpd/src/stat_cache.c\0" as *const u8
                as *const libc::c_char,
            1095 as libc::c_int as libc::c_uint,
            b"0 != len\0" as *const u8 as *const libc::c_char,
        );
    }
    if *name.offset(len.wrapping_sub(1 as libc::c_int as libc::c_uint) as isize) as libc::c_int
        == '/' as i32
    {
        len = len.wrapping_sub(1);
        if 0 as libc::c_int as libc::c_uint == len {
            len = 1 as libc::c_int as uint32_t;
        }
    }
    let mut sptree: *mut *mut splay_tree = &mut sc.files;
    let mut sce: *mut stat_cache_entry =
        stat_cache_sptree_find(sptree, name, len) as *mut stat_cache_entry;
    if !sce.is_null() && buffer_eq_slen(&mut (*sce).name, name, len as size_t) != 0 {
        if stat_cache_stat_eq(&mut (*sce).st, st) == 0 {
            buffer_clear(&mut (*sce).etag);
            if !etagb.is_null() {
                buffer_copy_string_len(
                    &mut (*sce).etag,
                    (*etagb).ptr,
                    buffer_clen(etagb) as size_t,
                );
            }
            if (*sce).fd >= 0 as libc::c_int {
                if 1 as libc::c_int == (*sce).refcnt {
                    close((*sce).fd);
                    (*sce).fd = -(1 as libc::c_int);
                } else {
                    (*sce).refcnt -= 1;
                    sce = stat_cache_entry_init();
                    (**sptree).data = sce as *mut libc::c_void;
                    buffer_copy_string_len(&mut (*sce).name, name, len as size_t);
                }
            }
            (*sce).st = *st;
        }
        (*sce).stat_ts = log_monotonic_secs;
    }
}
unsafe extern "C" fn stat_cache_tag_old_entries(
    t: *mut splay_tree,
    keys: *mut libc::c_int,
    ndx: *mut libc::c_int,
    max_age: time_t,
    cur_ts: unix_time64_t,
) {
    if *ndx == 8192 as libc::c_int {
        return;
    }
    if !((*t).left).is_null() {
        stat_cache_tag_old_entries((*t).left, keys, ndx, max_age, cur_ts);
    }
    if !((*t).right).is_null() {
        stat_cache_tag_old_entries((*t).right, keys, ndx, max_age, cur_ts);
    }
    if *ndx == 8192 as libc::c_int {
        return;
    }
    let sce: *const stat_cache_entry = (*t).data as *const stat_cache_entry;
    if cur_ts - (*sce).stat_ts > max_age {
        let fresh218 = *ndx;
        *ndx = *ndx + 1;
        *keys.offset(fresh218 as isize) = (*t).key;
    }
}
#[no_mangle]
pub unsafe extern "C" fn stat_cache_open_rdonly_fstat(
    mut name: *const buffer,
    mut st: *mut stat,
    mut symlinks: libc::c_int,
) -> libc::c_int {
    let fd: libc::c_int = fdevent_open_cloexec(
        (*name).ptr,
        symlinks,
        0 as libc::c_int,
        0 as libc::c_int as mode_t,
    );
    if fd >= 0 as libc::c_int {
        if 0 as libc::c_int == fstat(fd, st) {
            return fd;
        } else {
            let errnum: libc::c_int = *__errno_location();
            close(fd);
            *__errno_location() = errnum;
        }
    }
    return -(1 as libc::c_int);
}
#[no_mangle]
#[cold]
pub unsafe extern "C" fn stat_cache_path_contains_symlink(
    mut name: *const buffer,
    mut errh: *mut log_error_st,
) -> libc::c_int {
    let mut len: size_t = buffer_clen(name) as size_t;
    if !(0 as libc::c_int as libc::c_ulong != len) {
        ck_assert_failed(
            b"/home/kkysen/work/rust/lighttpd/src/stat_cache.c\0" as *const u8
                as *const libc::c_char,
            1425 as libc::c_int as libc::c_uint,
            b"0 != len\0" as *const u8 as *const libc::c_char,
        );
    }
    if !(*((*name).ptr).offset(0 as libc::c_int as isize) as libc::c_int == '/' as i32) {
        ck_assert_failed(
            b"/home/kkysen/work/rust/lighttpd/src/stat_cache.c\0" as *const u8
                as *const libc::c_char,
            1426 as libc::c_int as libc::c_uint,
            b"name->ptr[0] == '/'\0" as *const u8 as *const libc::c_char,
        );
    }
    if 1 as libc::c_int as libc::c_ulong == len {
        return 0 as libc::c_int;
    }
    if len >= 4096 as libc::c_int as libc::c_ulong {
        return -(1 as libc::c_int);
    }
    let mut buf: [libc::c_char; 4096] = [0; 4096];
    memcpy(
        buf.as_mut_ptr() as *mut libc::c_void,
        (*name).ptr as *const libc::c_void,
        len,
    );
    let mut s_cur: *mut libc::c_char = buf.as_mut_ptr().offset(len as isize);
    loop {
        *s_cur = '\0' as i32 as libc::c_char;
        let mut st: stat = stat {
            st_dev: 0,
            st_ino: 0,
            st_nlink: 0,
            st_mode: 0,
            st_uid: 0,
            st_gid: 0,
            __pad0: 0,
            st_rdev: 0,
            st_size: 0,
            st_blksize: 0,
            st_blocks: 0,
            st_atim: timespec {
                tv_sec: 0,
                tv_nsec: 0,
            },
            st_mtim: timespec {
                tv_sec: 0,
                tv_nsec: 0,
            },
            st_ctim: timespec {
                tv_sec: 0,
                tv_nsec: 0,
            },
            __glibc_reserved: [0; 3],
        };
        if 0 as libc::c_int == lstat(buf.as_mut_ptr(), &mut st) {
            if st.st_mode & 0o170000 as libc::c_int as libc::c_uint
                == 0o120000 as libc::c_int as libc::c_uint
            {
                return 1 as libc::c_int;
            }
        } else {
            log_perror(
                errh,
                b"/home/kkysen/work/rust/lighttpd/src/stat_cache.c\0" as *const u8
                    as *const libc::c_char,
                1443 as libc::c_int as libc::c_uint,
                b"lstat failed for: %s\0" as *const u8 as *const libc::c_char,
                buf.as_mut_ptr(),
            );
            return -(1 as libc::c_int);
        }
        s_cur = strrchr(buf.as_mut_ptr(), '/' as i32);
        if !(s_cur > buf.as_mut_ptr()) {
            break;
        }
    }
    return 0 as libc::c_int;
}
unsafe extern "C" fn stat_cache_delete_tree(mut name: *const libc::c_char, mut len: uint32_t) {
    stat_cache_delete_entry(name, len);
    stat_cache_prune_dir_tree(name, len as size_t);
}
#[inline(never)]
unsafe extern "C" fn stat_cache_prune_dir_tree(mut name: *const libc::c_char, mut len: size_t) {
    let mut sptree: *mut splay_tree = sc.files;
    let mut max_ndx: libc::c_int = 0;
    let mut i: libc::c_int = 0;
    let mut keys: [libc::c_int; 8192] = [0; 8192];
    while !sptree.is_null() {
        max_ndx = 0 as libc::c_int;
        stat_cache_tag_dir_tree(sptree, name, len, keys.as_mut_ptr(), &mut max_ndx);
        i = 0 as libc::c_int;
        while i < max_ndx {
            let ndx: libc::c_int = keys[i as usize];
            sptree = splaytree_splay(sptree, ndx);
            let mut node: *mut splay_tree = sptree;
            if !node.is_null() && (*node).key == ndx {
                stat_cache_entry_free((*node).data);
                sptree = splaytree_delete(sptree, ndx);
            }
            i += 1;
        }
        if !(max_ndx as libc::c_ulong
            == (::core::mem::size_of::<[libc::c_int; 8192]>() as libc::c_ulong)
                .wrapping_div(::core::mem::size_of::<libc::c_int>() as libc::c_ulong))
        {
            break;
        }
    }
    sc.files = sptree;
}
#[no_mangle]
pub unsafe extern "C" fn stat_cache_get_entry(name: *const buffer) -> *mut stat_cache_entry {
    let mut sce: *mut stat_cache_entry = 0 as *mut stat_cache_entry;
    let mut final_slash: libc::c_int = 0 as libc::c_int;
    let mut len: size_t = buffer_clen(name) as size_t;
    if !(0 as libc::c_int as libc::c_ulong != len) {
        ck_assert_failed(
            b"/home/kkysen/work/rust/lighttpd/src/stat_cache.c\0" as *const u8
                as *const libc::c_char,
            1262 as libc::c_int as libc::c_uint,
            b"0 != len\0" as *const u8 as *const libc::c_char,
        );
    }
    if *((*name).ptr).offset(len.wrapping_sub(1 as libc::c_int as libc::c_ulong) as isize)
        as libc::c_int
        == '/' as i32
    {
        final_slash = 1 as libc::c_int;
        len = len.wrapping_sub(1);
        if 0 as libc::c_int as libc::c_ulong == len {
            len = 1 as libc::c_int as size_t;
        }
    }
    if *((*name).ptr).offset(0 as libc::c_int as isize) as libc::c_int != '/' as i32 {
        *__errno_location() = 22 as libc::c_int;
        return 0 as *mut stat_cache_entry;
    }
    let cur_ts: unix_time64_t = log_monotonic_secs;
    let file_ndx: libc::c_int = splaytree_djbhash((*name).ptr, len as uint32_t);
    sc.files = splaytree_splay(sc.files, file_ndx);
    let mut sptree: *mut splay_tree = sc.files;
    if !sptree.is_null() && (*sptree).key == file_ndx {
        sce = (*sptree).data as *mut stat_cache_entry;
        if buffer_eq_slen(&mut (*sce).name, (*name).ptr, len) != 0 {
            if sc.stat_cache_engine == STAT_CACHE_ENGINE_SIMPLE as libc::c_int {
                if (*sce).stat_ts == cur_ts {
                    if final_slash != 0
                        && !((*sce).st.st_mode & 0o170000 as libc::c_int as libc::c_uint
                            == 0o40000 as libc::c_int as libc::c_uint)
                    {
                        *__errno_location() = 20 as libc::c_int;
                        return 0 as *mut stat_cache_entry;
                    }
                    return sce;
                }
            } else if sc.stat_cache_engine == STAT_CACHE_ENGINE_FAM as libc::c_int
                && !((*sce).fam_dir).is_null()
            {
                if cur_ts - (*sce).stat_ts < 16 as libc::c_int as libc::c_long {
                    if final_slash != 0
                        && !((*sce).st.st_mode & 0o170000 as libc::c_int as libc::c_uint
                            == 0o40000 as libc::c_int as libc::c_uint)
                    {
                        *__errno_location() = 20 as libc::c_int;
                        return 0 as *mut stat_cache_entry;
                    }
                    return sce;
                }
            }
        } else {
            sce = 0 as *mut stat_cache_entry;
        }
    }
    let mut st: stat = stat {
        st_dev: 0,
        st_ino: 0,
        st_nlink: 0,
        st_mode: 0,
        st_uid: 0,
        st_gid: 0,
        __pad0: 0,
        st_rdev: 0,
        st_size: 0,
        st_blksize: 0,
        st_blocks: 0,
        st_atim: timespec {
            tv_sec: 0,
            tv_nsec: 0,
        },
        st_mtim: timespec {
            tv_sec: 0,
            tv_nsec: 0,
        },
        st_ctim: timespec {
            tv_sec: 0,
            tv_nsec: 0,
        },
        __glibc_reserved: [0; 3],
    };
    if -(1 as libc::c_int) == stat((*name).ptr, &mut st) {
        return 0 as *mut stat_cache_entry;
    }
    if sce.is_null() {
        if final_slash != 0
            && st.st_mode & 0o170000 as libc::c_int as libc::c_uint
                == 0o100000 as libc::c_int as libc::c_uint
        {
            *__errno_location() = 20 as libc::c_int;
            return 0 as *mut stat_cache_entry;
        }
        sce = stat_cache_entry_init();
        buffer_copy_string_len(&mut (*sce).name, (*name).ptr, len);
        if !sptree.is_null() && (*sptree).key == file_ndx {
            stat_cache_entry_free((*sptree).data);
            (*sptree).data = sce as *mut libc::c_void;
        } else {
            sc.files = splaytree_insert(sptree, file_ndx, sce as *mut libc::c_void);
        }
    } else {
        buffer_clear(&mut (*sce).etag);
        if (*sce).fd >= 0 as libc::c_int && stat_cache_stat_eq(&mut (*sce).st, &mut st) == 0 {
            if 1 as libc::c_int == (*sce).refcnt {
                close((*sce).fd);
                (*sce).fd = -(1 as libc::c_int);
            } else {
                (*sce).refcnt -= 1;
                sce = stat_cache_entry_init();
                (*sptree).data = sce as *mut libc::c_void;
                buffer_copy_string_len(&mut (*sce).name, (*name).ptr, len);
            }
        }
    }
    (*sce).st = st;
    if sc.stat_cache_engine == STAT_CACHE_ENGINE_FAM as libc::c_int {
        if !((*sce).fam_dir).is_null() {
            let ref mut fresh219 = (*((*sce).fam_dir as *mut fam_dir_entry)).refcnt;
            *fresh219 -= 1;
        }
        (*sce).fam_dir =
            fam_dir_monitor(sc.scf, (*name).ptr, len as uint32_t, &mut st) as *mut libc::c_void;
    }
    (*sce).stat_ts = cur_ts;
    return sce;
}
unsafe extern "C" fn stat_cache_invalidate_dir_tree_walk(
    mut t: *mut splay_tree,
    mut name: *const libc::c_char,
    mut len: size_t,
) {
    if !((*t).left).is_null() {
        stat_cache_invalidate_dir_tree_walk((*t).left, name, len);
    }
    if !((*t).right).is_null() {
        stat_cache_invalidate_dir_tree_walk((*t).right, name, len);
    }
    let b: *const buffer = &mut (*((*t).data as *mut stat_cache_entry)).name;
    let blen: size_t = buffer_clen(b) as size_t;
    if blen > len
        && *((*b).ptr).offset(len as isize) as libc::c_int == '/' as i32
        && 0 as libc::c_int
            == memcmp(
                (*b).ptr as *const libc::c_void,
                name as *const libc::c_void,
                len,
            )
    {
        let mut sce: *mut stat_cache_entry = (*t).data as *mut stat_cache_entry;
        (*sce).stat_ts = 0 as libc::c_int as unix_time64_t;
        if !((*sce).fam_dir).is_null() {
            let ref mut fresh220 = (*((*sce).fam_dir as *mut fam_dir_entry)).refcnt;
            *fresh220 -= 1;
            (*sce).fam_dir = 0 as *mut libc::c_void;
        }
    }
}
unsafe extern "C" fn stat_cache_invalidate_dir_tree(
    mut name: *const libc::c_char,
    mut len: size_t,
) {
    let sptree: *mut splay_tree = sc.files;
    if !sptree.is_null() {
        stat_cache_invalidate_dir_tree_walk(sptree, name, len);
    }
}
#[no_mangle]
pub unsafe extern "C" fn stat_cache_get_entry_open(
    name: *const buffer,
    symlinks: libc::c_int,
) -> *mut stat_cache_entry {
    let sce: *mut stat_cache_entry = stat_cache_get_entry(name);
    if sce.is_null() {
        return 0 as *mut stat_cache_entry;
    }
    if (*sce).fd >= 0 as libc::c_int {
        return sce;
    }
    if (*sce).st.st_size > 0 as libc::c_int as libc::c_long {
        (*sce).fd = stat_cache_open_rdonly_fstat(name, &mut (*sce).st, symlinks);
        buffer_clear(&mut (*sce).etag);
    }
    return sce;
}
#[no_mangle]
pub unsafe extern "C" fn stat_cache_delete_dir(mut name: *const libc::c_char, mut len: uint32_t) {
    if !(0 as libc::c_int as libc::c_uint != len) {
        ck_assert_failed(
            b"/home/kkysen/work/rust/lighttpd/src/stat_cache.c\0" as *const u8
                as *const libc::c_char,
            1231 as libc::c_int as libc::c_uint,
            b"0 != len\0" as *const u8 as *const libc::c_char,
        );
    }
    if *name.offset(len.wrapping_sub(1 as libc::c_int as libc::c_uint) as isize) as libc::c_int
        == '/' as i32
    {
        len = len.wrapping_sub(1);
        if 0 as libc::c_int as libc::c_uint == len {
            len = 1 as libc::c_int as uint32_t;
        }
    }
    stat_cache_delete_tree(name, len);
    if sc.stat_cache_engine == STAT_CACHE_ENGINE_FAM as libc::c_int {
        let mut sptree: *mut *mut splay_tree = &mut (*sc.scf).dirs;
        let mut fam_dir: *mut fam_dir_entry =
            stat_cache_sptree_find(sptree, name, len) as *mut fam_dir_entry;
        if !fam_dir.is_null() && buffer_eq_slen(&mut (*fam_dir).name, name, len as size_t) != 0 {
            fam_dir_invalidate_node(fam_dir);
        }
        if !(*sptree).is_null() {
            fam_dir_invalidate_tree(*sptree, name, len as size_t);
        }
        fam_dir_periodic_cleanup();
    }
}
#[no_mangle]
pub unsafe extern "C" fn stat_cache_path_stat(name: *const buffer) -> *const stat_cache_st {
    let sce: *const stat_cache_entry = stat_cache_get_entry(name);
    return if !sce.is_null() {
        &(*sce).st
    } else {
        0 as *const stat
    };
}
#[no_mangle]
pub unsafe extern "C" fn stat_cache_path_isdir(mut name: *const buffer) -> libc::c_int {
    let sce: *const stat_cache_entry = stat_cache_get_entry(name);
    return (!sce.is_null()
        && (if (*sce).st.st_mode & 0o170000 as libc::c_int as libc::c_uint
            == 0o40000 as libc::c_int as libc::c_uint
        {
            1 as libc::c_int
        } else {
            *__errno_location() = 20 as libc::c_int;
            0 as libc::c_int
        }) != 0) as libc::c_int;
}
unsafe extern "C" fn stat_cache_tag_dir_tree(
    mut t: *mut splay_tree,
    mut name: *const libc::c_char,
    mut len: size_t,
    mut keys: *mut libc::c_int,
    mut ndx: *mut libc::c_int,
) {
    if *ndx == 8192 as libc::c_int {
        return;
    }
    if !((*t).left).is_null() {
        stat_cache_tag_dir_tree((*t).left, name, len, keys, ndx);
    }
    if !((*t).right).is_null() {
        stat_cache_tag_dir_tree((*t).right, name, len, keys, ndx);
    }
    if *ndx == 8192 as libc::c_int {
        return;
    }
    let b: *const buffer = &mut (*((*t).data as *mut stat_cache_entry)).name;
    let blen: size_t = buffer_clen(b) as size_t;
    if blen > len
        && *((*b).ptr).offset(len as isize) as libc::c_int == '/' as i32
        && 0 as libc::c_int
            == memcmp(
                (*b).ptr as *const libc::c_void,
                name as *const libc::c_void,
                len,
            )
    {
        let fresh221 = *ndx;
        *ndx = *ndx + 1;
        *keys.offset(fresh221 as isize) = (*t).key;
    }
}
unsafe extern "C" fn stat_cache_periodic_cleanup(max_age: time_t, cur_ts: unix_time64_t) {
    let mut sptree: *mut splay_tree = sc.files;
    let mut max_ndx: libc::c_int = 0;
    let mut i: libc::c_int = 0;
    let mut keys: [libc::c_int; 8192] = [0; 8192];
    while !sptree.is_null() {
        max_ndx = 0 as libc::c_int;
        stat_cache_tag_old_entries(sptree, keys.as_mut_ptr(), &mut max_ndx, max_age, cur_ts);
        i = 0 as libc::c_int;
        while i < max_ndx {
            let mut ndx: libc::c_int = keys[i as usize];
            sptree = splaytree_splay(sptree, ndx);
            if !sptree.is_null() && (*sptree).key == ndx {
                stat_cache_entry_free((*sptree).data);
                sptree = splaytree_delete(sptree, ndx);
            }
            i += 1;
        }
        if !(max_ndx as libc::c_ulong
            == (::core::mem::size_of::<[libc::c_int; 8192]>() as libc::c_ulong)
                .wrapping_div(::core::mem::size_of::<libc::c_int>() as libc::c_ulong))
        {
            break;
        }
    }
    sc.files = sptree;
}
#[no_mangle]
pub unsafe extern "C" fn stat_cache_trigger_cleanup() {
    let mut max_age: time_t = 2 as libc::c_int as time_t;
    if STAT_CACHE_ENGINE_FAM as libc::c_int == sc.stat_cache_engine {
        if log_monotonic_secs & 0x1f as libc::c_int as libc::c_long != 0 {
            return;
        }
        max_age = 32 as libc::c_int as time_t;
        fam_dir_periodic_cleanup();
    }
    stat_cache_periodic_cleanup(max_age, log_monotonic_secs);
}
#[no_mangle]
pub static mut plugin_stats: array = array {
    data: 0 as *const *mut data_unset as *mut *mut data_unset,
    sorted: 0 as *const *mut data_unset as *mut *mut data_unset,
    used: 0,
    size: 0,
};
unsafe extern "C" fn plugin_init() -> *mut plugin {
    let mut p: *mut plugin = 0 as *mut plugin;
    p = calloc(
        1 as libc::c_int as libc::c_ulong,
        ::core::mem::size_of::<plugin>() as libc::c_ulong,
    ) as *mut plugin;
    if p.is_null() {
        ck_assert_failed(
            b"/home/kkysen/work/rust/lighttpd/src/plugin.c\0" as *const u8 as *const libc::c_char,
            62 as libc::c_int as libc::c_uint,
            b"((void*)0) != p\0" as *const u8 as *const libc::c_char,
        );
    }
    return p;
}
unsafe extern "C" fn plugin_free(mut p: *mut plugin) {
    if p.is_null() {
        return;
    }
    if !((*p).lib).is_null() {
        dlclose((*p).lib);
    }
    free(p as *mut libc::c_void);
}
unsafe extern "C" fn plugins_register(mut srv: *mut server, mut p: *mut plugin) {
    let mut ps: *mut *mut plugin = 0 as *mut *mut plugin;
    if (*srv).plugins.used == (*srv).plugins.size {
        (*srv).plugins.size = ((*srv).plugins.size as libc::c_uint)
            .wrapping_add(4 as libc::c_int as libc::c_uint)
            as uint32_t as uint32_t;
        (*srv).plugins.ptr = realloc(
            (*srv).plugins.ptr,
            ((*srv).plugins.size as libc::c_ulong)
                .wrapping_mul(::core::mem::size_of::<*mut plugin>() as libc::c_ulong),
        );
        if ((*srv).plugins.ptr).is_null() {
            ck_assert_failed(
                b"/home/kkysen/work/rust/lighttpd/src/plugin.c\0" as *const u8
                    as *const libc::c_char,
                90 as libc::c_int as libc::c_uint,
                b"((void*)0) != srv->plugins.ptr\0" as *const u8 as *const libc::c_char,
            );
        }
    }
    ps = (*srv).plugins.ptr as *mut *mut plugin;
    let fresh222 = (*srv).plugins.used;
    (*srv).plugins.used = ((*srv).plugins.used).wrapping_add(1);
    let ref mut fresh223 = *ps.offset(fresh222 as isize);
    *fresh223 = p;
}
#[no_mangle]
#[cold]
pub unsafe extern "C" fn plugins_load(mut srv: *mut server) -> libc::c_int {
    let tb: *mut buffer = (*srv).tmp_buf;
    let mut p: *mut plugin = 0 as *mut plugin;
    let mut init: Option<unsafe extern "C" fn(*mut plugin) -> libc::c_int> = None;
    let mut current_block_24: u64;
    let mut i: uint32_t = 0 as libc::c_int as uint32_t;
    while i < (*(*srv).srvconf.modules).used {
        let module: *const buffer = &mut (*(*((*(*srv).srvconf.modules).data).offset(i as isize)
            as *mut data_string))
            .value;
        buffer_copy_string(tb, (*srv).srvconf.modules_dir);
        buffer_append_path_len(tb, (*module).ptr, buffer_clen(module) as size_t);
        buffer_append_string_len(
            tb,
            b".so\0" as *const u8 as *const libc::c_char,
            (::core::mem::size_of::<[libc::c_char; 4]>() as libc::c_ulong as uint32_t)
                .wrapping_sub(1 as libc::c_int as libc::c_uint) as size_t,
        );
        p = plugin_init();
        (*p).lib = dlopen((*tb).ptr, 0x2 as libc::c_int | 0x100 as libc::c_int);
        if ((*p).lib).is_null() {
            log_error(
                (*srv).errh,
                b"/home/kkysen/work/rust/lighttpd/src/plugin.c\0" as *const u8
                    as *const libc::c_char,
                203 as libc::c_int as libc::c_uint,
                b"dlopen() failed for: %s %s\0" as *const u8 as *const libc::c_char,
                (*tb).ptr,
                dlerror(),
            );
            plugin_free(p);
            if (*srv).srvconf.compat_module_load != 0 {
                if buffer_eq_slen(
                    module,
                    b"mod_deflate\0" as *const u8 as *const libc::c_char,
                    (::core::mem::size_of::<[libc::c_char; 12]>() as libc::c_ulong as uint32_t)
                        .wrapping_sub(1 as libc::c_int as libc::c_uint)
                        as size_t,
                ) != 0
                {
                    current_block_24 = 6239978542346980191;
                } else {
                    current_block_24 = 1394248824506584008;
                }
            } else {
                current_block_24 = 1394248824506584008;
            }
            match current_block_24 {
                6239978542346980191 => {}
                _ => return -(1 as libc::c_int),
            }
        } else {
            buffer_clear(tb);
            buffer_append_str2(
                tb,
                (*module).ptr,
                buffer_clen(module) as size_t,
                b"_plugin_init\0" as *const u8 as *const libc::c_char,
                (::core::mem::size_of::<[libc::c_char; 13]>() as libc::c_ulong as uint32_t)
                    .wrapping_sub(1 as libc::c_int as libc::c_uint) as size_t,
            );
            init = ::core::mem::transmute::<
                libc::intptr_t,
                Option<unsafe extern "C" fn(*mut plugin) -> libc::c_int>,
            >(dlsym((*p).lib, (*tb).ptr) as intptr_t as libc::intptr_t);
            if init.is_none() {
                let mut error: *const libc::c_char = dlerror();
                if !error.is_null() {
                    log_error(
                        (*srv).errh,
                        b"/home/kkysen/work/rust/lighttpd/src/plugin.c\0" as *const u8
                            as *const libc::c_char,
                        250 as libc::c_int as libc::c_uint,
                        b"dlsym: %s\0" as *const u8 as *const libc::c_char,
                        error,
                    );
                } else {
                    log_error(
                        (*srv).errh,
                        b"/home/kkysen/work/rust/lighttpd/src/plugin.c\0" as *const u8
                            as *const libc::c_char,
                        252 as libc::c_int as libc::c_uint,
                        b"dlsym symbol not found: %s\0" as *const u8 as *const libc::c_char,
                        (*tb).ptr,
                    );
                }
                plugin_free(p);
                return -(1 as libc::c_int);
            }
            if (Some(init.expect("non-null function pointer"))).expect("non-null function pointer")(
                p,
            ) != 0
            {
                log_error(
                    (*srv).errh,
                    b"/home/kkysen/work/rust/lighttpd/src/plugin.c\0" as *const u8
                        as *const libc::c_char,
                    261 as libc::c_int as libc::c_uint,
                    b"%s plugin init failed\0" as *const u8 as *const libc::c_char,
                    (*module).ptr,
                );
                plugin_free(p);
                return -(1 as libc::c_int);
            }
            plugins_register(srv, p);
        }
        i = i.wrapping_add(1);
    }
    return 0 as libc::c_int;
}
unsafe extern "C" fn plugins_call_fn_req_data(r: *mut request_st, e: libc::c_int) -> handler_t {
    let plugin_slots: *const libc::c_void = (*(*r).con).plugin_slots;
    let offset: uint32_t = *(plugin_slots as *const uint16_t).offset(e as isize) as uint32_t;
    if 0 as libc::c_int as libc::c_uint == offset {
        return HANDLER_GO_ON;
    }
    let mut plfd: *const plugin_fn_data =
        (plugin_slots as uintptr_t).wrapping_add(offset as libc::c_ulong) as *const plugin_fn_data;
    let mut rc: handler_t = HANDLER_GO_ON;
    while ((*plfd).fn_0).is_some() && {
        rc = ::core::mem::transmute::<_, fn(_, _) -> handler_t>(
            ((*plfd).fn_0).expect("non-null function pointer"),
        )(r, (*plfd).data);
        rc as libc::c_uint == HANDLER_GO_ON as libc::c_int as libc::c_uint
    } {
        plfd = plfd.offset(1);
    }
    return rc;
}
unsafe extern "C" fn plugins_call_fn_con_data(con: *mut connection, e: libc::c_int) -> handler_t {
    let plugin_slots: *const libc::c_void = (*con).plugin_slots;
    let offset: uint32_t = *(plugin_slots as *const uint16_t).offset(e as isize) as uint32_t;
    if 0 as libc::c_int as libc::c_uint == offset {
        return HANDLER_GO_ON;
    }
    let mut plfd: *const plugin_fn_data =
        (plugin_slots as uintptr_t).wrapping_add(offset as libc::c_ulong) as *const plugin_fn_data;
    let mut rc: handler_t = HANDLER_GO_ON;
    while ((*plfd).fn_0).is_some() && {
        rc = ::core::mem::transmute::<_, fn(_, _) -> handler_t>(
            ((*plfd).fn_0).expect("non-null function pointer"),
        )(con, (*plfd).data);
        rc as libc::c_uint == HANDLER_GO_ON as libc::c_int as libc::c_uint
    } {
        plfd = plfd.offset(1);
    }
    return rc;
}
unsafe extern "C" fn plugins_call_fn_srv_data(srv: *mut server, e: libc::c_int) -> handler_t {
    let offset: uint32_t = *((*srv).plugin_slots as *const uint16_t).offset(e as isize) as uint32_t;
    if 0 as libc::c_int as libc::c_uint == offset {
        return HANDLER_GO_ON;
    }
    let mut plfd: *const plugin_fn_data = ((*srv).plugin_slots as uintptr_t)
        .wrapping_add(offset as libc::c_ulong)
        as *const plugin_fn_data;
    let mut rc: handler_t = HANDLER_GO_ON;
    while ((*plfd).fn_0).is_some() && {
        rc = ::core::mem::transmute::<_, fn(_, _) -> handler_t>(
            ((*plfd).fn_0).expect("non-null function pointer"),
        )(srv, (*plfd).data);
        rc as libc::c_uint == HANDLER_GO_ON as libc::c_int as libc::c_uint
    } {
        plfd = plfd.offset(1);
    }
    return rc;
}
unsafe extern "C" fn plugins_call_fn_srv_data_all(srv: *mut server, e: libc::c_int) {
    let offset: uint32_t = *((*srv).plugin_slots as *const uint16_t).offset(e as isize) as uint32_t;
    if 0 as libc::c_int as libc::c_uint == offset {
        return;
    }
    let mut plfd: *const plugin_fn_data = ((*srv).plugin_slots as uintptr_t)
        .wrapping_add(offset as libc::c_ulong)
        as *const plugin_fn_data;
    while ((*plfd).fn_0).is_some() {
        ::core::mem::transmute::<_, fn(_, _) -> handler_t>(
            ((*plfd).fn_0).expect("non-null function pointer"),
        )(srv, (*plfd).data);
        plfd = plfd.offset(1);
    }
}
#[no_mangle]
pub unsafe extern "C" fn plugins_call_handle_uri_clean(r: *mut request_st) -> handler_t {
    return plugins_call_fn_req_data(r, PLUGIN_FUNC_HANDLE_URI_CLEAN as libc::c_int);
}
#[no_mangle]
pub unsafe extern "C" fn plugins_call_handle_docroot(r: *mut request_st) -> handler_t {
    return plugins_call_fn_req_data(r, PLUGIN_FUNC_HANDLE_DOCROOT as libc::c_int);
}
#[no_mangle]
pub unsafe extern "C" fn plugins_call_handle_physical(r: *mut request_st) -> handler_t {
    return plugins_call_fn_req_data(r, PLUGIN_FUNC_HANDLE_PHYSICAL as libc::c_int);
}
#[no_mangle]
pub unsafe extern "C" fn plugins_call_handle_subrequest_start(r: *mut request_st) -> handler_t {
    return plugins_call_fn_req_data(r, PLUGIN_FUNC_HANDLE_SUBREQUEST_START as libc::c_int);
}
#[no_mangle]
pub unsafe extern "C" fn plugins_call_handle_response_start(r: *mut request_st) -> handler_t {
    return plugins_call_fn_req_data(r, PLUGIN_FUNC_HANDLE_RESPONSE_START as libc::c_int);
}
#[no_mangle]
pub unsafe extern "C" fn plugins_call_handle_request_done(r: *mut request_st) -> handler_t {
    return plugins_call_fn_req_data(r, PLUGIN_FUNC_HANDLE_REQUEST_DONE as libc::c_int);
}
#[no_mangle]
pub unsafe extern "C" fn plugins_call_handle_request_reset(r: *mut request_st) -> handler_t {
    return plugins_call_fn_req_data(r, PLUGIN_FUNC_HANDLE_REQUEST_RESET as libc::c_int);
}
#[no_mangle]
pub unsafe extern "C" fn plugins_call_handle_request_env(r: *mut request_st) -> handler_t {
    return plugins_call_fn_req_data(r, PLUGIN_FUNC_HANDLE_REQUEST_ENV as libc::c_int);
}
#[no_mangle]
pub unsafe extern "C" fn plugins_call_handle_connection_accept(
    mut con: *mut connection,
) -> handler_t {
    return plugins_call_fn_con_data(con, PLUGIN_FUNC_HANDLE_CONNECTION_ACCEPT as libc::c_int);
}
#[no_mangle]
pub unsafe extern "C" fn plugins_call_handle_connection_shut_wr(
    mut con: *mut connection,
) -> handler_t {
    return plugins_call_fn_con_data(con, PLUGIN_FUNC_HANDLE_CONNECTION_SHUT_WR as libc::c_int);
}
#[no_mangle]
pub unsafe extern "C" fn plugins_call_handle_connection_close(
    mut con: *mut connection,
) -> handler_t {
    return plugins_call_fn_con_data(con, PLUGIN_FUNC_HANDLE_CONNECTION_CLOSE as libc::c_int);
}
#[no_mangle]
#[cold]
pub unsafe extern "C" fn plugins_call_set_defaults(mut srv: *mut server) -> handler_t {
    return plugins_call_fn_srv_data(srv, PLUGIN_FUNC_SET_DEFAULTS as libc::c_int);
}
#[no_mangle]
#[cold]
pub unsafe extern "C" fn plugins_call_worker_init(mut srv: *mut server) -> handler_t {
    return plugins_call_fn_srv_data(srv, PLUGIN_FUNC_WORKER_INIT as libc::c_int);
}
#[no_mangle]
pub unsafe extern "C" fn plugins_call_handle_trigger(mut srv: *mut server) {
    plugins_call_fn_srv_data_all(srv, PLUGIN_FUNC_HANDLE_TRIGGER as libc::c_int);
}
#[no_mangle]
#[cold]
pub unsafe extern "C" fn plugins_call_handle_sighup(mut srv: *mut server) {
    plugins_call_fn_srv_data_all(srv, PLUGIN_FUNC_HANDLE_SIGHUP as libc::c_int);
}
#[no_mangle]
pub unsafe extern "C" fn plugins_call_handle_waitpid(
    mut srv: *mut server,
    mut pid: pid_t,
    mut status: libc::c_int,
) -> handler_t {
    let offset: uint32_t = *((*srv).plugin_slots as *const uint16_t)
        .offset(PLUGIN_FUNC_HANDLE_WAITPID as libc::c_int as isize)
        as uint32_t;
    if 0 as libc::c_int as libc::c_uint == offset {
        return HANDLER_GO_ON;
    }
    let mut plfd: *const plugin_fn_data = ((*srv).plugin_slots as uintptr_t)
        .wrapping_add(offset as libc::c_ulong)
        as *const plugin_fn_data;
    let mut rc: handler_t = HANDLER_GO_ON;
    while ((*plfd).fn_0).is_some() && {
        rc = ::core::mem::transmute::<_, fn(_, _, _, _) -> handler_t>(
            ((*plfd).fn_0).expect("non-null function pointer"),
        )(srv, (*plfd).data, pid, status);
        rc as libc::c_uint == HANDLER_GO_ON as libc::c_int as libc::c_uint
    } {
        plfd = plfd.offset(1);
    }
    return rc;
}
unsafe extern "C" fn plugins_call_cleanup(srv: *mut server) {
    let ps: *mut *mut plugin = (*srv).plugins.ptr as *mut *mut plugin;
    let mut i: uint32_t = 0 as libc::c_int as uint32_t;
    while i < (*srv).plugins.used {
        let mut p: *mut plugin = *ps.offset(i as isize);
        if !p.is_null() {
            if !((*p).data).is_null() {
                let mut pd: *mut plugin_data_base = (*p).data as *mut plugin_data_base;
                if ((*p).cleanup).is_some() {
                    ((*p).cleanup).expect("non-null function pointer")((*p).data);
                }
                free((*pd).cvlist as *mut libc::c_void);
                free(pd as *mut libc::c_void);
                (*p).data = 0 as *mut libc::c_void;
            }
        }
        i = i.wrapping_add(1);
    }
}
#[cold]
unsafe extern "C" fn plugins_call_init_reverse(mut srv: *mut server, offset: uint32_t) {
    if 0 as libc::c_int as libc::c_uint == offset {
        return;
    }
    let mut a: *mut plugin_fn_data = ((*srv).plugin_slots as uintptr_t)
        .wrapping_add(offset as libc::c_ulong)
        as *mut plugin_fn_data;
    let mut b: *mut plugin_fn_data = a;
    while ((*b).fn_0).is_some() {
        b = b.offset(1);
    }
    loop {
        b = b.offset(-1);
        if !(a < b) {
            break;
        }
        let mut tmp: plugin_fn_data = *a;
        *a = *b;
        *b = tmp;
        a = a.offset(1);
    }
}
#[cold]
unsafe extern "C" fn plugins_call_init_slot(
    mut srv: *mut server,
    mut fn_0: Option<unsafe extern "C" fn() -> handler_t>,
    mut data: *mut libc::c_void,
    offset: uint32_t,
) {
    if fn_0.is_some() {
        let mut plfd: *mut plugin_fn_data = ((*srv).plugin_slots as uintptr_t)
            .wrapping_add(offset as libc::c_ulong)
            as *mut plugin_fn_data;
        while ((*plfd).fn_0).is_some() {
            plfd = plfd.offset(1);
        }
        (*plfd).fn_0 = fn_0;
        (*plfd).data = data as *mut plugin_data_base;
    }
}
#[no_mangle]
#[cold]
pub unsafe extern "C" fn plugins_call_init(mut srv: *mut server) -> handler_t {
    let ps: *mut *mut plugin = (*srv).plugins.ptr as *mut *mut plugin;
    let mut offsets: [uint16_t; 16] = [0; 16];
    memset(
        offsets.as_mut_ptr() as *mut libc::c_void,
        0 as libc::c_int,
        ::core::mem::size_of::<[uint16_t; 16]>() as libc::c_ulong,
    );
    let mut i: uint32_t = 0 as libc::c_int as uint32_t;
    while i < (*srv).plugins.used {
        let mut p: *mut plugin = *ps.offset(i as isize);
        if ((*p).init).is_some() {
            (*p).data = ::core::mem::transmute::<_, fn() -> *mut libc::c_void>(
                ((*p).init).expect("non-null function pointer"),
            )();
            if ((*p).data).is_null() {
                log_error(
                    (*srv).errh,
                    b"/home/kkysen/work/rust/lighttpd/src/plugin.c\0" as *const u8
                        as *const libc::c_char,
                    454 as libc::c_int as libc::c_uint,
                    b"plugin-init failed for module %s\0" as *const u8 as *const libc::c_char,
                    (*p).name,
                );
                return HANDLER_ERROR;
            }
            let ref mut fresh224 = (*((*p).data as *mut plugin_data_base)).self_0;
            *fresh224 = p;
            (*((*p).data as *mut plugin_data_base)).id =
                i.wrapping_add(1 as libc::c_int as libc::c_uint) as libc::c_int;
            if (*p).version != 10400 as libc::c_int as libc::c_ulong {
                log_error(
                    (*srv).errh,
                    b"/home/kkysen/work/rust/lighttpd/src/plugin.c\0" as *const u8
                        as *const libc::c_char,
                    463 as libc::c_int as libc::c_uint,
                    b"plugin-version doesn't match lighttpd-version for %s\0" as *const u8
                        as *const libc::c_char,
                    (*p).name,
                );
                return HANDLER_ERROR;
            }
        }
        if ((*p).priv_defaults).is_some()
            && HANDLER_ERROR as libc::c_int as libc::c_uint
                == ((*p).priv_defaults).expect("non-null function pointer")(srv, (*p).data)
                    as libc::c_uint
        {
            return HANDLER_ERROR;
        }
        if ((*p).handle_uri_clean).is_some() {
            offsets[PLUGIN_FUNC_HANDLE_URI_CLEAN as libc::c_int as usize] =
                (offsets[PLUGIN_FUNC_HANDLE_URI_CLEAN as libc::c_int as usize]).wrapping_add(1);
        }
        if ((*p).handle_uri_raw).is_some() && ((*p).handle_uri_clean).is_none() {
            offsets[PLUGIN_FUNC_HANDLE_URI_CLEAN as libc::c_int as usize] =
                (offsets[PLUGIN_FUNC_HANDLE_URI_CLEAN as libc::c_int as usize]).wrapping_add(1);
        }
        if ((*p).handle_request_env).is_some() {
            offsets[PLUGIN_FUNC_HANDLE_REQUEST_ENV as libc::c_int as usize] =
                (offsets[PLUGIN_FUNC_HANDLE_REQUEST_ENV as libc::c_int as usize]).wrapping_add(1);
        }
        if ((*p).handle_request_done).is_some() {
            offsets[PLUGIN_FUNC_HANDLE_REQUEST_DONE as libc::c_int as usize] =
                (offsets[PLUGIN_FUNC_HANDLE_REQUEST_DONE as libc::c_int as usize]).wrapping_add(1);
        }
        if ((*p).handle_connection_accept).is_some() {
            offsets[PLUGIN_FUNC_HANDLE_CONNECTION_ACCEPT as libc::c_int as usize] = (offsets
                [PLUGIN_FUNC_HANDLE_CONNECTION_ACCEPT as libc::c_int as usize])
                .wrapping_add(1);
        }
        if ((*p).handle_connection_shut_wr).is_some() {
            offsets[PLUGIN_FUNC_HANDLE_CONNECTION_SHUT_WR as libc::c_int as usize] = (offsets
                [PLUGIN_FUNC_HANDLE_CONNECTION_SHUT_WR as libc::c_int as usize])
                .wrapping_add(1);
        }
        if ((*p).handle_connection_close).is_some() {
            offsets[PLUGIN_FUNC_HANDLE_CONNECTION_CLOSE as libc::c_int as usize] = (offsets
                [PLUGIN_FUNC_HANDLE_CONNECTION_CLOSE as libc::c_int as usize])
                .wrapping_add(1);
        }
        if ((*p).handle_trigger).is_some() {
            offsets[PLUGIN_FUNC_HANDLE_TRIGGER as libc::c_int as usize] =
                (offsets[PLUGIN_FUNC_HANDLE_TRIGGER as libc::c_int as usize]).wrapping_add(1);
        }
        if ((*p).handle_sighup).is_some() {
            offsets[PLUGIN_FUNC_HANDLE_SIGHUP as libc::c_int as usize] =
                (offsets[PLUGIN_FUNC_HANDLE_SIGHUP as libc::c_int as usize]).wrapping_add(1);
        }
        if ((*p).handle_waitpid).is_some() {
            offsets[PLUGIN_FUNC_HANDLE_WAITPID as libc::c_int as usize] =
                (offsets[PLUGIN_FUNC_HANDLE_WAITPID as libc::c_int as usize]).wrapping_add(1);
        }
        if ((*p).handle_subrequest_start).is_some() {
            offsets[PLUGIN_FUNC_HANDLE_SUBREQUEST_START as libc::c_int as usize] = (offsets
                [PLUGIN_FUNC_HANDLE_SUBREQUEST_START as libc::c_int as usize])
                .wrapping_add(1);
        }
        if ((*p).handle_response_start).is_some() {
            offsets[PLUGIN_FUNC_HANDLE_RESPONSE_START as libc::c_int as usize] = (offsets
                [PLUGIN_FUNC_HANDLE_RESPONSE_START as libc::c_int as usize])
                .wrapping_add(1);
        }
        if ((*p).handle_docroot).is_some() {
            offsets[PLUGIN_FUNC_HANDLE_DOCROOT as libc::c_int as usize] =
                (offsets[PLUGIN_FUNC_HANDLE_DOCROOT as libc::c_int as usize]).wrapping_add(1);
        }
        if ((*p).handle_physical).is_some() {
            offsets[PLUGIN_FUNC_HANDLE_PHYSICAL as libc::c_int as usize] =
                (offsets[PLUGIN_FUNC_HANDLE_PHYSICAL as libc::c_int as usize]).wrapping_add(1);
        }
        if ((*p).handle_request_reset).is_some() {
            offsets[PLUGIN_FUNC_HANDLE_REQUEST_RESET as libc::c_int as usize] =
                (offsets[PLUGIN_FUNC_HANDLE_REQUEST_RESET as libc::c_int as usize]).wrapping_add(1);
        }
        if ((*p).set_defaults).is_some() {
            offsets[PLUGIN_FUNC_SET_DEFAULTS as libc::c_int as usize] =
                (offsets[PLUGIN_FUNC_SET_DEFAULTS as libc::c_int as usize]).wrapping_add(1);
        }
        if ((*p).worker_init).is_some() {
            offsets[PLUGIN_FUNC_WORKER_INIT as libc::c_int as usize] =
                (offsets[PLUGIN_FUNC_WORKER_INIT as libc::c_int as usize]).wrapping_add(1);
        }
        i = i.wrapping_add(1);
    }
    let mut nslots: uint32_t = (::core::mem::size_of::<[uint16_t; 16]>() as libc::c_ulong)
        .wrapping_add(::core::mem::size_of::<plugin_fn_data>() as libc::c_ulong)
        .wrapping_sub(1 as libc::c_int as libc::c_ulong)
        .wrapping_div(::core::mem::size_of::<plugin_fn_data>() as libc::c_ulong)
        as uint32_t;
    let mut i_0: uint32_t = 0 as libc::c_int as uint32_t;
    while i_0 < PLUGIN_FUNC_SIZEOF as libc::c_int as libc::c_uint {
        if offsets[i_0 as usize] != 0 {
            let mut offset: uint32_t = nslots;
            nslots = (nslots as libc::c_uint).wrapping_add(
                (offsets[i_0 as usize] as libc::c_int + 1 as libc::c_int) as libc::c_uint,
            ) as uint32_t as uint32_t;
            if !((offset as libc::c_ulong)
                .wrapping_mul(::core::mem::size_of::<plugin_fn_data>() as libc::c_ulong)
                <= (32767 as libc::c_int * 2 as libc::c_int + 1 as libc::c_int) as libc::c_ulong)
            {
                ck_assert_failed(
                    b"/home/kkysen/work/rust/lighttpd/src/plugin.c\0" as *const u8
                        as *const libc::c_char,
                    515 as libc::c_int as libc::c_uint,
                    b"offset * sizeof(plugin_fn_data) <= (32767 *2 +1)\0" as *const u8
                        as *const libc::c_char,
                );
            }
            offsets[i_0 as usize] = (offset as libc::c_ulong)
                .wrapping_mul(::core::mem::size_of::<plugin_fn_data>() as libc::c_ulong)
                as uint16_t;
        }
        i_0 = i_0.wrapping_add(1);
    }
    (*srv).plugin_slots = calloc(
        nslots as libc::c_ulong,
        ::core::mem::size_of::<plugin_fn_data>() as libc::c_ulong,
    );
    if ((*srv).plugin_slots).is_null() {
        ck_assert_failed(
            b"/home/kkysen/work/rust/lighttpd/src/plugin.c\0" as *const u8 as *const libc::c_char,
            522 as libc::c_int as libc::c_uint,
            b"((void*)0) != srv->plugin_slots\0" as *const u8 as *const libc::c_char,
        );
    }
    memcpy(
        (*srv).plugin_slots,
        offsets.as_mut_ptr() as *const libc::c_void,
        ::core::mem::size_of::<[uint16_t; 16]>() as libc::c_ulong,
    );
    let mut i_1: uint32_t = 0 as libc::c_int as uint32_t;
    while i_1 < (*srv).plugins.used {
        let p_0: *mut plugin = *ps.offset(i_1 as isize);
        plugins_call_init_slot(
            srv,
            ::core::mem::transmute::<
                Option<unsafe extern "C" fn(*mut request_st, *mut libc::c_void) -> handler_t>,
                Option<unsafe extern "C" fn() -> handler_t>,
            >((*p_0).handle_uri_raw),
            (*p_0).data,
            offsets[PLUGIN_FUNC_HANDLE_URI_CLEAN as libc::c_int as usize] as uint32_t,
        );
        i_1 = i_1.wrapping_add(1);
    }
    let mut i_2: uint32_t = 0 as libc::c_int as uint32_t;
    while i_2 < (*srv).plugins.used {
        let p_1: *mut plugin = *ps.offset(i_2 as isize);
        if ((*p_1).handle_uri_raw).is_none() {
            plugins_call_init_slot(
                srv,
                ::core::mem::transmute::<
                    Option<unsafe extern "C" fn(*mut request_st, *mut libc::c_void) -> handler_t>,
                    Option<unsafe extern "C" fn() -> handler_t>,
                >((*p_1).handle_uri_clean),
                (*p_1).data,
                offsets[PLUGIN_FUNC_HANDLE_URI_CLEAN as libc::c_int as usize] as uint32_t,
            );
        }
        plugins_call_init_slot(
            srv,
            ::core::mem::transmute::<
                Option<unsafe extern "C" fn(*mut request_st, *mut libc::c_void) -> handler_t>,
                Option<unsafe extern "C" fn() -> handler_t>,
            >((*p_1).handle_request_env),
            (*p_1).data,
            offsets[PLUGIN_FUNC_HANDLE_REQUEST_ENV as libc::c_int as usize] as uint32_t,
        );
        plugins_call_init_slot(
            srv,
            ::core::mem::transmute::<
                Option<unsafe extern "C" fn(*mut request_st, *mut libc::c_void) -> handler_t>,
                Option<unsafe extern "C" fn() -> handler_t>,
            >((*p_1).handle_request_done),
            (*p_1).data,
            offsets[PLUGIN_FUNC_HANDLE_REQUEST_DONE as libc::c_int as usize] as uint32_t,
        );
        plugins_call_init_slot(
            srv,
            ::core::mem::transmute::<
                Option<unsafe extern "C" fn(*mut connection, *mut libc::c_void) -> handler_t>,
                Option<unsafe extern "C" fn() -> handler_t>,
            >((*p_1).handle_connection_accept),
            (*p_1).data,
            offsets[PLUGIN_FUNC_HANDLE_CONNECTION_ACCEPT as libc::c_int as usize] as uint32_t,
        );
        plugins_call_init_slot(
            srv,
            ::core::mem::transmute::<
                Option<unsafe extern "C" fn(*mut connection, *mut libc::c_void) -> handler_t>,
                Option<unsafe extern "C" fn() -> handler_t>,
            >((*p_1).handle_connection_shut_wr),
            (*p_1).data,
            offsets[PLUGIN_FUNC_HANDLE_CONNECTION_SHUT_WR as libc::c_int as usize] as uint32_t,
        );
        plugins_call_init_slot(
            srv,
            ::core::mem::transmute::<
                Option<unsafe extern "C" fn(*mut connection, *mut libc::c_void) -> handler_t>,
                Option<unsafe extern "C" fn() -> handler_t>,
            >((*p_1).handle_connection_close),
            (*p_1).data,
            offsets[PLUGIN_FUNC_HANDLE_CONNECTION_CLOSE as libc::c_int as usize] as uint32_t,
        );
        plugins_call_init_slot(
            srv,
            ::core::mem::transmute::<
                Option<unsafe extern "C" fn(*mut server, *mut libc::c_void) -> handler_t>,
                Option<unsafe extern "C" fn() -> handler_t>,
            >((*p_1).handle_trigger),
            (*p_1).data,
            offsets[PLUGIN_FUNC_HANDLE_TRIGGER as libc::c_int as usize] as uint32_t,
        );
        plugins_call_init_slot(
            srv,
            ::core::mem::transmute::<
                Option<unsafe extern "C" fn(*mut server, *mut libc::c_void) -> handler_t>,
                Option<unsafe extern "C" fn() -> handler_t>,
            >((*p_1).handle_sighup),
            (*p_1).data,
            offsets[PLUGIN_FUNC_HANDLE_SIGHUP as libc::c_int as usize] as uint32_t,
        );
        plugins_call_init_slot(
            srv,
            ::core::mem::transmute::<
                Option<
                    unsafe extern "C" fn(
                        *mut server,
                        *mut libc::c_void,
                        pid_t,
                        libc::c_int,
                    ) -> handler_t,
                >,
                Option<unsafe extern "C" fn() -> handler_t>,
            >((*p_1).handle_waitpid),
            (*p_1).data,
            offsets[PLUGIN_FUNC_HANDLE_WAITPID as libc::c_int as usize] as uint32_t,
        );
        plugins_call_init_slot(
            srv,
            ::core::mem::transmute::<
                Option<unsafe extern "C" fn(*mut request_st, *mut libc::c_void) -> handler_t>,
                Option<unsafe extern "C" fn() -> handler_t>,
            >((*p_1).handle_subrequest_start),
            (*p_1).data,
            offsets[PLUGIN_FUNC_HANDLE_SUBREQUEST_START as libc::c_int as usize] as uint32_t,
        );
        plugins_call_init_slot(
            srv,
            ::core::mem::transmute::<
                Option<unsafe extern "C" fn(*mut request_st, *mut libc::c_void) -> handler_t>,
                Option<unsafe extern "C" fn() -> handler_t>,
            >((*p_1).handle_response_start),
            (*p_1).data,
            offsets[PLUGIN_FUNC_HANDLE_RESPONSE_START as libc::c_int as usize] as uint32_t,
        );
        plugins_call_init_slot(
            srv,
            ::core::mem::transmute::<
                Option<unsafe extern "C" fn(*mut request_st, *mut libc::c_void) -> handler_t>,
                Option<unsafe extern "C" fn() -> handler_t>,
            >((*p_1).handle_docroot),
            (*p_1).data,
            offsets[PLUGIN_FUNC_HANDLE_DOCROOT as libc::c_int as usize] as uint32_t,
        );
        plugins_call_init_slot(
            srv,
            ::core::mem::transmute::<
                Option<unsafe extern "C" fn(*mut request_st, *mut libc::c_void) -> handler_t>,
                Option<unsafe extern "C" fn() -> handler_t>,
            >((*p_1).handle_physical),
            (*p_1).data,
            offsets[PLUGIN_FUNC_HANDLE_PHYSICAL as libc::c_int as usize] as uint32_t,
        );
        plugins_call_init_slot(
            srv,
            ::core::mem::transmute::<
                Option<unsafe extern "C" fn(*mut request_st, *mut libc::c_void) -> handler_t>,
                Option<unsafe extern "C" fn() -> handler_t>,
            >((*p_1).handle_request_reset),
            (*p_1).data,
            offsets[PLUGIN_FUNC_HANDLE_REQUEST_RESET as libc::c_int as usize] as uint32_t,
        );
        plugins_call_init_slot(
            srv,
            ::core::mem::transmute::<
                Option<unsafe extern "C" fn(*mut server, *mut libc::c_void) -> handler_t>,
                Option<unsafe extern "C" fn() -> handler_t>,
            >((*p_1).set_defaults),
            (*p_1).data,
            offsets[PLUGIN_FUNC_SET_DEFAULTS as libc::c_int as usize] as uint32_t,
        );
        plugins_call_init_slot(
            srv,
            ::core::mem::transmute::<
                Option<unsafe extern "C" fn(*mut server, *mut libc::c_void) -> handler_t>,
                Option<unsafe extern "C" fn() -> handler_t>,
            >((*p_1).worker_init),
            (*p_1).data,
            offsets[PLUGIN_FUNC_WORKER_INIT as libc::c_int as usize] as uint32_t,
        );
        i_2 = i_2.wrapping_add(1);
    }
    plugins_call_init_reverse(
        srv,
        offsets[PLUGIN_FUNC_HANDLE_REQUEST_RESET as libc::c_int as usize] as uint32_t,
    );
    plugins_call_init_reverse(
        srv,
        offsets[PLUGIN_FUNC_HANDLE_CONNECTION_CLOSE as libc::c_int as usize] as uint32_t,
    );
    return HANDLER_GO_ON;
}
#[no_mangle]
#[cold]
pub unsafe extern "C" fn plugins_free(mut srv: *mut server) {
    if !((*srv).plugin_slots).is_null() {
        plugins_call_cleanup(srv);
        free((*srv).plugin_slots);
        (*srv).plugin_slots = 0 as *mut libc::c_void;
    }
    let mut i: uint32_t = 0 as libc::c_int as uint32_t;
    while i < (*srv).plugins.used {
        plugin_free(*((*srv).plugins.ptr as *mut *mut plugin).offset(i as isize));
        i = i.wrapping_add(1);
    }
    free((*srv).plugins.ptr);
    (*srv).plugins.ptr = 0 as *mut libc::c_void;
    (*srv).plugins.used = 0 as libc::c_int as uint32_t;
    (*srv).plugins.size = 0 as libc::c_int as uint32_t;
    array_free_data(&mut plugin_stats);
}
#[no_mangle]
pub unsafe extern "C" fn http_etag_matches(
    etag: *const buffer,
    mut s: *const libc::c_char,
    weak_ok: libc::c_int,
) -> libc::c_int {
    if '*' as i32 == *s.offset(0 as libc::c_int as isize) as libc::c_int
        && '\0' as i32 == *s.offset(1 as libc::c_int as isize) as libc::c_int
    {
        return 1 as libc::c_int;
    }
    if buffer_is_blank(etag) != 0 {
        return 0 as libc::c_int;
    }
    let mut etag_sz: uint32_t = buffer_clen(etag);
    let mut etag_ptr: *const libc::c_char = (*etag).ptr;
    if *etag_ptr.offset(0 as libc::c_int as isize) as libc::c_int == 'W' as i32
        && *etag_ptr.offset(1 as libc::c_int as isize) as libc::c_int == '/' as i32
    {
        if weak_ok == 0 {
            return 0 as libc::c_int;
        }
        etag_ptr = etag_ptr.offset(2 as libc::c_int as isize);
        etag_sz = (etag_sz as libc::c_uint).wrapping_sub(2 as libc::c_int as libc::c_uint)
            as uint32_t as uint32_t;
    }
    while *s != 0 {
        while *s as libc::c_int == ' ' as i32
            || *s as libc::c_int == '\t' as i32
            || *s as libc::c_int == ',' as i32
        {
            s = s.offset(1);
        }
        if if *s.offset(0 as libc::c_int as isize) as libc::c_int == 'W' as i32
            && *s.offset(1 as libc::c_int as isize) as libc::c_int == '/' as i32
        {
            s = s.offset(2 as libc::c_int as isize);
            weak_ok
        } else {
            1 as libc::c_int
        } != 0
        {
            if 0 as libc::c_int == strncmp(s, etag_ptr, etag_sz as libc::c_ulong)
                || *s as libc::c_int == '*' as i32
            {
                s = s.offset(
                    (if *s as libc::c_int != '*' as i32 {
                        etag_sz
                    } else {
                        1 as libc::c_int as libc::c_uint
                    }) as isize,
                );
                if *s as libc::c_int == '\0' as i32
                    || *s as libc::c_int == ' ' as i32
                    || *s as libc::c_int == '\t' as i32
                    || *s as libc::c_int == ',' as i32
                {
                    return 1 as libc::c_int;
                }
            }
        }
        while *s as libc::c_int != '\0' as i32 && *s as libc::c_int != ',' as i32 {
            s = s.offset(1);
        }
    }
    return 0 as libc::c_int;
}
unsafe extern "C" fn http_etag_remix(etag: *mut buffer, str: *const libc::c_char, len: uint32_t) {
    let mut h: uint32_t = dekhash(str, len, len);
    buffer_copy_string_len(
        etag,
        b"\"\0" as *const u8 as *const libc::c_char,
        (::core::mem::size_of::<[libc::c_char; 2]>() as libc::c_ulong as uint32_t)
            .wrapping_sub(1 as libc::c_int as libc::c_uint) as size_t,
    );
    buffer_append_int(etag, h as intmax_t);
    buffer_append_string_len(
        etag,
        b"\"\0" as *const u8 as *const libc::c_char,
        (::core::mem::size_of::<[libc::c_char; 2]>() as libc::c_ulong as uint32_t)
            .wrapping_sub(1 as libc::c_int as libc::c_uint) as size_t,
    );
}
#[no_mangle]
pub unsafe extern "C" fn http_etag_create(etag: *mut buffer, st: *const stat, flags: libc::c_int) {
    if 0 as libc::c_int == flags {
        return;
    }
    let mut x: [uint64_t; 4] = [0; 4];
    let mut len: uint32_t = 0 as libc::c_int as uint32_t;
    if flags & ETAG_USE_INODE as libc::c_int != 0 {
        let fresh225 = len;
        len = len.wrapping_add(1);
        x[fresh225 as usize] = (*st).st_ino;
    }
    if flags & ETAG_USE_SIZE as libc::c_int != 0 {
        let fresh226 = len;
        len = len.wrapping_add(1);
        x[fresh226 as usize] = (*st).st_size as uint64_t;
    }
    if flags & ETAG_USE_MTIME as libc::c_int != 0 {
        let fresh227 = len;
        len = len.wrapping_add(1);
        x[fresh227 as usize] = (*st).st_mtim.tv_sec as uint64_t;
        let fresh228 = len;
        len = len.wrapping_add(1);
        x[fresh228 as usize] = (*st).st_mtim.tv_nsec as uint64_t;
    }
    buffer_clear(etag);
    http_etag_remix(
        etag,
        x.as_mut_ptr() as *mut libc::c_char,
        len << 3 as libc::c_int,
    );
}
#[cold]
unsafe extern "C" fn array_data_string_copy(mut s: *const data_unset) -> *mut data_unset {
    let mut src: *mut data_string = s as *mut data_string;
    let mut ds: *mut data_string = array_data_string_init();
    if buffer_is_unset(&mut (*src).key) == 0 {
        buffer_copy_buffer(&mut (*ds).key, &mut (*src).key);
    }
    buffer_copy_buffer(&mut (*ds).value, &mut (*src).value);
    return ds as *mut data_unset;
}
#[cold]
unsafe extern "C" fn array_data_string_insert_dup(
    mut dst: *mut data_unset,
    mut src: *mut data_unset,
) {
    let mut ds_dst: *mut data_string = dst as *mut data_string;
    let mut ds_src: *mut data_string = src as *mut data_string;
    if buffer_is_blank(&mut (*ds_dst).value) == 0 {
        buffer_append_str2(
            &mut (*ds_dst).value,
            b", \0" as *const u8 as *const libc::c_char,
            (::core::mem::size_of::<[libc::c_char; 3]>() as libc::c_ulong as uint32_t)
                .wrapping_sub(1 as libc::c_int as libc::c_uint) as size_t,
            (*ds_src).value.ptr,
            buffer_clen(&mut (*ds_src).value) as size_t,
        );
    } else {
        buffer_copy_buffer(&mut (*ds_dst).value, &mut (*ds_src).value);
    };
}
unsafe extern "C" fn array_data_string_free(mut du: *mut data_unset) {
    let mut ds: *mut data_string = du as *mut data_string;
    free((*ds).key.ptr as *mut libc::c_void);
    free((*ds).value.ptr as *mut libc::c_void);
    free(ds as *mut libc::c_void);
}
#[no_mangle]
#[inline(never)]
pub unsafe extern "C" fn array_data_string_init() -> *mut data_string {
    static mut string_fn: data_methods = unsafe {
        {
            let mut init = data_methods {
                copy: Some(
                    array_data_string_copy
                        as unsafe extern "C" fn(*const data_unset) -> *mut data_unset,
                ),
                free: Some(array_data_string_free as unsafe extern "C" fn(*mut data_unset) -> ()),
                insert_dup: Some(
                    array_data_string_insert_dup
                        as unsafe extern "C" fn(*mut data_unset, *mut data_unset) -> (),
                ),
            };
            init
        }
    };
    let mut ds: *mut data_string = calloc(
        1 as libc::c_int as libc::c_ulong,
        ::core::mem::size_of::<data_string>() as libc::c_ulong,
    ) as *mut data_string;
    if ds.is_null() {
        ck_assert_failed(
            b"/home/kkysen/work/rust/lighttpd/src/array.c\0" as *const u8 as *const libc::c_char,
            46 as libc::c_int as libc::c_uint,
            b"((void*)0) != ds\0" as *const u8 as *const libc::c_char,
        );
    }
    (*ds).type_0 = TYPE_STRING;
    (*ds).fn_0 = &string_fn;
    return ds;
}
#[cold]
unsafe extern "C" fn array_data_integer_copy(mut s: *const data_unset) -> *mut data_unset {
    let mut src: *mut data_integer = s as *mut data_integer;
    let mut di: *mut data_integer = array_data_integer_init();
    if buffer_is_unset(&mut (*src).key) == 0 {
        buffer_copy_buffer(&mut (*di).key, &mut (*src).key);
    }
    (*di).value = (*src).value;
    return di as *mut data_unset;
}
unsafe extern "C" fn array_data_integer_free(mut du: *mut data_unset) {
    let mut di: *mut data_integer = du as *mut data_integer;
    free((*di).key.ptr as *mut libc::c_void);
    free(di as *mut libc::c_void);
}
#[no_mangle]
#[inline(never)]
pub unsafe extern "C" fn array_data_integer_init() -> *mut data_integer {
    static mut integer_fn: data_methods = unsafe {
        {
            let mut init = data_methods {
                copy: Some(
                    array_data_integer_copy
                        as unsafe extern "C" fn(*const data_unset) -> *mut data_unset,
                ),
                free: Some(array_data_integer_free as unsafe extern "C" fn(*mut data_unset) -> ()),
                insert_dup: None,
            };
            init
        }
    };
    let mut di: *mut data_integer = calloc(
        1 as libc::c_int as libc::c_ulong,
        ::core::mem::size_of::<data_integer>() as libc::c_ulong,
    ) as *mut data_integer;
    if di.is_null() {
        ck_assert_failed(
            b"/home/kkysen/work/rust/lighttpd/src/array.c\0" as *const u8 as *const libc::c_char,
            76 as libc::c_int as libc::c_uint,
            b"((void*)0) != di\0" as *const u8 as *const libc::c_char,
        );
    }
    (*di).type_0 = TYPE_INTEGER;
    (*di).fn_0 = &integer_fn;
    return di;
}
#[cold]
unsafe extern "C" fn array_data_array_copy(mut s: *const data_unset) -> *mut data_unset {
    let mut src: *mut data_array = s as *mut data_array;
    let mut da: *mut data_array = array_data_array_init();
    if buffer_is_unset(&mut (*src).key) == 0 {
        buffer_copy_buffer(&mut (*da).key, &mut (*src).key);
    }
    array_copy_array(&mut (*da).value, &mut (*src).value);
    return da as *mut data_unset;
}
unsafe extern "C" fn array_data_array_free(mut du: *mut data_unset) {
    let mut da: *mut data_array = du as *mut data_array;
    free((*da).key.ptr as *mut libc::c_void);
    array_free_data(&mut (*da).value);
    free(da as *mut libc::c_void);
}
#[no_mangle]
#[inline(never)]
pub unsafe extern "C" fn array_data_array_init() -> *mut data_array {
    static mut array_fn: data_methods = unsafe {
        {
            let mut init = data_methods {
                copy: Some(
                    array_data_array_copy
                        as unsafe extern "C" fn(*const data_unset) -> *mut data_unset,
                ),
                free: Some(array_data_array_free as unsafe extern "C" fn(*mut data_unset) -> ()),
                insert_dup: None,
            };
            init
        }
    };
    let mut da: *mut data_array = calloc(
        1 as libc::c_int as libc::c_ulong,
        ::core::mem::size_of::<data_array>() as libc::c_ulong,
    ) as *mut data_array;
    if da.is_null() {
        ck_assert_failed(
            b"/home/kkysen/work/rust/lighttpd/src/array.c\0" as *const u8 as *const libc::c_char,
            107 as libc::c_int as libc::c_uint,
            b"((void*)0) != da\0" as *const u8 as *const libc::c_char,
        );
    }
    (*da).type_0 = TYPE_ARRAY;
    (*da).fn_0 = &array_fn;
    return da;
}
#[cold]
unsafe extern "C" fn array_extend(a: *mut array, mut n: uint32_t) {
    if !((*a).size <= (2147483647 as libc::c_int as libc::c_uint).wrapping_sub(n)) {
        ck_assert_failed(
            b"/home/kkysen/work/rust/lighttpd/src/array.c\0" as *const u8 as *const libc::c_char,
            117 as libc::c_int as libc::c_uint,
            b"a->size <= (2147483647)-n\0" as *const u8 as *const libc::c_char,
        );
    }
    (*a).size = ((*a).size as libc::c_uint).wrapping_add(n) as uint32_t as uint32_t;
    (*a).data = realloc(
        (*a).data as *mut libc::c_void,
        (::core::mem::size_of::<*mut data_unset>() as libc::c_ulong)
            .wrapping_mul((*a).size as libc::c_ulong),
    ) as *mut *mut data_unset;
    (*a).sorted = realloc(
        (*a).sorted as *mut libc::c_void,
        (::core::mem::size_of::<*mut data_unset>() as libc::c_ulong)
            .wrapping_mul((*a).size as libc::c_ulong),
    ) as *mut *mut data_unset;
    if ((*a).data).is_null() {
        ck_assert_failed(
            b"/home/kkysen/work/rust/lighttpd/src/array.c\0" as *const u8 as *const libc::c_char,
            121 as libc::c_int as libc::c_uint,
            b"a->data\0" as *const u8 as *const libc::c_char,
        );
    }
    if ((*a).sorted).is_null() {
        ck_assert_failed(
            b"/home/kkysen/work/rust/lighttpd/src/array.c\0" as *const u8 as *const libc::c_char,
            122 as libc::c_int as libc::c_uint,
            b"a->sorted\0" as *const u8 as *const libc::c_char,
        );
    }
    memset(
        ((*a).data).offset((*a).used as isize) as *mut libc::c_void,
        0 as libc::c_int,
        (((*a).size).wrapping_sub((*a).used) as libc::c_ulong)
            .wrapping_mul(::core::mem::size_of::<*mut data_unset>() as libc::c_ulong),
    );
}
#[no_mangle]
pub unsafe extern "C" fn array_init(mut n: uint32_t) -> *mut array {
    let mut a: *mut array = 0 as *mut array;
    a = calloc(
        1 as libc::c_int as libc::c_ulong,
        ::core::mem::size_of::<array>() as libc::c_ulong,
    ) as *mut array;
    if a.is_null() {
        ck_assert_failed(
            b"/home/kkysen/work/rust/lighttpd/src/array.c\0" as *const u8 as *const libc::c_char,
            130 as libc::c_int as libc::c_uint,
            b"a\0" as *const u8 as *const libc::c_char,
        );
    }
    if n != 0 {
        array_extend(a, n);
    }
    return a;
}
#[no_mangle]
#[cold]
pub unsafe extern "C" fn array_free_data(a: *mut array) {
    if !((*a).sorted).is_null() {
        free((*a).sorted as *mut libc::c_void);
    }
    let data: *mut *mut data_unset = (*a).data;
    let sz: uint32_t = (*a).size;
    let mut i: uint32_t = 0 as libc::c_int as uint32_t;
    while i < sz {
        if !(*data.offset(i as isize)).is_null() {
            ((*(**data.offset(i as isize)).fn_0).free).expect("non-null function pointer")(
                *data.offset(i as isize),
            );
        }
        i = i.wrapping_add(1);
    }
    free(data as *mut libc::c_void);
    (*a).data = 0 as *mut *mut data_unset;
    (*a).sorted = 0 as *mut *mut data_unset;
    (*a).used = 0 as libc::c_int as uint32_t;
    (*a).size = 0 as libc::c_int as uint32_t;
}
#[no_mangle]
#[cold]
pub unsafe extern "C" fn array_copy_array(dst: *mut array, src: *const array) {
    array_free_data(dst);
    if 0 as libc::c_int as libc::c_uint == (*src).size {
        return;
    }
    array_extend(dst, (*src).size);
    let mut i: uint32_t = 0 as libc::c_int as uint32_t;
    while i < (*src).used {
        array_insert_unique(
            dst,
            ((*(**((*src).data).offset(i as isize)).fn_0).copy).expect("non-null function pointer")(
                *((*src).data).offset(i as isize),
            ),
        );
        i = i.wrapping_add(1);
    }
}
#[no_mangle]
pub unsafe extern "C" fn array_free(a: *mut array) {
    if a.is_null() {
        return;
    }
    array_free_data(a);
    free(a as *mut libc::c_void);
}
#[no_mangle]
pub unsafe extern "C" fn array_reset_data_strings(a: *mut array) {
    if a.is_null() {
        return;
    }
    let data: *mut *mut data_string = (*a).data as *mut *mut data_string;
    let used: uint32_t = (*a).used;
    (*a).used = 0 as libc::c_int as uint32_t;
    let mut i: uint32_t = 0 as libc::c_int as uint32_t;
    while i < used {
        let ds: *mut data_string = *data.offset(i as isize);
        buffer_reset(&mut (*ds).key);
        buffer_reset(&mut (*ds).value);
        i = i.wrapping_add(1);
    }
}
unsafe extern "C" fn array_caseless_compare(
    a: *const libc::c_char,
    b: *const libc::c_char,
    len: uint32_t,
) -> libc::c_int {
    let mut i: uint32_t = 0 as libc::c_int as uint32_t;
    while i < len {
        let mut ca: libc::c_uint = *(a as *mut libc::c_uchar).offset(i as isize) as libc::c_uint;
        let mut cb: libc::c_uint = *(b as *mut libc::c_uchar).offset(i as isize) as libc::c_uint;
        if !(ca == cb) {
            if ca.wrapping_sub('A' as i32 as libc::c_uint)
                <= ('Z' as i32 - 'A' as i32) as libc::c_uint
            {
                ca |= 0x20 as libc::c_int as libc::c_uint;
            }
            if cb.wrapping_sub('A' as i32 as libc::c_uint)
                <= ('Z' as i32 - 'A' as i32) as libc::c_uint
            {
                cb |= 0x20 as libc::c_int as libc::c_uint;
            }
            if !(ca == cb) {
                return ca.wrapping_sub(cb) as libc::c_int;
            }
        }
        i = i.wrapping_add(1);
    }
    return 0 as libc::c_int;
}
unsafe extern "C" fn array_keycmp(
    a: *const libc::c_char,
    alen: uint32_t,
    b: *const libc::c_char,
    blen: uint32_t,
) -> libc::c_int {
    return if alen < blen {
        -(1 as libc::c_int)
    } else if alen > blen {
        1 as libc::c_int
    } else {
        array_caseless_compare(a, b, blen)
    };
}
#[cold]
unsafe extern "C" fn array_keycmpb(
    k: *const libc::c_char,
    klen: uint32_t,
    b: *const buffer,
) -> libc::c_int {
    return array_keycmp(
        k,
        klen,
        (*b).ptr,
        ((*b).used).wrapping_sub(1 as libc::c_int as libc::c_uint),
    );
}
unsafe extern "C" fn array_get_index_ext(
    a: *const array,
    ext: libc::c_int,
    k: *const libc::c_char,
    klen: uint32_t,
) -> int32_t {
    let mut lower: uint_fast32_t = 0 as libc::c_int as uint_fast32_t;
    let mut upper: uint_fast32_t = (*a).used as uint_fast32_t;
    while lower != upper {
        let probe: uint_fast32_t = lower
            .wrapping_add(upper)
            .wrapping_div(2 as libc::c_int as libc::c_ulong);
        let x: libc::c_int = (*(*((*a).sorted).offset(probe as isize) as *mut data_string)).ext;
        let e: libc::c_int = if ext | x != 0 {
            ext
        } else {
            array_keycmpb(k, klen, &mut (**((*a).sorted).offset(probe as isize)).key)
        };
        if e < x {
            upper = probe;
        } else if e > x {
            lower = probe.wrapping_add(1 as libc::c_int as libc::c_ulong);
        } else {
            return probe as int32_t;
        }
    }
    return -(lower as libc::c_int) - 1 as libc::c_int;
}
#[no_mangle]
pub unsafe extern "C" fn array_get_element_klen_ext(
    a: *const array,
    ext: libc::c_int,
    mut key: *const libc::c_char,
    klen: uint32_t,
) -> *mut data_unset {
    let ipos: int32_t = array_get_index_ext(a, ext, key, klen);
    return if ipos >= 0 as libc::c_int {
        *((*a).sorted).offset(ipos as isize)
    } else {
        0 as *mut data_unset
    };
}
unsafe extern "C" fn array_get_index(
    a: *const array,
    k: *const libc::c_char,
    klen: uint32_t,
) -> int32_t {
    let mut lower: uint_fast32_t = 0 as libc::c_int as uint_fast32_t;
    let mut upper: uint_fast32_t = (*a).used as uint_fast32_t;
    while lower != upper {
        let mut probe: uint_fast32_t = lower
            .wrapping_add(upper)
            .wrapping_div(2 as libc::c_int as libc::c_ulong);
        let b: *const buffer = &mut (**((*a).sorted).offset(probe as isize)).key;
        let mut cmp: libc::c_int = array_keycmp(
            k,
            klen,
            (*b).ptr,
            ((*b).used).wrapping_sub(1 as libc::c_int as libc::c_uint),
        );
        if cmp < 0 as libc::c_int {
            upper = probe;
        } else if cmp > 0 as libc::c_int {
            lower = probe.wrapping_add(1 as libc::c_int as libc::c_ulong);
        } else {
            return probe as int32_t;
        }
    }
    return -(lower as libc::c_int) - 1 as libc::c_int;
}
#[no_mangle]
pub unsafe extern "C" fn array_get_element_klen(
    a: *const array,
    mut key: *const libc::c_char,
    klen: uint32_t,
) -> *const data_unset {
    let ipos: int32_t = array_get_index(a, key, klen);
    return if ipos >= 0 as libc::c_int {
        *((*a).sorted).offset(ipos as isize)
    } else {
        0 as *mut data_unset
    };
}
#[no_mangle]
#[cold]
pub unsafe extern "C" fn array_get_data_unset(
    a: *const array,
    mut key: *const libc::c_char,
    klen: uint32_t,
) -> *mut data_unset {
    let ipos: int32_t = array_get_index(a, key, klen);
    return if ipos >= 0 as libc::c_int {
        *((*a).sorted).offset(ipos as isize)
    } else {
        0 as *mut data_unset
    };
}
#[no_mangle]
#[cold]
pub unsafe extern "C" fn array_extract_element_klen(
    a: *mut array,
    mut key: *const libc::c_char,
    klen: uint32_t,
) -> *mut data_unset {
    let ipos: int32_t = array_get_index(a, key, klen);
    if ipos < 0 as libc::c_int {
        return 0 as *mut data_unset;
    }
    let entry: *mut data_unset = *((*a).sorted).offset(ipos as isize);
    (*a).used = ((*a).used).wrapping_sub(1);
    let last_ndx: uint32_t = (*a).used;
    if last_ndx != ipos as uint32_t {
        let d: *mut *mut data_unset = ((*a).sorted).offset(ipos as isize);
        memmove(
            d as *mut libc::c_void,
            d.offset(1 as libc::c_int as isize) as *const libc::c_void,
            (last_ndx.wrapping_sub(ipos as uint32_t) as libc::c_ulong)
                .wrapping_mul(::core::mem::size_of::<*mut data_unset>() as libc::c_ulong),
        );
    }
    if entry != *((*a).data).offset(last_ndx as isize) {
        let mut ndx: uint32_t = 0 as libc::c_int as uint32_t;
        while entry != *((*a).data).offset(ndx as isize) {
            ndx = ndx.wrapping_add(1);
        }
        let ref mut fresh229 = *((*a).data).offset(ndx as isize);
        *fresh229 = *((*a).data).offset(last_ndx as isize);
    }
    let ref mut fresh230 = *((*a).data).offset(last_ndx as isize);
    *fresh230 = 0 as *mut data_unset;
    return entry;
}
unsafe extern "C" fn array_get_unused_element(a: *mut array, t: data_type_t) -> *mut data_unset {
    let du: *mut data_unset = if (*a).used < (*a).size {
        *((*a).data).offset((*a).used as isize)
    } else {
        0 as *mut data_unset
    };
    if !du.is_null() && (*du).type_0 as libc::c_uint == t as libc::c_uint {
        let ref mut fresh231 = *((*a).data).offset((*a).used as isize);
        *fresh231 = 0 as *mut data_unset;
        return du;
    }
    return 0 as *mut data_unset;
}
unsafe extern "C" fn array_insert_data_at_pos(
    a: *mut array,
    entry: *mut data_unset,
    pos: uint_fast32_t,
) -> *mut data_unset {
    if (*a).used < (*a).size {
        let prev: *mut data_unset = *((*a).data).offset((*a).used as isize);
        if (prev != 0 as *mut libc::c_void as *mut data_unset) as libc::c_int as libc::c_long != 0 {
            ((*(*prev).fn_0).free).expect("non-null function pointer")(prev);
        }
    } else {
        array_extend(a, 16 as libc::c_int as uint32_t);
    }
    let fresh232 = (*a).used;
    (*a).used = ((*a).used).wrapping_add(1);
    let mut ndx: uint_fast32_t = fresh232 as uint_fast32_t;
    let ref mut fresh233 = *((*a).data).offset(ndx as isize);
    *fresh233 = entry;
    ndx = (ndx as libc::c_ulong).wrapping_sub(pos) as uint_fast32_t as uint_fast32_t;
    let d: *mut *mut data_unset = ((*a).sorted).offset(pos as isize);
    if ndx as libc::c_long != 0 {
        memmove(
            d.offset(1 as libc::c_int as isize) as *mut libc::c_void,
            d as *const libc::c_void,
            ndx.wrapping_mul(::core::mem::size_of::<*mut data_unset>() as libc::c_ulong),
        );
    }
    *d = entry;
    return entry;
}
unsafe extern "C" fn array_insert_integer_at_pos(
    a: *mut array,
    pos: uint_fast32_t,
) -> *mut data_integer {
    let di: *mut data_integer = array_data_integer_init();
    return array_insert_data_at_pos(a, di as *mut data_unset, pos) as *mut data_integer;
}
unsafe extern "C" fn array_insert_string_at_pos(
    a: *mut array,
    pos: uint_fast32_t,
) -> *mut data_string {
    let mut ds: *mut data_string = array_get_unused_element(a, TYPE_STRING) as *mut data_string;
    if ds.is_null() {
        ds = array_data_string_init();
    }
    return array_insert_data_at_pos(a, ds as *mut data_unset, pos) as *mut data_string;
}
#[no_mangle]
pub unsafe extern "C" fn array_get_buf_ptr_ext(
    a: *mut array,
    ext: libc::c_int,
    k: *const libc::c_char,
    klen: uint32_t,
) -> *mut buffer {
    let mut ipos: int32_t = array_get_index_ext(a, ext, k, klen);
    if ipos >= 0 as libc::c_int {
        return &mut (*(*((*a).sorted).offset(ipos as isize) as *mut data_string)).value;
    }
    let ds: *mut data_string =
        array_insert_string_at_pos(a, (-ipos - 1 as libc::c_int) as uint32_t as uint_fast32_t);
    (*ds).ext = ext;
    buffer_copy_string_len(&mut (*ds).key, k, klen as size_t);
    buffer_clear(&mut (*ds).value);
    return &mut (*ds).value;
}
#[no_mangle]
pub unsafe extern "C" fn array_get_int_ptr(
    a: *mut array,
    k: *const libc::c_char,
    klen: uint32_t,
) -> *mut libc::c_int {
    let mut ipos: int32_t = array_get_index(a, k, klen);
    if ipos >= 0 as libc::c_int {
        return &mut (*(*((*a).sorted).offset(ipos as isize) as *mut data_integer)).value;
    }
    let di: *mut data_integer =
        array_insert_integer_at_pos(a, (-ipos - 1 as libc::c_int) as uint32_t as uint_fast32_t);
    buffer_copy_string_len(&mut (*di).key, k, klen as size_t);
    (*di).value = 0 as libc::c_int;
    return &mut (*di).value;
}
#[no_mangle]
pub unsafe extern "C" fn array_get_buf_ptr(
    a: *mut array,
    k: *const libc::c_char,
    klen: uint32_t,
) -> *mut buffer {
    let mut ipos: int32_t = array_get_index(a, k, klen);
    if ipos >= 0 as libc::c_int {
        return &mut (*(*((*a).sorted).offset(ipos as isize) as *mut data_string)).value;
    }
    let ds: *mut data_string =
        array_insert_string_at_pos(a, (-ipos - 1 as libc::c_int) as uint32_t as uint_fast32_t);
    buffer_copy_string_len(&mut (*ds).key, k, klen as size_t);
    buffer_clear(&mut (*ds).value);
    return &mut (*ds).value;
}
#[no_mangle]
pub unsafe extern "C" fn array_insert_value(a: *mut array, v: *const libc::c_char, vlen: uint32_t) {
    let ds: *mut data_string = array_insert_string_at_pos(a, (*a).used as uint_fast32_t);
    buffer_clear(&mut (*ds).key);
    buffer_copy_string_len(&mut (*ds).value, v, vlen as size_t);
}
#[cold]
unsafe extern "C" fn array_find_or_insert(
    a: *mut array,
    entry: *mut data_unset,
) -> *mut *mut data_unset {
    if entry.is_null() {
        ck_assert_failed(
            b"/home/kkysen/work/rust/lighttpd/src/array.c\0" as *const u8 as *const libc::c_char,
            436 as libc::c_int as libc::c_uint,
            b"((void*)0) != entry\0" as *const u8 as *const libc::c_char,
        );
    }
    if buffer_is_unset(&mut (*entry).key) != 0 {
        array_insert_data_at_pos(a, entry, (*a).used as uint_fast32_t);
        return 0 as *mut *mut data_unset;
    }
    let ipos: int32_t = array_get_index(a, (*entry).key.ptr, buffer_clen(&mut (*entry).key));
    if ipos >= 0 as libc::c_int {
        return &mut *((*a).sorted).offset(ipos as isize) as *mut *mut data_unset;
    }
    array_insert_data_at_pos(
        a,
        entry,
        (-ipos - 1 as libc::c_int) as uint32_t as uint_fast32_t,
    );
    return 0 as *mut *mut data_unset;
}
#[no_mangle]
#[cold]
pub unsafe extern "C" fn array_replace(a: *mut array, entry: *mut data_unset) {
    if (array_find_or_insert(a, entry)).is_null() {
        return;
    }
    let ipos: int32_t = array_get_index(a, (*entry).key.ptr, buffer_clen(&mut (*entry).key));
    if !(ipos >= 0 as libc::c_int) {
        ck_assert_failed(
            b"/home/kkysen/work/rust/lighttpd/src/array.c\0" as *const u8 as *const libc::c_char,
            458 as libc::c_int as libc::c_uint,
            b"ipos >= 0\0" as *const u8 as *const libc::c_char,
        );
    }
    let mut old: *mut data_unset = *((*a).sorted).offset(ipos as isize);
    if !(old != entry) {
        ck_assert_failed(
            b"/home/kkysen/work/rust/lighttpd/src/array.c\0" as *const u8 as *const libc::c_char,
            460 as libc::c_int as libc::c_uint,
            b"old != entry\0" as *const u8 as *const libc::c_char,
        );
    }
    let ref mut fresh234 = *((*a).sorted).offset(ipos as isize);
    *fresh234 = entry;
    let mut i: uint32_t = 0 as libc::c_int as uint32_t;
    while i < (*a).used && *((*a).data).offset(i as isize) != old {
        i = i.wrapping_add(1);
    }
    if !(i != (*a).used) {
        ck_assert_failed(
            b"/home/kkysen/work/rust/lighttpd/src/array.c\0" as *const u8 as *const libc::c_char,
            465 as libc::c_int as libc::c_uint,
            b"i != a->used\0" as *const u8 as *const libc::c_char,
        );
    }
    let ref mut fresh235 = *((*a).data).offset(i as isize);
    *fresh235 = entry;
    ((*(*old).fn_0).free).expect("non-null function pointer")(old);
}
#[no_mangle]
#[cold]
pub unsafe extern "C" fn array_insert_unique(a: *mut array, entry: *mut data_unset) {
    let mut old: *mut *mut data_unset = 0 as *mut *mut data_unset;
    old = array_find_or_insert(a, entry);
    if !old.is_null() {
        if ((*(*entry).fn_0).insert_dup).is_some() {
            if !((**old).type_0 as libc::c_uint == (*entry).type_0 as libc::c_uint) {
                ck_assert_failed(
                    b"/home/kkysen/work/rust/lighttpd/src/array.c\0" as *const u8
                        as *const libc::c_char,
                    476 as libc::c_int as libc::c_uint,
                    b"(*old)->type == entry->type\0" as *const u8 as *const libc::c_char,
                );
            }
            ((*(*entry).fn_0).insert_dup).expect("non-null function pointer")(*old, entry);
        }
        ((*(*entry).fn_0).free).expect("non-null function pointer")(entry);
    }
}
#[no_mangle]
#[cold]
pub unsafe extern "C" fn array_is_vlist(a: *const array) -> libc::c_int {
    let mut i: uint32_t = 0 as libc::c_int as uint32_t;
    while i < (*a).used {
        let mut du: *mut data_unset = *((*a).data).offset(i as isize);
        if buffer_is_unset(&mut (*du).key) == 0
            || (*du).type_0 as libc::c_uint != TYPE_STRING as libc::c_int as libc::c_uint
        {
            return 0 as libc::c_int;
        }
        i = i.wrapping_add(1);
    }
    return 1 as libc::c_int;
}
#[no_mangle]
#[cold]
pub unsafe extern "C" fn array_is_kvany(a: *const array) -> libc::c_int {
    let mut i: uint32_t = 0 as libc::c_int as uint32_t;
    while i < (*a).used {
        let mut du: *mut data_unset = *((*a).data).offset(i as isize);
        if buffer_is_unset(&mut (*du).key) != 0 {
            return 0 as libc::c_int;
        }
        i = i.wrapping_add(1);
    }
    return 1 as libc::c_int;
}
#[no_mangle]
#[cold]
pub unsafe extern "C" fn array_is_kvarray(a: *const array) -> libc::c_int {
    let mut i: uint32_t = 0 as libc::c_int as uint32_t;
    while i < (*a).used {
        let mut du: *mut data_unset = *((*a).data).offset(i as isize);
        if buffer_is_unset(&mut (*du).key) != 0
            || (*du).type_0 as libc::c_uint != TYPE_ARRAY as libc::c_int as libc::c_uint
        {
            return 0 as libc::c_int;
        }
        i = i.wrapping_add(1);
    }
    return 1 as libc::c_int;
}
#[no_mangle]
#[cold]
pub unsafe extern "C" fn array_is_kvstring(a: *const array) -> libc::c_int {
    let mut i: uint32_t = 0 as libc::c_int as uint32_t;
    while i < (*a).used {
        let mut du: *mut data_unset = *((*a).data).offset(i as isize);
        if buffer_is_unset(&mut (*du).key) != 0
            || (*du).type_0 as libc::c_uint != TYPE_STRING as libc::c_int as libc::c_uint
        {
            return 0 as libc::c_int;
        }
        i = i.wrapping_add(1);
    }
    return 1 as libc::c_int;
}
#[no_mangle]
pub unsafe extern "C" fn array_match_key_prefix_klen(
    a: *const array,
    s: *const libc::c_char,
    slen: uint32_t,
) -> *mut data_unset {
    let mut i: uint32_t = 0 as libc::c_int as uint32_t;
    while i < (*a).used {
        let key: *const buffer = &mut (**((*a).data).offset(i as isize)).key;
        let klen: uint32_t = buffer_clen(key);
        if klen <= slen
            && 0 as libc::c_int
                == memcmp(
                    s as *const libc::c_void,
                    (*key).ptr as *const libc::c_void,
                    klen as libc::c_ulong,
                )
        {
            return *((*a).data).offset(i as isize);
        }
        i = i.wrapping_add(1);
    }
    return 0 as *mut data_unset;
}
#[no_mangle]
pub unsafe extern "C" fn array_match_key_prefix_nc_klen(
    a: *const array,
    s: *const libc::c_char,
    slen: uint32_t,
) -> *mut data_unset {
    let mut i: uint32_t = 0 as libc::c_int as uint32_t;
    while i < (*a).used {
        let key: *const buffer = &mut (**((*a).data).offset(i as isize)).key;
        let klen: uint32_t = buffer_clen(key);
        if klen <= slen && buffer_eq_icase_ssn(s, (*key).ptr, klen as size_t) != 0 {
            return *((*a).data).offset(i as isize);
        }
        i = i.wrapping_add(1);
    }
    return 0 as *mut data_unset;
}
#[no_mangle]
pub unsafe extern "C" fn array_match_key_prefix(
    a: *const array,
    b: *const buffer,
) -> *mut data_unset {
    return array_match_key_prefix_klen(a, (*b).ptr, buffer_clen(b));
}
#[no_mangle]
pub unsafe extern "C" fn array_match_key_prefix_nc(
    a: *const array,
    b: *const buffer,
) -> *mut data_unset {
    return array_match_key_prefix_nc_klen(a, (*b).ptr, buffer_clen(b));
}
#[no_mangle]
pub unsafe extern "C" fn array_match_value_prefix(
    a: *const array,
    b: *const buffer,
) -> *const buffer {
    let blen: uint32_t = buffer_clen(b);
    let mut i: uint32_t = 0 as libc::c_int as uint32_t;
    while i < (*a).used {
        let value: *const buffer =
            &mut (*(*((*a).data).offset(i as isize) as *mut data_string)).value;
        let vlen: uint32_t = buffer_clen(value);
        if vlen <= blen
            && 0 as libc::c_int
                == memcmp(
                    (*b).ptr as *const libc::c_void,
                    (*value).ptr as *const libc::c_void,
                    vlen as libc::c_ulong,
                )
        {
            return value;
        }
        i = i.wrapping_add(1);
    }
    return 0 as *const buffer;
}
#[no_mangle]
pub unsafe extern "C" fn array_match_value_prefix_nc(
    a: *const array,
    b: *const buffer,
) -> *const buffer {
    let blen: uint32_t = buffer_clen(b);
    let mut i: uint32_t = 0 as libc::c_int as uint32_t;
    while i < (*a).used {
        let value: *const buffer =
            &mut (*(*((*a).data).offset(i as isize) as *mut data_string)).value;
        let vlen: uint32_t = buffer_clen(value);
        if vlen <= blen && buffer_eq_icase_ssn((*b).ptr, (*value).ptr, vlen as size_t) != 0 {
            return value;
        }
        i = i.wrapping_add(1);
    }
    return 0 as *const buffer;
}
#[no_mangle]
pub unsafe extern "C" fn array_match_key_suffix(
    a: *const array,
    b: *const buffer,
) -> *mut data_unset {
    let blen: uint32_t = buffer_clen(b);
    let end: *const libc::c_char = ((*b).ptr).offset(blen as isize);
    let mut i: uint32_t = 0 as libc::c_int as uint32_t;
    while i < (*a).used {
        let key: *const buffer = &mut (**((*a).data).offset(i as isize)).key;
        let klen: uint32_t = buffer_clen(key);
        if klen <= blen
            && 0 as libc::c_int
                == memcmp(
                    end.offset(-(klen as isize)) as *const libc::c_void,
                    (*key).ptr as *const libc::c_void,
                    klen as libc::c_ulong,
                )
        {
            return *((*a).data).offset(i as isize);
        }
        i = i.wrapping_add(1);
    }
    return 0 as *mut data_unset;
}
#[no_mangle]
pub unsafe extern "C" fn array_match_key_suffix_nc(
    a: *const array,
    b: *const buffer,
) -> *mut data_unset {
    let blen: uint32_t = buffer_clen(b);
    let end: *const libc::c_char = ((*b).ptr).offset(blen as isize);
    let mut i: uint32_t = 0 as libc::c_int as uint32_t;
    while i < (*a).used {
        let key: *const buffer = &mut (**((*a).data).offset(i as isize)).key;
        let klen: uint32_t = buffer_clen(key);
        if klen <= blen
            && buffer_eq_icase_ssn(end.offset(-(klen as isize)), (*key).ptr, klen as size_t) != 0
        {
            return *((*a).data).offset(i as isize);
        }
        i = i.wrapping_add(1);
    }
    return 0 as *mut data_unset;
}
#[no_mangle]
pub unsafe extern "C" fn array_match_value_suffix(
    a: *const array,
    b: *const buffer,
) -> *const buffer {
    let blen: uint32_t = buffer_clen(b);
    let end: *const libc::c_char = ((*b).ptr).offset(blen as isize);
    let mut i: uint32_t = 0 as libc::c_int as uint32_t;
    while i < (*a).used {
        let value: *const buffer =
            &mut (*(*((*a).data).offset(i as isize) as *mut data_string)).value;
        let vlen: uint32_t = buffer_clen(value);
        if vlen <= blen
            && 0 as libc::c_int
                == memcmp(
                    end.offset(-(vlen as isize)) as *const libc::c_void,
                    (*value).ptr as *const libc::c_void,
                    vlen as libc::c_ulong,
                )
        {
            return value;
        }
        i = i.wrapping_add(1);
    }
    return 0 as *const buffer;
}
#[no_mangle]
pub unsafe extern "C" fn array_match_value_suffix_nc(
    a: *const array,
    b: *const buffer,
) -> *const buffer {
    let blen: uint32_t = buffer_clen(b);
    let end: *const libc::c_char = ((*b).ptr).offset(blen as isize);
    let mut i: uint32_t = 0 as libc::c_int as uint32_t;
    while i < (*a).used {
        let value: *const buffer =
            &mut (*(*((*a).data).offset(i as isize) as *mut data_string)).value;
        let vlen: uint32_t = buffer_clen(value);
        if vlen <= blen
            && buffer_eq_icase_ssn(end.offset(-(vlen as isize)), (*value).ptr, vlen as size_t) != 0
        {
            return value;
        }
        i = i.wrapping_add(1);
    }
    return 0 as *const buffer;
}
#[no_mangle]
pub unsafe extern "C" fn array_match_path_or_ext(
    a: *const array,
    b: *const buffer,
) -> *mut data_unset {
    let blen: uint32_t = buffer_clen(b);
    let mut i: uint32_t = 0 as libc::c_int as uint32_t;
    while i < (*a).used {
        let key: *const buffer = &mut (**((*a).data).offset(i as isize)).key;
        let klen: uint32_t = buffer_clen(key);
        if klen <= blen
            && 0 as libc::c_int
                == memcmp(
                    (if *(*key).ptr as libc::c_int == '/' as i32 {
                        (*b).ptr
                    } else {
                        ((*b).ptr).offset(blen as isize).offset(-(klen as isize))
                    }) as *const libc::c_void,
                    (*key).ptr as *const libc::c_void,
                    klen as libc::c_ulong,
                )
        {
            return *((*a).data).offset(i as isize);
        }
        i = i.wrapping_add(1);
    }
    return 0 as *mut data_unset;
}
unsafe extern "C" fn Decode(
    mut output: *mut uint32_t,
    mut input: *const libc::c_uchar,
    mut len: libc::c_uint,
) {
    let mut i: libc::c_uint = 0;
    let mut j: libc::c_uint = 0;
    i = 0 as libc::c_int as libc::c_uint;
    j = 0 as libc::c_int as libc::c_uint;
    while j < len {
        *output.offset(i as isize) = *input.offset(j as isize) as uint32_t
            | (*input.offset(j.wrapping_add(1 as libc::c_int as libc::c_uint) as isize)
                as uint32_t)
                << 8 as libc::c_int
            | (*input.offset(j.wrapping_add(2 as libc::c_int as libc::c_uint) as isize)
                as uint32_t)
                << 16 as libc::c_int
            | (*input.offset(j.wrapping_add(3 as libc::c_int as libc::c_uint) as isize)
                as uint32_t)
                << 24 as libc::c_int;
        i = i.wrapping_add(1);
        j = j.wrapping_add(4 as libc::c_int as libc::c_uint);
    }
}
#[no_mangle]
pub unsafe extern "C" fn MD5_Final(mut digest: *mut libc::c_uchar, mut context: *mut MD5_CTX) {
    let mut bits: [libc::c_uchar; 8] = [0; 8];
    let mut ndx: libc::c_uint = 0;
    let mut padLen: libc::c_uint = 0;
    Encode(
        bits.as_mut_ptr(),
        ((*context).count).as_mut_ptr(),
        8 as libc::c_int as libc::c_uint,
    );
    ndx = (*context).count[0 as libc::c_int as usize] >> 3 as libc::c_int
        & 0x3f as libc::c_int as libc::c_uint;
    padLen = if ndx < 56 as libc::c_int as libc::c_uint {
        (56 as libc::c_int as libc::c_uint).wrapping_sub(ndx)
    } else {
        (120 as libc::c_int as libc::c_uint).wrapping_sub(ndx)
    };
    MD5_Update(context, PADDING.as_mut_ptr() as *const libc::c_void, padLen);
    MD5_Update(
        context,
        bits.as_mut_ptr() as *const libc::c_void,
        8 as libc::c_int as libc::c_uint,
    );
    Encode(
        digest,
        ((*context).state).as_mut_ptr(),
        16 as libc::c_int as libc::c_uint,
    );
    memset(
        context as *mut libc::c_uchar as *mut libc::c_void,
        0 as libc::c_int,
        ::core::mem::size_of::<MD5_CTX>() as libc::c_ulong,
    );
}
unsafe extern "C" fn li_MD5Transform(mut state: *mut uint32_t, mut block: *const libc::c_uchar) {
    let mut a: uint32_t = *state.offset(0 as libc::c_int as isize);
    let mut b: uint32_t = *state.offset(1 as libc::c_int as isize);
    let mut c: uint32_t = *state.offset(2 as libc::c_int as isize);
    let mut d: uint32_t = *state.offset(3 as libc::c_int as isize);
    let mut x: [uint32_t; 16] = [0; 16];
    Decode(x.as_mut_ptr(), block, 64 as libc::c_int as libc::c_uint);
    a = (a as libc::c_uint).wrapping_add(
        (b & c | !b & d)
            .wrapping_add(x[0 as libc::c_int as usize])
            .wrapping_add(0xd76aa478 as libc::c_uint),
    ) as uint32_t as uint32_t;
    a = a << 7 as libc::c_int | a >> 32 as libc::c_int - 7 as libc::c_int;
    a = (a as libc::c_uint).wrapping_add(b) as uint32_t as uint32_t;
    d = (d as libc::c_uint).wrapping_add(
        (a & b | !a & c)
            .wrapping_add(x[1 as libc::c_int as usize])
            .wrapping_add(0xe8c7b756 as libc::c_uint),
    ) as uint32_t as uint32_t;
    d = d << 12 as libc::c_int | d >> 32 as libc::c_int - 12 as libc::c_int;
    d = (d as libc::c_uint).wrapping_add(a) as uint32_t as uint32_t;
    c = (c as libc::c_uint).wrapping_add(
        (d & a | !d & b)
            .wrapping_add(x[2 as libc::c_int as usize])
            .wrapping_add(0x242070db as libc::c_int as uint32_t),
    ) as uint32_t as uint32_t;
    c = c << 17 as libc::c_int | c >> 32 as libc::c_int - 17 as libc::c_int;
    c = (c as libc::c_uint).wrapping_add(d) as uint32_t as uint32_t;
    b = (b as libc::c_uint).wrapping_add(
        (c & d | !c & a)
            .wrapping_add(x[3 as libc::c_int as usize])
            .wrapping_add(0xc1bdceee as libc::c_uint),
    ) as uint32_t as uint32_t;
    b = b << 22 as libc::c_int | b >> 32 as libc::c_int - 22 as libc::c_int;
    b = (b as libc::c_uint).wrapping_add(c) as uint32_t as uint32_t;
    a = (a as libc::c_uint).wrapping_add(
        (b & c | !b & d)
            .wrapping_add(x[4 as libc::c_int as usize])
            .wrapping_add(0xf57c0faf as libc::c_uint),
    ) as uint32_t as uint32_t;
    a = a << 7 as libc::c_int | a >> 32 as libc::c_int - 7 as libc::c_int;
    a = (a as libc::c_uint).wrapping_add(b) as uint32_t as uint32_t;
    d = (d as libc::c_uint).wrapping_add(
        (a & b | !a & c)
            .wrapping_add(x[5 as libc::c_int as usize])
            .wrapping_add(0x4787c62a as libc::c_int as uint32_t),
    ) as uint32_t as uint32_t;
    d = d << 12 as libc::c_int | d >> 32 as libc::c_int - 12 as libc::c_int;
    d = (d as libc::c_uint).wrapping_add(a) as uint32_t as uint32_t;
    c = (c as libc::c_uint).wrapping_add(
        (d & a | !d & b)
            .wrapping_add(x[6 as libc::c_int as usize])
            .wrapping_add(0xa8304613 as libc::c_uint),
    ) as uint32_t as uint32_t;
    c = c << 17 as libc::c_int | c >> 32 as libc::c_int - 17 as libc::c_int;
    c = (c as libc::c_uint).wrapping_add(d) as uint32_t as uint32_t;
    b = (b as libc::c_uint).wrapping_add(
        (c & d | !c & a)
            .wrapping_add(x[7 as libc::c_int as usize])
            .wrapping_add(0xfd469501 as libc::c_uint),
    ) as uint32_t as uint32_t;
    b = b << 22 as libc::c_int | b >> 32 as libc::c_int - 22 as libc::c_int;
    b = (b as libc::c_uint).wrapping_add(c) as uint32_t as uint32_t;
    a = (a as libc::c_uint).wrapping_add(
        (b & c | !b & d)
            .wrapping_add(x[8 as libc::c_int as usize])
            .wrapping_add(0x698098d8 as libc::c_int as uint32_t),
    ) as uint32_t as uint32_t;
    a = a << 7 as libc::c_int | a >> 32 as libc::c_int - 7 as libc::c_int;
    a = (a as libc::c_uint).wrapping_add(b) as uint32_t as uint32_t;
    d = (d as libc::c_uint).wrapping_add(
        (a & b | !a & c)
            .wrapping_add(x[9 as libc::c_int as usize])
            .wrapping_add(0x8b44f7af as libc::c_uint),
    ) as uint32_t as uint32_t;
    d = d << 12 as libc::c_int | d >> 32 as libc::c_int - 12 as libc::c_int;
    d = (d as libc::c_uint).wrapping_add(a) as uint32_t as uint32_t;
    c = (c as libc::c_uint).wrapping_add(
        (d & a | !d & b)
            .wrapping_add(x[10 as libc::c_int as usize])
            .wrapping_add(0xffff5bb1 as libc::c_uint),
    ) as uint32_t as uint32_t;
    c = c << 17 as libc::c_int | c >> 32 as libc::c_int - 17 as libc::c_int;
    c = (c as libc::c_uint).wrapping_add(d) as uint32_t as uint32_t;
    b = (b as libc::c_uint).wrapping_add(
        (c & d | !c & a)
            .wrapping_add(x[11 as libc::c_int as usize])
            .wrapping_add(0x895cd7be as libc::c_uint),
    ) as uint32_t as uint32_t;
    b = b << 22 as libc::c_int | b >> 32 as libc::c_int - 22 as libc::c_int;
    b = (b as libc::c_uint).wrapping_add(c) as uint32_t as uint32_t;
    a = (a as libc::c_uint).wrapping_add(
        (b & c | !b & d)
            .wrapping_add(x[12 as libc::c_int as usize])
            .wrapping_add(0x6b901122 as libc::c_int as uint32_t),
    ) as uint32_t as uint32_t;
    a = a << 7 as libc::c_int | a >> 32 as libc::c_int - 7 as libc::c_int;
    a = (a as libc::c_uint).wrapping_add(b) as uint32_t as uint32_t;
    d = (d as libc::c_uint).wrapping_add(
        (a & b | !a & c)
            .wrapping_add(x[13 as libc::c_int as usize])
            .wrapping_add(0xfd987193 as libc::c_uint),
    ) as uint32_t as uint32_t;
    d = d << 12 as libc::c_int | d >> 32 as libc::c_int - 12 as libc::c_int;
    d = (d as libc::c_uint).wrapping_add(a) as uint32_t as uint32_t;
    c = (c as libc::c_uint).wrapping_add(
        (d & a | !d & b)
            .wrapping_add(x[14 as libc::c_int as usize])
            .wrapping_add(0xa679438e as libc::c_uint),
    ) as uint32_t as uint32_t;
    c = c << 17 as libc::c_int | c >> 32 as libc::c_int - 17 as libc::c_int;
    c = (c as libc::c_uint).wrapping_add(d) as uint32_t as uint32_t;
    b = (b as libc::c_uint).wrapping_add(
        (c & d | !c & a)
            .wrapping_add(x[15 as libc::c_int as usize])
            .wrapping_add(0x49b40821 as libc::c_int as uint32_t),
    ) as uint32_t as uint32_t;
    b = b << 22 as libc::c_int | b >> 32 as libc::c_int - 22 as libc::c_int;
    b = (b as libc::c_uint).wrapping_add(c) as uint32_t as uint32_t;
    a = (a as libc::c_uint).wrapping_add(
        (b & d | c & !d)
            .wrapping_add(x[1 as libc::c_int as usize])
            .wrapping_add(0xf61e2562 as libc::c_uint),
    ) as uint32_t as uint32_t;
    a = a << 5 as libc::c_int | a >> 32 as libc::c_int - 5 as libc::c_int;
    a = (a as libc::c_uint).wrapping_add(b) as uint32_t as uint32_t;
    d = (d as libc::c_uint).wrapping_add(
        (a & c | b & !c)
            .wrapping_add(x[6 as libc::c_int as usize])
            .wrapping_add(0xc040b340 as libc::c_uint),
    ) as uint32_t as uint32_t;
    d = d << 9 as libc::c_int | d >> 32 as libc::c_int - 9 as libc::c_int;
    d = (d as libc::c_uint).wrapping_add(a) as uint32_t as uint32_t;
    c = (c as libc::c_uint).wrapping_add(
        (d & b | a & !b)
            .wrapping_add(x[11 as libc::c_int as usize])
            .wrapping_add(0x265e5a51 as libc::c_int as uint32_t),
    ) as uint32_t as uint32_t;
    c = c << 14 as libc::c_int | c >> 32 as libc::c_int - 14 as libc::c_int;
    c = (c as libc::c_uint).wrapping_add(d) as uint32_t as uint32_t;
    b = (b as libc::c_uint).wrapping_add(
        (c & a | d & !a)
            .wrapping_add(x[0 as libc::c_int as usize])
            .wrapping_add(0xe9b6c7aa as libc::c_uint),
    ) as uint32_t as uint32_t;
    b = b << 20 as libc::c_int | b >> 32 as libc::c_int - 20 as libc::c_int;
    b = (b as libc::c_uint).wrapping_add(c) as uint32_t as uint32_t;
    a = (a as libc::c_uint).wrapping_add(
        (b & d | c & !d)
            .wrapping_add(x[5 as libc::c_int as usize])
            .wrapping_add(0xd62f105d as libc::c_uint),
    ) as uint32_t as uint32_t;
    a = a << 5 as libc::c_int | a >> 32 as libc::c_int - 5 as libc::c_int;
    a = (a as libc::c_uint).wrapping_add(b) as uint32_t as uint32_t;
    d = (d as libc::c_uint).wrapping_add(
        (a & c | b & !c)
            .wrapping_add(x[10 as libc::c_int as usize])
            .wrapping_add(0x2441453 as libc::c_int as uint32_t),
    ) as uint32_t as uint32_t;
    d = d << 9 as libc::c_int | d >> 32 as libc::c_int - 9 as libc::c_int;
    d = (d as libc::c_uint).wrapping_add(a) as uint32_t as uint32_t;
    c = (c as libc::c_uint).wrapping_add(
        (d & b | a & !b)
            .wrapping_add(x[15 as libc::c_int as usize])
            .wrapping_add(0xd8a1e681 as libc::c_uint),
    ) as uint32_t as uint32_t;
    c = c << 14 as libc::c_int | c >> 32 as libc::c_int - 14 as libc::c_int;
    c = (c as libc::c_uint).wrapping_add(d) as uint32_t as uint32_t;
    b = (b as libc::c_uint).wrapping_add(
        (c & a | d & !a)
            .wrapping_add(x[4 as libc::c_int as usize])
            .wrapping_add(0xe7d3fbc8 as libc::c_uint),
    ) as uint32_t as uint32_t;
    b = b << 20 as libc::c_int | b >> 32 as libc::c_int - 20 as libc::c_int;
    b = (b as libc::c_uint).wrapping_add(c) as uint32_t as uint32_t;
    a = (a as libc::c_uint).wrapping_add(
        (b & d | c & !d)
            .wrapping_add(x[9 as libc::c_int as usize])
            .wrapping_add(0x21e1cde6 as libc::c_int as uint32_t),
    ) as uint32_t as uint32_t;
    a = a << 5 as libc::c_int | a >> 32 as libc::c_int - 5 as libc::c_int;
    a = (a as libc::c_uint).wrapping_add(b) as uint32_t as uint32_t;
    d = (d as libc::c_uint).wrapping_add(
        (a & c | b & !c)
            .wrapping_add(x[14 as libc::c_int as usize])
            .wrapping_add(0xc33707d6 as libc::c_uint),
    ) as uint32_t as uint32_t;
    d = d << 9 as libc::c_int | d >> 32 as libc::c_int - 9 as libc::c_int;
    d = (d as libc::c_uint).wrapping_add(a) as uint32_t as uint32_t;
    c = (c as libc::c_uint).wrapping_add(
        (d & b | a & !b)
            .wrapping_add(x[3 as libc::c_int as usize])
            .wrapping_add(0xf4d50d87 as libc::c_uint),
    ) as uint32_t as uint32_t;
    c = c << 14 as libc::c_int | c >> 32 as libc::c_int - 14 as libc::c_int;
    c = (c as libc::c_uint).wrapping_add(d) as uint32_t as uint32_t;
    b = (b as libc::c_uint).wrapping_add(
        (c & a | d & !a)
            .wrapping_add(x[8 as libc::c_int as usize])
            .wrapping_add(0x455a14ed as libc::c_int as uint32_t),
    ) as uint32_t as uint32_t;
    b = b << 20 as libc::c_int | b >> 32 as libc::c_int - 20 as libc::c_int;
    b = (b as libc::c_uint).wrapping_add(c) as uint32_t as uint32_t;
    a = (a as libc::c_uint).wrapping_add(
        (b & d | c & !d)
            .wrapping_add(x[13 as libc::c_int as usize])
            .wrapping_add(0xa9e3e905 as libc::c_uint),
    ) as uint32_t as uint32_t;
    a = a << 5 as libc::c_int | a >> 32 as libc::c_int - 5 as libc::c_int;
    a = (a as libc::c_uint).wrapping_add(b) as uint32_t as uint32_t;
    d = (d as libc::c_uint).wrapping_add(
        (a & c | b & !c)
            .wrapping_add(x[2 as libc::c_int as usize])
            .wrapping_add(0xfcefa3f8 as libc::c_uint),
    ) as uint32_t as uint32_t;
    d = d << 9 as libc::c_int | d >> 32 as libc::c_int - 9 as libc::c_int;
    d = (d as libc::c_uint).wrapping_add(a) as uint32_t as uint32_t;
    c = (c as libc::c_uint).wrapping_add(
        (d & b | a & !b)
            .wrapping_add(x[7 as libc::c_int as usize])
            .wrapping_add(0x676f02d9 as libc::c_int as uint32_t),
    ) as uint32_t as uint32_t;
    c = c << 14 as libc::c_int | c >> 32 as libc::c_int - 14 as libc::c_int;
    c = (c as libc::c_uint).wrapping_add(d) as uint32_t as uint32_t;
    b = (b as libc::c_uint).wrapping_add(
        (c & a | d & !a)
            .wrapping_add(x[12 as libc::c_int as usize])
            .wrapping_add(0x8d2a4c8a as libc::c_uint),
    ) as uint32_t as uint32_t;
    b = b << 20 as libc::c_int | b >> 32 as libc::c_int - 20 as libc::c_int;
    b = (b as libc::c_uint).wrapping_add(c) as uint32_t as uint32_t;
    a = (a as libc::c_uint).wrapping_add(
        (b ^ c ^ d)
            .wrapping_add(x[5 as libc::c_int as usize])
            .wrapping_add(0xfffa3942 as libc::c_uint),
    ) as uint32_t as uint32_t;
    a = a << 4 as libc::c_int | a >> 32 as libc::c_int - 4 as libc::c_int;
    a = (a as libc::c_uint).wrapping_add(b) as uint32_t as uint32_t;
    d = (d as libc::c_uint).wrapping_add(
        (a ^ b ^ c)
            .wrapping_add(x[8 as libc::c_int as usize])
            .wrapping_add(0x8771f681 as libc::c_uint),
    ) as uint32_t as uint32_t;
    d = d << 11 as libc::c_int | d >> 32 as libc::c_int - 11 as libc::c_int;
    d = (d as libc::c_uint).wrapping_add(a) as uint32_t as uint32_t;
    c = (c as libc::c_uint).wrapping_add(
        (d ^ a ^ b)
            .wrapping_add(x[11 as libc::c_int as usize])
            .wrapping_add(0x6d9d6122 as libc::c_int as uint32_t),
    ) as uint32_t as uint32_t;
    c = c << 16 as libc::c_int | c >> 32 as libc::c_int - 16 as libc::c_int;
    c = (c as libc::c_uint).wrapping_add(d) as uint32_t as uint32_t;
    b = (b as libc::c_uint).wrapping_add(
        (c ^ d ^ a)
            .wrapping_add(x[14 as libc::c_int as usize])
            .wrapping_add(0xfde5380c as libc::c_uint),
    ) as uint32_t as uint32_t;
    b = b << 23 as libc::c_int | b >> 32 as libc::c_int - 23 as libc::c_int;
    b = (b as libc::c_uint).wrapping_add(c) as uint32_t as uint32_t;
    a = (a as libc::c_uint).wrapping_add(
        (b ^ c ^ d)
            .wrapping_add(x[1 as libc::c_int as usize])
            .wrapping_add(0xa4beea44 as libc::c_uint),
    ) as uint32_t as uint32_t;
    a = a << 4 as libc::c_int | a >> 32 as libc::c_int - 4 as libc::c_int;
    a = (a as libc::c_uint).wrapping_add(b) as uint32_t as uint32_t;
    d = (d as libc::c_uint).wrapping_add(
        (a ^ b ^ c)
            .wrapping_add(x[4 as libc::c_int as usize])
            .wrapping_add(0x4bdecfa9 as libc::c_int as uint32_t),
    ) as uint32_t as uint32_t;
    d = d << 11 as libc::c_int | d >> 32 as libc::c_int - 11 as libc::c_int;
    d = (d as libc::c_uint).wrapping_add(a) as uint32_t as uint32_t;
    c = (c as libc::c_uint).wrapping_add(
        (d ^ a ^ b)
            .wrapping_add(x[7 as libc::c_int as usize])
            .wrapping_add(0xf6bb4b60 as libc::c_uint),
    ) as uint32_t as uint32_t;
    c = c << 16 as libc::c_int | c >> 32 as libc::c_int - 16 as libc::c_int;
    c = (c as libc::c_uint).wrapping_add(d) as uint32_t as uint32_t;
    b = (b as libc::c_uint).wrapping_add(
        (c ^ d ^ a)
            .wrapping_add(x[10 as libc::c_int as usize])
            .wrapping_add(0xbebfbc70 as libc::c_uint),
    ) as uint32_t as uint32_t;
    b = b << 23 as libc::c_int | b >> 32 as libc::c_int - 23 as libc::c_int;
    b = (b as libc::c_uint).wrapping_add(c) as uint32_t as uint32_t;
    a = (a as libc::c_uint).wrapping_add(
        (b ^ c ^ d)
            .wrapping_add(x[13 as libc::c_int as usize])
            .wrapping_add(0x289b7ec6 as libc::c_int as uint32_t),
    ) as uint32_t as uint32_t;
    a = a << 4 as libc::c_int | a >> 32 as libc::c_int - 4 as libc::c_int;
    a = (a as libc::c_uint).wrapping_add(b) as uint32_t as uint32_t;
    d = (d as libc::c_uint).wrapping_add(
        (a ^ b ^ c)
            .wrapping_add(x[0 as libc::c_int as usize])
            .wrapping_add(0xeaa127fa as libc::c_uint),
    ) as uint32_t as uint32_t;
    d = d << 11 as libc::c_int | d >> 32 as libc::c_int - 11 as libc::c_int;
    d = (d as libc::c_uint).wrapping_add(a) as uint32_t as uint32_t;
    c = (c as libc::c_uint).wrapping_add(
        (d ^ a ^ b)
            .wrapping_add(x[3 as libc::c_int as usize])
            .wrapping_add(0xd4ef3085 as libc::c_uint),
    ) as uint32_t as uint32_t;
    c = c << 16 as libc::c_int | c >> 32 as libc::c_int - 16 as libc::c_int;
    c = (c as libc::c_uint).wrapping_add(d) as uint32_t as uint32_t;
    b = (b as libc::c_uint).wrapping_add(
        (c ^ d ^ a)
            .wrapping_add(x[6 as libc::c_int as usize])
            .wrapping_add(0x4881d05 as libc::c_int as uint32_t),
    ) as uint32_t as uint32_t;
    b = b << 23 as libc::c_int | b >> 32 as libc::c_int - 23 as libc::c_int;
    b = (b as libc::c_uint).wrapping_add(c) as uint32_t as uint32_t;
    a = (a as libc::c_uint).wrapping_add(
        (b ^ c ^ d)
            .wrapping_add(x[9 as libc::c_int as usize])
            .wrapping_add(0xd9d4d039 as libc::c_uint),
    ) as uint32_t as uint32_t;
    a = a << 4 as libc::c_int | a >> 32 as libc::c_int - 4 as libc::c_int;
    a = (a as libc::c_uint).wrapping_add(b) as uint32_t as uint32_t;
    d = (d as libc::c_uint).wrapping_add(
        (a ^ b ^ c)
            .wrapping_add(x[12 as libc::c_int as usize])
            .wrapping_add(0xe6db99e5 as libc::c_uint),
    ) as uint32_t as uint32_t;
    d = d << 11 as libc::c_int | d >> 32 as libc::c_int - 11 as libc::c_int;
    d = (d as libc::c_uint).wrapping_add(a) as uint32_t as uint32_t;
    c = (c as libc::c_uint).wrapping_add(
        (d ^ a ^ b)
            .wrapping_add(x[15 as libc::c_int as usize])
            .wrapping_add(0x1fa27cf8 as libc::c_int as uint32_t),
    ) as uint32_t as uint32_t;
    c = c << 16 as libc::c_int | c >> 32 as libc::c_int - 16 as libc::c_int;
    c = (c as libc::c_uint).wrapping_add(d) as uint32_t as uint32_t;
    b = (b as libc::c_uint).wrapping_add(
        (c ^ d ^ a)
            .wrapping_add(x[2 as libc::c_int as usize])
            .wrapping_add(0xc4ac5665 as libc::c_uint),
    ) as uint32_t as uint32_t;
    b = b << 23 as libc::c_int | b >> 32 as libc::c_int - 23 as libc::c_int;
    b = (b as libc::c_uint).wrapping_add(c) as uint32_t as uint32_t;
    a = (a as libc::c_uint).wrapping_add(
        (c ^ (b | !d))
            .wrapping_add(x[0 as libc::c_int as usize])
            .wrapping_add(0xf4292244 as libc::c_uint),
    ) as uint32_t as uint32_t;
    a = a << 6 as libc::c_int | a >> 32 as libc::c_int - 6 as libc::c_int;
    a = (a as libc::c_uint).wrapping_add(b) as uint32_t as uint32_t;
    d = (d as libc::c_uint).wrapping_add(
        (b ^ (a | !c))
            .wrapping_add(x[7 as libc::c_int as usize])
            .wrapping_add(0x432aff97 as libc::c_int as uint32_t),
    ) as uint32_t as uint32_t;
    d = d << 10 as libc::c_int | d >> 32 as libc::c_int - 10 as libc::c_int;
    d = (d as libc::c_uint).wrapping_add(a) as uint32_t as uint32_t;
    c = (c as libc::c_uint).wrapping_add(
        (a ^ (d | !b))
            .wrapping_add(x[14 as libc::c_int as usize])
            .wrapping_add(0xab9423a7 as libc::c_uint),
    ) as uint32_t as uint32_t;
    c = c << 15 as libc::c_int | c >> 32 as libc::c_int - 15 as libc::c_int;
    c = (c as libc::c_uint).wrapping_add(d) as uint32_t as uint32_t;
    b = (b as libc::c_uint).wrapping_add(
        (d ^ (c | !a))
            .wrapping_add(x[5 as libc::c_int as usize])
            .wrapping_add(0xfc93a039 as libc::c_uint),
    ) as uint32_t as uint32_t;
    b = b << 21 as libc::c_int | b >> 32 as libc::c_int - 21 as libc::c_int;
    b = (b as libc::c_uint).wrapping_add(c) as uint32_t as uint32_t;
    a = (a as libc::c_uint).wrapping_add(
        (c ^ (b | !d))
            .wrapping_add(x[12 as libc::c_int as usize])
            .wrapping_add(0x655b59c3 as libc::c_int as uint32_t),
    ) as uint32_t as uint32_t;
    a = a << 6 as libc::c_int | a >> 32 as libc::c_int - 6 as libc::c_int;
    a = (a as libc::c_uint).wrapping_add(b) as uint32_t as uint32_t;
    d = (d as libc::c_uint).wrapping_add(
        (b ^ (a | !c))
            .wrapping_add(x[3 as libc::c_int as usize])
            .wrapping_add(0x8f0ccc92 as libc::c_uint),
    ) as uint32_t as uint32_t;
    d = d << 10 as libc::c_int | d >> 32 as libc::c_int - 10 as libc::c_int;
    d = (d as libc::c_uint).wrapping_add(a) as uint32_t as uint32_t;
    c = (c as libc::c_uint).wrapping_add(
        (a ^ (d | !b))
            .wrapping_add(x[10 as libc::c_int as usize])
            .wrapping_add(0xffeff47d as libc::c_uint),
    ) as uint32_t as uint32_t;
    c = c << 15 as libc::c_int | c >> 32 as libc::c_int - 15 as libc::c_int;
    c = (c as libc::c_uint).wrapping_add(d) as uint32_t as uint32_t;
    b = (b as libc::c_uint).wrapping_add(
        (d ^ (c | !a))
            .wrapping_add(x[1 as libc::c_int as usize])
            .wrapping_add(0x85845dd1 as libc::c_uint),
    ) as uint32_t as uint32_t;
    b = b << 21 as libc::c_int | b >> 32 as libc::c_int - 21 as libc::c_int;
    b = (b as libc::c_uint).wrapping_add(c) as uint32_t as uint32_t;
    a = (a as libc::c_uint).wrapping_add(
        (c ^ (b | !d))
            .wrapping_add(x[8 as libc::c_int as usize])
            .wrapping_add(0x6fa87e4f as libc::c_int as uint32_t),
    ) as uint32_t as uint32_t;
    a = a << 6 as libc::c_int | a >> 32 as libc::c_int - 6 as libc::c_int;
    a = (a as libc::c_uint).wrapping_add(b) as uint32_t as uint32_t;
    d = (d as libc::c_uint).wrapping_add(
        (b ^ (a | !c))
            .wrapping_add(x[15 as libc::c_int as usize])
            .wrapping_add(0xfe2ce6e0 as libc::c_uint),
    ) as uint32_t as uint32_t;
    d = d << 10 as libc::c_int | d >> 32 as libc::c_int - 10 as libc::c_int;
    d = (d as libc::c_uint).wrapping_add(a) as uint32_t as uint32_t;
    c = (c as libc::c_uint).wrapping_add(
        (a ^ (d | !b))
            .wrapping_add(x[6 as libc::c_int as usize])
            .wrapping_add(0xa3014314 as libc::c_uint),
    ) as uint32_t as uint32_t;
    c = c << 15 as libc::c_int | c >> 32 as libc::c_int - 15 as libc::c_int;
    c = (c as libc::c_uint).wrapping_add(d) as uint32_t as uint32_t;
    b = (b as libc::c_uint).wrapping_add(
        (d ^ (c | !a))
            .wrapping_add(x[13 as libc::c_int as usize])
            .wrapping_add(0x4e0811a1 as libc::c_int as uint32_t),
    ) as uint32_t as uint32_t;
    b = b << 21 as libc::c_int | b >> 32 as libc::c_int - 21 as libc::c_int;
    b = (b as libc::c_uint).wrapping_add(c) as uint32_t as uint32_t;
    a = (a as libc::c_uint).wrapping_add(
        (c ^ (b | !d))
            .wrapping_add(x[4 as libc::c_int as usize])
            .wrapping_add(0xf7537e82 as libc::c_uint),
    ) as uint32_t as uint32_t;
    a = a << 6 as libc::c_int | a >> 32 as libc::c_int - 6 as libc::c_int;
    a = (a as libc::c_uint).wrapping_add(b) as uint32_t as uint32_t;
    d = (d as libc::c_uint).wrapping_add(
        (b ^ (a | !c))
            .wrapping_add(x[11 as libc::c_int as usize])
            .wrapping_add(0xbd3af235 as libc::c_uint),
    ) as uint32_t as uint32_t;
    d = d << 10 as libc::c_int | d >> 32 as libc::c_int - 10 as libc::c_int;
    d = (d as libc::c_uint).wrapping_add(a) as uint32_t as uint32_t;
    c = (c as libc::c_uint).wrapping_add(
        (a ^ (d | !b))
            .wrapping_add(x[2 as libc::c_int as usize])
            .wrapping_add(0x2ad7d2bb as libc::c_int as uint32_t),
    ) as uint32_t as uint32_t;
    c = c << 15 as libc::c_int | c >> 32 as libc::c_int - 15 as libc::c_int;
    c = (c as libc::c_uint).wrapping_add(d) as uint32_t as uint32_t;
    b = (b as libc::c_uint).wrapping_add(
        (d ^ (c | !a))
            .wrapping_add(x[9 as libc::c_int as usize])
            .wrapping_add(0xeb86d391 as libc::c_uint),
    ) as uint32_t as uint32_t;
    b = b << 21 as libc::c_int | b >> 32 as libc::c_int - 21 as libc::c_int;
    b = (b as libc::c_uint).wrapping_add(c) as uint32_t as uint32_t;
    let ref mut fresh236 = *state.offset(0 as libc::c_int as isize);
    *fresh236 = (*fresh236 as libc::c_uint).wrapping_add(a) as uint32_t as uint32_t;
    let ref mut fresh237 = *state.offset(1 as libc::c_int as isize);
    *fresh237 = (*fresh237 as libc::c_uint).wrapping_add(b) as uint32_t as uint32_t;
    let ref mut fresh238 = *state.offset(2 as libc::c_int as isize);
    *fresh238 = (*fresh238 as libc::c_uint).wrapping_add(c) as uint32_t as uint32_t;
    let ref mut fresh239 = *state.offset(3 as libc::c_int as isize);
    *fresh239 = (*fresh239 as libc::c_uint).wrapping_add(d) as uint32_t as uint32_t;
    memset(
        x.as_mut_ptr() as *mut libc::c_uchar as *mut libc::c_void,
        0 as libc::c_int,
        ::core::mem::size_of::<[uint32_t; 16]>() as libc::c_ulong,
    );
}
#[no_mangle]
pub unsafe extern "C" fn MD5_Update(
    mut context: *mut MD5_CTX,
    mut _input: *const libc::c_void,
    mut inputLen: libc::c_uint,
) {
    let mut i: libc::c_uint = 0;
    let mut ndx: libc::c_uint = 0;
    let mut partLen: libc::c_uint = 0;
    let mut input: *const libc::c_uchar = _input as *const libc::c_uchar;
    ndx = (*context).count[0 as libc::c_int as usize] >> 3 as libc::c_int
        & 0x3f as libc::c_int as libc::c_uint;
    (*context).count[0 as libc::c_int as usize] =
        ((*context).count[0 as libc::c_int as usize] as libc::c_uint)
            .wrapping_add(inputLen << 3 as libc::c_int) as uint32_t as uint32_t;
    if (*context).count[0 as libc::c_int as usize] < inputLen << 3 as libc::c_int {
        (*context).count[1 as libc::c_int as usize] =
            ((*context).count[1 as libc::c_int as usize]).wrapping_add(1);
    }
    (*context).count[1 as libc::c_int as usize] =
        ((*context).count[1 as libc::c_int as usize] as libc::c_uint)
            .wrapping_add(inputLen >> 29 as libc::c_int) as uint32_t as uint32_t;
    partLen = (64 as libc::c_int as libc::c_uint).wrapping_sub(ndx);
    if inputLen >= partLen {
        memcpy(
            &mut *((*context).buffer).as_mut_ptr().offset(ndx as isize) as *mut libc::c_uchar
                as *mut libc::c_void,
            input as *mut libc::c_uchar as *const libc::c_void,
            partLen as libc::c_ulong,
        );
        li_MD5Transform(
            ((*context).state).as_mut_ptr(),
            ((*context).buffer).as_mut_ptr() as *const libc::c_uchar,
        );
        i = partLen;
        while i.wrapping_add(63 as libc::c_int as libc::c_uint) < inputLen {
            li_MD5Transform(((*context).state).as_mut_ptr(), &*input.offset(i as isize));
            i = i.wrapping_add(64 as libc::c_int as libc::c_uint);
        }
        ndx = 0 as libc::c_int as libc::c_uint;
    } else {
        i = 0 as libc::c_int as libc::c_uint;
    }
    memcpy(
        &mut *((*context).buffer).as_mut_ptr().offset(ndx as isize) as *mut libc::c_uchar
            as *mut libc::c_void,
        &*input.offset(i as isize) as *const libc::c_uchar as *mut libc::c_uchar
            as *const libc::c_void,
        inputLen.wrapping_sub(i) as libc::c_ulong,
    );
}
#[no_mangle]
pub unsafe extern "C" fn MD5_Init(mut context: *mut MD5_CTX) {
    (*context).count[1 as libc::c_int as usize] = 0 as libc::c_int as uint32_t;
    (*context).count[0 as libc::c_int as usize] = (*context).count[1 as libc::c_int as usize];
    (*context).state[0 as libc::c_int as usize] = 0x67452301 as libc::c_int as uint32_t;
    (*context).state[1 as libc::c_int as usize] = 0xefcdab89 as libc::c_uint;
    (*context).state[2 as libc::c_int as usize] = 0x98badcfe as libc::c_uint;
    (*context).state[3 as libc::c_int as usize] = 0x10325476 as libc::c_int as uint32_t;
}
unsafe extern "C" fn Encode(
    mut output: *mut libc::c_uchar,
    mut input: *mut uint32_t,
    mut len: libc::c_uint,
) {
    let mut i: libc::c_uint = 0;
    let mut j: libc::c_uint = 0;
    i = 0 as libc::c_int as libc::c_uint;
    j = 0 as libc::c_int as libc::c_uint;
    while j < len {
        *output.offset(j as isize) =
            (*input.offset(i as isize) & 0xff as libc::c_int as libc::c_uint) as libc::c_uchar;
        *output.offset(j.wrapping_add(1 as libc::c_int as libc::c_uint) as isize) =
            (*input.offset(i as isize) >> 8 as libc::c_int & 0xff as libc::c_int as libc::c_uint)
                as libc::c_uchar;
        *output.offset(j.wrapping_add(2 as libc::c_int as libc::c_uint) as isize) =
            (*input.offset(i as isize) >> 16 as libc::c_int & 0xff as libc::c_int as libc::c_uint)
                as libc::c_uchar;
        *output.offset(j.wrapping_add(3 as libc::c_int as libc::c_uint) as isize) =
            (*input.offset(i as isize) >> 24 as libc::c_int & 0xff as libc::c_int as libc::c_uint)
                as libc::c_uchar;
        i = i.wrapping_add(1);
        j = j.wrapping_add(4 as libc::c_int as libc::c_uint);
    }
}
static mut PADDING: [libc::c_uchar; 64] = [
    0x80 as libc::c_int as libc::c_uchar,
    0 as libc::c_int as libc::c_uchar,
    0 as libc::c_int as libc::c_uchar,
    0 as libc::c_int as libc::c_uchar,
    0 as libc::c_int as libc::c_uchar,
    0 as libc::c_int as libc::c_uchar,
    0 as libc::c_int as libc::c_uchar,
    0 as libc::c_int as libc::c_uchar,
    0 as libc::c_int as libc::c_uchar,
    0 as libc::c_int as libc::c_uchar,
    0 as libc::c_int as libc::c_uchar,
    0 as libc::c_int as libc::c_uchar,
    0 as libc::c_int as libc::c_uchar,
    0 as libc::c_int as libc::c_uchar,
    0 as libc::c_int as libc::c_uchar,
    0 as libc::c_int as libc::c_uchar,
    0 as libc::c_int as libc::c_uchar,
    0 as libc::c_int as libc::c_uchar,
    0 as libc::c_int as libc::c_uchar,
    0 as libc::c_int as libc::c_uchar,
    0 as libc::c_int as libc::c_uchar,
    0 as libc::c_int as libc::c_uchar,
    0 as libc::c_int as libc::c_uchar,
    0 as libc::c_int as libc::c_uchar,
    0 as libc::c_int as libc::c_uchar,
    0 as libc::c_int as libc::c_uchar,
    0 as libc::c_int as libc::c_uchar,
    0 as libc::c_int as libc::c_uchar,
    0 as libc::c_int as libc::c_uchar,
    0 as libc::c_int as libc::c_uchar,
    0 as libc::c_int as libc::c_uchar,
    0 as libc::c_int as libc::c_uchar,
    0 as libc::c_int as libc::c_uchar,
    0 as libc::c_int as libc::c_uchar,
    0 as libc::c_int as libc::c_uchar,
    0 as libc::c_int as libc::c_uchar,
    0 as libc::c_int as libc::c_uchar,
    0 as libc::c_int as libc::c_uchar,
    0 as libc::c_int as libc::c_uchar,
    0 as libc::c_int as libc::c_uchar,
    0 as libc::c_int as libc::c_uchar,
    0 as libc::c_int as libc::c_uchar,
    0 as libc::c_int as libc::c_uchar,
    0 as libc::c_int as libc::c_uchar,
    0 as libc::c_int as libc::c_uchar,
    0 as libc::c_int as libc::c_uchar,
    0 as libc::c_int as libc::c_uchar,
    0 as libc::c_int as libc::c_uchar,
    0 as libc::c_int as libc::c_uchar,
    0 as libc::c_int as libc::c_uchar,
    0 as libc::c_int as libc::c_uchar,
    0 as libc::c_int as libc::c_uchar,
    0 as libc::c_int as libc::c_uchar,
    0 as libc::c_int as libc::c_uchar,
    0 as libc::c_int as libc::c_uchar,
    0 as libc::c_int as libc::c_uchar,
    0 as libc::c_int as libc::c_uchar,
    0 as libc::c_int as libc::c_uchar,
    0 as libc::c_int as libc::c_uchar,
    0 as libc::c_int as libc::c_uchar,
    0 as libc::c_int as libc::c_uchar,
    0 as libc::c_int as libc::c_uchar,
    0 as libc::c_int as libc::c_uchar,
    0 as libc::c_int as libc::c_uchar,
];
unsafe extern "C" fn SHA1_Transform(mut state: *mut sha1_quadbyte, mut buffer: *const sha1_byte) {
    let mut a: sha1_quadbyte = 0;
    let mut b: sha1_quadbyte = 0;
    let mut c: sha1_quadbyte = 0;
    let mut d: sha1_quadbyte = 0;
    let mut e: sha1_quadbyte = 0;
    let mut src: BYTE64QUAD16 = _BYTE64QUAD16 { c: [0; 64] };
    let mut block: *mut BYTE64QUAD16 = 0 as *mut BYTE64QUAD16;
    memcpy(
        (src.c).as_mut_ptr() as *mut libc::c_void,
        buffer as *const libc::c_void,
        (::core::mem::size_of::<sha1_byte>() as libc::c_ulong)
            .wrapping_mul(64 as libc::c_int as libc::c_ulong),
    );
    block = &mut src;
    a = *state.offset(0 as libc::c_int as isize);
    b = *state.offset(1 as libc::c_int as isize);
    c = *state.offset(2 as libc::c_int as isize);
    d = *state.offset(3 as libc::c_int as isize);
    e = *state.offset(4 as libc::c_int as isize);
    (*block).l[0 as libc::c_int as usize] = ((*block).l[0 as libc::c_int as usize]
        << 24 as libc::c_int
        | (*block).l[0 as libc::c_int as usize] >> 32 as libc::c_int - 24 as libc::c_int)
        & 0xff00ff00 as libc::c_uint
        | ((*block).l[0 as libc::c_int as usize] << 8 as libc::c_int
            | (*block).l[0 as libc::c_int as usize] >> 32 as libc::c_int - 8 as libc::c_int)
            & 0xff00ff as libc::c_int as sha1_quadbyte;
    e = (e as libc::c_uint).wrapping_add(
        (b & (c ^ d) ^ d)
            .wrapping_add((*block).l[0 as libc::c_int as usize])
            .wrapping_add(0x5a827999 as libc::c_int as libc::c_uint)
            .wrapping_add(a << 5 as libc::c_int | a >> 32 as libc::c_int - 5 as libc::c_int),
    ) as sha1_quadbyte as sha1_quadbyte;
    b = b << 30 as libc::c_int | b >> 32 as libc::c_int - 30 as libc::c_int;
    (*block).l[1 as libc::c_int as usize] = ((*block).l[1 as libc::c_int as usize]
        << 24 as libc::c_int
        | (*block).l[1 as libc::c_int as usize] >> 32 as libc::c_int - 24 as libc::c_int)
        & 0xff00ff00 as libc::c_uint
        | ((*block).l[1 as libc::c_int as usize] << 8 as libc::c_int
            | (*block).l[1 as libc::c_int as usize] >> 32 as libc::c_int - 8 as libc::c_int)
            & 0xff00ff as libc::c_int as sha1_quadbyte;
    d = (d as libc::c_uint).wrapping_add(
        (a & (b ^ c) ^ c)
            .wrapping_add((*block).l[1 as libc::c_int as usize])
            .wrapping_add(0x5a827999 as libc::c_int as libc::c_uint)
            .wrapping_add(e << 5 as libc::c_int | e >> 32 as libc::c_int - 5 as libc::c_int),
    ) as sha1_quadbyte as sha1_quadbyte;
    a = a << 30 as libc::c_int | a >> 32 as libc::c_int - 30 as libc::c_int;
    (*block).l[2 as libc::c_int as usize] = ((*block).l[2 as libc::c_int as usize]
        << 24 as libc::c_int
        | (*block).l[2 as libc::c_int as usize] >> 32 as libc::c_int - 24 as libc::c_int)
        & 0xff00ff00 as libc::c_uint
        | ((*block).l[2 as libc::c_int as usize] << 8 as libc::c_int
            | (*block).l[2 as libc::c_int as usize] >> 32 as libc::c_int - 8 as libc::c_int)
            & 0xff00ff as libc::c_int as sha1_quadbyte;
    c = (c as libc::c_uint).wrapping_add(
        (e & (a ^ b) ^ b)
            .wrapping_add((*block).l[2 as libc::c_int as usize])
            .wrapping_add(0x5a827999 as libc::c_int as libc::c_uint)
            .wrapping_add(d << 5 as libc::c_int | d >> 32 as libc::c_int - 5 as libc::c_int),
    ) as sha1_quadbyte as sha1_quadbyte;
    e = e << 30 as libc::c_int | e >> 32 as libc::c_int - 30 as libc::c_int;
    (*block).l[3 as libc::c_int as usize] = ((*block).l[3 as libc::c_int as usize]
        << 24 as libc::c_int
        | (*block).l[3 as libc::c_int as usize] >> 32 as libc::c_int - 24 as libc::c_int)
        & 0xff00ff00 as libc::c_uint
        | ((*block).l[3 as libc::c_int as usize] << 8 as libc::c_int
            | (*block).l[3 as libc::c_int as usize] >> 32 as libc::c_int - 8 as libc::c_int)
            & 0xff00ff as libc::c_int as sha1_quadbyte;
    b = (b as libc::c_uint).wrapping_add(
        (d & (e ^ a) ^ a)
            .wrapping_add((*block).l[3 as libc::c_int as usize])
            .wrapping_add(0x5a827999 as libc::c_int as libc::c_uint)
            .wrapping_add(c << 5 as libc::c_int | c >> 32 as libc::c_int - 5 as libc::c_int),
    ) as sha1_quadbyte as sha1_quadbyte;
    d = d << 30 as libc::c_int | d >> 32 as libc::c_int - 30 as libc::c_int;
    (*block).l[4 as libc::c_int as usize] = ((*block).l[4 as libc::c_int as usize]
        << 24 as libc::c_int
        | (*block).l[4 as libc::c_int as usize] >> 32 as libc::c_int - 24 as libc::c_int)
        & 0xff00ff00 as libc::c_uint
        | ((*block).l[4 as libc::c_int as usize] << 8 as libc::c_int
            | (*block).l[4 as libc::c_int as usize] >> 32 as libc::c_int - 8 as libc::c_int)
            & 0xff00ff as libc::c_int as sha1_quadbyte;
    a = (a as libc::c_uint).wrapping_add(
        (c & (d ^ e) ^ e)
            .wrapping_add((*block).l[4 as libc::c_int as usize])
            .wrapping_add(0x5a827999 as libc::c_int as libc::c_uint)
            .wrapping_add(b << 5 as libc::c_int | b >> 32 as libc::c_int - 5 as libc::c_int),
    ) as sha1_quadbyte as sha1_quadbyte;
    c = c << 30 as libc::c_int | c >> 32 as libc::c_int - 30 as libc::c_int;
    (*block).l[5 as libc::c_int as usize] = ((*block).l[5 as libc::c_int as usize]
        << 24 as libc::c_int
        | (*block).l[5 as libc::c_int as usize] >> 32 as libc::c_int - 24 as libc::c_int)
        & 0xff00ff00 as libc::c_uint
        | ((*block).l[5 as libc::c_int as usize] << 8 as libc::c_int
            | (*block).l[5 as libc::c_int as usize] >> 32 as libc::c_int - 8 as libc::c_int)
            & 0xff00ff as libc::c_int as sha1_quadbyte;
    e = (e as libc::c_uint).wrapping_add(
        (b & (c ^ d) ^ d)
            .wrapping_add((*block).l[5 as libc::c_int as usize])
            .wrapping_add(0x5a827999 as libc::c_int as libc::c_uint)
            .wrapping_add(a << 5 as libc::c_int | a >> 32 as libc::c_int - 5 as libc::c_int),
    ) as sha1_quadbyte as sha1_quadbyte;
    b = b << 30 as libc::c_int | b >> 32 as libc::c_int - 30 as libc::c_int;
    (*block).l[6 as libc::c_int as usize] = ((*block).l[6 as libc::c_int as usize]
        << 24 as libc::c_int
        | (*block).l[6 as libc::c_int as usize] >> 32 as libc::c_int - 24 as libc::c_int)
        & 0xff00ff00 as libc::c_uint
        | ((*block).l[6 as libc::c_int as usize] << 8 as libc::c_int
            | (*block).l[6 as libc::c_int as usize] >> 32 as libc::c_int - 8 as libc::c_int)
            & 0xff00ff as libc::c_int as sha1_quadbyte;
    d = (d as libc::c_uint).wrapping_add(
        (a & (b ^ c) ^ c)
            .wrapping_add((*block).l[6 as libc::c_int as usize])
            .wrapping_add(0x5a827999 as libc::c_int as libc::c_uint)
            .wrapping_add(e << 5 as libc::c_int | e >> 32 as libc::c_int - 5 as libc::c_int),
    ) as sha1_quadbyte as sha1_quadbyte;
    a = a << 30 as libc::c_int | a >> 32 as libc::c_int - 30 as libc::c_int;
    (*block).l[7 as libc::c_int as usize] = ((*block).l[7 as libc::c_int as usize]
        << 24 as libc::c_int
        | (*block).l[7 as libc::c_int as usize] >> 32 as libc::c_int - 24 as libc::c_int)
        & 0xff00ff00 as libc::c_uint
        | ((*block).l[7 as libc::c_int as usize] << 8 as libc::c_int
            | (*block).l[7 as libc::c_int as usize] >> 32 as libc::c_int - 8 as libc::c_int)
            & 0xff00ff as libc::c_int as sha1_quadbyte;
    c = (c as libc::c_uint).wrapping_add(
        (e & (a ^ b) ^ b)
            .wrapping_add((*block).l[7 as libc::c_int as usize])
            .wrapping_add(0x5a827999 as libc::c_int as libc::c_uint)
            .wrapping_add(d << 5 as libc::c_int | d >> 32 as libc::c_int - 5 as libc::c_int),
    ) as sha1_quadbyte as sha1_quadbyte;
    e = e << 30 as libc::c_int | e >> 32 as libc::c_int - 30 as libc::c_int;
    (*block).l[8 as libc::c_int as usize] = ((*block).l[8 as libc::c_int as usize]
        << 24 as libc::c_int
        | (*block).l[8 as libc::c_int as usize] >> 32 as libc::c_int - 24 as libc::c_int)
        & 0xff00ff00 as libc::c_uint
        | ((*block).l[8 as libc::c_int as usize] << 8 as libc::c_int
            | (*block).l[8 as libc::c_int as usize] >> 32 as libc::c_int - 8 as libc::c_int)
            & 0xff00ff as libc::c_int as sha1_quadbyte;
    b = (b as libc::c_uint).wrapping_add(
        (d & (e ^ a) ^ a)
            .wrapping_add((*block).l[8 as libc::c_int as usize])
            .wrapping_add(0x5a827999 as libc::c_int as libc::c_uint)
            .wrapping_add(c << 5 as libc::c_int | c >> 32 as libc::c_int - 5 as libc::c_int),
    ) as sha1_quadbyte as sha1_quadbyte;
    d = d << 30 as libc::c_int | d >> 32 as libc::c_int - 30 as libc::c_int;
    (*block).l[9 as libc::c_int as usize] = ((*block).l[9 as libc::c_int as usize]
        << 24 as libc::c_int
        | (*block).l[9 as libc::c_int as usize] >> 32 as libc::c_int - 24 as libc::c_int)
        & 0xff00ff00 as libc::c_uint
        | ((*block).l[9 as libc::c_int as usize] << 8 as libc::c_int
            | (*block).l[9 as libc::c_int as usize] >> 32 as libc::c_int - 8 as libc::c_int)
            & 0xff00ff as libc::c_int as sha1_quadbyte;
    a = (a as libc::c_uint).wrapping_add(
        (c & (d ^ e) ^ e)
            .wrapping_add((*block).l[9 as libc::c_int as usize])
            .wrapping_add(0x5a827999 as libc::c_int as libc::c_uint)
            .wrapping_add(b << 5 as libc::c_int | b >> 32 as libc::c_int - 5 as libc::c_int),
    ) as sha1_quadbyte as sha1_quadbyte;
    c = c << 30 as libc::c_int | c >> 32 as libc::c_int - 30 as libc::c_int;
    (*block).l[10 as libc::c_int as usize] = ((*block).l[10 as libc::c_int as usize]
        << 24 as libc::c_int
        | (*block).l[10 as libc::c_int as usize] >> 32 as libc::c_int - 24 as libc::c_int)
        & 0xff00ff00 as libc::c_uint
        | ((*block).l[10 as libc::c_int as usize] << 8 as libc::c_int
            | (*block).l[10 as libc::c_int as usize] >> 32 as libc::c_int - 8 as libc::c_int)
            & 0xff00ff as libc::c_int as sha1_quadbyte;
    e = (e as libc::c_uint).wrapping_add(
        (b & (c ^ d) ^ d)
            .wrapping_add((*block).l[10 as libc::c_int as usize])
            .wrapping_add(0x5a827999 as libc::c_int as libc::c_uint)
            .wrapping_add(a << 5 as libc::c_int | a >> 32 as libc::c_int - 5 as libc::c_int),
    ) as sha1_quadbyte as sha1_quadbyte;
    b = b << 30 as libc::c_int | b >> 32 as libc::c_int - 30 as libc::c_int;
    (*block).l[11 as libc::c_int as usize] = ((*block).l[11 as libc::c_int as usize]
        << 24 as libc::c_int
        | (*block).l[11 as libc::c_int as usize] >> 32 as libc::c_int - 24 as libc::c_int)
        & 0xff00ff00 as libc::c_uint
        | ((*block).l[11 as libc::c_int as usize] << 8 as libc::c_int
            | (*block).l[11 as libc::c_int as usize] >> 32 as libc::c_int - 8 as libc::c_int)
            & 0xff00ff as libc::c_int as sha1_quadbyte;
    d = (d as libc::c_uint).wrapping_add(
        (a & (b ^ c) ^ c)
            .wrapping_add((*block).l[11 as libc::c_int as usize])
            .wrapping_add(0x5a827999 as libc::c_int as libc::c_uint)
            .wrapping_add(e << 5 as libc::c_int | e >> 32 as libc::c_int - 5 as libc::c_int),
    ) as sha1_quadbyte as sha1_quadbyte;
    a = a << 30 as libc::c_int | a >> 32 as libc::c_int - 30 as libc::c_int;
    (*block).l[12 as libc::c_int as usize] = ((*block).l[12 as libc::c_int as usize]
        << 24 as libc::c_int
        | (*block).l[12 as libc::c_int as usize] >> 32 as libc::c_int - 24 as libc::c_int)
        & 0xff00ff00 as libc::c_uint
        | ((*block).l[12 as libc::c_int as usize] << 8 as libc::c_int
            | (*block).l[12 as libc::c_int as usize] >> 32 as libc::c_int - 8 as libc::c_int)
            & 0xff00ff as libc::c_int as sha1_quadbyte;
    c = (c as libc::c_uint).wrapping_add(
        (e & (a ^ b) ^ b)
            .wrapping_add((*block).l[12 as libc::c_int as usize])
            .wrapping_add(0x5a827999 as libc::c_int as libc::c_uint)
            .wrapping_add(d << 5 as libc::c_int | d >> 32 as libc::c_int - 5 as libc::c_int),
    ) as sha1_quadbyte as sha1_quadbyte;
    e = e << 30 as libc::c_int | e >> 32 as libc::c_int - 30 as libc::c_int;
    (*block).l[13 as libc::c_int as usize] = ((*block).l[13 as libc::c_int as usize]
        << 24 as libc::c_int
        | (*block).l[13 as libc::c_int as usize] >> 32 as libc::c_int - 24 as libc::c_int)
        & 0xff00ff00 as libc::c_uint
        | ((*block).l[13 as libc::c_int as usize] << 8 as libc::c_int
            | (*block).l[13 as libc::c_int as usize] >> 32 as libc::c_int - 8 as libc::c_int)
            & 0xff00ff as libc::c_int as sha1_quadbyte;
    b = (b as libc::c_uint).wrapping_add(
        (d & (e ^ a) ^ a)
            .wrapping_add((*block).l[13 as libc::c_int as usize])
            .wrapping_add(0x5a827999 as libc::c_int as libc::c_uint)
            .wrapping_add(c << 5 as libc::c_int | c >> 32 as libc::c_int - 5 as libc::c_int),
    ) as sha1_quadbyte as sha1_quadbyte;
    d = d << 30 as libc::c_int | d >> 32 as libc::c_int - 30 as libc::c_int;
    (*block).l[14 as libc::c_int as usize] = ((*block).l[14 as libc::c_int as usize]
        << 24 as libc::c_int
        | (*block).l[14 as libc::c_int as usize] >> 32 as libc::c_int - 24 as libc::c_int)
        & 0xff00ff00 as libc::c_uint
        | ((*block).l[14 as libc::c_int as usize] << 8 as libc::c_int
            | (*block).l[14 as libc::c_int as usize] >> 32 as libc::c_int - 8 as libc::c_int)
            & 0xff00ff as libc::c_int as sha1_quadbyte;
    a = (a as libc::c_uint).wrapping_add(
        (c & (d ^ e) ^ e)
            .wrapping_add((*block).l[14 as libc::c_int as usize])
            .wrapping_add(0x5a827999 as libc::c_int as libc::c_uint)
            .wrapping_add(b << 5 as libc::c_int | b >> 32 as libc::c_int - 5 as libc::c_int),
    ) as sha1_quadbyte as sha1_quadbyte;
    c = c << 30 as libc::c_int | c >> 32 as libc::c_int - 30 as libc::c_int;
    (*block).l[15 as libc::c_int as usize] = ((*block).l[15 as libc::c_int as usize]
        << 24 as libc::c_int
        | (*block).l[15 as libc::c_int as usize] >> 32 as libc::c_int - 24 as libc::c_int)
        & 0xff00ff00 as libc::c_uint
        | ((*block).l[15 as libc::c_int as usize] << 8 as libc::c_int
            | (*block).l[15 as libc::c_int as usize] >> 32 as libc::c_int - 8 as libc::c_int)
            & 0xff00ff as libc::c_int as sha1_quadbyte;
    e = (e as libc::c_uint).wrapping_add(
        (b & (c ^ d) ^ d)
            .wrapping_add((*block).l[15 as libc::c_int as usize])
            .wrapping_add(0x5a827999 as libc::c_int as libc::c_uint)
            .wrapping_add(a << 5 as libc::c_int | a >> 32 as libc::c_int - 5 as libc::c_int),
    ) as sha1_quadbyte as sha1_quadbyte;
    b = b << 30 as libc::c_int | b >> 32 as libc::c_int - 30 as libc::c_int;
    (*block).l[(16 as libc::c_int & 15 as libc::c_int) as usize] = ((*block).l
        [(16 as libc::c_int + 13 as libc::c_int & 15 as libc::c_int) as usize]
        ^ (*block).l[(16 as libc::c_int + 8 as libc::c_int & 15 as libc::c_int) as usize]
        ^ (*block).l[(16 as libc::c_int + 2 as libc::c_int & 15 as libc::c_int) as usize]
        ^ (*block).l[(16 as libc::c_int & 15 as libc::c_int) as usize])
        << 1 as libc::c_int
        | ((*block).l[(16 as libc::c_int + 13 as libc::c_int & 15 as libc::c_int) as usize]
            ^ (*block).l[(16 as libc::c_int + 8 as libc::c_int & 15 as libc::c_int) as usize]
            ^ (*block).l[(16 as libc::c_int + 2 as libc::c_int & 15 as libc::c_int) as usize]
            ^ (*block).l[(16 as libc::c_int & 15 as libc::c_int) as usize])
            >> 32 as libc::c_int - 1 as libc::c_int;
    d = (d as libc::c_uint).wrapping_add(
        (a & (b ^ c) ^ c)
            .wrapping_add((*block).l[(16 as libc::c_int & 15 as libc::c_int) as usize])
            .wrapping_add(0x5a827999 as libc::c_int as libc::c_uint)
            .wrapping_add(e << 5 as libc::c_int | e >> 32 as libc::c_int - 5 as libc::c_int),
    ) as sha1_quadbyte as sha1_quadbyte;
    a = a << 30 as libc::c_int | a >> 32 as libc::c_int - 30 as libc::c_int;
    (*block).l[(17 as libc::c_int & 15 as libc::c_int) as usize] = ((*block).l
        [(17 as libc::c_int + 13 as libc::c_int & 15 as libc::c_int) as usize]
        ^ (*block).l[(17 as libc::c_int + 8 as libc::c_int & 15 as libc::c_int) as usize]
        ^ (*block).l[(17 as libc::c_int + 2 as libc::c_int & 15 as libc::c_int) as usize]
        ^ (*block).l[(17 as libc::c_int & 15 as libc::c_int) as usize])
        << 1 as libc::c_int
        | ((*block).l[(17 as libc::c_int + 13 as libc::c_int & 15 as libc::c_int) as usize]
            ^ (*block).l[(17 as libc::c_int + 8 as libc::c_int & 15 as libc::c_int) as usize]
            ^ (*block).l[(17 as libc::c_int + 2 as libc::c_int & 15 as libc::c_int) as usize]
            ^ (*block).l[(17 as libc::c_int & 15 as libc::c_int) as usize])
            >> 32 as libc::c_int - 1 as libc::c_int;
    c = (c as libc::c_uint).wrapping_add(
        (e & (a ^ b) ^ b)
            .wrapping_add((*block).l[(17 as libc::c_int & 15 as libc::c_int) as usize])
            .wrapping_add(0x5a827999 as libc::c_int as libc::c_uint)
            .wrapping_add(d << 5 as libc::c_int | d >> 32 as libc::c_int - 5 as libc::c_int),
    ) as sha1_quadbyte as sha1_quadbyte;
    e = e << 30 as libc::c_int | e >> 32 as libc::c_int - 30 as libc::c_int;
    (*block).l[(18 as libc::c_int & 15 as libc::c_int) as usize] = ((*block).l
        [(18 as libc::c_int + 13 as libc::c_int & 15 as libc::c_int) as usize]
        ^ (*block).l[(18 as libc::c_int + 8 as libc::c_int & 15 as libc::c_int) as usize]
        ^ (*block).l[(18 as libc::c_int + 2 as libc::c_int & 15 as libc::c_int) as usize]
        ^ (*block).l[(18 as libc::c_int & 15 as libc::c_int) as usize])
        << 1 as libc::c_int
        | ((*block).l[(18 as libc::c_int + 13 as libc::c_int & 15 as libc::c_int) as usize]
            ^ (*block).l[(18 as libc::c_int + 8 as libc::c_int & 15 as libc::c_int) as usize]
            ^ (*block).l[(18 as libc::c_int + 2 as libc::c_int & 15 as libc::c_int) as usize]
            ^ (*block).l[(18 as libc::c_int & 15 as libc::c_int) as usize])
            >> 32 as libc::c_int - 1 as libc::c_int;
    b = (b as libc::c_uint).wrapping_add(
        (d & (e ^ a) ^ a)
            .wrapping_add((*block).l[(18 as libc::c_int & 15 as libc::c_int) as usize])
            .wrapping_add(0x5a827999 as libc::c_int as libc::c_uint)
            .wrapping_add(c << 5 as libc::c_int | c >> 32 as libc::c_int - 5 as libc::c_int),
    ) as sha1_quadbyte as sha1_quadbyte;
    d = d << 30 as libc::c_int | d >> 32 as libc::c_int - 30 as libc::c_int;
    (*block).l[(19 as libc::c_int & 15 as libc::c_int) as usize] = ((*block).l
        [(19 as libc::c_int + 13 as libc::c_int & 15 as libc::c_int) as usize]
        ^ (*block).l[(19 as libc::c_int + 8 as libc::c_int & 15 as libc::c_int) as usize]
        ^ (*block).l[(19 as libc::c_int + 2 as libc::c_int & 15 as libc::c_int) as usize]
        ^ (*block).l[(19 as libc::c_int & 15 as libc::c_int) as usize])
        << 1 as libc::c_int
        | ((*block).l[(19 as libc::c_int + 13 as libc::c_int & 15 as libc::c_int) as usize]
            ^ (*block).l[(19 as libc::c_int + 8 as libc::c_int & 15 as libc::c_int) as usize]
            ^ (*block).l[(19 as libc::c_int + 2 as libc::c_int & 15 as libc::c_int) as usize]
            ^ (*block).l[(19 as libc::c_int & 15 as libc::c_int) as usize])
            >> 32 as libc::c_int - 1 as libc::c_int;
    a = (a as libc::c_uint).wrapping_add(
        (c & (d ^ e) ^ e)
            .wrapping_add((*block).l[(19 as libc::c_int & 15 as libc::c_int) as usize])
            .wrapping_add(0x5a827999 as libc::c_int as libc::c_uint)
            .wrapping_add(b << 5 as libc::c_int | b >> 32 as libc::c_int - 5 as libc::c_int),
    ) as sha1_quadbyte as sha1_quadbyte;
    c = c << 30 as libc::c_int | c >> 32 as libc::c_int - 30 as libc::c_int;
    (*block).l[(20 as libc::c_int & 15 as libc::c_int) as usize] = ((*block).l
        [(20 as libc::c_int + 13 as libc::c_int & 15 as libc::c_int) as usize]
        ^ (*block).l[(20 as libc::c_int + 8 as libc::c_int & 15 as libc::c_int) as usize]
        ^ (*block).l[(20 as libc::c_int + 2 as libc::c_int & 15 as libc::c_int) as usize]
        ^ (*block).l[(20 as libc::c_int & 15 as libc::c_int) as usize])
        << 1 as libc::c_int
        | ((*block).l[(20 as libc::c_int + 13 as libc::c_int & 15 as libc::c_int) as usize]
            ^ (*block).l[(20 as libc::c_int + 8 as libc::c_int & 15 as libc::c_int) as usize]
            ^ (*block).l[(20 as libc::c_int + 2 as libc::c_int & 15 as libc::c_int) as usize]
            ^ (*block).l[(20 as libc::c_int & 15 as libc::c_int) as usize])
            >> 32 as libc::c_int - 1 as libc::c_int;
    e = (e as libc::c_uint).wrapping_add(
        (b ^ c ^ d)
            .wrapping_add((*block).l[(20 as libc::c_int & 15 as libc::c_int) as usize])
            .wrapping_add(0x6ed9eba1 as libc::c_int as libc::c_uint)
            .wrapping_add(a << 5 as libc::c_int | a >> 32 as libc::c_int - 5 as libc::c_int),
    ) as sha1_quadbyte as sha1_quadbyte;
    b = b << 30 as libc::c_int | b >> 32 as libc::c_int - 30 as libc::c_int;
    (*block).l[(21 as libc::c_int & 15 as libc::c_int) as usize] = ((*block).l
        [(21 as libc::c_int + 13 as libc::c_int & 15 as libc::c_int) as usize]
        ^ (*block).l[(21 as libc::c_int + 8 as libc::c_int & 15 as libc::c_int) as usize]
        ^ (*block).l[(21 as libc::c_int + 2 as libc::c_int & 15 as libc::c_int) as usize]
        ^ (*block).l[(21 as libc::c_int & 15 as libc::c_int) as usize])
        << 1 as libc::c_int
        | ((*block).l[(21 as libc::c_int + 13 as libc::c_int & 15 as libc::c_int) as usize]
            ^ (*block).l[(21 as libc::c_int + 8 as libc::c_int & 15 as libc::c_int) as usize]
            ^ (*block).l[(21 as libc::c_int + 2 as libc::c_int & 15 as libc::c_int) as usize]
            ^ (*block).l[(21 as libc::c_int & 15 as libc::c_int) as usize])
            >> 32 as libc::c_int - 1 as libc::c_int;
    d = (d as libc::c_uint).wrapping_add(
        (a ^ b ^ c)
            .wrapping_add((*block).l[(21 as libc::c_int & 15 as libc::c_int) as usize])
            .wrapping_add(0x6ed9eba1 as libc::c_int as libc::c_uint)
            .wrapping_add(e << 5 as libc::c_int | e >> 32 as libc::c_int - 5 as libc::c_int),
    ) as sha1_quadbyte as sha1_quadbyte;
    a = a << 30 as libc::c_int | a >> 32 as libc::c_int - 30 as libc::c_int;
    (*block).l[(22 as libc::c_int & 15 as libc::c_int) as usize] = ((*block).l
        [(22 as libc::c_int + 13 as libc::c_int & 15 as libc::c_int) as usize]
        ^ (*block).l[(22 as libc::c_int + 8 as libc::c_int & 15 as libc::c_int) as usize]
        ^ (*block).l[(22 as libc::c_int + 2 as libc::c_int & 15 as libc::c_int) as usize]
        ^ (*block).l[(22 as libc::c_int & 15 as libc::c_int) as usize])
        << 1 as libc::c_int
        | ((*block).l[(22 as libc::c_int + 13 as libc::c_int & 15 as libc::c_int) as usize]
            ^ (*block).l[(22 as libc::c_int + 8 as libc::c_int & 15 as libc::c_int) as usize]
            ^ (*block).l[(22 as libc::c_int + 2 as libc::c_int & 15 as libc::c_int) as usize]
            ^ (*block).l[(22 as libc::c_int & 15 as libc::c_int) as usize])
            >> 32 as libc::c_int - 1 as libc::c_int;
    c = (c as libc::c_uint).wrapping_add(
        (e ^ a ^ b)
            .wrapping_add((*block).l[(22 as libc::c_int & 15 as libc::c_int) as usize])
            .wrapping_add(0x6ed9eba1 as libc::c_int as libc::c_uint)
            .wrapping_add(d << 5 as libc::c_int | d >> 32 as libc::c_int - 5 as libc::c_int),
    ) as sha1_quadbyte as sha1_quadbyte;
    e = e << 30 as libc::c_int | e >> 32 as libc::c_int - 30 as libc::c_int;
    (*block).l[(23 as libc::c_int & 15 as libc::c_int) as usize] = ((*block).l
        [(23 as libc::c_int + 13 as libc::c_int & 15 as libc::c_int) as usize]
        ^ (*block).l[(23 as libc::c_int + 8 as libc::c_int & 15 as libc::c_int) as usize]
        ^ (*block).l[(23 as libc::c_int + 2 as libc::c_int & 15 as libc::c_int) as usize]
        ^ (*block).l[(23 as libc::c_int & 15 as libc::c_int) as usize])
        << 1 as libc::c_int
        | ((*block).l[(23 as libc::c_int + 13 as libc::c_int & 15 as libc::c_int) as usize]
            ^ (*block).l[(23 as libc::c_int + 8 as libc::c_int & 15 as libc::c_int) as usize]
            ^ (*block).l[(23 as libc::c_int + 2 as libc::c_int & 15 as libc::c_int) as usize]
            ^ (*block).l[(23 as libc::c_int & 15 as libc::c_int) as usize])
            >> 32 as libc::c_int - 1 as libc::c_int;
    b = (b as libc::c_uint).wrapping_add(
        (d ^ e ^ a)
            .wrapping_add((*block).l[(23 as libc::c_int & 15 as libc::c_int) as usize])
            .wrapping_add(0x6ed9eba1 as libc::c_int as libc::c_uint)
            .wrapping_add(c << 5 as libc::c_int | c >> 32 as libc::c_int - 5 as libc::c_int),
    ) as sha1_quadbyte as sha1_quadbyte;
    d = d << 30 as libc::c_int | d >> 32 as libc::c_int - 30 as libc::c_int;
    (*block).l[(24 as libc::c_int & 15 as libc::c_int) as usize] = ((*block).l
        [(24 as libc::c_int + 13 as libc::c_int & 15 as libc::c_int) as usize]
        ^ (*block).l[(24 as libc::c_int + 8 as libc::c_int & 15 as libc::c_int) as usize]
        ^ (*block).l[(24 as libc::c_int + 2 as libc::c_int & 15 as libc::c_int) as usize]
        ^ (*block).l[(24 as libc::c_int & 15 as libc::c_int) as usize])
        << 1 as libc::c_int
        | ((*block).l[(24 as libc::c_int + 13 as libc::c_int & 15 as libc::c_int) as usize]
            ^ (*block).l[(24 as libc::c_int + 8 as libc::c_int & 15 as libc::c_int) as usize]
            ^ (*block).l[(24 as libc::c_int + 2 as libc::c_int & 15 as libc::c_int) as usize]
            ^ (*block).l[(24 as libc::c_int & 15 as libc::c_int) as usize])
            >> 32 as libc::c_int - 1 as libc::c_int;
    a = (a as libc::c_uint).wrapping_add(
        (c ^ d ^ e)
            .wrapping_add((*block).l[(24 as libc::c_int & 15 as libc::c_int) as usize])
            .wrapping_add(0x6ed9eba1 as libc::c_int as libc::c_uint)
            .wrapping_add(b << 5 as libc::c_int | b >> 32 as libc::c_int - 5 as libc::c_int),
    ) as sha1_quadbyte as sha1_quadbyte;
    c = c << 30 as libc::c_int | c >> 32 as libc::c_int - 30 as libc::c_int;
    (*block).l[(25 as libc::c_int & 15 as libc::c_int) as usize] = ((*block).l
        [(25 as libc::c_int + 13 as libc::c_int & 15 as libc::c_int) as usize]
        ^ (*block).l[(25 as libc::c_int + 8 as libc::c_int & 15 as libc::c_int) as usize]
        ^ (*block).l[(25 as libc::c_int + 2 as libc::c_int & 15 as libc::c_int) as usize]
        ^ (*block).l[(25 as libc::c_int & 15 as libc::c_int) as usize])
        << 1 as libc::c_int
        | ((*block).l[(25 as libc::c_int + 13 as libc::c_int & 15 as libc::c_int) as usize]
            ^ (*block).l[(25 as libc::c_int + 8 as libc::c_int & 15 as libc::c_int) as usize]
            ^ (*block).l[(25 as libc::c_int + 2 as libc::c_int & 15 as libc::c_int) as usize]
            ^ (*block).l[(25 as libc::c_int & 15 as libc::c_int) as usize])
            >> 32 as libc::c_int - 1 as libc::c_int;
    e = (e as libc::c_uint).wrapping_add(
        (b ^ c ^ d)
            .wrapping_add((*block).l[(25 as libc::c_int & 15 as libc::c_int) as usize])
            .wrapping_add(0x6ed9eba1 as libc::c_int as libc::c_uint)
            .wrapping_add(a << 5 as libc::c_int | a >> 32 as libc::c_int - 5 as libc::c_int),
    ) as sha1_quadbyte as sha1_quadbyte;
    b = b << 30 as libc::c_int | b >> 32 as libc::c_int - 30 as libc::c_int;
    (*block).l[(26 as libc::c_int & 15 as libc::c_int) as usize] = ((*block).l
        [(26 as libc::c_int + 13 as libc::c_int & 15 as libc::c_int) as usize]
        ^ (*block).l[(26 as libc::c_int + 8 as libc::c_int & 15 as libc::c_int) as usize]
        ^ (*block).l[(26 as libc::c_int + 2 as libc::c_int & 15 as libc::c_int) as usize]
        ^ (*block).l[(26 as libc::c_int & 15 as libc::c_int) as usize])
        << 1 as libc::c_int
        | ((*block).l[(26 as libc::c_int + 13 as libc::c_int & 15 as libc::c_int) as usize]
            ^ (*block).l[(26 as libc::c_int + 8 as libc::c_int & 15 as libc::c_int) as usize]
            ^ (*block).l[(26 as libc::c_int + 2 as libc::c_int & 15 as libc::c_int) as usize]
            ^ (*block).l[(26 as libc::c_int & 15 as libc::c_int) as usize])
            >> 32 as libc::c_int - 1 as libc::c_int;
    d = (d as libc::c_uint).wrapping_add(
        (a ^ b ^ c)
            .wrapping_add((*block).l[(26 as libc::c_int & 15 as libc::c_int) as usize])
            .wrapping_add(0x6ed9eba1 as libc::c_int as libc::c_uint)
            .wrapping_add(e << 5 as libc::c_int | e >> 32 as libc::c_int - 5 as libc::c_int),
    ) as sha1_quadbyte as sha1_quadbyte;
    a = a << 30 as libc::c_int | a >> 32 as libc::c_int - 30 as libc::c_int;
    (*block).l[(27 as libc::c_int & 15 as libc::c_int) as usize] = ((*block).l
        [(27 as libc::c_int + 13 as libc::c_int & 15 as libc::c_int) as usize]
        ^ (*block).l[(27 as libc::c_int + 8 as libc::c_int & 15 as libc::c_int) as usize]
        ^ (*block).l[(27 as libc::c_int + 2 as libc::c_int & 15 as libc::c_int) as usize]
        ^ (*block).l[(27 as libc::c_int & 15 as libc::c_int) as usize])
        << 1 as libc::c_int
        | ((*block).l[(27 as libc::c_int + 13 as libc::c_int & 15 as libc::c_int) as usize]
            ^ (*block).l[(27 as libc::c_int + 8 as libc::c_int & 15 as libc::c_int) as usize]
            ^ (*block).l[(27 as libc::c_int + 2 as libc::c_int & 15 as libc::c_int) as usize]
            ^ (*block).l[(27 as libc::c_int & 15 as libc::c_int) as usize])
            >> 32 as libc::c_int - 1 as libc::c_int;
    c = (c as libc::c_uint).wrapping_add(
        (e ^ a ^ b)
            .wrapping_add((*block).l[(27 as libc::c_int & 15 as libc::c_int) as usize])
            .wrapping_add(0x6ed9eba1 as libc::c_int as libc::c_uint)
            .wrapping_add(d << 5 as libc::c_int | d >> 32 as libc::c_int - 5 as libc::c_int),
    ) as sha1_quadbyte as sha1_quadbyte;
    e = e << 30 as libc::c_int | e >> 32 as libc::c_int - 30 as libc::c_int;
    (*block).l[(28 as libc::c_int & 15 as libc::c_int) as usize] = ((*block).l
        [(28 as libc::c_int + 13 as libc::c_int & 15 as libc::c_int) as usize]
        ^ (*block).l[(28 as libc::c_int + 8 as libc::c_int & 15 as libc::c_int) as usize]
        ^ (*block).l[(28 as libc::c_int + 2 as libc::c_int & 15 as libc::c_int) as usize]
        ^ (*block).l[(28 as libc::c_int & 15 as libc::c_int) as usize])
        << 1 as libc::c_int
        | ((*block).l[(28 as libc::c_int + 13 as libc::c_int & 15 as libc::c_int) as usize]
            ^ (*block).l[(28 as libc::c_int + 8 as libc::c_int & 15 as libc::c_int) as usize]
            ^ (*block).l[(28 as libc::c_int + 2 as libc::c_int & 15 as libc::c_int) as usize]
            ^ (*block).l[(28 as libc::c_int & 15 as libc::c_int) as usize])
            >> 32 as libc::c_int - 1 as libc::c_int;
    b = (b as libc::c_uint).wrapping_add(
        (d ^ e ^ a)
            .wrapping_add((*block).l[(28 as libc::c_int & 15 as libc::c_int) as usize])
            .wrapping_add(0x6ed9eba1 as libc::c_int as libc::c_uint)
            .wrapping_add(c << 5 as libc::c_int | c >> 32 as libc::c_int - 5 as libc::c_int),
    ) as sha1_quadbyte as sha1_quadbyte;
    d = d << 30 as libc::c_int | d >> 32 as libc::c_int - 30 as libc::c_int;
    (*block).l[(29 as libc::c_int & 15 as libc::c_int) as usize] = ((*block).l
        [(29 as libc::c_int + 13 as libc::c_int & 15 as libc::c_int) as usize]
        ^ (*block).l[(29 as libc::c_int + 8 as libc::c_int & 15 as libc::c_int) as usize]
        ^ (*block).l[(29 as libc::c_int + 2 as libc::c_int & 15 as libc::c_int) as usize]
        ^ (*block).l[(29 as libc::c_int & 15 as libc::c_int) as usize])
        << 1 as libc::c_int
        | ((*block).l[(29 as libc::c_int + 13 as libc::c_int & 15 as libc::c_int) as usize]
            ^ (*block).l[(29 as libc::c_int + 8 as libc::c_int & 15 as libc::c_int) as usize]
            ^ (*block).l[(29 as libc::c_int + 2 as libc::c_int & 15 as libc::c_int) as usize]
            ^ (*block).l[(29 as libc::c_int & 15 as libc::c_int) as usize])
            >> 32 as libc::c_int - 1 as libc::c_int;
    a = (a as libc::c_uint).wrapping_add(
        (c ^ d ^ e)
            .wrapping_add((*block).l[(29 as libc::c_int & 15 as libc::c_int) as usize])
            .wrapping_add(0x6ed9eba1 as libc::c_int as libc::c_uint)
            .wrapping_add(b << 5 as libc::c_int | b >> 32 as libc::c_int - 5 as libc::c_int),
    ) as sha1_quadbyte as sha1_quadbyte;
    c = c << 30 as libc::c_int | c >> 32 as libc::c_int - 30 as libc::c_int;
    (*block).l[(30 as libc::c_int & 15 as libc::c_int) as usize] = ((*block).l
        [(30 as libc::c_int + 13 as libc::c_int & 15 as libc::c_int) as usize]
        ^ (*block).l[(30 as libc::c_int + 8 as libc::c_int & 15 as libc::c_int) as usize]
        ^ (*block).l[(30 as libc::c_int + 2 as libc::c_int & 15 as libc::c_int) as usize]
        ^ (*block).l[(30 as libc::c_int & 15 as libc::c_int) as usize])
        << 1 as libc::c_int
        | ((*block).l[(30 as libc::c_int + 13 as libc::c_int & 15 as libc::c_int) as usize]
            ^ (*block).l[(30 as libc::c_int + 8 as libc::c_int & 15 as libc::c_int) as usize]
            ^ (*block).l[(30 as libc::c_int + 2 as libc::c_int & 15 as libc::c_int) as usize]
            ^ (*block).l[(30 as libc::c_int & 15 as libc::c_int) as usize])
            >> 32 as libc::c_int - 1 as libc::c_int;
    e = (e as libc::c_uint).wrapping_add(
        (b ^ c ^ d)
            .wrapping_add((*block).l[(30 as libc::c_int & 15 as libc::c_int) as usize])
            .wrapping_add(0x6ed9eba1 as libc::c_int as libc::c_uint)
            .wrapping_add(a << 5 as libc::c_int | a >> 32 as libc::c_int - 5 as libc::c_int),
    ) as sha1_quadbyte as sha1_quadbyte;
    b = b << 30 as libc::c_int | b >> 32 as libc::c_int - 30 as libc::c_int;
    (*block).l[(31 as libc::c_int & 15 as libc::c_int) as usize] = ((*block).l
        [(31 as libc::c_int + 13 as libc::c_int & 15 as libc::c_int) as usize]
        ^ (*block).l[(31 as libc::c_int + 8 as libc::c_int & 15 as libc::c_int) as usize]
        ^ (*block).l[(31 as libc::c_int + 2 as libc::c_int & 15 as libc::c_int) as usize]
        ^ (*block).l[(31 as libc::c_int & 15 as libc::c_int) as usize])
        << 1 as libc::c_int
        | ((*block).l[(31 as libc::c_int + 13 as libc::c_int & 15 as libc::c_int) as usize]
            ^ (*block).l[(31 as libc::c_int + 8 as libc::c_int & 15 as libc::c_int) as usize]
            ^ (*block).l[(31 as libc::c_int + 2 as libc::c_int & 15 as libc::c_int) as usize]
            ^ (*block).l[(31 as libc::c_int & 15 as libc::c_int) as usize])
            >> 32 as libc::c_int - 1 as libc::c_int;
    d = (d as libc::c_uint).wrapping_add(
        (a ^ b ^ c)
            .wrapping_add((*block).l[(31 as libc::c_int & 15 as libc::c_int) as usize])
            .wrapping_add(0x6ed9eba1 as libc::c_int as libc::c_uint)
            .wrapping_add(e << 5 as libc::c_int | e >> 32 as libc::c_int - 5 as libc::c_int),
    ) as sha1_quadbyte as sha1_quadbyte;
    a = a << 30 as libc::c_int | a >> 32 as libc::c_int - 30 as libc::c_int;
    (*block).l[(32 as libc::c_int & 15 as libc::c_int) as usize] = ((*block).l
        [(32 as libc::c_int + 13 as libc::c_int & 15 as libc::c_int) as usize]
        ^ (*block).l[(32 as libc::c_int + 8 as libc::c_int & 15 as libc::c_int) as usize]
        ^ (*block).l[(32 as libc::c_int + 2 as libc::c_int & 15 as libc::c_int) as usize]
        ^ (*block).l[(32 as libc::c_int & 15 as libc::c_int) as usize])
        << 1 as libc::c_int
        | ((*block).l[(32 as libc::c_int + 13 as libc::c_int & 15 as libc::c_int) as usize]
            ^ (*block).l[(32 as libc::c_int + 8 as libc::c_int & 15 as libc::c_int) as usize]
            ^ (*block).l[(32 as libc::c_int + 2 as libc::c_int & 15 as libc::c_int) as usize]
            ^ (*block).l[(32 as libc::c_int & 15 as libc::c_int) as usize])
            >> 32 as libc::c_int - 1 as libc::c_int;
    c = (c as libc::c_uint).wrapping_add(
        (e ^ a ^ b)
            .wrapping_add((*block).l[(32 as libc::c_int & 15 as libc::c_int) as usize])
            .wrapping_add(0x6ed9eba1 as libc::c_int as libc::c_uint)
            .wrapping_add(d << 5 as libc::c_int | d >> 32 as libc::c_int - 5 as libc::c_int),
    ) as sha1_quadbyte as sha1_quadbyte;
    e = e << 30 as libc::c_int | e >> 32 as libc::c_int - 30 as libc::c_int;
    (*block).l[(33 as libc::c_int & 15 as libc::c_int) as usize] = ((*block).l
        [(33 as libc::c_int + 13 as libc::c_int & 15 as libc::c_int) as usize]
        ^ (*block).l[(33 as libc::c_int + 8 as libc::c_int & 15 as libc::c_int) as usize]
        ^ (*block).l[(33 as libc::c_int + 2 as libc::c_int & 15 as libc::c_int) as usize]
        ^ (*block).l[(33 as libc::c_int & 15 as libc::c_int) as usize])
        << 1 as libc::c_int
        | ((*block).l[(33 as libc::c_int + 13 as libc::c_int & 15 as libc::c_int) as usize]
            ^ (*block).l[(33 as libc::c_int + 8 as libc::c_int & 15 as libc::c_int) as usize]
            ^ (*block).l[(33 as libc::c_int + 2 as libc::c_int & 15 as libc::c_int) as usize]
            ^ (*block).l[(33 as libc::c_int & 15 as libc::c_int) as usize])
            >> 32 as libc::c_int - 1 as libc::c_int;
    b = (b as libc::c_uint).wrapping_add(
        (d ^ e ^ a)
            .wrapping_add((*block).l[(33 as libc::c_int & 15 as libc::c_int) as usize])
            .wrapping_add(0x6ed9eba1 as libc::c_int as libc::c_uint)
            .wrapping_add(c << 5 as libc::c_int | c >> 32 as libc::c_int - 5 as libc::c_int),
    ) as sha1_quadbyte as sha1_quadbyte;
    d = d << 30 as libc::c_int | d >> 32 as libc::c_int - 30 as libc::c_int;
    (*block).l[(34 as libc::c_int & 15 as libc::c_int) as usize] = ((*block).l
        [(34 as libc::c_int + 13 as libc::c_int & 15 as libc::c_int) as usize]
        ^ (*block).l[(34 as libc::c_int + 8 as libc::c_int & 15 as libc::c_int) as usize]
        ^ (*block).l[(34 as libc::c_int + 2 as libc::c_int & 15 as libc::c_int) as usize]
        ^ (*block).l[(34 as libc::c_int & 15 as libc::c_int) as usize])
        << 1 as libc::c_int
        | ((*block).l[(34 as libc::c_int + 13 as libc::c_int & 15 as libc::c_int) as usize]
            ^ (*block).l[(34 as libc::c_int + 8 as libc::c_int & 15 as libc::c_int) as usize]
            ^ (*block).l[(34 as libc::c_int + 2 as libc::c_int & 15 as libc::c_int) as usize]
            ^ (*block).l[(34 as libc::c_int & 15 as libc::c_int) as usize])
            >> 32 as libc::c_int - 1 as libc::c_int;
    a = (a as libc::c_uint).wrapping_add(
        (c ^ d ^ e)
            .wrapping_add((*block).l[(34 as libc::c_int & 15 as libc::c_int) as usize])
            .wrapping_add(0x6ed9eba1 as libc::c_int as libc::c_uint)
            .wrapping_add(b << 5 as libc::c_int | b >> 32 as libc::c_int - 5 as libc::c_int),
    ) as sha1_quadbyte as sha1_quadbyte;
    c = c << 30 as libc::c_int | c >> 32 as libc::c_int - 30 as libc::c_int;
    (*block).l[(35 as libc::c_int & 15 as libc::c_int) as usize] = ((*block).l
        [(35 as libc::c_int + 13 as libc::c_int & 15 as libc::c_int) as usize]
        ^ (*block).l[(35 as libc::c_int + 8 as libc::c_int & 15 as libc::c_int) as usize]
        ^ (*block).l[(35 as libc::c_int + 2 as libc::c_int & 15 as libc::c_int) as usize]
        ^ (*block).l[(35 as libc::c_int & 15 as libc::c_int) as usize])
        << 1 as libc::c_int
        | ((*block).l[(35 as libc::c_int + 13 as libc::c_int & 15 as libc::c_int) as usize]
            ^ (*block).l[(35 as libc::c_int + 8 as libc::c_int & 15 as libc::c_int) as usize]
            ^ (*block).l[(35 as libc::c_int + 2 as libc::c_int & 15 as libc::c_int) as usize]
            ^ (*block).l[(35 as libc::c_int & 15 as libc::c_int) as usize])
            >> 32 as libc::c_int - 1 as libc::c_int;
    e = (e as libc::c_uint).wrapping_add(
        (b ^ c ^ d)
            .wrapping_add((*block).l[(35 as libc::c_int & 15 as libc::c_int) as usize])
            .wrapping_add(0x6ed9eba1 as libc::c_int as libc::c_uint)
            .wrapping_add(a << 5 as libc::c_int | a >> 32 as libc::c_int - 5 as libc::c_int),
    ) as sha1_quadbyte as sha1_quadbyte;
    b = b << 30 as libc::c_int | b >> 32 as libc::c_int - 30 as libc::c_int;
    (*block).l[(36 as libc::c_int & 15 as libc::c_int) as usize] = ((*block).l
        [(36 as libc::c_int + 13 as libc::c_int & 15 as libc::c_int) as usize]
        ^ (*block).l[(36 as libc::c_int + 8 as libc::c_int & 15 as libc::c_int) as usize]
        ^ (*block).l[(36 as libc::c_int + 2 as libc::c_int & 15 as libc::c_int) as usize]
        ^ (*block).l[(36 as libc::c_int & 15 as libc::c_int) as usize])
        << 1 as libc::c_int
        | ((*block).l[(36 as libc::c_int + 13 as libc::c_int & 15 as libc::c_int) as usize]
            ^ (*block).l[(36 as libc::c_int + 8 as libc::c_int & 15 as libc::c_int) as usize]
            ^ (*block).l[(36 as libc::c_int + 2 as libc::c_int & 15 as libc::c_int) as usize]
            ^ (*block).l[(36 as libc::c_int & 15 as libc::c_int) as usize])
            >> 32 as libc::c_int - 1 as libc::c_int;
    d = (d as libc::c_uint).wrapping_add(
        (a ^ b ^ c)
            .wrapping_add((*block).l[(36 as libc::c_int & 15 as libc::c_int) as usize])
            .wrapping_add(0x6ed9eba1 as libc::c_int as libc::c_uint)
            .wrapping_add(e << 5 as libc::c_int | e >> 32 as libc::c_int - 5 as libc::c_int),
    ) as sha1_quadbyte as sha1_quadbyte;
    a = a << 30 as libc::c_int | a >> 32 as libc::c_int - 30 as libc::c_int;
    (*block).l[(37 as libc::c_int & 15 as libc::c_int) as usize] = ((*block).l
        [(37 as libc::c_int + 13 as libc::c_int & 15 as libc::c_int) as usize]
        ^ (*block).l[(37 as libc::c_int + 8 as libc::c_int & 15 as libc::c_int) as usize]
        ^ (*block).l[(37 as libc::c_int + 2 as libc::c_int & 15 as libc::c_int) as usize]
        ^ (*block).l[(37 as libc::c_int & 15 as libc::c_int) as usize])
        << 1 as libc::c_int
        | ((*block).l[(37 as libc::c_int + 13 as libc::c_int & 15 as libc::c_int) as usize]
            ^ (*block).l[(37 as libc::c_int + 8 as libc::c_int & 15 as libc::c_int) as usize]
            ^ (*block).l[(37 as libc::c_int + 2 as libc::c_int & 15 as libc::c_int) as usize]
            ^ (*block).l[(37 as libc::c_int & 15 as libc::c_int) as usize])
            >> 32 as libc::c_int - 1 as libc::c_int;
    c = (c as libc::c_uint).wrapping_add(
        (e ^ a ^ b)
            .wrapping_add((*block).l[(37 as libc::c_int & 15 as libc::c_int) as usize])
            .wrapping_add(0x6ed9eba1 as libc::c_int as libc::c_uint)
            .wrapping_add(d << 5 as libc::c_int | d >> 32 as libc::c_int - 5 as libc::c_int),
    ) as sha1_quadbyte as sha1_quadbyte;
    e = e << 30 as libc::c_int | e >> 32 as libc::c_int - 30 as libc::c_int;
    (*block).l[(38 as libc::c_int & 15 as libc::c_int) as usize] = ((*block).l
        [(38 as libc::c_int + 13 as libc::c_int & 15 as libc::c_int) as usize]
        ^ (*block).l[(38 as libc::c_int + 8 as libc::c_int & 15 as libc::c_int) as usize]
        ^ (*block).l[(38 as libc::c_int + 2 as libc::c_int & 15 as libc::c_int) as usize]
        ^ (*block).l[(38 as libc::c_int & 15 as libc::c_int) as usize])
        << 1 as libc::c_int
        | ((*block).l[(38 as libc::c_int + 13 as libc::c_int & 15 as libc::c_int) as usize]
            ^ (*block).l[(38 as libc::c_int + 8 as libc::c_int & 15 as libc::c_int) as usize]
            ^ (*block).l[(38 as libc::c_int + 2 as libc::c_int & 15 as libc::c_int) as usize]
            ^ (*block).l[(38 as libc::c_int & 15 as libc::c_int) as usize])
            >> 32 as libc::c_int - 1 as libc::c_int;
    b = (b as libc::c_uint).wrapping_add(
        (d ^ e ^ a)
            .wrapping_add((*block).l[(38 as libc::c_int & 15 as libc::c_int) as usize])
            .wrapping_add(0x6ed9eba1 as libc::c_int as libc::c_uint)
            .wrapping_add(c << 5 as libc::c_int | c >> 32 as libc::c_int - 5 as libc::c_int),
    ) as sha1_quadbyte as sha1_quadbyte;
    d = d << 30 as libc::c_int | d >> 32 as libc::c_int - 30 as libc::c_int;
    (*block).l[(39 as libc::c_int & 15 as libc::c_int) as usize] = ((*block).l
        [(39 as libc::c_int + 13 as libc::c_int & 15 as libc::c_int) as usize]
        ^ (*block).l[(39 as libc::c_int + 8 as libc::c_int & 15 as libc::c_int) as usize]
        ^ (*block).l[(39 as libc::c_int + 2 as libc::c_int & 15 as libc::c_int) as usize]
        ^ (*block).l[(39 as libc::c_int & 15 as libc::c_int) as usize])
        << 1 as libc::c_int
        | ((*block).l[(39 as libc::c_int + 13 as libc::c_int & 15 as libc::c_int) as usize]
            ^ (*block).l[(39 as libc::c_int + 8 as libc::c_int & 15 as libc::c_int) as usize]
            ^ (*block).l[(39 as libc::c_int + 2 as libc::c_int & 15 as libc::c_int) as usize]
            ^ (*block).l[(39 as libc::c_int & 15 as libc::c_int) as usize])
            >> 32 as libc::c_int - 1 as libc::c_int;
    a = (a as libc::c_uint).wrapping_add(
        (c ^ d ^ e)
            .wrapping_add((*block).l[(39 as libc::c_int & 15 as libc::c_int) as usize])
            .wrapping_add(0x6ed9eba1 as libc::c_int as libc::c_uint)
            .wrapping_add(b << 5 as libc::c_int | b >> 32 as libc::c_int - 5 as libc::c_int),
    ) as sha1_quadbyte as sha1_quadbyte;
    c = c << 30 as libc::c_int | c >> 32 as libc::c_int - 30 as libc::c_int;
    (*block).l[(40 as libc::c_int & 15 as libc::c_int) as usize] = ((*block).l
        [(40 as libc::c_int + 13 as libc::c_int & 15 as libc::c_int) as usize]
        ^ (*block).l[(40 as libc::c_int + 8 as libc::c_int & 15 as libc::c_int) as usize]
        ^ (*block).l[(40 as libc::c_int + 2 as libc::c_int & 15 as libc::c_int) as usize]
        ^ (*block).l[(40 as libc::c_int & 15 as libc::c_int) as usize])
        << 1 as libc::c_int
        | ((*block).l[(40 as libc::c_int + 13 as libc::c_int & 15 as libc::c_int) as usize]
            ^ (*block).l[(40 as libc::c_int + 8 as libc::c_int & 15 as libc::c_int) as usize]
            ^ (*block).l[(40 as libc::c_int + 2 as libc::c_int & 15 as libc::c_int) as usize]
            ^ (*block).l[(40 as libc::c_int & 15 as libc::c_int) as usize])
            >> 32 as libc::c_int - 1 as libc::c_int;
    e = (e as libc::c_uint).wrapping_add(
        ((b | c) & d | b & c)
            .wrapping_add((*block).l[(40 as libc::c_int & 15 as libc::c_int) as usize])
            .wrapping_add(0x8f1bbcdc as libc::c_uint)
            .wrapping_add(a << 5 as libc::c_int | a >> 32 as libc::c_int - 5 as libc::c_int),
    ) as sha1_quadbyte as sha1_quadbyte;
    b = b << 30 as libc::c_int | b >> 32 as libc::c_int - 30 as libc::c_int;
    (*block).l[(41 as libc::c_int & 15 as libc::c_int) as usize] = ((*block).l
        [(41 as libc::c_int + 13 as libc::c_int & 15 as libc::c_int) as usize]
        ^ (*block).l[(41 as libc::c_int + 8 as libc::c_int & 15 as libc::c_int) as usize]
        ^ (*block).l[(41 as libc::c_int + 2 as libc::c_int & 15 as libc::c_int) as usize]
        ^ (*block).l[(41 as libc::c_int & 15 as libc::c_int) as usize])
        << 1 as libc::c_int
        | ((*block).l[(41 as libc::c_int + 13 as libc::c_int & 15 as libc::c_int) as usize]
            ^ (*block).l[(41 as libc::c_int + 8 as libc::c_int & 15 as libc::c_int) as usize]
            ^ (*block).l[(41 as libc::c_int + 2 as libc::c_int & 15 as libc::c_int) as usize]
            ^ (*block).l[(41 as libc::c_int & 15 as libc::c_int) as usize])
            >> 32 as libc::c_int - 1 as libc::c_int;
    d = (d as libc::c_uint).wrapping_add(
        ((a | b) & c | a & b)
            .wrapping_add((*block).l[(41 as libc::c_int & 15 as libc::c_int) as usize])
            .wrapping_add(0x8f1bbcdc as libc::c_uint)
            .wrapping_add(e << 5 as libc::c_int | e >> 32 as libc::c_int - 5 as libc::c_int),
    ) as sha1_quadbyte as sha1_quadbyte;
    a = a << 30 as libc::c_int | a >> 32 as libc::c_int - 30 as libc::c_int;
    (*block).l[(42 as libc::c_int & 15 as libc::c_int) as usize] = ((*block).l
        [(42 as libc::c_int + 13 as libc::c_int & 15 as libc::c_int) as usize]
        ^ (*block).l[(42 as libc::c_int + 8 as libc::c_int & 15 as libc::c_int) as usize]
        ^ (*block).l[(42 as libc::c_int + 2 as libc::c_int & 15 as libc::c_int) as usize]
        ^ (*block).l[(42 as libc::c_int & 15 as libc::c_int) as usize])
        << 1 as libc::c_int
        | ((*block).l[(42 as libc::c_int + 13 as libc::c_int & 15 as libc::c_int) as usize]
            ^ (*block).l[(42 as libc::c_int + 8 as libc::c_int & 15 as libc::c_int) as usize]
            ^ (*block).l[(42 as libc::c_int + 2 as libc::c_int & 15 as libc::c_int) as usize]
            ^ (*block).l[(42 as libc::c_int & 15 as libc::c_int) as usize])
            >> 32 as libc::c_int - 1 as libc::c_int;
    c = (c as libc::c_uint).wrapping_add(
        ((e | a) & b | e & a)
            .wrapping_add((*block).l[(42 as libc::c_int & 15 as libc::c_int) as usize])
            .wrapping_add(0x8f1bbcdc as libc::c_uint)
            .wrapping_add(d << 5 as libc::c_int | d >> 32 as libc::c_int - 5 as libc::c_int),
    ) as sha1_quadbyte as sha1_quadbyte;
    e = e << 30 as libc::c_int | e >> 32 as libc::c_int - 30 as libc::c_int;
    (*block).l[(43 as libc::c_int & 15 as libc::c_int) as usize] = ((*block).l
        [(43 as libc::c_int + 13 as libc::c_int & 15 as libc::c_int) as usize]
        ^ (*block).l[(43 as libc::c_int + 8 as libc::c_int & 15 as libc::c_int) as usize]
        ^ (*block).l[(43 as libc::c_int + 2 as libc::c_int & 15 as libc::c_int) as usize]
        ^ (*block).l[(43 as libc::c_int & 15 as libc::c_int) as usize])
        << 1 as libc::c_int
        | ((*block).l[(43 as libc::c_int + 13 as libc::c_int & 15 as libc::c_int) as usize]
            ^ (*block).l[(43 as libc::c_int + 8 as libc::c_int & 15 as libc::c_int) as usize]
            ^ (*block).l[(43 as libc::c_int + 2 as libc::c_int & 15 as libc::c_int) as usize]
            ^ (*block).l[(43 as libc::c_int & 15 as libc::c_int) as usize])
            >> 32 as libc::c_int - 1 as libc::c_int;
    b = (b as libc::c_uint).wrapping_add(
        ((d | e) & a | d & e)
            .wrapping_add((*block).l[(43 as libc::c_int & 15 as libc::c_int) as usize])
            .wrapping_add(0x8f1bbcdc as libc::c_uint)
            .wrapping_add(c << 5 as libc::c_int | c >> 32 as libc::c_int - 5 as libc::c_int),
    ) as sha1_quadbyte as sha1_quadbyte;
    d = d << 30 as libc::c_int | d >> 32 as libc::c_int - 30 as libc::c_int;
    (*block).l[(44 as libc::c_int & 15 as libc::c_int) as usize] = ((*block).l
        [(44 as libc::c_int + 13 as libc::c_int & 15 as libc::c_int) as usize]
        ^ (*block).l[(44 as libc::c_int + 8 as libc::c_int & 15 as libc::c_int) as usize]
        ^ (*block).l[(44 as libc::c_int + 2 as libc::c_int & 15 as libc::c_int) as usize]
        ^ (*block).l[(44 as libc::c_int & 15 as libc::c_int) as usize])
        << 1 as libc::c_int
        | ((*block).l[(44 as libc::c_int + 13 as libc::c_int & 15 as libc::c_int) as usize]
            ^ (*block).l[(44 as libc::c_int + 8 as libc::c_int & 15 as libc::c_int) as usize]
            ^ (*block).l[(44 as libc::c_int + 2 as libc::c_int & 15 as libc::c_int) as usize]
            ^ (*block).l[(44 as libc::c_int & 15 as libc::c_int) as usize])
            >> 32 as libc::c_int - 1 as libc::c_int;
    a = (a as libc::c_uint).wrapping_add(
        ((c | d) & e | c & d)
            .wrapping_add((*block).l[(44 as libc::c_int & 15 as libc::c_int) as usize])
            .wrapping_add(0x8f1bbcdc as libc::c_uint)
            .wrapping_add(b << 5 as libc::c_int | b >> 32 as libc::c_int - 5 as libc::c_int),
    ) as sha1_quadbyte as sha1_quadbyte;
    c = c << 30 as libc::c_int | c >> 32 as libc::c_int - 30 as libc::c_int;
    (*block).l[(45 as libc::c_int & 15 as libc::c_int) as usize] = ((*block).l
        [(45 as libc::c_int + 13 as libc::c_int & 15 as libc::c_int) as usize]
        ^ (*block).l[(45 as libc::c_int + 8 as libc::c_int & 15 as libc::c_int) as usize]
        ^ (*block).l[(45 as libc::c_int + 2 as libc::c_int & 15 as libc::c_int) as usize]
        ^ (*block).l[(45 as libc::c_int & 15 as libc::c_int) as usize])
        << 1 as libc::c_int
        | ((*block).l[(45 as libc::c_int + 13 as libc::c_int & 15 as libc::c_int) as usize]
            ^ (*block).l[(45 as libc::c_int + 8 as libc::c_int & 15 as libc::c_int) as usize]
            ^ (*block).l[(45 as libc::c_int + 2 as libc::c_int & 15 as libc::c_int) as usize]
            ^ (*block).l[(45 as libc::c_int & 15 as libc::c_int) as usize])
            >> 32 as libc::c_int - 1 as libc::c_int;
    e = (e as libc::c_uint).wrapping_add(
        ((b | c) & d | b & c)
            .wrapping_add((*block).l[(45 as libc::c_int & 15 as libc::c_int) as usize])
            .wrapping_add(0x8f1bbcdc as libc::c_uint)
            .wrapping_add(a << 5 as libc::c_int | a >> 32 as libc::c_int - 5 as libc::c_int),
    ) as sha1_quadbyte as sha1_quadbyte;
    b = b << 30 as libc::c_int | b >> 32 as libc::c_int - 30 as libc::c_int;
    (*block).l[(46 as libc::c_int & 15 as libc::c_int) as usize] = ((*block).l
        [(46 as libc::c_int + 13 as libc::c_int & 15 as libc::c_int) as usize]
        ^ (*block).l[(46 as libc::c_int + 8 as libc::c_int & 15 as libc::c_int) as usize]
        ^ (*block).l[(46 as libc::c_int + 2 as libc::c_int & 15 as libc::c_int) as usize]
        ^ (*block).l[(46 as libc::c_int & 15 as libc::c_int) as usize])
        << 1 as libc::c_int
        | ((*block).l[(46 as libc::c_int + 13 as libc::c_int & 15 as libc::c_int) as usize]
            ^ (*block).l[(46 as libc::c_int + 8 as libc::c_int & 15 as libc::c_int) as usize]
            ^ (*block).l[(46 as libc::c_int + 2 as libc::c_int & 15 as libc::c_int) as usize]
            ^ (*block).l[(46 as libc::c_int & 15 as libc::c_int) as usize])
            >> 32 as libc::c_int - 1 as libc::c_int;
    d = (d as libc::c_uint).wrapping_add(
        ((a | b) & c | a & b)
            .wrapping_add((*block).l[(46 as libc::c_int & 15 as libc::c_int) as usize])
            .wrapping_add(0x8f1bbcdc as libc::c_uint)
            .wrapping_add(e << 5 as libc::c_int | e >> 32 as libc::c_int - 5 as libc::c_int),
    ) as sha1_quadbyte as sha1_quadbyte;
    a = a << 30 as libc::c_int | a >> 32 as libc::c_int - 30 as libc::c_int;
    (*block).l[(47 as libc::c_int & 15 as libc::c_int) as usize] = ((*block).l
        [(47 as libc::c_int + 13 as libc::c_int & 15 as libc::c_int) as usize]
        ^ (*block).l[(47 as libc::c_int + 8 as libc::c_int & 15 as libc::c_int) as usize]
        ^ (*block).l[(47 as libc::c_int + 2 as libc::c_int & 15 as libc::c_int) as usize]
        ^ (*block).l[(47 as libc::c_int & 15 as libc::c_int) as usize])
        << 1 as libc::c_int
        | ((*block).l[(47 as libc::c_int + 13 as libc::c_int & 15 as libc::c_int) as usize]
            ^ (*block).l[(47 as libc::c_int + 8 as libc::c_int & 15 as libc::c_int) as usize]
            ^ (*block).l[(47 as libc::c_int + 2 as libc::c_int & 15 as libc::c_int) as usize]
            ^ (*block).l[(47 as libc::c_int & 15 as libc::c_int) as usize])
            >> 32 as libc::c_int - 1 as libc::c_int;
    c = (c as libc::c_uint).wrapping_add(
        ((e | a) & b | e & a)
            .wrapping_add((*block).l[(47 as libc::c_int & 15 as libc::c_int) as usize])
            .wrapping_add(0x8f1bbcdc as libc::c_uint)
            .wrapping_add(d << 5 as libc::c_int | d >> 32 as libc::c_int - 5 as libc::c_int),
    ) as sha1_quadbyte as sha1_quadbyte;
    e = e << 30 as libc::c_int | e >> 32 as libc::c_int - 30 as libc::c_int;
    (*block).l[(48 as libc::c_int & 15 as libc::c_int) as usize] = ((*block).l
        [(48 as libc::c_int + 13 as libc::c_int & 15 as libc::c_int) as usize]
        ^ (*block).l[(48 as libc::c_int + 8 as libc::c_int & 15 as libc::c_int) as usize]
        ^ (*block).l[(48 as libc::c_int + 2 as libc::c_int & 15 as libc::c_int) as usize]
        ^ (*block).l[(48 as libc::c_int & 15 as libc::c_int) as usize])
        << 1 as libc::c_int
        | ((*block).l[(48 as libc::c_int + 13 as libc::c_int & 15 as libc::c_int) as usize]
            ^ (*block).l[(48 as libc::c_int + 8 as libc::c_int & 15 as libc::c_int) as usize]
            ^ (*block).l[(48 as libc::c_int + 2 as libc::c_int & 15 as libc::c_int) as usize]
            ^ (*block).l[(48 as libc::c_int & 15 as libc::c_int) as usize])
            >> 32 as libc::c_int - 1 as libc::c_int;
    b = (b as libc::c_uint).wrapping_add(
        ((d | e) & a | d & e)
            .wrapping_add((*block).l[(48 as libc::c_int & 15 as libc::c_int) as usize])
            .wrapping_add(0x8f1bbcdc as libc::c_uint)
            .wrapping_add(c << 5 as libc::c_int | c >> 32 as libc::c_int - 5 as libc::c_int),
    ) as sha1_quadbyte as sha1_quadbyte;
    d = d << 30 as libc::c_int | d >> 32 as libc::c_int - 30 as libc::c_int;
    (*block).l[(49 as libc::c_int & 15 as libc::c_int) as usize] = ((*block).l
        [(49 as libc::c_int + 13 as libc::c_int & 15 as libc::c_int) as usize]
        ^ (*block).l[(49 as libc::c_int + 8 as libc::c_int & 15 as libc::c_int) as usize]
        ^ (*block).l[(49 as libc::c_int + 2 as libc::c_int & 15 as libc::c_int) as usize]
        ^ (*block).l[(49 as libc::c_int & 15 as libc::c_int) as usize])
        << 1 as libc::c_int
        | ((*block).l[(49 as libc::c_int + 13 as libc::c_int & 15 as libc::c_int) as usize]
            ^ (*block).l[(49 as libc::c_int + 8 as libc::c_int & 15 as libc::c_int) as usize]
            ^ (*block).l[(49 as libc::c_int + 2 as libc::c_int & 15 as libc::c_int) as usize]
            ^ (*block).l[(49 as libc::c_int & 15 as libc::c_int) as usize])
            >> 32 as libc::c_int - 1 as libc::c_int;
    a = (a as libc::c_uint).wrapping_add(
        ((c | d) & e | c & d)
            .wrapping_add((*block).l[(49 as libc::c_int & 15 as libc::c_int) as usize])
            .wrapping_add(0x8f1bbcdc as libc::c_uint)
            .wrapping_add(b << 5 as libc::c_int | b >> 32 as libc::c_int - 5 as libc::c_int),
    ) as sha1_quadbyte as sha1_quadbyte;
    c = c << 30 as libc::c_int | c >> 32 as libc::c_int - 30 as libc::c_int;
    (*block).l[(50 as libc::c_int & 15 as libc::c_int) as usize] = ((*block).l
        [(50 as libc::c_int + 13 as libc::c_int & 15 as libc::c_int) as usize]
        ^ (*block).l[(50 as libc::c_int + 8 as libc::c_int & 15 as libc::c_int) as usize]
        ^ (*block).l[(50 as libc::c_int + 2 as libc::c_int & 15 as libc::c_int) as usize]
        ^ (*block).l[(50 as libc::c_int & 15 as libc::c_int) as usize])
        << 1 as libc::c_int
        | ((*block).l[(50 as libc::c_int + 13 as libc::c_int & 15 as libc::c_int) as usize]
            ^ (*block).l[(50 as libc::c_int + 8 as libc::c_int & 15 as libc::c_int) as usize]
            ^ (*block).l[(50 as libc::c_int + 2 as libc::c_int & 15 as libc::c_int) as usize]
            ^ (*block).l[(50 as libc::c_int & 15 as libc::c_int) as usize])
            >> 32 as libc::c_int - 1 as libc::c_int;
    e = (e as libc::c_uint).wrapping_add(
        ((b | c) & d | b & c)
            .wrapping_add((*block).l[(50 as libc::c_int & 15 as libc::c_int) as usize])
            .wrapping_add(0x8f1bbcdc as libc::c_uint)
            .wrapping_add(a << 5 as libc::c_int | a >> 32 as libc::c_int - 5 as libc::c_int),
    ) as sha1_quadbyte as sha1_quadbyte;
    b = b << 30 as libc::c_int | b >> 32 as libc::c_int - 30 as libc::c_int;
    (*block).l[(51 as libc::c_int & 15 as libc::c_int) as usize] = ((*block).l
        [(51 as libc::c_int + 13 as libc::c_int & 15 as libc::c_int) as usize]
        ^ (*block).l[(51 as libc::c_int + 8 as libc::c_int & 15 as libc::c_int) as usize]
        ^ (*block).l[(51 as libc::c_int + 2 as libc::c_int & 15 as libc::c_int) as usize]
        ^ (*block).l[(51 as libc::c_int & 15 as libc::c_int) as usize])
        << 1 as libc::c_int
        | ((*block).l[(51 as libc::c_int + 13 as libc::c_int & 15 as libc::c_int) as usize]
            ^ (*block).l[(51 as libc::c_int + 8 as libc::c_int & 15 as libc::c_int) as usize]
            ^ (*block).l[(51 as libc::c_int + 2 as libc::c_int & 15 as libc::c_int) as usize]
            ^ (*block).l[(51 as libc::c_int & 15 as libc::c_int) as usize])
            >> 32 as libc::c_int - 1 as libc::c_int;
    d = (d as libc::c_uint).wrapping_add(
        ((a | b) & c | a & b)
            .wrapping_add((*block).l[(51 as libc::c_int & 15 as libc::c_int) as usize])
            .wrapping_add(0x8f1bbcdc as libc::c_uint)
            .wrapping_add(e << 5 as libc::c_int | e >> 32 as libc::c_int - 5 as libc::c_int),
    ) as sha1_quadbyte as sha1_quadbyte;
    a = a << 30 as libc::c_int | a >> 32 as libc::c_int - 30 as libc::c_int;
    (*block).l[(52 as libc::c_int & 15 as libc::c_int) as usize] = ((*block).l
        [(52 as libc::c_int + 13 as libc::c_int & 15 as libc::c_int) as usize]
        ^ (*block).l[(52 as libc::c_int + 8 as libc::c_int & 15 as libc::c_int) as usize]
        ^ (*block).l[(52 as libc::c_int + 2 as libc::c_int & 15 as libc::c_int) as usize]
        ^ (*block).l[(52 as libc::c_int & 15 as libc::c_int) as usize])
        << 1 as libc::c_int
        | ((*block).l[(52 as libc::c_int + 13 as libc::c_int & 15 as libc::c_int) as usize]
            ^ (*block).l[(52 as libc::c_int + 8 as libc::c_int & 15 as libc::c_int) as usize]
            ^ (*block).l[(52 as libc::c_int + 2 as libc::c_int & 15 as libc::c_int) as usize]
            ^ (*block).l[(52 as libc::c_int & 15 as libc::c_int) as usize])
            >> 32 as libc::c_int - 1 as libc::c_int;
    c = (c as libc::c_uint).wrapping_add(
        ((e | a) & b | e & a)
            .wrapping_add((*block).l[(52 as libc::c_int & 15 as libc::c_int) as usize])
            .wrapping_add(0x8f1bbcdc as libc::c_uint)
            .wrapping_add(d << 5 as libc::c_int | d >> 32 as libc::c_int - 5 as libc::c_int),
    ) as sha1_quadbyte as sha1_quadbyte;
    e = e << 30 as libc::c_int | e >> 32 as libc::c_int - 30 as libc::c_int;
    (*block).l[(53 as libc::c_int & 15 as libc::c_int) as usize] = ((*block).l
        [(53 as libc::c_int + 13 as libc::c_int & 15 as libc::c_int) as usize]
        ^ (*block).l[(53 as libc::c_int + 8 as libc::c_int & 15 as libc::c_int) as usize]
        ^ (*block).l[(53 as libc::c_int + 2 as libc::c_int & 15 as libc::c_int) as usize]
        ^ (*block).l[(53 as libc::c_int & 15 as libc::c_int) as usize])
        << 1 as libc::c_int
        | ((*block).l[(53 as libc::c_int + 13 as libc::c_int & 15 as libc::c_int) as usize]
            ^ (*block).l[(53 as libc::c_int + 8 as libc::c_int & 15 as libc::c_int) as usize]
            ^ (*block).l[(53 as libc::c_int + 2 as libc::c_int & 15 as libc::c_int) as usize]
            ^ (*block).l[(53 as libc::c_int & 15 as libc::c_int) as usize])
            >> 32 as libc::c_int - 1 as libc::c_int;
    b = (b as libc::c_uint).wrapping_add(
        ((d | e) & a | d & e)
            .wrapping_add((*block).l[(53 as libc::c_int & 15 as libc::c_int) as usize])
            .wrapping_add(0x8f1bbcdc as libc::c_uint)
            .wrapping_add(c << 5 as libc::c_int | c >> 32 as libc::c_int - 5 as libc::c_int),
    ) as sha1_quadbyte as sha1_quadbyte;
    d = d << 30 as libc::c_int | d >> 32 as libc::c_int - 30 as libc::c_int;
    (*block).l[(54 as libc::c_int & 15 as libc::c_int) as usize] = ((*block).l
        [(54 as libc::c_int + 13 as libc::c_int & 15 as libc::c_int) as usize]
        ^ (*block).l[(54 as libc::c_int + 8 as libc::c_int & 15 as libc::c_int) as usize]
        ^ (*block).l[(54 as libc::c_int + 2 as libc::c_int & 15 as libc::c_int) as usize]
        ^ (*block).l[(54 as libc::c_int & 15 as libc::c_int) as usize])
        << 1 as libc::c_int
        | ((*block).l[(54 as libc::c_int + 13 as libc::c_int & 15 as libc::c_int) as usize]
            ^ (*block).l[(54 as libc::c_int + 8 as libc::c_int & 15 as libc::c_int) as usize]
            ^ (*block).l[(54 as libc::c_int + 2 as libc::c_int & 15 as libc::c_int) as usize]
            ^ (*block).l[(54 as libc::c_int & 15 as libc::c_int) as usize])
            >> 32 as libc::c_int - 1 as libc::c_int;
    a = (a as libc::c_uint).wrapping_add(
        ((c | d) & e | c & d)
            .wrapping_add((*block).l[(54 as libc::c_int & 15 as libc::c_int) as usize])
            .wrapping_add(0x8f1bbcdc as libc::c_uint)
            .wrapping_add(b << 5 as libc::c_int | b >> 32 as libc::c_int - 5 as libc::c_int),
    ) as sha1_quadbyte as sha1_quadbyte;
    c = c << 30 as libc::c_int | c >> 32 as libc::c_int - 30 as libc::c_int;
    (*block).l[(55 as libc::c_int & 15 as libc::c_int) as usize] = ((*block).l
        [(55 as libc::c_int + 13 as libc::c_int & 15 as libc::c_int) as usize]
        ^ (*block).l[(55 as libc::c_int + 8 as libc::c_int & 15 as libc::c_int) as usize]
        ^ (*block).l[(55 as libc::c_int + 2 as libc::c_int & 15 as libc::c_int) as usize]
        ^ (*block).l[(55 as libc::c_int & 15 as libc::c_int) as usize])
        << 1 as libc::c_int
        | ((*block).l[(55 as libc::c_int + 13 as libc::c_int & 15 as libc::c_int) as usize]
            ^ (*block).l[(55 as libc::c_int + 8 as libc::c_int & 15 as libc::c_int) as usize]
            ^ (*block).l[(55 as libc::c_int + 2 as libc::c_int & 15 as libc::c_int) as usize]
            ^ (*block).l[(55 as libc::c_int & 15 as libc::c_int) as usize])
            >> 32 as libc::c_int - 1 as libc::c_int;
    e = (e as libc::c_uint).wrapping_add(
        ((b | c) & d | b & c)
            .wrapping_add((*block).l[(55 as libc::c_int & 15 as libc::c_int) as usize])
            .wrapping_add(0x8f1bbcdc as libc::c_uint)
            .wrapping_add(a << 5 as libc::c_int | a >> 32 as libc::c_int - 5 as libc::c_int),
    ) as sha1_quadbyte as sha1_quadbyte;
    b = b << 30 as libc::c_int | b >> 32 as libc::c_int - 30 as libc::c_int;
    (*block).l[(56 as libc::c_int & 15 as libc::c_int) as usize] = ((*block).l
        [(56 as libc::c_int + 13 as libc::c_int & 15 as libc::c_int) as usize]
        ^ (*block).l[(56 as libc::c_int + 8 as libc::c_int & 15 as libc::c_int) as usize]
        ^ (*block).l[(56 as libc::c_int + 2 as libc::c_int & 15 as libc::c_int) as usize]
        ^ (*block).l[(56 as libc::c_int & 15 as libc::c_int) as usize])
        << 1 as libc::c_int
        | ((*block).l[(56 as libc::c_int + 13 as libc::c_int & 15 as libc::c_int) as usize]
            ^ (*block).l[(56 as libc::c_int + 8 as libc::c_int & 15 as libc::c_int) as usize]
            ^ (*block).l[(56 as libc::c_int + 2 as libc::c_int & 15 as libc::c_int) as usize]
            ^ (*block).l[(56 as libc::c_int & 15 as libc::c_int) as usize])
            >> 32 as libc::c_int - 1 as libc::c_int;
    d = (d as libc::c_uint).wrapping_add(
        ((a | b) & c | a & b)
            .wrapping_add((*block).l[(56 as libc::c_int & 15 as libc::c_int) as usize])
            .wrapping_add(0x8f1bbcdc as libc::c_uint)
            .wrapping_add(e << 5 as libc::c_int | e >> 32 as libc::c_int - 5 as libc::c_int),
    ) as sha1_quadbyte as sha1_quadbyte;
    a = a << 30 as libc::c_int | a >> 32 as libc::c_int - 30 as libc::c_int;
    (*block).l[(57 as libc::c_int & 15 as libc::c_int) as usize] = ((*block).l
        [(57 as libc::c_int + 13 as libc::c_int & 15 as libc::c_int) as usize]
        ^ (*block).l[(57 as libc::c_int + 8 as libc::c_int & 15 as libc::c_int) as usize]
        ^ (*block).l[(57 as libc::c_int + 2 as libc::c_int & 15 as libc::c_int) as usize]
        ^ (*block).l[(57 as libc::c_int & 15 as libc::c_int) as usize])
        << 1 as libc::c_int
        | ((*block).l[(57 as libc::c_int + 13 as libc::c_int & 15 as libc::c_int) as usize]
            ^ (*block).l[(57 as libc::c_int + 8 as libc::c_int & 15 as libc::c_int) as usize]
            ^ (*block).l[(57 as libc::c_int + 2 as libc::c_int & 15 as libc::c_int) as usize]
            ^ (*block).l[(57 as libc::c_int & 15 as libc::c_int) as usize])
            >> 32 as libc::c_int - 1 as libc::c_int;
    c = (c as libc::c_uint).wrapping_add(
        ((e | a) & b | e & a)
            .wrapping_add((*block).l[(57 as libc::c_int & 15 as libc::c_int) as usize])
            .wrapping_add(0x8f1bbcdc as libc::c_uint)
            .wrapping_add(d << 5 as libc::c_int | d >> 32 as libc::c_int - 5 as libc::c_int),
    ) as sha1_quadbyte as sha1_quadbyte;
    e = e << 30 as libc::c_int | e >> 32 as libc::c_int - 30 as libc::c_int;
    (*block).l[(58 as libc::c_int & 15 as libc::c_int) as usize] = ((*block).l
        [(58 as libc::c_int + 13 as libc::c_int & 15 as libc::c_int) as usize]
        ^ (*block).l[(58 as libc::c_int + 8 as libc::c_int & 15 as libc::c_int) as usize]
        ^ (*block).l[(58 as libc::c_int + 2 as libc::c_int & 15 as libc::c_int) as usize]
        ^ (*block).l[(58 as libc::c_int & 15 as libc::c_int) as usize])
        << 1 as libc::c_int
        | ((*block).l[(58 as libc::c_int + 13 as libc::c_int & 15 as libc::c_int) as usize]
            ^ (*block).l[(58 as libc::c_int + 8 as libc::c_int & 15 as libc::c_int) as usize]
            ^ (*block).l[(58 as libc::c_int + 2 as libc::c_int & 15 as libc::c_int) as usize]
            ^ (*block).l[(58 as libc::c_int & 15 as libc::c_int) as usize])
            >> 32 as libc::c_int - 1 as libc::c_int;
    b = (b as libc::c_uint).wrapping_add(
        ((d | e) & a | d & e)
            .wrapping_add((*block).l[(58 as libc::c_int & 15 as libc::c_int) as usize])
            .wrapping_add(0x8f1bbcdc as libc::c_uint)
            .wrapping_add(c << 5 as libc::c_int | c >> 32 as libc::c_int - 5 as libc::c_int),
    ) as sha1_quadbyte as sha1_quadbyte;
    d = d << 30 as libc::c_int | d >> 32 as libc::c_int - 30 as libc::c_int;
    (*block).l[(59 as libc::c_int & 15 as libc::c_int) as usize] = ((*block).l
        [(59 as libc::c_int + 13 as libc::c_int & 15 as libc::c_int) as usize]
        ^ (*block).l[(59 as libc::c_int + 8 as libc::c_int & 15 as libc::c_int) as usize]
        ^ (*block).l[(59 as libc::c_int + 2 as libc::c_int & 15 as libc::c_int) as usize]
        ^ (*block).l[(59 as libc::c_int & 15 as libc::c_int) as usize])
        << 1 as libc::c_int
        | ((*block).l[(59 as libc::c_int + 13 as libc::c_int & 15 as libc::c_int) as usize]
            ^ (*block).l[(59 as libc::c_int + 8 as libc::c_int & 15 as libc::c_int) as usize]
            ^ (*block).l[(59 as libc::c_int + 2 as libc::c_int & 15 as libc::c_int) as usize]
            ^ (*block).l[(59 as libc::c_int & 15 as libc::c_int) as usize])
            >> 32 as libc::c_int - 1 as libc::c_int;
    a = (a as libc::c_uint).wrapping_add(
        ((c | d) & e | c & d)
            .wrapping_add((*block).l[(59 as libc::c_int & 15 as libc::c_int) as usize])
            .wrapping_add(0x8f1bbcdc as libc::c_uint)
            .wrapping_add(b << 5 as libc::c_int | b >> 32 as libc::c_int - 5 as libc::c_int),
    ) as sha1_quadbyte as sha1_quadbyte;
    c = c << 30 as libc::c_int | c >> 32 as libc::c_int - 30 as libc::c_int;
    (*block).l[(60 as libc::c_int & 15 as libc::c_int) as usize] = ((*block).l
        [(60 as libc::c_int + 13 as libc::c_int & 15 as libc::c_int) as usize]
        ^ (*block).l[(60 as libc::c_int + 8 as libc::c_int & 15 as libc::c_int) as usize]
        ^ (*block).l[(60 as libc::c_int + 2 as libc::c_int & 15 as libc::c_int) as usize]
        ^ (*block).l[(60 as libc::c_int & 15 as libc::c_int) as usize])
        << 1 as libc::c_int
        | ((*block).l[(60 as libc::c_int + 13 as libc::c_int & 15 as libc::c_int) as usize]
            ^ (*block).l[(60 as libc::c_int + 8 as libc::c_int & 15 as libc::c_int) as usize]
            ^ (*block).l[(60 as libc::c_int + 2 as libc::c_int & 15 as libc::c_int) as usize]
            ^ (*block).l[(60 as libc::c_int & 15 as libc::c_int) as usize])
            >> 32 as libc::c_int - 1 as libc::c_int;
    e = (e as libc::c_uint).wrapping_add(
        (b ^ c ^ d)
            .wrapping_add((*block).l[(60 as libc::c_int & 15 as libc::c_int) as usize])
            .wrapping_add(0xca62c1d6 as libc::c_uint)
            .wrapping_add(a << 5 as libc::c_int | a >> 32 as libc::c_int - 5 as libc::c_int),
    ) as sha1_quadbyte as sha1_quadbyte;
    b = b << 30 as libc::c_int | b >> 32 as libc::c_int - 30 as libc::c_int;
    (*block).l[(61 as libc::c_int & 15 as libc::c_int) as usize] = ((*block).l
        [(61 as libc::c_int + 13 as libc::c_int & 15 as libc::c_int) as usize]
        ^ (*block).l[(61 as libc::c_int + 8 as libc::c_int & 15 as libc::c_int) as usize]
        ^ (*block).l[(61 as libc::c_int + 2 as libc::c_int & 15 as libc::c_int) as usize]
        ^ (*block).l[(61 as libc::c_int & 15 as libc::c_int) as usize])
        << 1 as libc::c_int
        | ((*block).l[(61 as libc::c_int + 13 as libc::c_int & 15 as libc::c_int) as usize]
            ^ (*block).l[(61 as libc::c_int + 8 as libc::c_int & 15 as libc::c_int) as usize]
            ^ (*block).l[(61 as libc::c_int + 2 as libc::c_int & 15 as libc::c_int) as usize]
            ^ (*block).l[(61 as libc::c_int & 15 as libc::c_int) as usize])
            >> 32 as libc::c_int - 1 as libc::c_int;
    d = (d as libc::c_uint).wrapping_add(
        (a ^ b ^ c)
            .wrapping_add((*block).l[(61 as libc::c_int & 15 as libc::c_int) as usize])
            .wrapping_add(0xca62c1d6 as libc::c_uint)
            .wrapping_add(e << 5 as libc::c_int | e >> 32 as libc::c_int - 5 as libc::c_int),
    ) as sha1_quadbyte as sha1_quadbyte;
    a = a << 30 as libc::c_int | a >> 32 as libc::c_int - 30 as libc::c_int;
    (*block).l[(62 as libc::c_int & 15 as libc::c_int) as usize] = ((*block).l
        [(62 as libc::c_int + 13 as libc::c_int & 15 as libc::c_int) as usize]
        ^ (*block).l[(62 as libc::c_int + 8 as libc::c_int & 15 as libc::c_int) as usize]
        ^ (*block).l[(62 as libc::c_int + 2 as libc::c_int & 15 as libc::c_int) as usize]
        ^ (*block).l[(62 as libc::c_int & 15 as libc::c_int) as usize])
        << 1 as libc::c_int
        | ((*block).l[(62 as libc::c_int + 13 as libc::c_int & 15 as libc::c_int) as usize]
            ^ (*block).l[(62 as libc::c_int + 8 as libc::c_int & 15 as libc::c_int) as usize]
            ^ (*block).l[(62 as libc::c_int + 2 as libc::c_int & 15 as libc::c_int) as usize]
            ^ (*block).l[(62 as libc::c_int & 15 as libc::c_int) as usize])
            >> 32 as libc::c_int - 1 as libc::c_int;
    c = (c as libc::c_uint).wrapping_add(
        (e ^ a ^ b)
            .wrapping_add((*block).l[(62 as libc::c_int & 15 as libc::c_int) as usize])
            .wrapping_add(0xca62c1d6 as libc::c_uint)
            .wrapping_add(d << 5 as libc::c_int | d >> 32 as libc::c_int - 5 as libc::c_int),
    ) as sha1_quadbyte as sha1_quadbyte;
    e = e << 30 as libc::c_int | e >> 32 as libc::c_int - 30 as libc::c_int;
    (*block).l[(63 as libc::c_int & 15 as libc::c_int) as usize] = ((*block).l
        [(63 as libc::c_int + 13 as libc::c_int & 15 as libc::c_int) as usize]
        ^ (*block).l[(63 as libc::c_int + 8 as libc::c_int & 15 as libc::c_int) as usize]
        ^ (*block).l[(63 as libc::c_int + 2 as libc::c_int & 15 as libc::c_int) as usize]
        ^ (*block).l[(63 as libc::c_int & 15 as libc::c_int) as usize])
        << 1 as libc::c_int
        | ((*block).l[(63 as libc::c_int + 13 as libc::c_int & 15 as libc::c_int) as usize]
            ^ (*block).l[(63 as libc::c_int + 8 as libc::c_int & 15 as libc::c_int) as usize]
            ^ (*block).l[(63 as libc::c_int + 2 as libc::c_int & 15 as libc::c_int) as usize]
            ^ (*block).l[(63 as libc::c_int & 15 as libc::c_int) as usize])
            >> 32 as libc::c_int - 1 as libc::c_int;
    b = (b as libc::c_uint).wrapping_add(
        (d ^ e ^ a)
            .wrapping_add((*block).l[(63 as libc::c_int & 15 as libc::c_int) as usize])
            .wrapping_add(0xca62c1d6 as libc::c_uint)
            .wrapping_add(c << 5 as libc::c_int | c >> 32 as libc::c_int - 5 as libc::c_int),
    ) as sha1_quadbyte as sha1_quadbyte;
    d = d << 30 as libc::c_int | d >> 32 as libc::c_int - 30 as libc::c_int;
    (*block).l[(64 as libc::c_int & 15 as libc::c_int) as usize] = ((*block).l
        [(64 as libc::c_int + 13 as libc::c_int & 15 as libc::c_int) as usize]
        ^ (*block).l[(64 as libc::c_int + 8 as libc::c_int & 15 as libc::c_int) as usize]
        ^ (*block).l[(64 as libc::c_int + 2 as libc::c_int & 15 as libc::c_int) as usize]
        ^ (*block).l[(64 as libc::c_int & 15 as libc::c_int) as usize])
        << 1 as libc::c_int
        | ((*block).l[(64 as libc::c_int + 13 as libc::c_int & 15 as libc::c_int) as usize]
            ^ (*block).l[(64 as libc::c_int + 8 as libc::c_int & 15 as libc::c_int) as usize]
            ^ (*block).l[(64 as libc::c_int + 2 as libc::c_int & 15 as libc::c_int) as usize]
            ^ (*block).l[(64 as libc::c_int & 15 as libc::c_int) as usize])
            >> 32 as libc::c_int - 1 as libc::c_int;
    a = (a as libc::c_uint).wrapping_add(
        (c ^ d ^ e)
            .wrapping_add((*block).l[(64 as libc::c_int & 15 as libc::c_int) as usize])
            .wrapping_add(0xca62c1d6 as libc::c_uint)
            .wrapping_add(b << 5 as libc::c_int | b >> 32 as libc::c_int - 5 as libc::c_int),
    ) as sha1_quadbyte as sha1_quadbyte;
    c = c << 30 as libc::c_int | c >> 32 as libc::c_int - 30 as libc::c_int;
    (*block).l[(65 as libc::c_int & 15 as libc::c_int) as usize] = ((*block).l
        [(65 as libc::c_int + 13 as libc::c_int & 15 as libc::c_int) as usize]
        ^ (*block).l[(65 as libc::c_int + 8 as libc::c_int & 15 as libc::c_int) as usize]
        ^ (*block).l[(65 as libc::c_int + 2 as libc::c_int & 15 as libc::c_int) as usize]
        ^ (*block).l[(65 as libc::c_int & 15 as libc::c_int) as usize])
        << 1 as libc::c_int
        | ((*block).l[(65 as libc::c_int + 13 as libc::c_int & 15 as libc::c_int) as usize]
            ^ (*block).l[(65 as libc::c_int + 8 as libc::c_int & 15 as libc::c_int) as usize]
            ^ (*block).l[(65 as libc::c_int + 2 as libc::c_int & 15 as libc::c_int) as usize]
            ^ (*block).l[(65 as libc::c_int & 15 as libc::c_int) as usize])
            >> 32 as libc::c_int - 1 as libc::c_int;
    e = (e as libc::c_uint).wrapping_add(
        (b ^ c ^ d)
            .wrapping_add((*block).l[(65 as libc::c_int & 15 as libc::c_int) as usize])
            .wrapping_add(0xca62c1d6 as libc::c_uint)
            .wrapping_add(a << 5 as libc::c_int | a >> 32 as libc::c_int - 5 as libc::c_int),
    ) as sha1_quadbyte as sha1_quadbyte;
    b = b << 30 as libc::c_int | b >> 32 as libc::c_int - 30 as libc::c_int;
    (*block).l[(66 as libc::c_int & 15 as libc::c_int) as usize] = ((*block).l
        [(66 as libc::c_int + 13 as libc::c_int & 15 as libc::c_int) as usize]
        ^ (*block).l[(66 as libc::c_int + 8 as libc::c_int & 15 as libc::c_int) as usize]
        ^ (*block).l[(66 as libc::c_int + 2 as libc::c_int & 15 as libc::c_int) as usize]
        ^ (*block).l[(66 as libc::c_int & 15 as libc::c_int) as usize])
        << 1 as libc::c_int
        | ((*block).l[(66 as libc::c_int + 13 as libc::c_int & 15 as libc::c_int) as usize]
            ^ (*block).l[(66 as libc::c_int + 8 as libc::c_int & 15 as libc::c_int) as usize]
            ^ (*block).l[(66 as libc::c_int + 2 as libc::c_int & 15 as libc::c_int) as usize]
            ^ (*block).l[(66 as libc::c_int & 15 as libc::c_int) as usize])
            >> 32 as libc::c_int - 1 as libc::c_int;
    d = (d as libc::c_uint).wrapping_add(
        (a ^ b ^ c)
            .wrapping_add((*block).l[(66 as libc::c_int & 15 as libc::c_int) as usize])
            .wrapping_add(0xca62c1d6 as libc::c_uint)
            .wrapping_add(e << 5 as libc::c_int | e >> 32 as libc::c_int - 5 as libc::c_int),
    ) as sha1_quadbyte as sha1_quadbyte;
    a = a << 30 as libc::c_int | a >> 32 as libc::c_int - 30 as libc::c_int;
    (*block).l[(67 as libc::c_int & 15 as libc::c_int) as usize] = ((*block).l
        [(67 as libc::c_int + 13 as libc::c_int & 15 as libc::c_int) as usize]
        ^ (*block).l[(67 as libc::c_int + 8 as libc::c_int & 15 as libc::c_int) as usize]
        ^ (*block).l[(67 as libc::c_int + 2 as libc::c_int & 15 as libc::c_int) as usize]
        ^ (*block).l[(67 as libc::c_int & 15 as libc::c_int) as usize])
        << 1 as libc::c_int
        | ((*block).l[(67 as libc::c_int + 13 as libc::c_int & 15 as libc::c_int) as usize]
            ^ (*block).l[(67 as libc::c_int + 8 as libc::c_int & 15 as libc::c_int) as usize]
            ^ (*block).l[(67 as libc::c_int + 2 as libc::c_int & 15 as libc::c_int) as usize]
            ^ (*block).l[(67 as libc::c_int & 15 as libc::c_int) as usize])
            >> 32 as libc::c_int - 1 as libc::c_int;
    c = (c as libc::c_uint).wrapping_add(
        (e ^ a ^ b)
            .wrapping_add((*block).l[(67 as libc::c_int & 15 as libc::c_int) as usize])
            .wrapping_add(0xca62c1d6 as libc::c_uint)
            .wrapping_add(d << 5 as libc::c_int | d >> 32 as libc::c_int - 5 as libc::c_int),
    ) as sha1_quadbyte as sha1_quadbyte;
    e = e << 30 as libc::c_int | e >> 32 as libc::c_int - 30 as libc::c_int;
    (*block).l[(68 as libc::c_int & 15 as libc::c_int) as usize] = ((*block).l
        [(68 as libc::c_int + 13 as libc::c_int & 15 as libc::c_int) as usize]
        ^ (*block).l[(68 as libc::c_int + 8 as libc::c_int & 15 as libc::c_int) as usize]
        ^ (*block).l[(68 as libc::c_int + 2 as libc::c_int & 15 as libc::c_int) as usize]
        ^ (*block).l[(68 as libc::c_int & 15 as libc::c_int) as usize])
        << 1 as libc::c_int
        | ((*block).l[(68 as libc::c_int + 13 as libc::c_int & 15 as libc::c_int) as usize]
            ^ (*block).l[(68 as libc::c_int + 8 as libc::c_int & 15 as libc::c_int) as usize]
            ^ (*block).l[(68 as libc::c_int + 2 as libc::c_int & 15 as libc::c_int) as usize]
            ^ (*block).l[(68 as libc::c_int & 15 as libc::c_int) as usize])
            >> 32 as libc::c_int - 1 as libc::c_int;
    b = (b as libc::c_uint).wrapping_add(
        (d ^ e ^ a)
            .wrapping_add((*block).l[(68 as libc::c_int & 15 as libc::c_int) as usize])
            .wrapping_add(0xca62c1d6 as libc::c_uint)
            .wrapping_add(c << 5 as libc::c_int | c >> 32 as libc::c_int - 5 as libc::c_int),
    ) as sha1_quadbyte as sha1_quadbyte;
    d = d << 30 as libc::c_int | d >> 32 as libc::c_int - 30 as libc::c_int;
    (*block).l[(69 as libc::c_int & 15 as libc::c_int) as usize] = ((*block).l
        [(69 as libc::c_int + 13 as libc::c_int & 15 as libc::c_int) as usize]
        ^ (*block).l[(69 as libc::c_int + 8 as libc::c_int & 15 as libc::c_int) as usize]
        ^ (*block).l[(69 as libc::c_int + 2 as libc::c_int & 15 as libc::c_int) as usize]
        ^ (*block).l[(69 as libc::c_int & 15 as libc::c_int) as usize])
        << 1 as libc::c_int
        | ((*block).l[(69 as libc::c_int + 13 as libc::c_int & 15 as libc::c_int) as usize]
            ^ (*block).l[(69 as libc::c_int + 8 as libc::c_int & 15 as libc::c_int) as usize]
            ^ (*block).l[(69 as libc::c_int + 2 as libc::c_int & 15 as libc::c_int) as usize]
            ^ (*block).l[(69 as libc::c_int & 15 as libc::c_int) as usize])
            >> 32 as libc::c_int - 1 as libc::c_int;
    a = (a as libc::c_uint).wrapping_add(
        (c ^ d ^ e)
            .wrapping_add((*block).l[(69 as libc::c_int & 15 as libc::c_int) as usize])
            .wrapping_add(0xca62c1d6 as libc::c_uint)
            .wrapping_add(b << 5 as libc::c_int | b >> 32 as libc::c_int - 5 as libc::c_int),
    ) as sha1_quadbyte as sha1_quadbyte;
    c = c << 30 as libc::c_int | c >> 32 as libc::c_int - 30 as libc::c_int;
    (*block).l[(70 as libc::c_int & 15 as libc::c_int) as usize] = ((*block).l
        [(70 as libc::c_int + 13 as libc::c_int & 15 as libc::c_int) as usize]
        ^ (*block).l[(70 as libc::c_int + 8 as libc::c_int & 15 as libc::c_int) as usize]
        ^ (*block).l[(70 as libc::c_int + 2 as libc::c_int & 15 as libc::c_int) as usize]
        ^ (*block).l[(70 as libc::c_int & 15 as libc::c_int) as usize])
        << 1 as libc::c_int
        | ((*block).l[(70 as libc::c_int + 13 as libc::c_int & 15 as libc::c_int) as usize]
            ^ (*block).l[(70 as libc::c_int + 8 as libc::c_int & 15 as libc::c_int) as usize]
            ^ (*block).l[(70 as libc::c_int + 2 as libc::c_int & 15 as libc::c_int) as usize]
            ^ (*block).l[(70 as libc::c_int & 15 as libc::c_int) as usize])
            >> 32 as libc::c_int - 1 as libc::c_int;
    e = (e as libc::c_uint).wrapping_add(
        (b ^ c ^ d)
            .wrapping_add((*block).l[(70 as libc::c_int & 15 as libc::c_int) as usize])
            .wrapping_add(0xca62c1d6 as libc::c_uint)
            .wrapping_add(a << 5 as libc::c_int | a >> 32 as libc::c_int - 5 as libc::c_int),
    ) as sha1_quadbyte as sha1_quadbyte;
    b = b << 30 as libc::c_int | b >> 32 as libc::c_int - 30 as libc::c_int;
    (*block).l[(71 as libc::c_int & 15 as libc::c_int) as usize] = ((*block).l
        [(71 as libc::c_int + 13 as libc::c_int & 15 as libc::c_int) as usize]
        ^ (*block).l[(71 as libc::c_int + 8 as libc::c_int & 15 as libc::c_int) as usize]
        ^ (*block).l[(71 as libc::c_int + 2 as libc::c_int & 15 as libc::c_int) as usize]
        ^ (*block).l[(71 as libc::c_int & 15 as libc::c_int) as usize])
        << 1 as libc::c_int
        | ((*block).l[(71 as libc::c_int + 13 as libc::c_int & 15 as libc::c_int) as usize]
            ^ (*block).l[(71 as libc::c_int + 8 as libc::c_int & 15 as libc::c_int) as usize]
            ^ (*block).l[(71 as libc::c_int + 2 as libc::c_int & 15 as libc::c_int) as usize]
            ^ (*block).l[(71 as libc::c_int & 15 as libc::c_int) as usize])
            >> 32 as libc::c_int - 1 as libc::c_int;
    d = (d as libc::c_uint).wrapping_add(
        (a ^ b ^ c)
            .wrapping_add((*block).l[(71 as libc::c_int & 15 as libc::c_int) as usize])
            .wrapping_add(0xca62c1d6 as libc::c_uint)
            .wrapping_add(e << 5 as libc::c_int | e >> 32 as libc::c_int - 5 as libc::c_int),
    ) as sha1_quadbyte as sha1_quadbyte;
    a = a << 30 as libc::c_int | a >> 32 as libc::c_int - 30 as libc::c_int;
    (*block).l[(72 as libc::c_int & 15 as libc::c_int) as usize] = ((*block).l
        [(72 as libc::c_int + 13 as libc::c_int & 15 as libc::c_int) as usize]
        ^ (*block).l[(72 as libc::c_int + 8 as libc::c_int & 15 as libc::c_int) as usize]
        ^ (*block).l[(72 as libc::c_int + 2 as libc::c_int & 15 as libc::c_int) as usize]
        ^ (*block).l[(72 as libc::c_int & 15 as libc::c_int) as usize])
        << 1 as libc::c_int
        | ((*block).l[(72 as libc::c_int + 13 as libc::c_int & 15 as libc::c_int) as usize]
            ^ (*block).l[(72 as libc::c_int + 8 as libc::c_int & 15 as libc::c_int) as usize]
            ^ (*block).l[(72 as libc::c_int + 2 as libc::c_int & 15 as libc::c_int) as usize]
            ^ (*block).l[(72 as libc::c_int & 15 as libc::c_int) as usize])
            >> 32 as libc::c_int - 1 as libc::c_int;
    c = (c as libc::c_uint).wrapping_add(
        (e ^ a ^ b)
            .wrapping_add((*block).l[(72 as libc::c_int & 15 as libc::c_int) as usize])
            .wrapping_add(0xca62c1d6 as libc::c_uint)
            .wrapping_add(d << 5 as libc::c_int | d >> 32 as libc::c_int - 5 as libc::c_int),
    ) as sha1_quadbyte as sha1_quadbyte;
    e = e << 30 as libc::c_int | e >> 32 as libc::c_int - 30 as libc::c_int;
    (*block).l[(73 as libc::c_int & 15 as libc::c_int) as usize] = ((*block).l
        [(73 as libc::c_int + 13 as libc::c_int & 15 as libc::c_int) as usize]
        ^ (*block).l[(73 as libc::c_int + 8 as libc::c_int & 15 as libc::c_int) as usize]
        ^ (*block).l[(73 as libc::c_int + 2 as libc::c_int & 15 as libc::c_int) as usize]
        ^ (*block).l[(73 as libc::c_int & 15 as libc::c_int) as usize])
        << 1 as libc::c_int
        | ((*block).l[(73 as libc::c_int + 13 as libc::c_int & 15 as libc::c_int) as usize]
            ^ (*block).l[(73 as libc::c_int + 8 as libc::c_int & 15 as libc::c_int) as usize]
            ^ (*block).l[(73 as libc::c_int + 2 as libc::c_int & 15 as libc::c_int) as usize]
            ^ (*block).l[(73 as libc::c_int & 15 as libc::c_int) as usize])
            >> 32 as libc::c_int - 1 as libc::c_int;
    b = (b as libc::c_uint).wrapping_add(
        (d ^ e ^ a)
            .wrapping_add((*block).l[(73 as libc::c_int & 15 as libc::c_int) as usize])
            .wrapping_add(0xca62c1d6 as libc::c_uint)
            .wrapping_add(c << 5 as libc::c_int | c >> 32 as libc::c_int - 5 as libc::c_int),
    ) as sha1_quadbyte as sha1_quadbyte;
    d = d << 30 as libc::c_int | d >> 32 as libc::c_int - 30 as libc::c_int;
    (*block).l[(74 as libc::c_int & 15 as libc::c_int) as usize] = ((*block).l
        [(74 as libc::c_int + 13 as libc::c_int & 15 as libc::c_int) as usize]
        ^ (*block).l[(74 as libc::c_int + 8 as libc::c_int & 15 as libc::c_int) as usize]
        ^ (*block).l[(74 as libc::c_int + 2 as libc::c_int & 15 as libc::c_int) as usize]
        ^ (*block).l[(74 as libc::c_int & 15 as libc::c_int) as usize])
        << 1 as libc::c_int
        | ((*block).l[(74 as libc::c_int + 13 as libc::c_int & 15 as libc::c_int) as usize]
            ^ (*block).l[(74 as libc::c_int + 8 as libc::c_int & 15 as libc::c_int) as usize]
            ^ (*block).l[(74 as libc::c_int + 2 as libc::c_int & 15 as libc::c_int) as usize]
            ^ (*block).l[(74 as libc::c_int & 15 as libc::c_int) as usize])
            >> 32 as libc::c_int - 1 as libc::c_int;
    a = (a as libc::c_uint).wrapping_add(
        (c ^ d ^ e)
            .wrapping_add((*block).l[(74 as libc::c_int & 15 as libc::c_int) as usize])
            .wrapping_add(0xca62c1d6 as libc::c_uint)
            .wrapping_add(b << 5 as libc::c_int | b >> 32 as libc::c_int - 5 as libc::c_int),
    ) as sha1_quadbyte as sha1_quadbyte;
    c = c << 30 as libc::c_int | c >> 32 as libc::c_int - 30 as libc::c_int;
    (*block).l[(75 as libc::c_int & 15 as libc::c_int) as usize] = ((*block).l
        [(75 as libc::c_int + 13 as libc::c_int & 15 as libc::c_int) as usize]
        ^ (*block).l[(75 as libc::c_int + 8 as libc::c_int & 15 as libc::c_int) as usize]
        ^ (*block).l[(75 as libc::c_int + 2 as libc::c_int & 15 as libc::c_int) as usize]
        ^ (*block).l[(75 as libc::c_int & 15 as libc::c_int) as usize])
        << 1 as libc::c_int
        | ((*block).l[(75 as libc::c_int + 13 as libc::c_int & 15 as libc::c_int) as usize]
            ^ (*block).l[(75 as libc::c_int + 8 as libc::c_int & 15 as libc::c_int) as usize]
            ^ (*block).l[(75 as libc::c_int + 2 as libc::c_int & 15 as libc::c_int) as usize]
            ^ (*block).l[(75 as libc::c_int & 15 as libc::c_int) as usize])
            >> 32 as libc::c_int - 1 as libc::c_int;
    e = (e as libc::c_uint).wrapping_add(
        (b ^ c ^ d)
            .wrapping_add((*block).l[(75 as libc::c_int & 15 as libc::c_int) as usize])
            .wrapping_add(0xca62c1d6 as libc::c_uint)
            .wrapping_add(a << 5 as libc::c_int | a >> 32 as libc::c_int - 5 as libc::c_int),
    ) as sha1_quadbyte as sha1_quadbyte;
    b = b << 30 as libc::c_int | b >> 32 as libc::c_int - 30 as libc::c_int;
    (*block).l[(76 as libc::c_int & 15 as libc::c_int) as usize] = ((*block).l
        [(76 as libc::c_int + 13 as libc::c_int & 15 as libc::c_int) as usize]
        ^ (*block).l[(76 as libc::c_int + 8 as libc::c_int & 15 as libc::c_int) as usize]
        ^ (*block).l[(76 as libc::c_int + 2 as libc::c_int & 15 as libc::c_int) as usize]
        ^ (*block).l[(76 as libc::c_int & 15 as libc::c_int) as usize])
        << 1 as libc::c_int
        | ((*block).l[(76 as libc::c_int + 13 as libc::c_int & 15 as libc::c_int) as usize]
            ^ (*block).l[(76 as libc::c_int + 8 as libc::c_int & 15 as libc::c_int) as usize]
            ^ (*block).l[(76 as libc::c_int + 2 as libc::c_int & 15 as libc::c_int) as usize]
            ^ (*block).l[(76 as libc::c_int & 15 as libc::c_int) as usize])
            >> 32 as libc::c_int - 1 as libc::c_int;
    d = (d as libc::c_uint).wrapping_add(
        (a ^ b ^ c)
            .wrapping_add((*block).l[(76 as libc::c_int & 15 as libc::c_int) as usize])
            .wrapping_add(0xca62c1d6 as libc::c_uint)
            .wrapping_add(e << 5 as libc::c_int | e >> 32 as libc::c_int - 5 as libc::c_int),
    ) as sha1_quadbyte as sha1_quadbyte;
    a = a << 30 as libc::c_int | a >> 32 as libc::c_int - 30 as libc::c_int;
    (*block).l[(77 as libc::c_int & 15 as libc::c_int) as usize] = ((*block).l
        [(77 as libc::c_int + 13 as libc::c_int & 15 as libc::c_int) as usize]
        ^ (*block).l[(77 as libc::c_int + 8 as libc::c_int & 15 as libc::c_int) as usize]
        ^ (*block).l[(77 as libc::c_int + 2 as libc::c_int & 15 as libc::c_int) as usize]
        ^ (*block).l[(77 as libc::c_int & 15 as libc::c_int) as usize])
        << 1 as libc::c_int
        | ((*block).l[(77 as libc::c_int + 13 as libc::c_int & 15 as libc::c_int) as usize]
            ^ (*block).l[(77 as libc::c_int + 8 as libc::c_int & 15 as libc::c_int) as usize]
            ^ (*block).l[(77 as libc::c_int + 2 as libc::c_int & 15 as libc::c_int) as usize]
            ^ (*block).l[(77 as libc::c_int & 15 as libc::c_int) as usize])
            >> 32 as libc::c_int - 1 as libc::c_int;
    c = (c as libc::c_uint).wrapping_add(
        (e ^ a ^ b)
            .wrapping_add((*block).l[(77 as libc::c_int & 15 as libc::c_int) as usize])
            .wrapping_add(0xca62c1d6 as libc::c_uint)
            .wrapping_add(d << 5 as libc::c_int | d >> 32 as libc::c_int - 5 as libc::c_int),
    ) as sha1_quadbyte as sha1_quadbyte;
    e = e << 30 as libc::c_int | e >> 32 as libc::c_int - 30 as libc::c_int;
    (*block).l[(78 as libc::c_int & 15 as libc::c_int) as usize] = ((*block).l
        [(78 as libc::c_int + 13 as libc::c_int & 15 as libc::c_int) as usize]
        ^ (*block).l[(78 as libc::c_int + 8 as libc::c_int & 15 as libc::c_int) as usize]
        ^ (*block).l[(78 as libc::c_int + 2 as libc::c_int & 15 as libc::c_int) as usize]
        ^ (*block).l[(78 as libc::c_int & 15 as libc::c_int) as usize])
        << 1 as libc::c_int
        | ((*block).l[(78 as libc::c_int + 13 as libc::c_int & 15 as libc::c_int) as usize]
            ^ (*block).l[(78 as libc::c_int + 8 as libc::c_int & 15 as libc::c_int) as usize]
            ^ (*block).l[(78 as libc::c_int + 2 as libc::c_int & 15 as libc::c_int) as usize]
            ^ (*block).l[(78 as libc::c_int & 15 as libc::c_int) as usize])
            >> 32 as libc::c_int - 1 as libc::c_int;
    b = (b as libc::c_uint).wrapping_add(
        (d ^ e ^ a)
            .wrapping_add((*block).l[(78 as libc::c_int & 15 as libc::c_int) as usize])
            .wrapping_add(0xca62c1d6 as libc::c_uint)
            .wrapping_add(c << 5 as libc::c_int | c >> 32 as libc::c_int - 5 as libc::c_int),
    ) as sha1_quadbyte as sha1_quadbyte;
    d = d << 30 as libc::c_int | d >> 32 as libc::c_int - 30 as libc::c_int;
    (*block).l[(79 as libc::c_int & 15 as libc::c_int) as usize] = ((*block).l
        [(79 as libc::c_int + 13 as libc::c_int & 15 as libc::c_int) as usize]
        ^ (*block).l[(79 as libc::c_int + 8 as libc::c_int & 15 as libc::c_int) as usize]
        ^ (*block).l[(79 as libc::c_int + 2 as libc::c_int & 15 as libc::c_int) as usize]
        ^ (*block).l[(79 as libc::c_int & 15 as libc::c_int) as usize])
        << 1 as libc::c_int
        | ((*block).l[(79 as libc::c_int + 13 as libc::c_int & 15 as libc::c_int) as usize]
            ^ (*block).l[(79 as libc::c_int + 8 as libc::c_int & 15 as libc::c_int) as usize]
            ^ (*block).l[(79 as libc::c_int + 2 as libc::c_int & 15 as libc::c_int) as usize]
            ^ (*block).l[(79 as libc::c_int & 15 as libc::c_int) as usize])
            >> 32 as libc::c_int - 1 as libc::c_int;
    a = (a as libc::c_uint).wrapping_add(
        (c ^ d ^ e)
            .wrapping_add((*block).l[(79 as libc::c_int & 15 as libc::c_int) as usize])
            .wrapping_add(0xca62c1d6 as libc::c_uint)
            .wrapping_add(b << 5 as libc::c_int | b >> 32 as libc::c_int - 5 as libc::c_int),
    ) as sha1_quadbyte as sha1_quadbyte;
    c = c << 30 as libc::c_int | c >> 32 as libc::c_int - 30 as libc::c_int;
    let ref mut fresh240 = *state.offset(0 as libc::c_int as isize);
    *fresh240 = (*fresh240 as libc::c_uint).wrapping_add(a) as sha1_quadbyte as sha1_quadbyte;
    let ref mut fresh241 = *state.offset(1 as libc::c_int as isize);
    *fresh241 = (*fresh241 as libc::c_uint).wrapping_add(b) as sha1_quadbyte as sha1_quadbyte;
    let ref mut fresh242 = *state.offset(2 as libc::c_int as isize);
    *fresh242 = (*fresh242 as libc::c_uint).wrapping_add(c) as sha1_quadbyte as sha1_quadbyte;
    let ref mut fresh243 = *state.offset(3 as libc::c_int as isize);
    *fresh243 = (*fresh243 as libc::c_uint).wrapping_add(d) as sha1_quadbyte as sha1_quadbyte;
    let ref mut fresh244 = *state.offset(4 as libc::c_int as isize);
    *fresh244 = (*fresh244 as libc::c_uint).wrapping_add(e) as sha1_quadbyte as sha1_quadbyte;
    e = 0 as libc::c_int as sha1_quadbyte;
    d = e;
    c = d;
    b = c;
    a = b;
}
#[no_mangle]
pub unsafe extern "C" fn SHA1_Init(mut context: *mut SHA_CTX) {
    (*context).state[0 as libc::c_int as usize] = 0x67452301 as libc::c_int as sha1_quadbyte;
    (*context).state[1 as libc::c_int as usize] = 0xefcdab89 as libc::c_uint;
    (*context).state[2 as libc::c_int as usize] = 0x98badcfe as libc::c_uint;
    (*context).state[3 as libc::c_int as usize] = 0x10325476 as libc::c_int as sha1_quadbyte;
    (*context).state[4 as libc::c_int as usize] = 0xc3d2e1f0 as libc::c_uint;
    (*context).count[1 as libc::c_int as usize] = 0 as libc::c_int as sha1_quadbyte;
    (*context).count[0 as libc::c_int as usize] = (*context).count[1 as libc::c_int as usize];
}
#[no_mangle]
pub unsafe extern "C" fn SHA1_Update(
    mut context: *mut SHA_CTX,
    mut data: *const sha1_byte,
    mut len: libc::c_uint,
) {
    let mut i: libc::c_uint = 0;
    let mut j: libc::c_uint = 0;
    j = (*context).count[0 as libc::c_int as usize] >> 3 as libc::c_int
        & 63 as libc::c_int as libc::c_uint;
    (*context).count[0 as libc::c_int as usize] =
        ((*context).count[0 as libc::c_int as usize] as libc::c_uint)
            .wrapping_add(len << 3 as libc::c_int) as sha1_quadbyte as sha1_quadbyte;
    if (*context).count[0 as libc::c_int as usize] < len << 3 as libc::c_int {
        (*context).count[1 as libc::c_int as usize] =
            ((*context).count[1 as libc::c_int as usize]).wrapping_add(1);
    }
    (*context).count[1 as libc::c_int as usize] =
        ((*context).count[1 as libc::c_int as usize] as libc::c_uint)
            .wrapping_add(len >> 29 as libc::c_int) as sha1_quadbyte as sha1_quadbyte;
    if j.wrapping_add(len) > 63 as libc::c_int as libc::c_uint {
        i = (64 as libc::c_int as libc::c_uint).wrapping_sub(j);
        memcpy(
            &mut *((*context).buffer).as_mut_ptr().offset(j as isize) as *mut sha1_byte
                as *mut libc::c_void,
            data as *const libc::c_void,
            i as libc::c_ulong,
        );
        SHA1_Transform(
            ((*context).state).as_mut_ptr(),
            ((*context).buffer).as_mut_ptr() as *const sha1_byte,
        );
        while i.wrapping_add(63 as libc::c_int as libc::c_uint) < len {
            SHA1_Transform(((*context).state).as_mut_ptr(), &*data.offset(i as isize));
            i = i.wrapping_add(64 as libc::c_int as libc::c_uint);
        }
        j = 0 as libc::c_int as libc::c_uint;
    } else {
        i = 0 as libc::c_int as libc::c_uint;
    }
    memcpy(
        &mut *((*context).buffer).as_mut_ptr().offset(j as isize) as *mut sha1_byte
            as *mut libc::c_void,
        &*data.offset(i as isize) as *const sha1_byte as *const libc::c_void,
        len.wrapping_sub(i) as libc::c_ulong,
    );
}
#[no_mangle]
pub unsafe extern "C" fn SHA1_Final(mut digest: *mut sha1_byte, mut context: *mut SHA_CTX) {
    let mut i: sha1_quadbyte = 0;
    let mut j: sha1_quadbyte = 0;
    let mut finalcount: [sha1_byte; 8] = [0; 8];
    i = 0 as libc::c_int as sha1_quadbyte;
    while i < 8 as libc::c_int as libc::c_uint {
        finalcount[i as usize] = ((*context).count[(if i >= 4 as libc::c_int as libc::c_uint {
            0 as libc::c_int
        } else {
            1 as libc::c_int
        }) as usize]
            >> (3 as libc::c_int as libc::c_uint)
                .wrapping_sub(i & 3 as libc::c_int as libc::c_uint)
                .wrapping_mul(8 as libc::c_int as libc::c_uint)
            & 255 as libc::c_int as libc::c_uint) as sha1_byte;
        i = i.wrapping_add(1);
    }
    SHA1_Update(
        context,
        b"\x80\0" as *const u8 as *const libc::c_char as *mut sha1_byte,
        1 as libc::c_int as libc::c_uint,
    );
    while (*context).count[0 as libc::c_int as usize] & 504 as libc::c_int as libc::c_uint
        != 448 as libc::c_int as libc::c_uint
    {
        SHA1_Update(
            context,
            b"\0\0" as *const u8 as *const libc::c_char as *mut sha1_byte,
            1 as libc::c_int as libc::c_uint,
        );
    }
    SHA1_Update(
        context,
        finalcount.as_mut_ptr(),
        8 as libc::c_int as libc::c_uint,
    );
    i = 0 as libc::c_int as sha1_quadbyte;
    while i < 20 as libc::c_int as libc::c_uint {
        *digest.offset(i as isize) = ((*context).state[(i >> 2 as libc::c_int) as usize]
            >> (3 as libc::c_int as libc::c_uint)
                .wrapping_sub(i & 3 as libc::c_int as libc::c_uint)
                .wrapping_mul(8 as libc::c_int as libc::c_uint)
            & 255 as libc::c_int as libc::c_uint) as sha1_byte;
        i = i.wrapping_add(1);
    }
    j = 0 as libc::c_int as sha1_quadbyte;
    i = j;
    memset(
        ((*context).buffer).as_mut_ptr() as *mut libc::c_void,
        0 as libc::c_int,
        64 as libc::c_int as libc::c_ulong,
    );
    memset(
        ((*context).state).as_mut_ptr() as *mut libc::c_void,
        0 as libc::c_int,
        20 as libc::c_int as libc::c_ulong,
    );
    memset(
        ((*context).count).as_mut_ptr() as *mut libc::c_void,
        0 as libc::c_int,
        8 as libc::c_int as libc::c_ulong,
    );
    memset(
        &mut finalcount as *mut [sha1_byte; 8] as *mut libc::c_void,
        0 as libc::c_int,
        8 as libc::c_int as libc::c_ulong,
    );
}
#[no_mangle]
pub unsafe extern "C" fn splaytree_splay(
    mut t: *mut splay_tree,
    mut i: libc::c_int,
) -> *mut splay_tree {
    let mut N: splay_tree = splay_tree {
        left: 0 as *mut tree_node,
        right: 0 as *mut tree_node,
        key: 0,
        data: 0 as *mut libc::c_void,
    };
    let mut l: *mut splay_tree = 0 as *mut splay_tree;
    let mut r: *mut splay_tree = 0 as *mut splay_tree;
    let mut y: *mut splay_tree = 0 as *mut splay_tree;
    let mut comp: libc::c_int = 0;
    if t.is_null() {
        return t;
    }
    N.right = 0 as *mut tree_node;
    N.left = N.right;
    r = &mut N;
    l = r;
    loop {
        comp = i - (*t).key;
        if comp < 0 as libc::c_int {
            if ((*t).left).is_null() {
                break;
            }
            if i - (*(*t).left).key < 0 as libc::c_int {
                y = (*t).left;
                (*t).left = (*y).right;
                (*y).right = t;
                t = y;
                if ((*t).left).is_null() {
                    break;
                }
            }
            (*r).left = t;
            r = t;
            t = (*t).left;
        } else {
            if !(comp > 0 as libc::c_int) {
                break;
            }
            if ((*t).right).is_null() {
                break;
            }
            if i - (*(*t).right).key > 0 as libc::c_int {
                y = (*t).right;
                (*t).right = (*y).left;
                (*y).left = t;
                t = y;
                if ((*t).right).is_null() {
                    break;
                }
            }
            (*l).right = t;
            l = t;
            t = (*t).right;
        }
    }
    (*l).right = (*t).left;
    (*r).left = (*t).right;
    (*t).left = N.right;
    (*t).right = N.left;
    return t;
}
#[no_mangle]
pub unsafe extern "C" fn splaytree_insert(
    mut t: *mut splay_tree,
    mut i: libc::c_int,
    mut data: *mut libc::c_void,
) -> *mut splay_tree {
    let mut new: *mut splay_tree = 0 as *mut splay_tree;
    if !t.is_null() {
        t = splaytree_splay(t, i);
        if i - (*t).key == 0 as libc::c_int {
            return t;
        }
    }
    new = malloc(::core::mem::size_of::<splay_tree>() as libc::c_ulong) as *mut splay_tree;
    if t.is_null() {
        (*new).right = 0 as *mut tree_node;
        (*new).left = (*new).right;
    } else if i - (*t).key < 0 as libc::c_int {
        (*new).left = (*t).left;
        (*new).right = t;
        (*t).left = 0 as *mut tree_node;
    } else {
        (*new).right = (*t).right;
        (*new).left = t;
        (*t).right = 0 as *mut tree_node;
    }
    (*new).key = i;
    (*new).data = data;
    return new;
}
#[no_mangle]
pub unsafe extern "C" fn splaytree_delete(
    mut t: *mut splay_tree,
    mut i: libc::c_int,
) -> *mut splay_tree {
    let mut x: *mut splay_tree = 0 as *mut splay_tree;
    if t.is_null() {
        return 0 as *mut splay_tree;
    }
    t = splaytree_splay(t, i);
    if i - (*t).key == 0 as libc::c_int {
        if ((*t).left).is_null() {
            x = (*t).right;
        } else {
            x = splaytree_splay((*t).left, i);
            (*x).right = (*t).right;
        }
        free(t as *mut libc::c_void);
        return x;
    } else {
        return t;
    };
}
static mut config_reference: C2RustUnnamed_13 = C2RustUnnamed_13 {
    data: 0 as *const *const data_config,
    used: 0,
};
#[no_mangle]
#[cold]
pub unsafe extern "C" fn config_get_config_cond_info(
    cfginfo: *mut config_cond_info,
    mut idx: uint32_t,
) {
    let dc: *const data_config = *(config_reference.data).offset(idx as isize) as *mut data_config;
    (*cfginfo).comp = (*dc).comp;
    (*cfginfo).cond = (*dc).cond;
    (*cfginfo).string = &(*dc).string;
    (*cfginfo).comp_key = (*dc).comp_key;
}
#[no_mangle]
#[cold]
pub unsafe extern "C" fn config_capture(mut srv: *mut server, mut idx: libc::c_int) -> libc::c_int {
    let dc: *mut data_config = *(config_reference.data).offset(idx as isize) as *mut data_config;
    return if (*dc).capture_idx != 0 {
        (*dc).capture_idx
    } else {
        (*srv).config_captures += 1;
        (*dc).capture_idx = (*srv).config_captures;
        (*dc).capture_idx
    };
}
#[no_mangle]
#[cold]
pub unsafe extern "C" fn config_feature_bool(
    mut srv: *const server,
    mut feature: *const libc::c_char,
    mut default_value: libc::c_int,
) -> libc::c_int {
    return if !((*srv).srvconf.feature_flags).is_null() {
        config_plugin_value_tobool(
            array_get_element_klen(
                (*srv).srvconf.feature_flags,
                feature,
                strlen(feature) as uint32_t,
            ),
            default_value,
        )
    } else {
        default_value
    };
}
#[no_mangle]
#[cold]
pub unsafe extern "C" fn config_feature_int(
    mut srv: *const server,
    mut feature: *const libc::c_char,
    mut default_value: int32_t,
) -> int32_t {
    return if !((*srv).srvconf.feature_flags).is_null() {
        config_plugin_value_to_int32(
            array_get_element_klen(
                (*srv).srvconf.feature_flags,
                feature,
                strlen(feature) as uint32_t,
            ),
            default_value,
        )
    } else {
        default_value
    };
}
#[no_mangle]
#[cold]
pub unsafe extern "C" fn config_plugin_value_tobool(
    mut du: *const data_unset,
    mut default_value: libc::c_int,
) -> libc::c_int {
    if du.is_null() {
        return default_value;
    }
    if (*du).type_0 as libc::c_uint == TYPE_STRING as libc::c_int as libc::c_uint {
        let mut b: *const buffer = &(*(du as *const data_string)).value;
        if buffer_eq_icase_slen(
            b,
            b"enable\0" as *const u8 as *const libc::c_char,
            (::core::mem::size_of::<[libc::c_char; 7]>() as libc::c_ulong as uint32_t)
                .wrapping_sub(1 as libc::c_int as libc::c_uint) as size_t,
        ) != 0
            || buffer_eq_icase_slen(
                b,
                b"enabled\0" as *const u8 as *const libc::c_char,
                (::core::mem::size_of::<[libc::c_char; 8]>() as libc::c_ulong as uint32_t)
                    .wrapping_sub(1 as libc::c_int as libc::c_uint) as size_t,
            ) != 0
            || buffer_eq_icase_slen(
                b,
                b"true\0" as *const u8 as *const libc::c_char,
                (::core::mem::size_of::<[libc::c_char; 5]>() as libc::c_ulong as uint32_t)
                    .wrapping_sub(1 as libc::c_int as libc::c_uint) as size_t,
            ) != 0
            || buffer_eq_icase_slen(
                b,
                b"1\0" as *const u8 as *const libc::c_char,
                (::core::mem::size_of::<[libc::c_char; 2]>() as libc::c_ulong as uint32_t)
                    .wrapping_sub(1 as libc::c_int as libc::c_uint) as size_t,
            ) != 0
        {
            return 1 as libc::c_int;
        } else if buffer_eq_icase_slen(
            b,
            b"disable\0" as *const u8 as *const libc::c_char,
            (::core::mem::size_of::<[libc::c_char; 8]>() as libc::c_ulong as uint32_t)
                .wrapping_sub(1 as libc::c_int as libc::c_uint) as size_t,
        ) != 0
            || buffer_eq_icase_slen(
                b,
                b"disabled\0" as *const u8 as *const libc::c_char,
                (::core::mem::size_of::<[libc::c_char; 9]>() as libc::c_ulong as uint32_t)
                    .wrapping_sub(1 as libc::c_int as libc::c_uint) as size_t,
            ) != 0
            || buffer_eq_icase_slen(
                b,
                b"false\0" as *const u8 as *const libc::c_char,
                (::core::mem::size_of::<[libc::c_char; 6]>() as libc::c_ulong as uint32_t)
                    .wrapping_sub(1 as libc::c_int as libc::c_uint) as size_t,
            ) != 0
            || buffer_eq_icase_slen(
                b,
                b"0\0" as *const u8 as *const libc::c_char,
                (::core::mem::size_of::<[libc::c_char; 2]>() as libc::c_ulong as uint32_t)
                    .wrapping_sub(1 as libc::c_int as libc::c_uint) as size_t,
            ) != 0
        {
            return 0 as libc::c_int;
        } else {
            return default_value;
        }
    } else if (*du).type_0 as libc::c_uint == TYPE_INTEGER as libc::c_int as libc::c_uint {
        return (0 as libc::c_int != (*(du as *const data_integer)).value) as libc::c_int;
    } else {
        return default_value;
    };
}
#[no_mangle]
#[cold]
pub unsafe extern "C" fn config_plugin_value_to_int32(
    mut du: *const data_unset,
    mut default_value: int32_t,
) -> int32_t {
    if du.is_null() {
        return default_value;
    }
    if (*du).type_0 as libc::c_uint == TYPE_STRING as libc::c_int as libc::c_uint {
        let b: *const buffer = &(*(du as *const data_string)).value;
        let mut err: *mut libc::c_char = 0 as *mut libc::c_char;
        let mut v: libc::c_long = strtol((*b).ptr, &mut err, 10 as libc::c_int);
        return if *err as libc::c_int == '\0' as i32
            && err != (*b).ptr
            && (-(2147483647 as libc::c_int) - 1 as libc::c_int) as libc::c_long <= v
            && v <= 2147483647 as libc::c_int as libc::c_long
        {
            v as int32_t
        } else {
            default_value
        };
    } else if (*du).type_0 as libc::c_uint == TYPE_INTEGER as libc::c_int as libc::c_uint {
        return (*(du as *const data_integer)).value;
    } else {
        return default_value;
    };
}
#[no_mangle]
#[cold]
pub unsafe extern "C" fn config_plugin_values_init_block(
    srv: *mut server,
    ca: *const array,
    cpk_3: *const config_plugin_keys_t,
    mname: *const libc::c_char,
    mut cpv: *mut config_plugin_value_t,
) -> libc::c_int {
    let mut rc: libc::c_int = 1 as libc::c_int;
    let mut current_block_37: u64;
    let mut i: libc::c_int = 0 as libc::c_int;
    while (*cpk_3.offset(i as isize)).ktype as libc::c_int != T_CONFIG_UNSET as libc::c_int {
        let du: *const data_unset = array_get_element_klen(
            ca,
            (*cpk_3.offset(i as isize)).k,
            (*cpk_3.offset(i as isize)).klen as uint32_t,
        );
        if !du.is_null() {
            (*cpv).k_id = i;
            (*cpv).vtype = (*cpk_3.offset(i as isize)).ktype as config_values_type_t;
            match (*cpk_3.offset(i as isize)).ktype as libc::c_int {
                5 | 6 | 7 | 8 | 9 => {
                    current_block_37 = 5772900442197213762;
                    match current_block_37 {
                        7343950298149844727 => {
                            let mut v_1: libc::c_int =
                                config_plugin_value_tobool(du, -(1 as libc::c_int));
                            if -(1 as libc::c_int) == v_1 {
                                log_error(
                                    (*srv).errh,
                                    b"/home/kkysen/work/rust/lighttpd/src/configfile-glue.c\0"
                                        as *const u8 as *const libc::c_char,
                                    259 as libc::c_int as libc::c_uint,
                                    b"ERROR: unexpected type for key: %s (string) \"(enable|disable)\"\0"
                                        as *const u8 as *const libc::c_char,
                                    (*cpk_3.offset(i as isize)).k,
                                );
                                rc = 0 as libc::c_int;
                                current_block_37 = 11174649648027449784;
                            } else {
                                (*cpv).v.u = v_1 as libc::c_uint;
                                current_block_37 = 7494008139977416618;
                            }
                        }
                        16999457480941319821 => match (*du).type_0 as libc::c_uint {
                            2 => {
                                (*cpv).v.u = (*(du as *const data_integer)).value as libc::c_uint;
                                current_block_37 = 7494008139977416618;
                            }
                            0 => {
                                let v_0: *const libc::c_char =
                                    (*(du as *const data_string)).value.ptr;
                                if !v_0.is_null() && *v_0 as libc::c_int != 0 {
                                    let mut e_0: *mut libc::c_char = 0 as *mut libc::c_char;
                                    let mut l_0: libc::c_long =
                                        strtol(v_0, &mut e_0, 10 as libc::c_int);
                                    if e_0 != v_0 as *mut libc::c_char
                                        && *e_0 == 0
                                        && l_0 >= 0 as libc::c_int as libc::c_long
                                    {
                                        (*cpv).v.shrt = l_0 as libc::c_uint as libc::c_ushort;
                                        current_block_37 = 7494008139977416618;
                                    } else {
                                        current_block_37 = 5891011138178424807;
                                    }
                                } else {
                                    current_block_37 = 5891011138178424807;
                                }
                                match current_block_37 {
                                    7494008139977416618 => {}
                                    _ => {
                                        log_error(
                                                (*srv).errh,
                                                b"/home/kkysen/work/rust/lighttpd/src/configfile-glue.c\0"
                                                    as *const u8 as *const libc::c_char,
                                                242 as libc::c_int as libc::c_uint,
                                                b"got a string but expected an integer: %s %s\0"
                                                    as *const u8 as *const libc::c_char,
                                                (*cpk_3.offset(i as isize)).k,
                                                v_0,
                                            );
                                        rc = 0 as libc::c_int;
                                        current_block_37 = 11174649648027449784;
                                    }
                                }
                            }
                            _ => {
                                log_error(
                                        (*srv).errh,
                                        b"/home/kkysen/work/rust/lighttpd/src/configfile-glue.c\0"
                                            as *const u8 as *const libc::c_char,
                                        248 as libc::c_int as libc::c_uint,
                                        b"unexpected type for key: %s %d expected an integer, range 0 ... 4294967295\0"
                                            as *const u8 as *const libc::c_char,
                                        (*cpk_3.offset(i as isize)).k,
                                        (*du).type_0 as libc::c_uint,
                                    );
                                rc = 0 as libc::c_int;
                                current_block_37 = 11174649648027449784;
                            }
                        },
                        8415733402176751844 => match (*du).type_0 as libc::c_uint {
                            2 => {
                                (*cpv).v.shrt =
                                    (*(du as *const data_integer)).value as libc::c_ushort;
                                current_block_37 = 7494008139977416618;
                            }
                            0 => {
                                let v: *const libc::c_char =
                                    (*(du as *const data_string)).value.ptr;
                                if !v.is_null() && *v as libc::c_int != 0 {
                                    let mut e: *mut libc::c_char = 0 as *mut libc::c_char;
                                    let mut l: libc::c_long = strtol(v, &mut e, 10 as libc::c_int);
                                    if e != v as *mut libc::c_char
                                        && *e == 0
                                        && l >= 0 as libc::c_int as libc::c_long
                                        && l <= 65535 as libc::c_int as libc::c_long
                                    {
                                        (*cpv).v.shrt = l as libc::c_ushort;
                                        current_block_37 = 7494008139977416618;
                                    } else {
                                        current_block_37 = 3123434771885419771;
                                    }
                                } else {
                                    current_block_37 = 3123434771885419771;
                                }
                                match current_block_37 {
                                    7494008139977416618 => {}
                                    _ => {
                                        log_error(
                                                (*srv).errh,
                                                b"/home/kkysen/work/rust/lighttpd/src/configfile-glue.c\0"
                                                    as *const u8 as *const libc::c_char,
                                                214 as libc::c_int as libc::c_uint,
                                                b"got a string but expected a short: %s %s\0" as *const u8
                                                    as *const libc::c_char,
                                                (*cpk_3.offset(i as isize)).k,
                                                v,
                                            );
                                        rc = 0 as libc::c_int;
                                        current_block_37 = 11174649648027449784;
                                    }
                                }
                            }
                            _ => {
                                log_error(
                                        (*srv).errh,
                                        b"/home/kkysen/work/rust/lighttpd/src/configfile-glue.c\0"
                                            as *const u8 as *const libc::c_char,
                                        220 as libc::c_int as libc::c_uint,
                                        b"unexpected type for key: %s %d expected a short integer, range 0 ... 65535\0"
                                            as *const u8 as *const libc::c_char,
                                        (*cpk_3.offset(i as isize)).k,
                                        (*du).type_0 as libc::c_uint,
                                    );
                                rc = 0 as libc::c_int;
                                current_block_37 = 11174649648027449784;
                            }
                        },
                        711017519835216269 => {
                            if (*du).type_0 as libc::c_uint
                                == TYPE_STRING as libc::c_int as libc::c_uint
                            {
                                (*cpv).v.b = &(*(du as *const data_string)).value;
                                current_block_37 = 7494008139977416618;
                            } else {
                                log_error(
                                    (*srv).errh,
                                    b"/home/kkysen/work/rust/lighttpd/src/configfile-glue.c\0"
                                        as *const u8
                                        as *const libc::c_char,
                                    186 as libc::c_int as libc::c_uint,
                                    b"%s should have been a string like ... = \"...\"\0"
                                        as *const u8
                                        as *const libc::c_char,
                                    (*cpk_3.offset(i as isize)).k,
                                );
                                rc = 0 as libc::c_int;
                                current_block_37 = 11174649648027449784;
                            }
                        }
                        5772900442197213762 => {
                            if (*du).type_0 as libc::c_uint
                                == TYPE_ARRAY as libc::c_int as libc::c_uint
                            {
                                (*cpv).v.a = &(*(du as *const data_array)).value;
                                match (*cpk_3.offset(i as isize)).ktype as libc::c_int {
                                    6 => {
                                        current_block_37 = 18094548196697502083;
                                        match current_block_37 {
                                            15359267663982909818 => {
                                                if array_is_vlist((*cpv).v.a) == 0 {
                                                    log_error(
                                                        (*srv).errh,
                                                        b"/home/kkysen/work/rust/lighttpd/src/configfile-glue.c\0"
                                                            as *const u8 as *const libc::c_char,
                                                        168 as libc::c_int as libc::c_uint,
                                                        b"%s should have been a list of string values like %s = ( \"...\", \"...\" )\0"
                                                            as *const u8 as *const libc::c_char,
                                                        (*cpk_3.offset(i as isize)).k,
                                                        (*cpk_3.offset(i as isize)).k,
                                                    );
                                                    rc = 0 as libc::c_int;
                                                    current_block_37 = 11174649648027449784;
                                                } else {
                                                    current_block_37 = 7494008139977416618;
                                                }
                                            }
                                            14601221856387937457 => {
                                                if array_is_kvarray((*cpv).v.a) == 0 {
                                                    log_error(
                                                        (*srv).errh,
                                                        b"/home/kkysen/work/rust/lighttpd/src/configfile-glue.c\0"
                                                            as *const u8 as *const libc::c_char,
                                                        148 as libc::c_int as libc::c_uint,
                                                        b"%s should have been a list of key => list like %s = ( \"...\" => ( \"...\" => \"...\" ) )\0"
                                                            as *const u8 as *const libc::c_char,
                                                        (*cpk_3.offset(i as isize)).k,
                                                        (*cpk_3.offset(i as isize)).k,
                                                    );
                                                    rc = 0 as libc::c_int;
                                                    current_block_37 = 11174649648027449784;
                                                } else {
                                                    current_block_37 = 7494008139977416618;
                                                }
                                            }
                                            18094548196697502083 => {
                                                if array_is_kvany((*cpv).v.a) == 0 {
                                                    log_error(
                                                        (*srv).errh,
                                                        b"/home/kkysen/work/rust/lighttpd/src/configfile-glue.c\0"
                                                            as *const u8 as *const libc::c_char,
                                                        138 as libc::c_int as libc::c_uint,
                                                        b"%s should have been a list of key => values like %s = ( \"...\" => \"...\", \"...\" => \"...\" )\0"
                                                            as *const u8 as *const libc::c_char,
                                                        (*cpk_3.offset(i as isize)).k,
                                                        (*cpk_3.offset(i as isize)).k,
                                                    );
                                                    rc = 0 as libc::c_int;
                                                    current_block_37 = 11174649648027449784;
                                                } else {
                                                    current_block_37 = 7494008139977416618;
                                                }
                                            }
                                            _ => {
                                                if array_is_kvstring((*cpv).v.a) == 0 {
                                                    log_error(
                                                        (*srv).errh,
                                                        b"/home/kkysen/work/rust/lighttpd/src/configfile-glue.c\0"
                                                            as *const u8 as *const libc::c_char,
                                                        158 as libc::c_int as libc::c_uint,
                                                        b"%s should have been a list of key => string values like %s = ( \"...\" => \"...\", \"...\" => \"...\" )\0"
                                                            as *const u8 as *const libc::c_char,
                                                        (*cpk_3.offset(i as isize)).k,
                                                        (*cpk_3.offset(i as isize)).k,
                                                    );
                                                    rc = 0 as libc::c_int;
                                                    current_block_37 = 11174649648027449784;
                                                } else {
                                                    current_block_37 = 7494008139977416618;
                                                }
                                            }
                                        }
                                    }
                                    7 => {
                                        current_block_37 = 14601221856387937457;
                                        match current_block_37 {
                                            15359267663982909818 => {
                                                if array_is_vlist((*cpv).v.a) == 0 {
                                                    log_error(
                                                        (*srv).errh,
                                                        b"/home/kkysen/work/rust/lighttpd/src/configfile-glue.c\0"
                                                            as *const u8 as *const libc::c_char,
                                                        168 as libc::c_int as libc::c_uint,
                                                        b"%s should have been a list of string values like %s = ( \"...\", \"...\" )\0"
                                                            as *const u8 as *const libc::c_char,
                                                        (*cpk_3.offset(i as isize)).k,
                                                        (*cpk_3.offset(i as isize)).k,
                                                    );
                                                    rc = 0 as libc::c_int;
                                                    current_block_37 = 11174649648027449784;
                                                } else {
                                                    current_block_37 = 7494008139977416618;
                                                }
                                            }
                                            14601221856387937457 => {
                                                if array_is_kvarray((*cpv).v.a) == 0 {
                                                    log_error(
                                                        (*srv).errh,
                                                        b"/home/kkysen/work/rust/lighttpd/src/configfile-glue.c\0"
                                                            as *const u8 as *const libc::c_char,
                                                        148 as libc::c_int as libc::c_uint,
                                                        b"%s should have been a list of key => list like %s = ( \"...\" => ( \"...\" => \"...\" ) )\0"
                                                            as *const u8 as *const libc::c_char,
                                                        (*cpk_3.offset(i as isize)).k,
                                                        (*cpk_3.offset(i as isize)).k,
                                                    );
                                                    rc = 0 as libc::c_int;
                                                    current_block_37 = 11174649648027449784;
                                                } else {
                                                    current_block_37 = 7494008139977416618;
                                                }
                                            }
                                            18094548196697502083 => {
                                                if array_is_kvany((*cpv).v.a) == 0 {
                                                    log_error(
                                                        (*srv).errh,
                                                        b"/home/kkysen/work/rust/lighttpd/src/configfile-glue.c\0"
                                                            as *const u8 as *const libc::c_char,
                                                        138 as libc::c_int as libc::c_uint,
                                                        b"%s should have been a list of key => values like %s = ( \"...\" => \"...\", \"...\" => \"...\" )\0"
                                                            as *const u8 as *const libc::c_char,
                                                        (*cpk_3.offset(i as isize)).k,
                                                        (*cpk_3.offset(i as isize)).k,
                                                    );
                                                    rc = 0 as libc::c_int;
                                                    current_block_37 = 11174649648027449784;
                                                } else {
                                                    current_block_37 = 7494008139977416618;
                                                }
                                            }
                                            _ => {
                                                if array_is_kvstring((*cpv).v.a) == 0 {
                                                    log_error(
                                                        (*srv).errh,
                                                        b"/home/kkysen/work/rust/lighttpd/src/configfile-glue.c\0"
                                                            as *const u8 as *const libc::c_char,
                                                        158 as libc::c_int as libc::c_uint,
                                                        b"%s should have been a list of key => string values like %s = ( \"...\" => \"...\", \"...\" => \"...\" )\0"
                                                            as *const u8 as *const libc::c_char,
                                                        (*cpk_3.offset(i as isize)).k,
                                                        (*cpk_3.offset(i as isize)).k,
                                                    );
                                                    rc = 0 as libc::c_int;
                                                    current_block_37 = 11174649648027449784;
                                                } else {
                                                    current_block_37 = 7494008139977416618;
                                                }
                                            }
                                        }
                                    }
                                    8 => {
                                        current_block_37 = 2973921165121704668;
                                        match current_block_37 {
                                            15359267663982909818 => {
                                                if array_is_vlist((*cpv).v.a) == 0 {
                                                    log_error(
                                                        (*srv).errh,
                                                        b"/home/kkysen/work/rust/lighttpd/src/configfile-glue.c\0"
                                                            as *const u8 as *const libc::c_char,
                                                        168 as libc::c_int as libc::c_uint,
                                                        b"%s should have been a list of string values like %s = ( \"...\", \"...\" )\0"
                                                            as *const u8 as *const libc::c_char,
                                                        (*cpk_3.offset(i as isize)).k,
                                                        (*cpk_3.offset(i as isize)).k,
                                                    );
                                                    rc = 0 as libc::c_int;
                                                    current_block_37 = 11174649648027449784;
                                                } else {
                                                    current_block_37 = 7494008139977416618;
                                                }
                                            }
                                            14601221856387937457 => {
                                                if array_is_kvarray((*cpv).v.a) == 0 {
                                                    log_error(
                                                        (*srv).errh,
                                                        b"/home/kkysen/work/rust/lighttpd/src/configfile-glue.c\0"
                                                            as *const u8 as *const libc::c_char,
                                                        148 as libc::c_int as libc::c_uint,
                                                        b"%s should have been a list of key => list like %s = ( \"...\" => ( \"...\" => \"...\" ) )\0"
                                                            as *const u8 as *const libc::c_char,
                                                        (*cpk_3.offset(i as isize)).k,
                                                        (*cpk_3.offset(i as isize)).k,
                                                    );
                                                    rc = 0 as libc::c_int;
                                                    current_block_37 = 11174649648027449784;
                                                } else {
                                                    current_block_37 = 7494008139977416618;
                                                }
                                            }
                                            18094548196697502083 => {
                                                if array_is_kvany((*cpv).v.a) == 0 {
                                                    log_error(
                                                        (*srv).errh,
                                                        b"/home/kkysen/work/rust/lighttpd/src/configfile-glue.c\0"
                                                            as *const u8 as *const libc::c_char,
                                                        138 as libc::c_int as libc::c_uint,
                                                        b"%s should have been a list of key => values like %s = ( \"...\" => \"...\", \"...\" => \"...\" )\0"
                                                            as *const u8 as *const libc::c_char,
                                                        (*cpk_3.offset(i as isize)).k,
                                                        (*cpk_3.offset(i as isize)).k,
                                                    );
                                                    rc = 0 as libc::c_int;
                                                    current_block_37 = 11174649648027449784;
                                                } else {
                                                    current_block_37 = 7494008139977416618;
                                                }
                                            }
                                            _ => {
                                                if array_is_kvstring((*cpv).v.a) == 0 {
                                                    log_error(
                                                        (*srv).errh,
                                                        b"/home/kkysen/work/rust/lighttpd/src/configfile-glue.c\0"
                                                            as *const u8 as *const libc::c_char,
                                                        158 as libc::c_int as libc::c_uint,
                                                        b"%s should have been a list of key => string values like %s = ( \"...\" => \"...\", \"...\" => \"...\" )\0"
                                                            as *const u8 as *const libc::c_char,
                                                        (*cpk_3.offset(i as isize)).k,
                                                        (*cpk_3.offset(i as isize)).k,
                                                    );
                                                    rc = 0 as libc::c_int;
                                                    current_block_37 = 11174649648027449784;
                                                } else {
                                                    current_block_37 = 7494008139977416618;
                                                }
                                            }
                                        }
                                    }
                                    9 => {
                                        current_block_37 = 15359267663982909818;
                                        match current_block_37 {
                                            15359267663982909818 => {
                                                if array_is_vlist((*cpv).v.a) == 0 {
                                                    log_error(
                                                        (*srv).errh,
                                                        b"/home/kkysen/work/rust/lighttpd/src/configfile-glue.c\0"
                                                            as *const u8 as *const libc::c_char,
                                                        168 as libc::c_int as libc::c_uint,
                                                        b"%s should have been a list of string values like %s = ( \"...\", \"...\" )\0"
                                                            as *const u8 as *const libc::c_char,
                                                        (*cpk_3.offset(i as isize)).k,
                                                        (*cpk_3.offset(i as isize)).k,
                                                    );
                                                    rc = 0 as libc::c_int;
                                                    current_block_37 = 11174649648027449784;
                                                } else {
                                                    current_block_37 = 7494008139977416618;
                                                }
                                            }
                                            14601221856387937457 => {
                                                if array_is_kvarray((*cpv).v.a) == 0 {
                                                    log_error(
                                                        (*srv).errh,
                                                        b"/home/kkysen/work/rust/lighttpd/src/configfile-glue.c\0"
                                                            as *const u8 as *const libc::c_char,
                                                        148 as libc::c_int as libc::c_uint,
                                                        b"%s should have been a list of key => list like %s = ( \"...\" => ( \"...\" => \"...\" ) )\0"
                                                            as *const u8 as *const libc::c_char,
                                                        (*cpk_3.offset(i as isize)).k,
                                                        (*cpk_3.offset(i as isize)).k,
                                                    );
                                                    rc = 0 as libc::c_int;
                                                    current_block_37 = 11174649648027449784;
                                                } else {
                                                    current_block_37 = 7494008139977416618;
                                                }
                                            }
                                            18094548196697502083 => {
                                                if array_is_kvany((*cpv).v.a) == 0 {
                                                    log_error(
                                                        (*srv).errh,
                                                        b"/home/kkysen/work/rust/lighttpd/src/configfile-glue.c\0"
                                                            as *const u8 as *const libc::c_char,
                                                        138 as libc::c_int as libc::c_uint,
                                                        b"%s should have been a list of key => values like %s = ( \"...\" => \"...\", \"...\" => \"...\" )\0"
                                                            as *const u8 as *const libc::c_char,
                                                        (*cpk_3.offset(i as isize)).k,
                                                        (*cpk_3.offset(i as isize)).k,
                                                    );
                                                    rc = 0 as libc::c_int;
                                                    current_block_37 = 11174649648027449784;
                                                } else {
                                                    current_block_37 = 7494008139977416618;
                                                }
                                            }
                                            _ => {
                                                if array_is_kvstring((*cpv).v.a) == 0 {
                                                    log_error(
                                                        (*srv).errh,
                                                        b"/home/kkysen/work/rust/lighttpd/src/configfile-glue.c\0"
                                                            as *const u8 as *const libc::c_char,
                                                        158 as libc::c_int as libc::c_uint,
                                                        b"%s should have been a list of key => string values like %s = ( \"...\" => \"...\", \"...\" => \"...\" )\0"
                                                            as *const u8 as *const libc::c_char,
                                                        (*cpk_3.offset(i as isize)).k,
                                                        (*cpk_3.offset(i as isize)).k,
                                                    );
                                                    rc = 0 as libc::c_int;
                                                    current_block_37 = 11174649648027449784;
                                                } else {
                                                    current_block_37 = 7494008139977416618;
                                                }
                                            }
                                        }
                                    }
                                    _ => {
                                        current_block_37 = 7494008139977416618;
                                    }
                                }
                            } else {
                                log_error(
                                    (*srv).errh,
                                    b"/home/kkysen/work/rust/lighttpd/src/configfile-glue.c\0"
                                        as *const u8
                                        as *const libc::c_char,
                                    129 as libc::c_int as libc::c_uint,
                                    b"%s should have been a list like %s = ( \"...\" )\0"
                                        as *const u8
                                        as *const libc::c_char,
                                    (*cpk_3.offset(i as isize)).k,
                                    (*cpk_3.offset(i as isize)).k,
                                );
                                rc = 0 as libc::c_int;
                                current_block_37 = 11174649648027449784;
                            }
                        }
                        4711845900019386151 => {
                            log_error(
                                (*srv).errh,
                                b"/home/kkysen/work/rust/lighttpd/src/configfile-glue.c\0"
                                    as *const u8
                                    as *const libc::c_char,
                                272 as libc::c_int as libc::c_uint,
                                b"ERROR: found unsupported key: %s (%s)\0" as *const u8
                                    as *const libc::c_char,
                                (*cpk_3.offset(i as isize)).k,
                                mname,
                            );
                            (*srv).srvconf.config_unsupported = 1 as libc::c_int as libc::c_uchar;
                            current_block_37 = 11174649648027449784;
                        }
                        8566665978537710866 => {
                            log_error(
                                (*srv).errh,
                                b"/home/kkysen/work/rust/lighttpd/src/configfile-glue.c\0"
                                    as *const u8
                                    as *const libc::c_char,
                                277 as libc::c_int as libc::c_uint,
                                b"ERROR: found deprecated key: %s (%s)\0" as *const u8
                                    as *const libc::c_char,
                                (*cpk_3.offset(i as isize)).k,
                                mname,
                            );
                            (*srv).srvconf.config_deprecated = 1 as libc::c_int as libc::c_uchar;
                            current_block_37 = 11174649648027449784;
                        }
                        _ => {}
                    }
                    match current_block_37 {
                        11174649648027449784 => {}
                        _ => {
                            cpv = cpv.offset(1);
                        }
                    }
                }
                1 => {
                    current_block_37 = 711017519835216269;
                    match current_block_37 {
                        7343950298149844727 => {
                            let mut v_1: libc::c_int =
                                config_plugin_value_tobool(du, -(1 as libc::c_int));
                            if -(1 as libc::c_int) == v_1 {
                                log_error(
                                    (*srv).errh,
                                    b"/home/kkysen/work/rust/lighttpd/src/configfile-glue.c\0"
                                        as *const u8 as *const libc::c_char,
                                    259 as libc::c_int as libc::c_uint,
                                    b"ERROR: unexpected type for key: %s (string) \"(enable|disable)\"\0"
                                        as *const u8 as *const libc::c_char,
                                    (*cpk_3.offset(i as isize)).k,
                                );
                                rc = 0 as libc::c_int;
                                current_block_37 = 11174649648027449784;
                            } else {
                                (*cpv).v.u = v_1 as libc::c_uint;
                                current_block_37 = 7494008139977416618;
                            }
                        }
                        16999457480941319821 => match (*du).type_0 as libc::c_uint {
                            2 => {
                                (*cpv).v.u = (*(du as *const data_integer)).value as libc::c_uint;
                                current_block_37 = 7494008139977416618;
                            }
                            0 => {
                                let v_0: *const libc::c_char =
                                    (*(du as *const data_string)).value.ptr;
                                if !v_0.is_null() && *v_0 as libc::c_int != 0 {
                                    let mut e_0: *mut libc::c_char = 0 as *mut libc::c_char;
                                    let mut l_0: libc::c_long =
                                        strtol(v_0, &mut e_0, 10 as libc::c_int);
                                    if e_0 != v_0 as *mut libc::c_char
                                        && *e_0 == 0
                                        && l_0 >= 0 as libc::c_int as libc::c_long
                                    {
                                        (*cpv).v.shrt = l_0 as libc::c_uint as libc::c_ushort;
                                        current_block_37 = 7494008139977416618;
                                    } else {
                                        current_block_37 = 5891011138178424807;
                                    }
                                } else {
                                    current_block_37 = 5891011138178424807;
                                }
                                match current_block_37 {
                                    7494008139977416618 => {}
                                    _ => {
                                        log_error(
                                                (*srv).errh,
                                                b"/home/kkysen/work/rust/lighttpd/src/configfile-glue.c\0"
                                                    as *const u8 as *const libc::c_char,
                                                242 as libc::c_int as libc::c_uint,
                                                b"got a string but expected an integer: %s %s\0"
                                                    as *const u8 as *const libc::c_char,
                                                (*cpk_3.offset(i as isize)).k,
                                                v_0,
                                            );
                                        rc = 0 as libc::c_int;
                                        current_block_37 = 11174649648027449784;
                                    }
                                }
                            }
                            _ => {
                                log_error(
                                        (*srv).errh,
                                        b"/home/kkysen/work/rust/lighttpd/src/configfile-glue.c\0"
                                            as *const u8 as *const libc::c_char,
                                        248 as libc::c_int as libc::c_uint,
                                        b"unexpected type for key: %s %d expected an integer, range 0 ... 4294967295\0"
                                            as *const u8 as *const libc::c_char,
                                        (*cpk_3.offset(i as isize)).k,
                                        (*du).type_0 as libc::c_uint,
                                    );
                                rc = 0 as libc::c_int;
                                current_block_37 = 11174649648027449784;
                            }
                        },
                        8415733402176751844 => match (*du).type_0 as libc::c_uint {
                            2 => {
                                (*cpv).v.shrt =
                                    (*(du as *const data_integer)).value as libc::c_ushort;
                                current_block_37 = 7494008139977416618;
                            }
                            0 => {
                                let v: *const libc::c_char =
                                    (*(du as *const data_string)).value.ptr;
                                if !v.is_null() && *v as libc::c_int != 0 {
                                    let mut e: *mut libc::c_char = 0 as *mut libc::c_char;
                                    let mut l: libc::c_long = strtol(v, &mut e, 10 as libc::c_int);
                                    if e != v as *mut libc::c_char
                                        && *e == 0
                                        && l >= 0 as libc::c_int as libc::c_long
                                        && l <= 65535 as libc::c_int as libc::c_long
                                    {
                                        (*cpv).v.shrt = l as libc::c_ushort;
                                        current_block_37 = 7494008139977416618;
                                    } else {
                                        current_block_37 = 3123434771885419771;
                                    }
                                } else {
                                    current_block_37 = 3123434771885419771;
                                }
                                match current_block_37 {
                                    7494008139977416618 => {}
                                    _ => {
                                        log_error(
                                                (*srv).errh,
                                                b"/home/kkysen/work/rust/lighttpd/src/configfile-glue.c\0"
                                                    as *const u8 as *const libc::c_char,
                                                214 as libc::c_int as libc::c_uint,
                                                b"got a string but expected a short: %s %s\0" as *const u8
                                                    as *const libc::c_char,
                                                (*cpk_3.offset(i as isize)).k,
                                                v,
                                            );
                                        rc = 0 as libc::c_int;
                                        current_block_37 = 11174649648027449784;
                                    }
                                }
                            }
                            _ => {
                                log_error(
                                        (*srv).errh,
                                        b"/home/kkysen/work/rust/lighttpd/src/configfile-glue.c\0"
                                            as *const u8 as *const libc::c_char,
                                        220 as libc::c_int as libc::c_uint,
                                        b"unexpected type for key: %s %d expected a short integer, range 0 ... 65535\0"
                                            as *const u8 as *const libc::c_char,
                                        (*cpk_3.offset(i as isize)).k,
                                        (*du).type_0 as libc::c_uint,
                                    );
                                rc = 0 as libc::c_int;
                                current_block_37 = 11174649648027449784;
                            }
                        },
                        711017519835216269 => {
                            if (*du).type_0 as libc::c_uint
                                == TYPE_STRING as libc::c_int as libc::c_uint
                            {
                                (*cpv).v.b = &(*(du as *const data_string)).value;
                                current_block_37 = 7494008139977416618;
                            } else {
                                log_error(
                                    (*srv).errh,
                                    b"/home/kkysen/work/rust/lighttpd/src/configfile-glue.c\0"
                                        as *const u8
                                        as *const libc::c_char,
                                    186 as libc::c_int as libc::c_uint,
                                    b"%s should have been a string like ... = \"...\"\0"
                                        as *const u8
                                        as *const libc::c_char,
                                    (*cpk_3.offset(i as isize)).k,
                                );
                                rc = 0 as libc::c_int;
                                current_block_37 = 11174649648027449784;
                            }
                        }
                        5772900442197213762 => {
                            if (*du).type_0 as libc::c_uint
                                == TYPE_ARRAY as libc::c_int as libc::c_uint
                            {
                                (*cpv).v.a = &(*(du as *const data_array)).value;
                                match (*cpk_3.offset(i as isize)).ktype as libc::c_int {
                                    6 => {
                                        current_block_37 = 18094548196697502083;
                                        match current_block_37 {
                                            15359267663982909818 => {
                                                if array_is_vlist((*cpv).v.a) == 0 {
                                                    log_error(
                                                        (*srv).errh,
                                                        b"/home/kkysen/work/rust/lighttpd/src/configfile-glue.c\0"
                                                            as *const u8 as *const libc::c_char,
                                                        168 as libc::c_int as libc::c_uint,
                                                        b"%s should have been a list of string values like %s = ( \"...\", \"...\" )\0"
                                                            as *const u8 as *const libc::c_char,
                                                        (*cpk_3.offset(i as isize)).k,
                                                        (*cpk_3.offset(i as isize)).k,
                                                    );
                                                    rc = 0 as libc::c_int;
                                                    current_block_37 = 11174649648027449784;
                                                } else {
                                                    current_block_37 = 7494008139977416618;
                                                }
                                            }
                                            14601221856387937457 => {
                                                if array_is_kvarray((*cpv).v.a) == 0 {
                                                    log_error(
                                                        (*srv).errh,
                                                        b"/home/kkysen/work/rust/lighttpd/src/configfile-glue.c\0"
                                                            as *const u8 as *const libc::c_char,
                                                        148 as libc::c_int as libc::c_uint,
                                                        b"%s should have been a list of key => list like %s = ( \"...\" => ( \"...\" => \"...\" ) )\0"
                                                            as *const u8 as *const libc::c_char,
                                                        (*cpk_3.offset(i as isize)).k,
                                                        (*cpk_3.offset(i as isize)).k,
                                                    );
                                                    rc = 0 as libc::c_int;
                                                    current_block_37 = 11174649648027449784;
                                                } else {
                                                    current_block_37 = 7494008139977416618;
                                                }
                                            }
                                            18094548196697502083 => {
                                                if array_is_kvany((*cpv).v.a) == 0 {
                                                    log_error(
                                                        (*srv).errh,
                                                        b"/home/kkysen/work/rust/lighttpd/src/configfile-glue.c\0"
                                                            as *const u8 as *const libc::c_char,
                                                        138 as libc::c_int as libc::c_uint,
                                                        b"%s should have been a list of key => values like %s = ( \"...\" => \"...\", \"...\" => \"...\" )\0"
                                                            as *const u8 as *const libc::c_char,
                                                        (*cpk_3.offset(i as isize)).k,
                                                        (*cpk_3.offset(i as isize)).k,
                                                    );
                                                    rc = 0 as libc::c_int;
                                                    current_block_37 = 11174649648027449784;
                                                } else {
                                                    current_block_37 = 7494008139977416618;
                                                }
                                            }
                                            _ => {
                                                if array_is_kvstring((*cpv).v.a) == 0 {
                                                    log_error(
                                                        (*srv).errh,
                                                        b"/home/kkysen/work/rust/lighttpd/src/configfile-glue.c\0"
                                                            as *const u8 as *const libc::c_char,
                                                        158 as libc::c_int as libc::c_uint,
                                                        b"%s should have been a list of key => string values like %s = ( \"...\" => \"...\", \"...\" => \"...\" )\0"
                                                            as *const u8 as *const libc::c_char,
                                                        (*cpk_3.offset(i as isize)).k,
                                                        (*cpk_3.offset(i as isize)).k,
                                                    );
                                                    rc = 0 as libc::c_int;
                                                    current_block_37 = 11174649648027449784;
                                                } else {
                                                    current_block_37 = 7494008139977416618;
                                                }
                                            }
                                        }
                                    }
                                    7 => {
                                        current_block_37 = 14601221856387937457;
                                        match current_block_37 {
                                            15359267663982909818 => {
                                                if array_is_vlist((*cpv).v.a) == 0 {
                                                    log_error(
                                                        (*srv).errh,
                                                        b"/home/kkysen/work/rust/lighttpd/src/configfile-glue.c\0"
                                                            as *const u8 as *const libc::c_char,
                                                        168 as libc::c_int as libc::c_uint,
                                                        b"%s should have been a list of string values like %s = ( \"...\", \"...\" )\0"
                                                            as *const u8 as *const libc::c_char,
                                                        (*cpk_3.offset(i as isize)).k,
                                                        (*cpk_3.offset(i as isize)).k,
                                                    );
                                                    rc = 0 as libc::c_int;
                                                    current_block_37 = 11174649648027449784;
                                                } else {
                                                    current_block_37 = 7494008139977416618;
                                                }
                                            }
                                            14601221856387937457 => {
                                                if array_is_kvarray((*cpv).v.a) == 0 {
                                                    log_error(
                                                        (*srv).errh,
                                                        b"/home/kkysen/work/rust/lighttpd/src/configfile-glue.c\0"
                                                            as *const u8 as *const libc::c_char,
                                                        148 as libc::c_int as libc::c_uint,
                                                        b"%s should have been a list of key => list like %s = ( \"...\" => ( \"...\" => \"...\" ) )\0"
                                                            as *const u8 as *const libc::c_char,
                                                        (*cpk_3.offset(i as isize)).k,
                                                        (*cpk_3.offset(i as isize)).k,
                                                    );
                                                    rc = 0 as libc::c_int;
                                                    current_block_37 = 11174649648027449784;
                                                } else {
                                                    current_block_37 = 7494008139977416618;
                                                }
                                            }
                                            18094548196697502083 => {
                                                if array_is_kvany((*cpv).v.a) == 0 {
                                                    log_error(
                                                        (*srv).errh,
                                                        b"/home/kkysen/work/rust/lighttpd/src/configfile-glue.c\0"
                                                            as *const u8 as *const libc::c_char,
                                                        138 as libc::c_int as libc::c_uint,
                                                        b"%s should have been a list of key => values like %s = ( \"...\" => \"...\", \"...\" => \"...\" )\0"
                                                            as *const u8 as *const libc::c_char,
                                                        (*cpk_3.offset(i as isize)).k,
                                                        (*cpk_3.offset(i as isize)).k,
                                                    );
                                                    rc = 0 as libc::c_int;
                                                    current_block_37 = 11174649648027449784;
                                                } else {
                                                    current_block_37 = 7494008139977416618;
                                                }
                                            }
                                            _ => {
                                                if array_is_kvstring((*cpv).v.a) == 0 {
                                                    log_error(
                                                        (*srv).errh,
                                                        b"/home/kkysen/work/rust/lighttpd/src/configfile-glue.c\0"
                                                            as *const u8 as *const libc::c_char,
                                                        158 as libc::c_int as libc::c_uint,
                                                        b"%s should have been a list of key => string values like %s = ( \"...\" => \"...\", \"...\" => \"...\" )\0"
                                                            as *const u8 as *const libc::c_char,
                                                        (*cpk_3.offset(i as isize)).k,
                                                        (*cpk_3.offset(i as isize)).k,
                                                    );
                                                    rc = 0 as libc::c_int;
                                                    current_block_37 = 11174649648027449784;
                                                } else {
                                                    current_block_37 = 7494008139977416618;
                                                }
                                            }
                                        }
                                    }
                                    8 => {
                                        current_block_37 = 2973921165121704668;
                                        match current_block_37 {
                                            15359267663982909818 => {
                                                if array_is_vlist((*cpv).v.a) == 0 {
                                                    log_error(
                                                        (*srv).errh,
                                                        b"/home/kkysen/work/rust/lighttpd/src/configfile-glue.c\0"
                                                            as *const u8 as *const libc::c_char,
                                                        168 as libc::c_int as libc::c_uint,
                                                        b"%s should have been a list of string values like %s = ( \"...\", \"...\" )\0"
                                                            as *const u8 as *const libc::c_char,
                                                        (*cpk_3.offset(i as isize)).k,
                                                        (*cpk_3.offset(i as isize)).k,
                                                    );
                                                    rc = 0 as libc::c_int;
                                                    current_block_37 = 11174649648027449784;
                                                } else {
                                                    current_block_37 = 7494008139977416618;
                                                }
                                            }
                                            14601221856387937457 => {
                                                if array_is_kvarray((*cpv).v.a) == 0 {
                                                    log_error(
                                                        (*srv).errh,
                                                        b"/home/kkysen/work/rust/lighttpd/src/configfile-glue.c\0"
                                                            as *const u8 as *const libc::c_char,
                                                        148 as libc::c_int as libc::c_uint,
                                                        b"%s should have been a list of key => list like %s = ( \"...\" => ( \"...\" => \"...\" ) )\0"
                                                            as *const u8 as *const libc::c_char,
                                                        (*cpk_3.offset(i as isize)).k,
                                                        (*cpk_3.offset(i as isize)).k,
                                                    );
                                                    rc = 0 as libc::c_int;
                                                    current_block_37 = 11174649648027449784;
                                                } else {
                                                    current_block_37 = 7494008139977416618;
                                                }
                                            }
                                            18094548196697502083 => {
                                                if array_is_kvany((*cpv).v.a) == 0 {
                                                    log_error(
                                                        (*srv).errh,
                                                        b"/home/kkysen/work/rust/lighttpd/src/configfile-glue.c\0"
                                                            as *const u8 as *const libc::c_char,
                                                        138 as libc::c_int as libc::c_uint,
                                                        b"%s should have been a list of key => values like %s = ( \"...\" => \"...\", \"...\" => \"...\" )\0"
                                                            as *const u8 as *const libc::c_char,
                                                        (*cpk_3.offset(i as isize)).k,
                                                        (*cpk_3.offset(i as isize)).k,
                                                    );
                                                    rc = 0 as libc::c_int;
                                                    current_block_37 = 11174649648027449784;
                                                } else {
                                                    current_block_37 = 7494008139977416618;
                                                }
                                            }
                                            _ => {
                                                if array_is_kvstring((*cpv).v.a) == 0 {
                                                    log_error(
                                                        (*srv).errh,
                                                        b"/home/kkysen/work/rust/lighttpd/src/configfile-glue.c\0"
                                                            as *const u8 as *const libc::c_char,
                                                        158 as libc::c_int as libc::c_uint,
                                                        b"%s should have been a list of key => string values like %s = ( \"...\" => \"...\", \"...\" => \"...\" )\0"
                                                            as *const u8 as *const libc::c_char,
                                                        (*cpk_3.offset(i as isize)).k,
                                                        (*cpk_3.offset(i as isize)).k,
                                                    );
                                                    rc = 0 as libc::c_int;
                                                    current_block_37 = 11174649648027449784;
                                                } else {
                                                    current_block_37 = 7494008139977416618;
                                                }
                                            }
                                        }
                                    }
                                    9 => {
                                        current_block_37 = 15359267663982909818;
                                        match current_block_37 {
                                            15359267663982909818 => {
                                                if array_is_vlist((*cpv).v.a) == 0 {
                                                    log_error(
                                                        (*srv).errh,
                                                        b"/home/kkysen/work/rust/lighttpd/src/configfile-glue.c\0"
                                                            as *const u8 as *const libc::c_char,
                                                        168 as libc::c_int as libc::c_uint,
                                                        b"%s should have been a list of string values like %s = ( \"...\", \"...\" )\0"
                                                            as *const u8 as *const libc::c_char,
                                                        (*cpk_3.offset(i as isize)).k,
                                                        (*cpk_3.offset(i as isize)).k,
                                                    );
                                                    rc = 0 as libc::c_int;
                                                    current_block_37 = 11174649648027449784;
                                                } else {
                                                    current_block_37 = 7494008139977416618;
                                                }
                                            }
                                            14601221856387937457 => {
                                                if array_is_kvarray((*cpv).v.a) == 0 {
                                                    log_error(
                                                        (*srv).errh,
                                                        b"/home/kkysen/work/rust/lighttpd/src/configfile-glue.c\0"
                                                            as *const u8 as *const libc::c_char,
                                                        148 as libc::c_int as libc::c_uint,
                                                        b"%s should have been a list of key => list like %s = ( \"...\" => ( \"...\" => \"...\" ) )\0"
                                                            as *const u8 as *const libc::c_char,
                                                        (*cpk_3.offset(i as isize)).k,
                                                        (*cpk_3.offset(i as isize)).k,
                                                    );
                                                    rc = 0 as libc::c_int;
                                                    current_block_37 = 11174649648027449784;
                                                } else {
                                                    current_block_37 = 7494008139977416618;
                                                }
                                            }
                                            18094548196697502083 => {
                                                if array_is_kvany((*cpv).v.a) == 0 {
                                                    log_error(
                                                        (*srv).errh,
                                                        b"/home/kkysen/work/rust/lighttpd/src/configfile-glue.c\0"
                                                            as *const u8 as *const libc::c_char,
                                                        138 as libc::c_int as libc::c_uint,
                                                        b"%s should have been a list of key => values like %s = ( \"...\" => \"...\", \"...\" => \"...\" )\0"
                                                            as *const u8 as *const libc::c_char,
                                                        (*cpk_3.offset(i as isize)).k,
                                                        (*cpk_3.offset(i as isize)).k,
                                                    );
                                                    rc = 0 as libc::c_int;
                                                    current_block_37 = 11174649648027449784;
                                                } else {
                                                    current_block_37 = 7494008139977416618;
                                                }
                                            }
                                            _ => {
                                                if array_is_kvstring((*cpv).v.a) == 0 {
                                                    log_error(
                                                        (*srv).errh,
                                                        b"/home/kkysen/work/rust/lighttpd/src/configfile-glue.c\0"
                                                            as *const u8 as *const libc::c_char,
                                                        158 as libc::c_int as libc::c_uint,
                                                        b"%s should have been a list of key => string values like %s = ( \"...\" => \"...\", \"...\" => \"...\" )\0"
                                                            as *const u8 as *const libc::c_char,
                                                        (*cpk_3.offset(i as isize)).k,
                                                        (*cpk_3.offset(i as isize)).k,
                                                    );
                                                    rc = 0 as libc::c_int;
                                                    current_block_37 = 11174649648027449784;
                                                } else {
                                                    current_block_37 = 7494008139977416618;
                                                }
                                            }
                                        }
                                    }
                                    _ => {
                                        current_block_37 = 7494008139977416618;
                                    }
                                }
                            } else {
                                log_error(
                                    (*srv).errh,
                                    b"/home/kkysen/work/rust/lighttpd/src/configfile-glue.c\0"
                                        as *const u8
                                        as *const libc::c_char,
                                    129 as libc::c_int as libc::c_uint,
                                    b"%s should have been a list like %s = ( \"...\" )\0"
                                        as *const u8
                                        as *const libc::c_char,
                                    (*cpk_3.offset(i as isize)).k,
                                    (*cpk_3.offset(i as isize)).k,
                                );
                                rc = 0 as libc::c_int;
                                current_block_37 = 11174649648027449784;
                            }
                        }
                        4711845900019386151 => {
                            log_error(
                                (*srv).errh,
                                b"/home/kkysen/work/rust/lighttpd/src/configfile-glue.c\0"
                                    as *const u8
                                    as *const libc::c_char,
                                272 as libc::c_int as libc::c_uint,
                                b"ERROR: found unsupported key: %s (%s)\0" as *const u8
                                    as *const libc::c_char,
                                (*cpk_3.offset(i as isize)).k,
                                mname,
                            );
                            (*srv).srvconf.config_unsupported = 1 as libc::c_int as libc::c_uchar;
                            current_block_37 = 11174649648027449784;
                        }
                        8566665978537710866 => {
                            log_error(
                                (*srv).errh,
                                b"/home/kkysen/work/rust/lighttpd/src/configfile-glue.c\0"
                                    as *const u8
                                    as *const libc::c_char,
                                277 as libc::c_int as libc::c_uint,
                                b"ERROR: found deprecated key: %s (%s)\0" as *const u8
                                    as *const libc::c_char,
                                (*cpk_3.offset(i as isize)).k,
                                mname,
                            );
                            (*srv).srvconf.config_deprecated = 1 as libc::c_int as libc::c_uchar;
                            current_block_37 = 11174649648027449784;
                        }
                        _ => {}
                    }
                    match current_block_37 {
                        11174649648027449784 => {}
                        _ => {
                            cpv = cpv.offset(1);
                        }
                    }
                }
                2 => {
                    current_block_37 = 8415733402176751844;
                    match current_block_37 {
                        7343950298149844727 => {
                            let mut v_1: libc::c_int =
                                config_plugin_value_tobool(du, -(1 as libc::c_int));
                            if -(1 as libc::c_int) == v_1 {
                                log_error(
                                    (*srv).errh,
                                    b"/home/kkysen/work/rust/lighttpd/src/configfile-glue.c\0"
                                        as *const u8 as *const libc::c_char,
                                    259 as libc::c_int as libc::c_uint,
                                    b"ERROR: unexpected type for key: %s (string) \"(enable|disable)\"\0"
                                        as *const u8 as *const libc::c_char,
                                    (*cpk_3.offset(i as isize)).k,
                                );
                                rc = 0 as libc::c_int;
                                current_block_37 = 11174649648027449784;
                            } else {
                                (*cpv).v.u = v_1 as libc::c_uint;
                                current_block_37 = 7494008139977416618;
                            }
                        }
                        16999457480941319821 => match (*du).type_0 as libc::c_uint {
                            2 => {
                                (*cpv).v.u = (*(du as *const data_integer)).value as libc::c_uint;
                                current_block_37 = 7494008139977416618;
                            }
                            0 => {
                                let v_0: *const libc::c_char =
                                    (*(du as *const data_string)).value.ptr;
                                if !v_0.is_null() && *v_0 as libc::c_int != 0 {
                                    let mut e_0: *mut libc::c_char = 0 as *mut libc::c_char;
                                    let mut l_0: libc::c_long =
                                        strtol(v_0, &mut e_0, 10 as libc::c_int);
                                    if e_0 != v_0 as *mut libc::c_char
                                        && *e_0 == 0
                                        && l_0 >= 0 as libc::c_int as libc::c_long
                                    {
                                        (*cpv).v.shrt = l_0 as libc::c_uint as libc::c_ushort;
                                        current_block_37 = 7494008139977416618;
                                    } else {
                                        current_block_37 = 5891011138178424807;
                                    }
                                } else {
                                    current_block_37 = 5891011138178424807;
                                }
                                match current_block_37 {
                                    7494008139977416618 => {}
                                    _ => {
                                        log_error(
                                                (*srv).errh,
                                                b"/home/kkysen/work/rust/lighttpd/src/configfile-glue.c\0"
                                                    as *const u8 as *const libc::c_char,
                                                242 as libc::c_int as libc::c_uint,
                                                b"got a string but expected an integer: %s %s\0"
                                                    as *const u8 as *const libc::c_char,
                                                (*cpk_3.offset(i as isize)).k,
                                                v_0,
                                            );
                                        rc = 0 as libc::c_int;
                                        current_block_37 = 11174649648027449784;
                                    }
                                }
                            }
                            _ => {
                                log_error(
                                        (*srv).errh,
                                        b"/home/kkysen/work/rust/lighttpd/src/configfile-glue.c\0"
                                            as *const u8 as *const libc::c_char,
                                        248 as libc::c_int as libc::c_uint,
                                        b"unexpected type for key: %s %d expected an integer, range 0 ... 4294967295\0"
                                            as *const u8 as *const libc::c_char,
                                        (*cpk_3.offset(i as isize)).k,
                                        (*du).type_0 as libc::c_uint,
                                    );
                                rc = 0 as libc::c_int;
                                current_block_37 = 11174649648027449784;
                            }
                        },
                        8415733402176751844 => match (*du).type_0 as libc::c_uint {
                            2 => {
                                (*cpv).v.shrt =
                                    (*(du as *const data_integer)).value as libc::c_ushort;
                                current_block_37 = 7494008139977416618;
                            }
                            0 => {
                                let v: *const libc::c_char =
                                    (*(du as *const data_string)).value.ptr;
                                if !v.is_null() && *v as libc::c_int != 0 {
                                    let mut e: *mut libc::c_char = 0 as *mut libc::c_char;
                                    let mut l: libc::c_long = strtol(v, &mut e, 10 as libc::c_int);
                                    if e != v as *mut libc::c_char
                                        && *e == 0
                                        && l >= 0 as libc::c_int as libc::c_long
                                        && l <= 65535 as libc::c_int as libc::c_long
                                    {
                                        (*cpv).v.shrt = l as libc::c_ushort;
                                        current_block_37 = 7494008139977416618;
                                    } else {
                                        current_block_37 = 3123434771885419771;
                                    }
                                } else {
                                    current_block_37 = 3123434771885419771;
                                }
                                match current_block_37 {
                                    7494008139977416618 => {}
                                    _ => {
                                        log_error(
                                                (*srv).errh,
                                                b"/home/kkysen/work/rust/lighttpd/src/configfile-glue.c\0"
                                                    as *const u8 as *const libc::c_char,
                                                214 as libc::c_int as libc::c_uint,
                                                b"got a string but expected a short: %s %s\0" as *const u8
                                                    as *const libc::c_char,
                                                (*cpk_3.offset(i as isize)).k,
                                                v,
                                            );
                                        rc = 0 as libc::c_int;
                                        current_block_37 = 11174649648027449784;
                                    }
                                }
                            }
                            _ => {
                                log_error(
                                        (*srv).errh,
                                        b"/home/kkysen/work/rust/lighttpd/src/configfile-glue.c\0"
                                            as *const u8 as *const libc::c_char,
                                        220 as libc::c_int as libc::c_uint,
                                        b"unexpected type for key: %s %d expected a short integer, range 0 ... 65535\0"
                                            as *const u8 as *const libc::c_char,
                                        (*cpk_3.offset(i as isize)).k,
                                        (*du).type_0 as libc::c_uint,
                                    );
                                rc = 0 as libc::c_int;
                                current_block_37 = 11174649648027449784;
                            }
                        },
                        711017519835216269 => {
                            if (*du).type_0 as libc::c_uint
                                == TYPE_STRING as libc::c_int as libc::c_uint
                            {
                                (*cpv).v.b = &(*(du as *const data_string)).value;
                                current_block_37 = 7494008139977416618;
                            } else {
                                log_error(
                                    (*srv).errh,
                                    b"/home/kkysen/work/rust/lighttpd/src/configfile-glue.c\0"
                                        as *const u8
                                        as *const libc::c_char,
                                    186 as libc::c_int as libc::c_uint,
                                    b"%s should have been a string like ... = \"...\"\0"
                                        as *const u8
                                        as *const libc::c_char,
                                    (*cpk_3.offset(i as isize)).k,
                                );
                                rc = 0 as libc::c_int;
                                current_block_37 = 11174649648027449784;
                            }
                        }
                        5772900442197213762 => {
                            if (*du).type_0 as libc::c_uint
                                == TYPE_ARRAY as libc::c_int as libc::c_uint
                            {
                                (*cpv).v.a = &(*(du as *const data_array)).value;
                                match (*cpk_3.offset(i as isize)).ktype as libc::c_int {
                                    6 => {
                                        current_block_37 = 18094548196697502083;
                                        match current_block_37 {
                                            15359267663982909818 => {
                                                if array_is_vlist((*cpv).v.a) == 0 {
                                                    log_error(
                                                        (*srv).errh,
                                                        b"/home/kkysen/work/rust/lighttpd/src/configfile-glue.c\0"
                                                            as *const u8 as *const libc::c_char,
                                                        168 as libc::c_int as libc::c_uint,
                                                        b"%s should have been a list of string values like %s = ( \"...\", \"...\" )\0"
                                                            as *const u8 as *const libc::c_char,
                                                        (*cpk_3.offset(i as isize)).k,
                                                        (*cpk_3.offset(i as isize)).k,
                                                    );
                                                    rc = 0 as libc::c_int;
                                                    current_block_37 = 11174649648027449784;
                                                } else {
                                                    current_block_37 = 7494008139977416618;
                                                }
                                            }
                                            14601221856387937457 => {
                                                if array_is_kvarray((*cpv).v.a) == 0 {
                                                    log_error(
                                                        (*srv).errh,
                                                        b"/home/kkysen/work/rust/lighttpd/src/configfile-glue.c\0"
                                                            as *const u8 as *const libc::c_char,
                                                        148 as libc::c_int as libc::c_uint,
                                                        b"%s should have been a list of key => list like %s = ( \"...\" => ( \"...\" => \"...\" ) )\0"
                                                            as *const u8 as *const libc::c_char,
                                                        (*cpk_3.offset(i as isize)).k,
                                                        (*cpk_3.offset(i as isize)).k,
                                                    );
                                                    rc = 0 as libc::c_int;
                                                    current_block_37 = 11174649648027449784;
                                                } else {
                                                    current_block_37 = 7494008139977416618;
                                                }
                                            }
                                            18094548196697502083 => {
                                                if array_is_kvany((*cpv).v.a) == 0 {
                                                    log_error(
                                                        (*srv).errh,
                                                        b"/home/kkysen/work/rust/lighttpd/src/configfile-glue.c\0"
                                                            as *const u8 as *const libc::c_char,
                                                        138 as libc::c_int as libc::c_uint,
                                                        b"%s should have been a list of key => values like %s = ( \"...\" => \"...\", \"...\" => \"...\" )\0"
                                                            as *const u8 as *const libc::c_char,
                                                        (*cpk_3.offset(i as isize)).k,
                                                        (*cpk_3.offset(i as isize)).k,
                                                    );
                                                    rc = 0 as libc::c_int;
                                                    current_block_37 = 11174649648027449784;
                                                } else {
                                                    current_block_37 = 7494008139977416618;
                                                }
                                            }
                                            _ => {
                                                if array_is_kvstring((*cpv).v.a) == 0 {
                                                    log_error(
                                                        (*srv).errh,
                                                        b"/home/kkysen/work/rust/lighttpd/src/configfile-glue.c\0"
                                                            as *const u8 as *const libc::c_char,
                                                        158 as libc::c_int as libc::c_uint,
                                                        b"%s should have been a list of key => string values like %s = ( \"...\" => \"...\", \"...\" => \"...\" )\0"
                                                            as *const u8 as *const libc::c_char,
                                                        (*cpk_3.offset(i as isize)).k,
                                                        (*cpk_3.offset(i as isize)).k,
                                                    );
                                                    rc = 0 as libc::c_int;
                                                    current_block_37 = 11174649648027449784;
                                                } else {
                                                    current_block_37 = 7494008139977416618;
                                                }
                                            }
                                        }
                                    }
                                    7 => {
                                        current_block_37 = 14601221856387937457;
                                        match current_block_37 {
                                            15359267663982909818 => {
                                                if array_is_vlist((*cpv).v.a) == 0 {
                                                    log_error(
                                                        (*srv).errh,
                                                        b"/home/kkysen/work/rust/lighttpd/src/configfile-glue.c\0"
                                                            as *const u8 as *const libc::c_char,
                                                        168 as libc::c_int as libc::c_uint,
                                                        b"%s should have been a list of string values like %s = ( \"...\", \"...\" )\0"
                                                            as *const u8 as *const libc::c_char,
                                                        (*cpk_3.offset(i as isize)).k,
                                                        (*cpk_3.offset(i as isize)).k,
                                                    );
                                                    rc = 0 as libc::c_int;
                                                    current_block_37 = 11174649648027449784;
                                                } else {
                                                    current_block_37 = 7494008139977416618;
                                                }
                                            }
                                            14601221856387937457 => {
                                                if array_is_kvarray((*cpv).v.a) == 0 {
                                                    log_error(
                                                        (*srv).errh,
                                                        b"/home/kkysen/work/rust/lighttpd/src/configfile-glue.c\0"
                                                            as *const u8 as *const libc::c_char,
                                                        148 as libc::c_int as libc::c_uint,
                                                        b"%s should have been a list of key => list like %s = ( \"...\" => ( \"...\" => \"...\" ) )\0"
                                                            as *const u8 as *const libc::c_char,
                                                        (*cpk_3.offset(i as isize)).k,
                                                        (*cpk_3.offset(i as isize)).k,
                                                    );
                                                    rc = 0 as libc::c_int;
                                                    current_block_37 = 11174649648027449784;
                                                } else {
                                                    current_block_37 = 7494008139977416618;
                                                }
                                            }
                                            18094548196697502083 => {
                                                if array_is_kvany((*cpv).v.a) == 0 {
                                                    log_error(
                                                        (*srv).errh,
                                                        b"/home/kkysen/work/rust/lighttpd/src/configfile-glue.c\0"
                                                            as *const u8 as *const libc::c_char,
                                                        138 as libc::c_int as libc::c_uint,
                                                        b"%s should have been a list of key => values like %s = ( \"...\" => \"...\", \"...\" => \"...\" )\0"
                                                            as *const u8 as *const libc::c_char,
                                                        (*cpk_3.offset(i as isize)).k,
                                                        (*cpk_3.offset(i as isize)).k,
                                                    );
                                                    rc = 0 as libc::c_int;
                                                    current_block_37 = 11174649648027449784;
                                                } else {
                                                    current_block_37 = 7494008139977416618;
                                                }
                                            }
                                            _ => {
                                                if array_is_kvstring((*cpv).v.a) == 0 {
                                                    log_error(
                                                        (*srv).errh,
                                                        b"/home/kkysen/work/rust/lighttpd/src/configfile-glue.c\0"
                                                            as *const u8 as *const libc::c_char,
                                                        158 as libc::c_int as libc::c_uint,
                                                        b"%s should have been a list of key => string values like %s = ( \"...\" => \"...\", \"...\" => \"...\" )\0"
                                                            as *const u8 as *const libc::c_char,
                                                        (*cpk_3.offset(i as isize)).k,
                                                        (*cpk_3.offset(i as isize)).k,
                                                    );
                                                    rc = 0 as libc::c_int;
                                                    current_block_37 = 11174649648027449784;
                                                } else {
                                                    current_block_37 = 7494008139977416618;
                                                }
                                            }
                                        }
                                    }
                                    8 => {
                                        current_block_37 = 2973921165121704668;
                                        match current_block_37 {
                                            15359267663982909818 => {
                                                if array_is_vlist((*cpv).v.a) == 0 {
                                                    log_error(
                                                        (*srv).errh,
                                                        b"/home/kkysen/work/rust/lighttpd/src/configfile-glue.c\0"
                                                            as *const u8 as *const libc::c_char,
                                                        168 as libc::c_int as libc::c_uint,
                                                        b"%s should have been a list of string values like %s = ( \"...\", \"...\" )\0"
                                                            as *const u8 as *const libc::c_char,
                                                        (*cpk_3.offset(i as isize)).k,
                                                        (*cpk_3.offset(i as isize)).k,
                                                    );
                                                    rc = 0 as libc::c_int;
                                                    current_block_37 = 11174649648027449784;
                                                } else {
                                                    current_block_37 = 7494008139977416618;
                                                }
                                            }
                                            14601221856387937457 => {
                                                if array_is_kvarray((*cpv).v.a) == 0 {
                                                    log_error(
                                                        (*srv).errh,
                                                        b"/home/kkysen/work/rust/lighttpd/src/configfile-glue.c\0"
                                                            as *const u8 as *const libc::c_char,
                                                        148 as libc::c_int as libc::c_uint,
                                                        b"%s should have been a list of key => list like %s = ( \"...\" => ( \"...\" => \"...\" ) )\0"
                                                            as *const u8 as *const libc::c_char,
                                                        (*cpk_3.offset(i as isize)).k,
                                                        (*cpk_3.offset(i as isize)).k,
                                                    );
                                                    rc = 0 as libc::c_int;
                                                    current_block_37 = 11174649648027449784;
                                                } else {
                                                    current_block_37 = 7494008139977416618;
                                                }
                                            }
                                            18094548196697502083 => {
                                                if array_is_kvany((*cpv).v.a) == 0 {
                                                    log_error(
                                                        (*srv).errh,
                                                        b"/home/kkysen/work/rust/lighttpd/src/configfile-glue.c\0"
                                                            as *const u8 as *const libc::c_char,
                                                        138 as libc::c_int as libc::c_uint,
                                                        b"%s should have been a list of key => values like %s = ( \"...\" => \"...\", \"...\" => \"...\" )\0"
                                                            as *const u8 as *const libc::c_char,
                                                        (*cpk_3.offset(i as isize)).k,
                                                        (*cpk_3.offset(i as isize)).k,
                                                    );
                                                    rc = 0 as libc::c_int;
                                                    current_block_37 = 11174649648027449784;
                                                } else {
                                                    current_block_37 = 7494008139977416618;
                                                }
                                            }
                                            _ => {
                                                if array_is_kvstring((*cpv).v.a) == 0 {
                                                    log_error(
                                                        (*srv).errh,
                                                        b"/home/kkysen/work/rust/lighttpd/src/configfile-glue.c\0"
                                                            as *const u8 as *const libc::c_char,
                                                        158 as libc::c_int as libc::c_uint,
                                                        b"%s should have been a list of key => string values like %s = ( \"...\" => \"...\", \"...\" => \"...\" )\0"
                                                            as *const u8 as *const libc::c_char,
                                                        (*cpk_3.offset(i as isize)).k,
                                                        (*cpk_3.offset(i as isize)).k,
                                                    );
                                                    rc = 0 as libc::c_int;
                                                    current_block_37 = 11174649648027449784;
                                                } else {
                                                    current_block_37 = 7494008139977416618;
                                                }
                                            }
                                        }
                                    }
                                    9 => {
                                        current_block_37 = 15359267663982909818;
                                        match current_block_37 {
                                            15359267663982909818 => {
                                                if array_is_vlist((*cpv).v.a) == 0 {
                                                    log_error(
                                                        (*srv).errh,
                                                        b"/home/kkysen/work/rust/lighttpd/src/configfile-glue.c\0"
                                                            as *const u8 as *const libc::c_char,
                                                        168 as libc::c_int as libc::c_uint,
                                                        b"%s should have been a list of string values like %s = ( \"...\", \"...\" )\0"
                                                            as *const u8 as *const libc::c_char,
                                                        (*cpk_3.offset(i as isize)).k,
                                                        (*cpk_3.offset(i as isize)).k,
                                                    );
                                                    rc = 0 as libc::c_int;
                                                    current_block_37 = 11174649648027449784;
                                                } else {
                                                    current_block_37 = 7494008139977416618;
                                                }
                                            }
                                            14601221856387937457 => {
                                                if array_is_kvarray((*cpv).v.a) == 0 {
                                                    log_error(
                                                        (*srv).errh,
                                                        b"/home/kkysen/work/rust/lighttpd/src/configfile-glue.c\0"
                                                            as *const u8 as *const libc::c_char,
                                                        148 as libc::c_int as libc::c_uint,
                                                        b"%s should have been a list of key => list like %s = ( \"...\" => ( \"...\" => \"...\" ) )\0"
                                                            as *const u8 as *const libc::c_char,
                                                        (*cpk_3.offset(i as isize)).k,
                                                        (*cpk_3.offset(i as isize)).k,
                                                    );
                                                    rc = 0 as libc::c_int;
                                                    current_block_37 = 11174649648027449784;
                                                } else {
                                                    current_block_37 = 7494008139977416618;
                                                }
                                            }
                                            18094548196697502083 => {
                                                if array_is_kvany((*cpv).v.a) == 0 {
                                                    log_error(
                                                        (*srv).errh,
                                                        b"/home/kkysen/work/rust/lighttpd/src/configfile-glue.c\0"
                                                            as *const u8 as *const libc::c_char,
                                                        138 as libc::c_int as libc::c_uint,
                                                        b"%s should have been a list of key => values like %s = ( \"...\" => \"...\", \"...\" => \"...\" )\0"
                                                            as *const u8 as *const libc::c_char,
                                                        (*cpk_3.offset(i as isize)).k,
                                                        (*cpk_3.offset(i as isize)).k,
                                                    );
                                                    rc = 0 as libc::c_int;
                                                    current_block_37 = 11174649648027449784;
                                                } else {
                                                    current_block_37 = 7494008139977416618;
                                                }
                                            }
                                            _ => {
                                                if array_is_kvstring((*cpv).v.a) == 0 {
                                                    log_error(
                                                        (*srv).errh,
                                                        b"/home/kkysen/work/rust/lighttpd/src/configfile-glue.c\0"
                                                            as *const u8 as *const libc::c_char,
                                                        158 as libc::c_int as libc::c_uint,
                                                        b"%s should have been a list of key => string values like %s = ( \"...\" => \"...\", \"...\" => \"...\" )\0"
                                                            as *const u8 as *const libc::c_char,
                                                        (*cpk_3.offset(i as isize)).k,
                                                        (*cpk_3.offset(i as isize)).k,
                                                    );
                                                    rc = 0 as libc::c_int;
                                                    current_block_37 = 11174649648027449784;
                                                } else {
                                                    current_block_37 = 7494008139977416618;
                                                }
                                            }
                                        }
                                    }
                                    _ => {
                                        current_block_37 = 7494008139977416618;
                                    }
                                }
                            } else {
                                log_error(
                                    (*srv).errh,
                                    b"/home/kkysen/work/rust/lighttpd/src/configfile-glue.c\0"
                                        as *const u8
                                        as *const libc::c_char,
                                    129 as libc::c_int as libc::c_uint,
                                    b"%s should have been a list like %s = ( \"...\" )\0"
                                        as *const u8
                                        as *const libc::c_char,
                                    (*cpk_3.offset(i as isize)).k,
                                    (*cpk_3.offset(i as isize)).k,
                                );
                                rc = 0 as libc::c_int;
                                current_block_37 = 11174649648027449784;
                            }
                        }
                        4711845900019386151 => {
                            log_error(
                                (*srv).errh,
                                b"/home/kkysen/work/rust/lighttpd/src/configfile-glue.c\0"
                                    as *const u8
                                    as *const libc::c_char,
                                272 as libc::c_int as libc::c_uint,
                                b"ERROR: found unsupported key: %s (%s)\0" as *const u8
                                    as *const libc::c_char,
                                (*cpk_3.offset(i as isize)).k,
                                mname,
                            );
                            (*srv).srvconf.config_unsupported = 1 as libc::c_int as libc::c_uchar;
                            current_block_37 = 11174649648027449784;
                        }
                        8566665978537710866 => {
                            log_error(
                                (*srv).errh,
                                b"/home/kkysen/work/rust/lighttpd/src/configfile-glue.c\0"
                                    as *const u8
                                    as *const libc::c_char,
                                277 as libc::c_int as libc::c_uint,
                                b"ERROR: found deprecated key: %s (%s)\0" as *const u8
                                    as *const libc::c_char,
                                (*cpk_3.offset(i as isize)).k,
                                mname,
                            );
                            (*srv).srvconf.config_deprecated = 1 as libc::c_int as libc::c_uchar;
                            current_block_37 = 11174649648027449784;
                        }
                        _ => {}
                    }
                    match current_block_37 {
                        11174649648027449784 => {}
                        _ => {
                            cpv = cpv.offset(1);
                        }
                    }
                }
                3 => {
                    current_block_37 = 16999457480941319821;
                    match current_block_37 {
                        7343950298149844727 => {
                            let mut v_1: libc::c_int =
                                config_plugin_value_tobool(du, -(1 as libc::c_int));
                            if -(1 as libc::c_int) == v_1 {
                                log_error(
                                    (*srv).errh,
                                    b"/home/kkysen/work/rust/lighttpd/src/configfile-glue.c\0"
                                        as *const u8 as *const libc::c_char,
                                    259 as libc::c_int as libc::c_uint,
                                    b"ERROR: unexpected type for key: %s (string) \"(enable|disable)\"\0"
                                        as *const u8 as *const libc::c_char,
                                    (*cpk_3.offset(i as isize)).k,
                                );
                                rc = 0 as libc::c_int;
                                current_block_37 = 11174649648027449784;
                            } else {
                                (*cpv).v.u = v_1 as libc::c_uint;
                                current_block_37 = 7494008139977416618;
                            }
                        }
                        16999457480941319821 => match (*du).type_0 as libc::c_uint {
                            2 => {
                                (*cpv).v.u = (*(du as *const data_integer)).value as libc::c_uint;
                                current_block_37 = 7494008139977416618;
                            }
                            0 => {
                                let v_0: *const libc::c_char =
                                    (*(du as *const data_string)).value.ptr;
                                if !v_0.is_null() && *v_0 as libc::c_int != 0 {
                                    let mut e_0: *mut libc::c_char = 0 as *mut libc::c_char;
                                    let mut l_0: libc::c_long =
                                        strtol(v_0, &mut e_0, 10 as libc::c_int);
                                    if e_0 != v_0 as *mut libc::c_char
                                        && *e_0 == 0
                                        && l_0 >= 0 as libc::c_int as libc::c_long
                                    {
                                        (*cpv).v.shrt = l_0 as libc::c_uint as libc::c_ushort;
                                        current_block_37 = 7494008139977416618;
                                    } else {
                                        current_block_37 = 5891011138178424807;
                                    }
                                } else {
                                    current_block_37 = 5891011138178424807;
                                }
                                match current_block_37 {
                                    7494008139977416618 => {}
                                    _ => {
                                        log_error(
                                                (*srv).errh,
                                                b"/home/kkysen/work/rust/lighttpd/src/configfile-glue.c\0"
                                                    as *const u8 as *const libc::c_char,
                                                242 as libc::c_int as libc::c_uint,
                                                b"got a string but expected an integer: %s %s\0"
                                                    as *const u8 as *const libc::c_char,
                                                (*cpk_3.offset(i as isize)).k,
                                                v_0,
                                            );
                                        rc = 0 as libc::c_int;
                                        current_block_37 = 11174649648027449784;
                                    }
                                }
                            }
                            _ => {
                                log_error(
                                        (*srv).errh,
                                        b"/home/kkysen/work/rust/lighttpd/src/configfile-glue.c\0"
                                            as *const u8 as *const libc::c_char,
                                        248 as libc::c_int as libc::c_uint,
                                        b"unexpected type for key: %s %d expected an integer, range 0 ... 4294967295\0"
                                            as *const u8 as *const libc::c_char,
                                        (*cpk_3.offset(i as isize)).k,
                                        (*du).type_0 as libc::c_uint,
                                    );
                                rc = 0 as libc::c_int;
                                current_block_37 = 11174649648027449784;
                            }
                        },
                        8415733402176751844 => match (*du).type_0 as libc::c_uint {
                            2 => {
                                (*cpv).v.shrt =
                                    (*(du as *const data_integer)).value as libc::c_ushort;
                                current_block_37 = 7494008139977416618;
                            }
                            0 => {
                                let v: *const libc::c_char =
                                    (*(du as *const data_string)).value.ptr;
                                if !v.is_null() && *v as libc::c_int != 0 {
                                    let mut e: *mut libc::c_char = 0 as *mut libc::c_char;
                                    let mut l: libc::c_long = strtol(v, &mut e, 10 as libc::c_int);
                                    if e != v as *mut libc::c_char
                                        && *e == 0
                                        && l >= 0 as libc::c_int as libc::c_long
                                        && l <= 65535 as libc::c_int as libc::c_long
                                    {
                                        (*cpv).v.shrt = l as libc::c_ushort;
                                        current_block_37 = 7494008139977416618;
                                    } else {
                                        current_block_37 = 3123434771885419771;
                                    }
                                } else {
                                    current_block_37 = 3123434771885419771;
                                }
                                match current_block_37 {
                                    7494008139977416618 => {}
                                    _ => {
                                        log_error(
                                                (*srv).errh,
                                                b"/home/kkysen/work/rust/lighttpd/src/configfile-glue.c\0"
                                                    as *const u8 as *const libc::c_char,
                                                214 as libc::c_int as libc::c_uint,
                                                b"got a string but expected a short: %s %s\0" as *const u8
                                                    as *const libc::c_char,
                                                (*cpk_3.offset(i as isize)).k,
                                                v,
                                            );
                                        rc = 0 as libc::c_int;
                                        current_block_37 = 11174649648027449784;
                                    }
                                }
                            }
                            _ => {
                                log_error(
                                        (*srv).errh,
                                        b"/home/kkysen/work/rust/lighttpd/src/configfile-glue.c\0"
                                            as *const u8 as *const libc::c_char,
                                        220 as libc::c_int as libc::c_uint,
                                        b"unexpected type for key: %s %d expected a short integer, range 0 ... 65535\0"
                                            as *const u8 as *const libc::c_char,
                                        (*cpk_3.offset(i as isize)).k,
                                        (*du).type_0 as libc::c_uint,
                                    );
                                rc = 0 as libc::c_int;
                                current_block_37 = 11174649648027449784;
                            }
                        },
                        711017519835216269 => {
                            if (*du).type_0 as libc::c_uint
                                == TYPE_STRING as libc::c_int as libc::c_uint
                            {
                                (*cpv).v.b = &(*(du as *const data_string)).value;
                                current_block_37 = 7494008139977416618;
                            } else {
                                log_error(
                                    (*srv).errh,
                                    b"/home/kkysen/work/rust/lighttpd/src/configfile-glue.c\0"
                                        as *const u8
                                        as *const libc::c_char,
                                    186 as libc::c_int as libc::c_uint,
                                    b"%s should have been a string like ... = \"...\"\0"
                                        as *const u8
                                        as *const libc::c_char,
                                    (*cpk_3.offset(i as isize)).k,
                                );
                                rc = 0 as libc::c_int;
                                current_block_37 = 11174649648027449784;
                            }
                        }
                        5772900442197213762 => {
                            if (*du).type_0 as libc::c_uint
                                == TYPE_ARRAY as libc::c_int as libc::c_uint
                            {
                                (*cpv).v.a = &(*(du as *const data_array)).value;
                                match (*cpk_3.offset(i as isize)).ktype as libc::c_int {
                                    6 => {
                                        current_block_37 = 18094548196697502083;
                                        match current_block_37 {
                                            15359267663982909818 => {
                                                if array_is_vlist((*cpv).v.a) == 0 {
                                                    log_error(
                                                        (*srv).errh,
                                                        b"/home/kkysen/work/rust/lighttpd/src/configfile-glue.c\0"
                                                            as *const u8 as *const libc::c_char,
                                                        168 as libc::c_int as libc::c_uint,
                                                        b"%s should have been a list of string values like %s = ( \"...\", \"...\" )\0"
                                                            as *const u8 as *const libc::c_char,
                                                        (*cpk_3.offset(i as isize)).k,
                                                        (*cpk_3.offset(i as isize)).k,
                                                    );
                                                    rc = 0 as libc::c_int;
                                                    current_block_37 = 11174649648027449784;
                                                } else {
                                                    current_block_37 = 7494008139977416618;
                                                }
                                            }
                                            14601221856387937457 => {
                                                if array_is_kvarray((*cpv).v.a) == 0 {
                                                    log_error(
                                                        (*srv).errh,
                                                        b"/home/kkysen/work/rust/lighttpd/src/configfile-glue.c\0"
                                                            as *const u8 as *const libc::c_char,
                                                        148 as libc::c_int as libc::c_uint,
                                                        b"%s should have been a list of key => list like %s = ( \"...\" => ( \"...\" => \"...\" ) )\0"
                                                            as *const u8 as *const libc::c_char,
                                                        (*cpk_3.offset(i as isize)).k,
                                                        (*cpk_3.offset(i as isize)).k,
                                                    );
                                                    rc = 0 as libc::c_int;
                                                    current_block_37 = 11174649648027449784;
                                                } else {
                                                    current_block_37 = 7494008139977416618;
                                                }
                                            }
                                            18094548196697502083 => {
                                                if array_is_kvany((*cpv).v.a) == 0 {
                                                    log_error(
                                                        (*srv).errh,
                                                        b"/home/kkysen/work/rust/lighttpd/src/configfile-glue.c\0"
                                                            as *const u8 as *const libc::c_char,
                                                        138 as libc::c_int as libc::c_uint,
                                                        b"%s should have been a list of key => values like %s = ( \"...\" => \"...\", \"...\" => \"...\" )\0"
                                                            as *const u8 as *const libc::c_char,
                                                        (*cpk_3.offset(i as isize)).k,
                                                        (*cpk_3.offset(i as isize)).k,
                                                    );
                                                    rc = 0 as libc::c_int;
                                                    current_block_37 = 11174649648027449784;
                                                } else {
                                                    current_block_37 = 7494008139977416618;
                                                }
                                            }
                                            _ => {
                                                if array_is_kvstring((*cpv).v.a) == 0 {
                                                    log_error(
                                                        (*srv).errh,
                                                        b"/home/kkysen/work/rust/lighttpd/src/configfile-glue.c\0"
                                                            as *const u8 as *const libc::c_char,
                                                        158 as libc::c_int as libc::c_uint,
                                                        b"%s should have been a list of key => string values like %s = ( \"...\" => \"...\", \"...\" => \"...\" )\0"
                                                            as *const u8 as *const libc::c_char,
                                                        (*cpk_3.offset(i as isize)).k,
                                                        (*cpk_3.offset(i as isize)).k,
                                                    );
                                                    rc = 0 as libc::c_int;
                                                    current_block_37 = 11174649648027449784;
                                                } else {
                                                    current_block_37 = 7494008139977416618;
                                                }
                                            }
                                        }
                                    }
                                    7 => {
                                        current_block_37 = 14601221856387937457;
                                        match current_block_37 {
                                            15359267663982909818 => {
                                                if array_is_vlist((*cpv).v.a) == 0 {
                                                    log_error(
                                                        (*srv).errh,
                                                        b"/home/kkysen/work/rust/lighttpd/src/configfile-glue.c\0"
                                                            as *const u8 as *const libc::c_char,
                                                        168 as libc::c_int as libc::c_uint,
                                                        b"%s should have been a list of string values like %s = ( \"...\", \"...\" )\0"
                                                            as *const u8 as *const libc::c_char,
                                                        (*cpk_3.offset(i as isize)).k,
                                                        (*cpk_3.offset(i as isize)).k,
                                                    );
                                                    rc = 0 as libc::c_int;
                                                    current_block_37 = 11174649648027449784;
                                                } else {
                                                    current_block_37 = 7494008139977416618;
                                                }
                                            }
                                            14601221856387937457 => {
                                                if array_is_kvarray((*cpv).v.a) == 0 {
                                                    log_error(
                                                        (*srv).errh,
                                                        b"/home/kkysen/work/rust/lighttpd/src/configfile-glue.c\0"
                                                            as *const u8 as *const libc::c_char,
                                                        148 as libc::c_int as libc::c_uint,
                                                        b"%s should have been a list of key => list like %s = ( \"...\" => ( \"...\" => \"...\" ) )\0"
                                                            as *const u8 as *const libc::c_char,
                                                        (*cpk_3.offset(i as isize)).k,
                                                        (*cpk_3.offset(i as isize)).k,
                                                    );
                                                    rc = 0 as libc::c_int;
                                                    current_block_37 = 11174649648027449784;
                                                } else {
                                                    current_block_37 = 7494008139977416618;
                                                }
                                            }
                                            18094548196697502083 => {
                                                if array_is_kvany((*cpv).v.a) == 0 {
                                                    log_error(
                                                        (*srv).errh,
                                                        b"/home/kkysen/work/rust/lighttpd/src/configfile-glue.c\0"
                                                            as *const u8 as *const libc::c_char,
                                                        138 as libc::c_int as libc::c_uint,
                                                        b"%s should have been a list of key => values like %s = ( \"...\" => \"...\", \"...\" => \"...\" )\0"
                                                            as *const u8 as *const libc::c_char,
                                                        (*cpk_3.offset(i as isize)).k,
                                                        (*cpk_3.offset(i as isize)).k,
                                                    );
                                                    rc = 0 as libc::c_int;
                                                    current_block_37 = 11174649648027449784;
                                                } else {
                                                    current_block_37 = 7494008139977416618;
                                                }
                                            }
                                            _ => {
                                                if array_is_kvstring((*cpv).v.a) == 0 {
                                                    log_error(
                                                        (*srv).errh,
                                                        b"/home/kkysen/work/rust/lighttpd/src/configfile-glue.c\0"
                                                            as *const u8 as *const libc::c_char,
                                                        158 as libc::c_int as libc::c_uint,
                                                        b"%s should have been a list of key => string values like %s = ( \"...\" => \"...\", \"...\" => \"...\" )\0"
                                                            as *const u8 as *const libc::c_char,
                                                        (*cpk_3.offset(i as isize)).k,
                                                        (*cpk_3.offset(i as isize)).k,
                                                    );
                                                    rc = 0 as libc::c_int;
                                                    current_block_37 = 11174649648027449784;
                                                } else {
                                                    current_block_37 = 7494008139977416618;
                                                }
                                            }
                                        }
                                    }
                                    8 => {
                                        current_block_37 = 2973921165121704668;
                                        match current_block_37 {
                                            15359267663982909818 => {
                                                if array_is_vlist((*cpv).v.a) == 0 {
                                                    log_error(
                                                        (*srv).errh,
                                                        b"/home/kkysen/work/rust/lighttpd/src/configfile-glue.c\0"
                                                            as *const u8 as *const libc::c_char,
                                                        168 as libc::c_int as libc::c_uint,
                                                        b"%s should have been a list of string values like %s = ( \"...\", \"...\" )\0"
                                                            as *const u8 as *const libc::c_char,
                                                        (*cpk_3.offset(i as isize)).k,
                                                        (*cpk_3.offset(i as isize)).k,
                                                    );
                                                    rc = 0 as libc::c_int;
                                                    current_block_37 = 11174649648027449784;
                                                } else {
                                                    current_block_37 = 7494008139977416618;
                                                }
                                            }
                                            14601221856387937457 => {
                                                if array_is_kvarray((*cpv).v.a) == 0 {
                                                    log_error(
                                                        (*srv).errh,
                                                        b"/home/kkysen/work/rust/lighttpd/src/configfile-glue.c\0"
                                                            as *const u8 as *const libc::c_char,
                                                        148 as libc::c_int as libc::c_uint,
                                                        b"%s should have been a list of key => list like %s = ( \"...\" => ( \"...\" => \"...\" ) )\0"
                                                            as *const u8 as *const libc::c_char,
                                                        (*cpk_3.offset(i as isize)).k,
                                                        (*cpk_3.offset(i as isize)).k,
                                                    );
                                                    rc = 0 as libc::c_int;
                                                    current_block_37 = 11174649648027449784;
                                                } else {
                                                    current_block_37 = 7494008139977416618;
                                                }
                                            }
                                            18094548196697502083 => {
                                                if array_is_kvany((*cpv).v.a) == 0 {
                                                    log_error(
                                                        (*srv).errh,
                                                        b"/home/kkysen/work/rust/lighttpd/src/configfile-glue.c\0"
                                                            as *const u8 as *const libc::c_char,
                                                        138 as libc::c_int as libc::c_uint,
                                                        b"%s should have been a list of key => values like %s = ( \"...\" => \"...\", \"...\" => \"...\" )\0"
                                                            as *const u8 as *const libc::c_char,
                                                        (*cpk_3.offset(i as isize)).k,
                                                        (*cpk_3.offset(i as isize)).k,
                                                    );
                                                    rc = 0 as libc::c_int;
                                                    current_block_37 = 11174649648027449784;
                                                } else {
                                                    current_block_37 = 7494008139977416618;
                                                }
                                            }
                                            _ => {
                                                if array_is_kvstring((*cpv).v.a) == 0 {
                                                    log_error(
                                                        (*srv).errh,
                                                        b"/home/kkysen/work/rust/lighttpd/src/configfile-glue.c\0"
                                                            as *const u8 as *const libc::c_char,
                                                        158 as libc::c_int as libc::c_uint,
                                                        b"%s should have been a list of key => string values like %s = ( \"...\" => \"...\", \"...\" => \"...\" )\0"
                                                            as *const u8 as *const libc::c_char,
                                                        (*cpk_3.offset(i as isize)).k,
                                                        (*cpk_3.offset(i as isize)).k,
                                                    );
                                                    rc = 0 as libc::c_int;
                                                    current_block_37 = 11174649648027449784;
                                                } else {
                                                    current_block_37 = 7494008139977416618;
                                                }
                                            }
                                        }
                                    }
                                    9 => {
                                        current_block_37 = 15359267663982909818;
                                        match current_block_37 {
                                            15359267663982909818 => {
                                                if array_is_vlist((*cpv).v.a) == 0 {
                                                    log_error(
                                                        (*srv).errh,
                                                        b"/home/kkysen/work/rust/lighttpd/src/configfile-glue.c\0"
                                                            as *const u8 as *const libc::c_char,
                                                        168 as libc::c_int as libc::c_uint,
                                                        b"%s should have been a list of string values like %s = ( \"...\", \"...\" )\0"
                                                            as *const u8 as *const libc::c_char,
                                                        (*cpk_3.offset(i as isize)).k,
                                                        (*cpk_3.offset(i as isize)).k,
                                                    );
                                                    rc = 0 as libc::c_int;
                                                    current_block_37 = 11174649648027449784;
                                                } else {
                                                    current_block_37 = 7494008139977416618;
                                                }
                                            }
                                            14601221856387937457 => {
                                                if array_is_kvarray((*cpv).v.a) == 0 {
                                                    log_error(
                                                        (*srv).errh,
                                                        b"/home/kkysen/work/rust/lighttpd/src/configfile-glue.c\0"
                                                            as *const u8 as *const libc::c_char,
                                                        148 as libc::c_int as libc::c_uint,
                                                        b"%s should have been a list of key => list like %s = ( \"...\" => ( \"...\" => \"...\" ) )\0"
                                                            as *const u8 as *const libc::c_char,
                                                        (*cpk_3.offset(i as isize)).k,
                                                        (*cpk_3.offset(i as isize)).k,
                                                    );
                                                    rc = 0 as libc::c_int;
                                                    current_block_37 = 11174649648027449784;
                                                } else {
                                                    current_block_37 = 7494008139977416618;
                                                }
                                            }
                                            18094548196697502083 => {
                                                if array_is_kvany((*cpv).v.a) == 0 {
                                                    log_error(
                                                        (*srv).errh,
                                                        b"/home/kkysen/work/rust/lighttpd/src/configfile-glue.c\0"
                                                            as *const u8 as *const libc::c_char,
                                                        138 as libc::c_int as libc::c_uint,
                                                        b"%s should have been a list of key => values like %s = ( \"...\" => \"...\", \"...\" => \"...\" )\0"
                                                            as *const u8 as *const libc::c_char,
                                                        (*cpk_3.offset(i as isize)).k,
                                                        (*cpk_3.offset(i as isize)).k,
                                                    );
                                                    rc = 0 as libc::c_int;
                                                    current_block_37 = 11174649648027449784;
                                                } else {
                                                    current_block_37 = 7494008139977416618;
                                                }
                                            }
                                            _ => {
                                                if array_is_kvstring((*cpv).v.a) == 0 {
                                                    log_error(
                                                        (*srv).errh,
                                                        b"/home/kkysen/work/rust/lighttpd/src/configfile-glue.c\0"
                                                            as *const u8 as *const libc::c_char,
                                                        158 as libc::c_int as libc::c_uint,
                                                        b"%s should have been a list of key => string values like %s = ( \"...\" => \"...\", \"...\" => \"...\" )\0"
                                                            as *const u8 as *const libc::c_char,
                                                        (*cpk_3.offset(i as isize)).k,
                                                        (*cpk_3.offset(i as isize)).k,
                                                    );
                                                    rc = 0 as libc::c_int;
                                                    current_block_37 = 11174649648027449784;
                                                } else {
                                                    current_block_37 = 7494008139977416618;
                                                }
                                            }
                                        }
                                    }
                                    _ => {
                                        current_block_37 = 7494008139977416618;
                                    }
                                }
                            } else {
                                log_error(
                                    (*srv).errh,
                                    b"/home/kkysen/work/rust/lighttpd/src/configfile-glue.c\0"
                                        as *const u8
                                        as *const libc::c_char,
                                    129 as libc::c_int as libc::c_uint,
                                    b"%s should have been a list like %s = ( \"...\" )\0"
                                        as *const u8
                                        as *const libc::c_char,
                                    (*cpk_3.offset(i as isize)).k,
                                    (*cpk_3.offset(i as isize)).k,
                                );
                                rc = 0 as libc::c_int;
                                current_block_37 = 11174649648027449784;
                            }
                        }
                        4711845900019386151 => {
                            log_error(
                                (*srv).errh,
                                b"/home/kkysen/work/rust/lighttpd/src/configfile-glue.c\0"
                                    as *const u8
                                    as *const libc::c_char,
                                272 as libc::c_int as libc::c_uint,
                                b"ERROR: found unsupported key: %s (%s)\0" as *const u8
                                    as *const libc::c_char,
                                (*cpk_3.offset(i as isize)).k,
                                mname,
                            );
                            (*srv).srvconf.config_unsupported = 1 as libc::c_int as libc::c_uchar;
                            current_block_37 = 11174649648027449784;
                        }
                        8566665978537710866 => {
                            log_error(
                                (*srv).errh,
                                b"/home/kkysen/work/rust/lighttpd/src/configfile-glue.c\0"
                                    as *const u8
                                    as *const libc::c_char,
                                277 as libc::c_int as libc::c_uint,
                                b"ERROR: found deprecated key: %s (%s)\0" as *const u8
                                    as *const libc::c_char,
                                (*cpk_3.offset(i as isize)).k,
                                mname,
                            );
                            (*srv).srvconf.config_deprecated = 1 as libc::c_int as libc::c_uchar;
                            current_block_37 = 11174649648027449784;
                        }
                        _ => {}
                    }
                    match current_block_37 {
                        11174649648027449784 => {}
                        _ => {
                            cpv = cpv.offset(1);
                        }
                    }
                }
                4 => {
                    current_block_37 = 7343950298149844727;
                    match current_block_37 {
                        7343950298149844727 => {
                            let mut v_1: libc::c_int =
                                config_plugin_value_tobool(du, -(1 as libc::c_int));
                            if -(1 as libc::c_int) == v_1 {
                                log_error(
                                    (*srv).errh,
                                    b"/home/kkysen/work/rust/lighttpd/src/configfile-glue.c\0"
                                        as *const u8 as *const libc::c_char,
                                    259 as libc::c_int as libc::c_uint,
                                    b"ERROR: unexpected type for key: %s (string) \"(enable|disable)\"\0"
                                        as *const u8 as *const libc::c_char,
                                    (*cpk_3.offset(i as isize)).k,
                                );
                                rc = 0 as libc::c_int;
                                current_block_37 = 11174649648027449784;
                            } else {
                                (*cpv).v.u = v_1 as libc::c_uint;
                                current_block_37 = 7494008139977416618;
                            }
                        }
                        16999457480941319821 => match (*du).type_0 as libc::c_uint {
                            2 => {
                                (*cpv).v.u = (*(du as *const data_integer)).value as libc::c_uint;
                                current_block_37 = 7494008139977416618;
                            }
                            0 => {
                                let v_0: *const libc::c_char =
                                    (*(du as *const data_string)).value.ptr;
                                if !v_0.is_null() && *v_0 as libc::c_int != 0 {
                                    let mut e_0: *mut libc::c_char = 0 as *mut libc::c_char;
                                    let mut l_0: libc::c_long =
                                        strtol(v_0, &mut e_0, 10 as libc::c_int);
                                    if e_0 != v_0 as *mut libc::c_char
                                        && *e_0 == 0
                                        && l_0 >= 0 as libc::c_int as libc::c_long
                                    {
                                        (*cpv).v.shrt = l_0 as libc::c_uint as libc::c_ushort;
                                        current_block_37 = 7494008139977416618;
                                    } else {
                                        current_block_37 = 5891011138178424807;
                                    }
                                } else {
                                    current_block_37 = 5891011138178424807;
                                }
                                match current_block_37 {
                                    7494008139977416618 => {}
                                    _ => {
                                        log_error(
                                                (*srv).errh,
                                                b"/home/kkysen/work/rust/lighttpd/src/configfile-glue.c\0"
                                                    as *const u8 as *const libc::c_char,
                                                242 as libc::c_int as libc::c_uint,
                                                b"got a string but expected an integer: %s %s\0"
                                                    as *const u8 as *const libc::c_char,
                                                (*cpk_3.offset(i as isize)).k,
                                                v_0,
                                            );
                                        rc = 0 as libc::c_int;
                                        current_block_37 = 11174649648027449784;
                                    }
                                }
                            }
                            _ => {
                                log_error(
                                        (*srv).errh,
                                        b"/home/kkysen/work/rust/lighttpd/src/configfile-glue.c\0"
                                            as *const u8 as *const libc::c_char,
                                        248 as libc::c_int as libc::c_uint,
                                        b"unexpected type for key: %s %d expected an integer, range 0 ... 4294967295\0"
                                            as *const u8 as *const libc::c_char,
                                        (*cpk_3.offset(i as isize)).k,
                                        (*du).type_0 as libc::c_uint,
                                    );
                                rc = 0 as libc::c_int;
                                current_block_37 = 11174649648027449784;
                            }
                        },
                        8415733402176751844 => match (*du).type_0 as libc::c_uint {
                            2 => {
                                (*cpv).v.shrt =
                                    (*(du as *const data_integer)).value as libc::c_ushort;
                                current_block_37 = 7494008139977416618;
                            }
                            0 => {
                                let v: *const libc::c_char =
                                    (*(du as *const data_string)).value.ptr;
                                if !v.is_null() && *v as libc::c_int != 0 {
                                    let mut e: *mut libc::c_char = 0 as *mut libc::c_char;
                                    let mut l: libc::c_long = strtol(v, &mut e, 10 as libc::c_int);
                                    if e != v as *mut libc::c_char
                                        && *e == 0
                                        && l >= 0 as libc::c_int as libc::c_long
                                        && l <= 65535 as libc::c_int as libc::c_long
                                    {
                                        (*cpv).v.shrt = l as libc::c_ushort;
                                        current_block_37 = 7494008139977416618;
                                    } else {
                                        current_block_37 = 3123434771885419771;
                                    }
                                } else {
                                    current_block_37 = 3123434771885419771;
                                }
                                match current_block_37 {
                                    7494008139977416618 => {}
                                    _ => {
                                        log_error(
                                                (*srv).errh,
                                                b"/home/kkysen/work/rust/lighttpd/src/configfile-glue.c\0"
                                                    as *const u8 as *const libc::c_char,
                                                214 as libc::c_int as libc::c_uint,
                                                b"got a string but expected a short: %s %s\0" as *const u8
                                                    as *const libc::c_char,
                                                (*cpk_3.offset(i as isize)).k,
                                                v,
                                            );
                                        rc = 0 as libc::c_int;
                                        current_block_37 = 11174649648027449784;
                                    }
                                }
                            }
                            _ => {
                                log_error(
                                        (*srv).errh,
                                        b"/home/kkysen/work/rust/lighttpd/src/configfile-glue.c\0"
                                            as *const u8 as *const libc::c_char,
                                        220 as libc::c_int as libc::c_uint,
                                        b"unexpected type for key: %s %d expected a short integer, range 0 ... 65535\0"
                                            as *const u8 as *const libc::c_char,
                                        (*cpk_3.offset(i as isize)).k,
                                        (*du).type_0 as libc::c_uint,
                                    );
                                rc = 0 as libc::c_int;
                                current_block_37 = 11174649648027449784;
                            }
                        },
                        711017519835216269 => {
                            if (*du).type_0 as libc::c_uint
                                == TYPE_STRING as libc::c_int as libc::c_uint
                            {
                                (*cpv).v.b = &(*(du as *const data_string)).value;
                                current_block_37 = 7494008139977416618;
                            } else {
                                log_error(
                                    (*srv).errh,
                                    b"/home/kkysen/work/rust/lighttpd/src/configfile-glue.c\0"
                                        as *const u8
                                        as *const libc::c_char,
                                    186 as libc::c_int as libc::c_uint,
                                    b"%s should have been a string like ... = \"...\"\0"
                                        as *const u8
                                        as *const libc::c_char,
                                    (*cpk_3.offset(i as isize)).k,
                                );
                                rc = 0 as libc::c_int;
                                current_block_37 = 11174649648027449784;
                            }
                        }
                        5772900442197213762 => {
                            if (*du).type_0 as libc::c_uint
                                == TYPE_ARRAY as libc::c_int as libc::c_uint
                            {
                                (*cpv).v.a = &(*(du as *const data_array)).value;
                                match (*cpk_3.offset(i as isize)).ktype as libc::c_int {
                                    6 => {
                                        current_block_37 = 18094548196697502083;
                                        match current_block_37 {
                                            15359267663982909818 => {
                                                if array_is_vlist((*cpv).v.a) == 0 {
                                                    log_error(
                                                        (*srv).errh,
                                                        b"/home/kkysen/work/rust/lighttpd/src/configfile-glue.c\0"
                                                            as *const u8 as *const libc::c_char,
                                                        168 as libc::c_int as libc::c_uint,
                                                        b"%s should have been a list of string values like %s = ( \"...\", \"...\" )\0"
                                                            as *const u8 as *const libc::c_char,
                                                        (*cpk_3.offset(i as isize)).k,
                                                        (*cpk_3.offset(i as isize)).k,
                                                    );
                                                    rc = 0 as libc::c_int;
                                                    current_block_37 = 11174649648027449784;
                                                } else {
                                                    current_block_37 = 7494008139977416618;
                                                }
                                            }
                                            14601221856387937457 => {
                                                if array_is_kvarray((*cpv).v.a) == 0 {
                                                    log_error(
                                                        (*srv).errh,
                                                        b"/home/kkysen/work/rust/lighttpd/src/configfile-glue.c\0"
                                                            as *const u8 as *const libc::c_char,
                                                        148 as libc::c_int as libc::c_uint,
                                                        b"%s should have been a list of key => list like %s = ( \"...\" => ( \"...\" => \"...\" ) )\0"
                                                            as *const u8 as *const libc::c_char,
                                                        (*cpk_3.offset(i as isize)).k,
                                                        (*cpk_3.offset(i as isize)).k,
                                                    );
                                                    rc = 0 as libc::c_int;
                                                    current_block_37 = 11174649648027449784;
                                                } else {
                                                    current_block_37 = 7494008139977416618;
                                                }
                                            }
                                            18094548196697502083 => {
                                                if array_is_kvany((*cpv).v.a) == 0 {
                                                    log_error(
                                                        (*srv).errh,
                                                        b"/home/kkysen/work/rust/lighttpd/src/configfile-glue.c\0"
                                                            as *const u8 as *const libc::c_char,
                                                        138 as libc::c_int as libc::c_uint,
                                                        b"%s should have been a list of key => values like %s = ( \"...\" => \"...\", \"...\" => \"...\" )\0"
                                                            as *const u8 as *const libc::c_char,
                                                        (*cpk_3.offset(i as isize)).k,
                                                        (*cpk_3.offset(i as isize)).k,
                                                    );
                                                    rc = 0 as libc::c_int;
                                                    current_block_37 = 11174649648027449784;
                                                } else {
                                                    current_block_37 = 7494008139977416618;
                                                }
                                            }
                                            _ => {
                                                if array_is_kvstring((*cpv).v.a) == 0 {
                                                    log_error(
                                                        (*srv).errh,
                                                        b"/home/kkysen/work/rust/lighttpd/src/configfile-glue.c\0"
                                                            as *const u8 as *const libc::c_char,
                                                        158 as libc::c_int as libc::c_uint,
                                                        b"%s should have been a list of key => string values like %s = ( \"...\" => \"...\", \"...\" => \"...\" )\0"
                                                            as *const u8 as *const libc::c_char,
                                                        (*cpk_3.offset(i as isize)).k,
                                                        (*cpk_3.offset(i as isize)).k,
                                                    );
                                                    rc = 0 as libc::c_int;
                                                    current_block_37 = 11174649648027449784;
                                                } else {
                                                    current_block_37 = 7494008139977416618;
                                                }
                                            }
                                        }
                                    }
                                    7 => {
                                        current_block_37 = 14601221856387937457;
                                        match current_block_37 {
                                            15359267663982909818 => {
                                                if array_is_vlist((*cpv).v.a) == 0 {
                                                    log_error(
                                                        (*srv).errh,
                                                        b"/home/kkysen/work/rust/lighttpd/src/configfile-glue.c\0"
                                                            as *const u8 as *const libc::c_char,
                                                        168 as libc::c_int as libc::c_uint,
                                                        b"%s should have been a list of string values like %s = ( \"...\", \"...\" )\0"
                                                            as *const u8 as *const libc::c_char,
                                                        (*cpk_3.offset(i as isize)).k,
                                                        (*cpk_3.offset(i as isize)).k,
                                                    );
                                                    rc = 0 as libc::c_int;
                                                    current_block_37 = 11174649648027449784;
                                                } else {
                                                    current_block_37 = 7494008139977416618;
                                                }
                                            }
                                            14601221856387937457 => {
                                                if array_is_kvarray((*cpv).v.a) == 0 {
                                                    log_error(
                                                        (*srv).errh,
                                                        b"/home/kkysen/work/rust/lighttpd/src/configfile-glue.c\0"
                                                            as *const u8 as *const libc::c_char,
                                                        148 as libc::c_int as libc::c_uint,
                                                        b"%s should have been a list of key => list like %s = ( \"...\" => ( \"...\" => \"...\" ) )\0"
                                                            as *const u8 as *const libc::c_char,
                                                        (*cpk_3.offset(i as isize)).k,
                                                        (*cpk_3.offset(i as isize)).k,
                                                    );
                                                    rc = 0 as libc::c_int;
                                                    current_block_37 = 11174649648027449784;
                                                } else {
                                                    current_block_37 = 7494008139977416618;
                                                }
                                            }
                                            18094548196697502083 => {
                                                if array_is_kvany((*cpv).v.a) == 0 {
                                                    log_error(
                                                        (*srv).errh,
                                                        b"/home/kkysen/work/rust/lighttpd/src/configfile-glue.c\0"
                                                            as *const u8 as *const libc::c_char,
                                                        138 as libc::c_int as libc::c_uint,
                                                        b"%s should have been a list of key => values like %s = ( \"...\" => \"...\", \"...\" => \"...\" )\0"
                                                            as *const u8 as *const libc::c_char,
                                                        (*cpk_3.offset(i as isize)).k,
                                                        (*cpk_3.offset(i as isize)).k,
                                                    );
                                                    rc = 0 as libc::c_int;
                                                    current_block_37 = 11174649648027449784;
                                                } else {
                                                    current_block_37 = 7494008139977416618;
                                                }
                                            }
                                            _ => {
                                                if array_is_kvstring((*cpv).v.a) == 0 {
                                                    log_error(
                                                        (*srv).errh,
                                                        b"/home/kkysen/work/rust/lighttpd/src/configfile-glue.c\0"
                                                            as *const u8 as *const libc::c_char,
                                                        158 as libc::c_int as libc::c_uint,
                                                        b"%s should have been a list of key => string values like %s = ( \"...\" => \"...\", \"...\" => \"...\" )\0"
                                                            as *const u8 as *const libc::c_char,
                                                        (*cpk_3.offset(i as isize)).k,
                                                        (*cpk_3.offset(i as isize)).k,
                                                    );
                                                    rc = 0 as libc::c_int;
                                                    current_block_37 = 11174649648027449784;
                                                } else {
                                                    current_block_37 = 7494008139977416618;
                                                }
                                            }
                                        }
                                    }
                                    8 => {
                                        current_block_37 = 2973921165121704668;
                                        match current_block_37 {
                                            15359267663982909818 => {
                                                if array_is_vlist((*cpv).v.a) == 0 {
                                                    log_error(
                                                        (*srv).errh,
                                                        b"/home/kkysen/work/rust/lighttpd/src/configfile-glue.c\0"
                                                            as *const u8 as *const libc::c_char,
                                                        168 as libc::c_int as libc::c_uint,
                                                        b"%s should have been a list of string values like %s = ( \"...\", \"...\" )\0"
                                                            as *const u8 as *const libc::c_char,
                                                        (*cpk_3.offset(i as isize)).k,
                                                        (*cpk_3.offset(i as isize)).k,
                                                    );
                                                    rc = 0 as libc::c_int;
                                                    current_block_37 = 11174649648027449784;
                                                } else {
                                                    current_block_37 = 7494008139977416618;
                                                }
                                            }
                                            14601221856387937457 => {
                                                if array_is_kvarray((*cpv).v.a) == 0 {
                                                    log_error(
                                                        (*srv).errh,
                                                        b"/home/kkysen/work/rust/lighttpd/src/configfile-glue.c\0"
                                                            as *const u8 as *const libc::c_char,
                                                        148 as libc::c_int as libc::c_uint,
                                                        b"%s should have been a list of key => list like %s = ( \"...\" => ( \"...\" => \"...\" ) )\0"
                                                            as *const u8 as *const libc::c_char,
                                                        (*cpk_3.offset(i as isize)).k,
                                                        (*cpk_3.offset(i as isize)).k,
                                                    );
                                                    rc = 0 as libc::c_int;
                                                    current_block_37 = 11174649648027449784;
                                                } else {
                                                    current_block_37 = 7494008139977416618;
                                                }
                                            }
                                            18094548196697502083 => {
                                                if array_is_kvany((*cpv).v.a) == 0 {
                                                    log_error(
                                                        (*srv).errh,
                                                        b"/home/kkysen/work/rust/lighttpd/src/configfile-glue.c\0"
                                                            as *const u8 as *const libc::c_char,
                                                        138 as libc::c_int as libc::c_uint,
                                                        b"%s should have been a list of key => values like %s = ( \"...\" => \"...\", \"...\" => \"...\" )\0"
                                                            as *const u8 as *const libc::c_char,
                                                        (*cpk_3.offset(i as isize)).k,
                                                        (*cpk_3.offset(i as isize)).k,
                                                    );
                                                    rc = 0 as libc::c_int;
                                                    current_block_37 = 11174649648027449784;
                                                } else {
                                                    current_block_37 = 7494008139977416618;
                                                }
                                            }
                                            _ => {
                                                if array_is_kvstring((*cpv).v.a) == 0 {
                                                    log_error(
                                                        (*srv).errh,
                                                        b"/home/kkysen/work/rust/lighttpd/src/configfile-glue.c\0"
                                                            as *const u8 as *const libc::c_char,
                                                        158 as libc::c_int as libc::c_uint,
                                                        b"%s should have been a list of key => string values like %s = ( \"...\" => \"...\", \"...\" => \"...\" )\0"
                                                            as *const u8 as *const libc::c_char,
                                                        (*cpk_3.offset(i as isize)).k,
                                                        (*cpk_3.offset(i as isize)).k,
                                                    );
                                                    rc = 0 as libc::c_int;
                                                    current_block_37 = 11174649648027449784;
                                                } else {
                                                    current_block_37 = 7494008139977416618;
                                                }
                                            }
                                        }
                                    }
                                    9 => {
                                        current_block_37 = 15359267663982909818;
                                        match current_block_37 {
                                            15359267663982909818 => {
                                                if array_is_vlist((*cpv).v.a) == 0 {
                                                    log_error(
                                                        (*srv).errh,
                                                        b"/home/kkysen/work/rust/lighttpd/src/configfile-glue.c\0"
                                                            as *const u8 as *const libc::c_char,
                                                        168 as libc::c_int as libc::c_uint,
                                                        b"%s should have been a list of string values like %s = ( \"...\", \"...\" )\0"
                                                            as *const u8 as *const libc::c_char,
                                                        (*cpk_3.offset(i as isize)).k,
                                                        (*cpk_3.offset(i as isize)).k,
                                                    );
                                                    rc = 0 as libc::c_int;
                                                    current_block_37 = 11174649648027449784;
                                                } else {
                                                    current_block_37 = 7494008139977416618;
                                                }
                                            }
                                            14601221856387937457 => {
                                                if array_is_kvarray((*cpv).v.a) == 0 {
                                                    log_error(
                                                        (*srv).errh,
                                                        b"/home/kkysen/work/rust/lighttpd/src/configfile-glue.c\0"
                                                            as *const u8 as *const libc::c_char,
                                                        148 as libc::c_int as libc::c_uint,
                                                        b"%s should have been a list of key => list like %s = ( \"...\" => ( \"...\" => \"...\" ) )\0"
                                                            as *const u8 as *const libc::c_char,
                                                        (*cpk_3.offset(i as isize)).k,
                                                        (*cpk_3.offset(i as isize)).k,
                                                    );
                                                    rc = 0 as libc::c_int;
                                                    current_block_37 = 11174649648027449784;
                                                } else {
                                                    current_block_37 = 7494008139977416618;
                                                }
                                            }
                                            18094548196697502083 => {
                                                if array_is_kvany((*cpv).v.a) == 0 {
                                                    log_error(
                                                        (*srv).errh,
                                                        b"/home/kkysen/work/rust/lighttpd/src/configfile-glue.c\0"
                                                            as *const u8 as *const libc::c_char,
                                                        138 as libc::c_int as libc::c_uint,
                                                        b"%s should have been a list of key => values like %s = ( \"...\" => \"...\", \"...\" => \"...\" )\0"
                                                            as *const u8 as *const libc::c_char,
                                                        (*cpk_3.offset(i as isize)).k,
                                                        (*cpk_3.offset(i as isize)).k,
                                                    );
                                                    rc = 0 as libc::c_int;
                                                    current_block_37 = 11174649648027449784;
                                                } else {
                                                    current_block_37 = 7494008139977416618;
                                                }
                                            }
                                            _ => {
                                                if array_is_kvstring((*cpv).v.a) == 0 {
                                                    log_error(
                                                        (*srv).errh,
                                                        b"/home/kkysen/work/rust/lighttpd/src/configfile-glue.c\0"
                                                            as *const u8 as *const libc::c_char,
                                                        158 as libc::c_int as libc::c_uint,
                                                        b"%s should have been a list of key => string values like %s = ( \"...\" => \"...\", \"...\" => \"...\" )\0"
                                                            as *const u8 as *const libc::c_char,
                                                        (*cpk_3.offset(i as isize)).k,
                                                        (*cpk_3.offset(i as isize)).k,
                                                    );
                                                    rc = 0 as libc::c_int;
                                                    current_block_37 = 11174649648027449784;
                                                } else {
                                                    current_block_37 = 7494008139977416618;
                                                }
                                            }
                                        }
                                    }
                                    _ => {
                                        current_block_37 = 7494008139977416618;
                                    }
                                }
                            } else {
                                log_error(
                                    (*srv).errh,
                                    b"/home/kkysen/work/rust/lighttpd/src/configfile-glue.c\0"
                                        as *const u8
                                        as *const libc::c_char,
                                    129 as libc::c_int as libc::c_uint,
                                    b"%s should have been a list like %s = ( \"...\" )\0"
                                        as *const u8
                                        as *const libc::c_char,
                                    (*cpk_3.offset(i as isize)).k,
                                    (*cpk_3.offset(i as isize)).k,
                                );
                                rc = 0 as libc::c_int;
                                current_block_37 = 11174649648027449784;
                            }
                        }
                        4711845900019386151 => {
                            log_error(
                                (*srv).errh,
                                b"/home/kkysen/work/rust/lighttpd/src/configfile-glue.c\0"
                                    as *const u8
                                    as *const libc::c_char,
                                272 as libc::c_int as libc::c_uint,
                                b"ERROR: found unsupported key: %s (%s)\0" as *const u8
                                    as *const libc::c_char,
                                (*cpk_3.offset(i as isize)).k,
                                mname,
                            );
                            (*srv).srvconf.config_unsupported = 1 as libc::c_int as libc::c_uchar;
                            current_block_37 = 11174649648027449784;
                        }
                        8566665978537710866 => {
                            log_error(
                                (*srv).errh,
                                b"/home/kkysen/work/rust/lighttpd/src/configfile-glue.c\0"
                                    as *const u8
                                    as *const libc::c_char,
                                277 as libc::c_int as libc::c_uint,
                                b"ERROR: found deprecated key: %s (%s)\0" as *const u8
                                    as *const libc::c_char,
                                (*cpk_3.offset(i as isize)).k,
                                mname,
                            );
                            (*srv).srvconf.config_deprecated = 1 as libc::c_int as libc::c_uchar;
                            current_block_37 = 11174649648027449784;
                        }
                        _ => {}
                    }
                    match current_block_37 {
                        11174649648027449784 => {}
                        _ => {
                            cpv = cpv.offset(1);
                        }
                    }
                }
                10 | 0 => {}
                12 => {
                    current_block_37 = 4711845900019386151;
                    match current_block_37 {
                        7343950298149844727 => {
                            let mut v_1: libc::c_int =
                                config_plugin_value_tobool(du, -(1 as libc::c_int));
                            if -(1 as libc::c_int) == v_1 {
                                log_error(
                                    (*srv).errh,
                                    b"/home/kkysen/work/rust/lighttpd/src/configfile-glue.c\0"
                                        as *const u8 as *const libc::c_char,
                                    259 as libc::c_int as libc::c_uint,
                                    b"ERROR: unexpected type for key: %s (string) \"(enable|disable)\"\0"
                                        as *const u8 as *const libc::c_char,
                                    (*cpk_3.offset(i as isize)).k,
                                );
                                rc = 0 as libc::c_int;
                                current_block_37 = 11174649648027449784;
                            } else {
                                (*cpv).v.u = v_1 as libc::c_uint;
                                current_block_37 = 7494008139977416618;
                            }
                        }
                        16999457480941319821 => match (*du).type_0 as libc::c_uint {
                            2 => {
                                (*cpv).v.u = (*(du as *const data_integer)).value as libc::c_uint;
                                current_block_37 = 7494008139977416618;
                            }
                            0 => {
                                let v_0: *const libc::c_char =
                                    (*(du as *const data_string)).value.ptr;
                                if !v_0.is_null() && *v_0 as libc::c_int != 0 {
                                    let mut e_0: *mut libc::c_char = 0 as *mut libc::c_char;
                                    let mut l_0: libc::c_long =
                                        strtol(v_0, &mut e_0, 10 as libc::c_int);
                                    if e_0 != v_0 as *mut libc::c_char
                                        && *e_0 == 0
                                        && l_0 >= 0 as libc::c_int as libc::c_long
                                    {
                                        (*cpv).v.shrt = l_0 as libc::c_uint as libc::c_ushort;
                                        current_block_37 = 7494008139977416618;
                                    } else {
                                        current_block_37 = 5891011138178424807;
                                    }
                                } else {
                                    current_block_37 = 5891011138178424807;
                                }
                                match current_block_37 {
                                    7494008139977416618 => {}
                                    _ => {
                                        log_error(
                                                (*srv).errh,
                                                b"/home/kkysen/work/rust/lighttpd/src/configfile-glue.c\0"
                                                    as *const u8 as *const libc::c_char,
                                                242 as libc::c_int as libc::c_uint,
                                                b"got a string but expected an integer: %s %s\0"
                                                    as *const u8 as *const libc::c_char,
                                                (*cpk_3.offset(i as isize)).k,
                                                v_0,
                                            );
                                        rc = 0 as libc::c_int;
                                        current_block_37 = 11174649648027449784;
                                    }
                                }
                            }
                            _ => {
                                log_error(
                                        (*srv).errh,
                                        b"/home/kkysen/work/rust/lighttpd/src/configfile-glue.c\0"
                                            as *const u8 as *const libc::c_char,
                                        248 as libc::c_int as libc::c_uint,
                                        b"unexpected type for key: %s %d expected an integer, range 0 ... 4294967295\0"
                                            as *const u8 as *const libc::c_char,
                                        (*cpk_3.offset(i as isize)).k,
                                        (*du).type_0 as libc::c_uint,
                                    );
                                rc = 0 as libc::c_int;
                                current_block_37 = 11174649648027449784;
                            }
                        },
                        8415733402176751844 => match (*du).type_0 as libc::c_uint {
                            2 => {
                                (*cpv).v.shrt =
                                    (*(du as *const data_integer)).value as libc::c_ushort;
                                current_block_37 = 7494008139977416618;
                            }
                            0 => {
                                let v: *const libc::c_char =
                                    (*(du as *const data_string)).value.ptr;
                                if !v.is_null() && *v as libc::c_int != 0 {
                                    let mut e: *mut libc::c_char = 0 as *mut libc::c_char;
                                    let mut l: libc::c_long = strtol(v, &mut e, 10 as libc::c_int);
                                    if e != v as *mut libc::c_char
                                        && *e == 0
                                        && l >= 0 as libc::c_int as libc::c_long
                                        && l <= 65535 as libc::c_int as libc::c_long
                                    {
                                        (*cpv).v.shrt = l as libc::c_ushort;
                                        current_block_37 = 7494008139977416618;
                                    } else {
                                        current_block_37 = 3123434771885419771;
                                    }
                                } else {
                                    current_block_37 = 3123434771885419771;
                                }
                                match current_block_37 {
                                    7494008139977416618 => {}
                                    _ => {
                                        log_error(
                                                (*srv).errh,
                                                b"/home/kkysen/work/rust/lighttpd/src/configfile-glue.c\0"
                                                    as *const u8 as *const libc::c_char,
                                                214 as libc::c_int as libc::c_uint,
                                                b"got a string but expected a short: %s %s\0" as *const u8
                                                    as *const libc::c_char,
                                                (*cpk_3.offset(i as isize)).k,
                                                v,
                                            );
                                        rc = 0 as libc::c_int;
                                        current_block_37 = 11174649648027449784;
                                    }
                                }
                            }
                            _ => {
                                log_error(
                                        (*srv).errh,
                                        b"/home/kkysen/work/rust/lighttpd/src/configfile-glue.c\0"
                                            as *const u8 as *const libc::c_char,
                                        220 as libc::c_int as libc::c_uint,
                                        b"unexpected type for key: %s %d expected a short integer, range 0 ... 65535\0"
                                            as *const u8 as *const libc::c_char,
                                        (*cpk_3.offset(i as isize)).k,
                                        (*du).type_0 as libc::c_uint,
                                    );
                                rc = 0 as libc::c_int;
                                current_block_37 = 11174649648027449784;
                            }
                        },
                        711017519835216269 => {
                            if (*du).type_0 as libc::c_uint
                                == TYPE_STRING as libc::c_int as libc::c_uint
                            {
                                (*cpv).v.b = &(*(du as *const data_string)).value;
                                current_block_37 = 7494008139977416618;
                            } else {
                                log_error(
                                    (*srv).errh,
                                    b"/home/kkysen/work/rust/lighttpd/src/configfile-glue.c\0"
                                        as *const u8
                                        as *const libc::c_char,
                                    186 as libc::c_int as libc::c_uint,
                                    b"%s should have been a string like ... = \"...\"\0"
                                        as *const u8
                                        as *const libc::c_char,
                                    (*cpk_3.offset(i as isize)).k,
                                );
                                rc = 0 as libc::c_int;
                                current_block_37 = 11174649648027449784;
                            }
                        }
                        5772900442197213762 => {
                            if (*du).type_0 as libc::c_uint
                                == TYPE_ARRAY as libc::c_int as libc::c_uint
                            {
                                (*cpv).v.a = &(*(du as *const data_array)).value;
                                match (*cpk_3.offset(i as isize)).ktype as libc::c_int {
                                    6 => {
                                        current_block_37 = 18094548196697502083;
                                        match current_block_37 {
                                            15359267663982909818 => {
                                                if array_is_vlist((*cpv).v.a) == 0 {
                                                    log_error(
                                                        (*srv).errh,
                                                        b"/home/kkysen/work/rust/lighttpd/src/configfile-glue.c\0"
                                                            as *const u8 as *const libc::c_char,
                                                        168 as libc::c_int as libc::c_uint,
                                                        b"%s should have been a list of string values like %s = ( \"...\", \"...\" )\0"
                                                            as *const u8 as *const libc::c_char,
                                                        (*cpk_3.offset(i as isize)).k,
                                                        (*cpk_3.offset(i as isize)).k,
                                                    );
                                                    rc = 0 as libc::c_int;
                                                    current_block_37 = 11174649648027449784;
                                                } else {
                                                    current_block_37 = 7494008139977416618;
                                                }
                                            }
                                            14601221856387937457 => {
                                                if array_is_kvarray((*cpv).v.a) == 0 {
                                                    log_error(
                                                        (*srv).errh,
                                                        b"/home/kkysen/work/rust/lighttpd/src/configfile-glue.c\0"
                                                            as *const u8 as *const libc::c_char,
                                                        148 as libc::c_int as libc::c_uint,
                                                        b"%s should have been a list of key => list like %s = ( \"...\" => ( \"...\" => \"...\" ) )\0"
                                                            as *const u8 as *const libc::c_char,
                                                        (*cpk_3.offset(i as isize)).k,
                                                        (*cpk_3.offset(i as isize)).k,
                                                    );
                                                    rc = 0 as libc::c_int;
                                                    current_block_37 = 11174649648027449784;
                                                } else {
                                                    current_block_37 = 7494008139977416618;
                                                }
                                            }
                                            18094548196697502083 => {
                                                if array_is_kvany((*cpv).v.a) == 0 {
                                                    log_error(
                                                        (*srv).errh,
                                                        b"/home/kkysen/work/rust/lighttpd/src/configfile-glue.c\0"
                                                            as *const u8 as *const libc::c_char,
                                                        138 as libc::c_int as libc::c_uint,
                                                        b"%s should have been a list of key => values like %s = ( \"...\" => \"...\", \"...\" => \"...\" )\0"
                                                            as *const u8 as *const libc::c_char,
                                                        (*cpk_3.offset(i as isize)).k,
                                                        (*cpk_3.offset(i as isize)).k,
                                                    );
                                                    rc = 0 as libc::c_int;
                                                    current_block_37 = 11174649648027449784;
                                                } else {
                                                    current_block_37 = 7494008139977416618;
                                                }
                                            }
                                            _ => {
                                                if array_is_kvstring((*cpv).v.a) == 0 {
                                                    log_error(
                                                        (*srv).errh,
                                                        b"/home/kkysen/work/rust/lighttpd/src/configfile-glue.c\0"
                                                            as *const u8 as *const libc::c_char,
                                                        158 as libc::c_int as libc::c_uint,
                                                        b"%s should have been a list of key => string values like %s = ( \"...\" => \"...\", \"...\" => \"...\" )\0"
                                                            as *const u8 as *const libc::c_char,
                                                        (*cpk_3.offset(i as isize)).k,
                                                        (*cpk_3.offset(i as isize)).k,
                                                    );
                                                    rc = 0 as libc::c_int;
                                                    current_block_37 = 11174649648027449784;
                                                } else {
                                                    current_block_37 = 7494008139977416618;
                                                }
                                            }
                                        }
                                    }
                                    7 => {
                                        current_block_37 = 14601221856387937457;
                                        match current_block_37 {
                                            15359267663982909818 => {
                                                if array_is_vlist((*cpv).v.a) == 0 {
                                                    log_error(
                                                        (*srv).errh,
                                                        b"/home/kkysen/work/rust/lighttpd/src/configfile-glue.c\0"
                                                            as *const u8 as *const libc::c_char,
                                                        168 as libc::c_int as libc::c_uint,
                                                        b"%s should have been a list of string values like %s = ( \"...\", \"...\" )\0"
                                                            as *const u8 as *const libc::c_char,
                                                        (*cpk_3.offset(i as isize)).k,
                                                        (*cpk_3.offset(i as isize)).k,
                                                    );
                                                    rc = 0 as libc::c_int;
                                                    current_block_37 = 11174649648027449784;
                                                } else {
                                                    current_block_37 = 7494008139977416618;
                                                }
                                            }
                                            14601221856387937457 => {
                                                if array_is_kvarray((*cpv).v.a) == 0 {
                                                    log_error(
                                                        (*srv).errh,
                                                        b"/home/kkysen/work/rust/lighttpd/src/configfile-glue.c\0"
                                                            as *const u8 as *const libc::c_char,
                                                        148 as libc::c_int as libc::c_uint,
                                                        b"%s should have been a list of key => list like %s = ( \"...\" => ( \"...\" => \"...\" ) )\0"
                                                            as *const u8 as *const libc::c_char,
                                                        (*cpk_3.offset(i as isize)).k,
                                                        (*cpk_3.offset(i as isize)).k,
                                                    );
                                                    rc = 0 as libc::c_int;
                                                    current_block_37 = 11174649648027449784;
                                                } else {
                                                    current_block_37 = 7494008139977416618;
                                                }
                                            }
                                            18094548196697502083 => {
                                                if array_is_kvany((*cpv).v.a) == 0 {
                                                    log_error(
                                                        (*srv).errh,
                                                        b"/home/kkysen/work/rust/lighttpd/src/configfile-glue.c\0"
                                                            as *const u8 as *const libc::c_char,
                                                        138 as libc::c_int as libc::c_uint,
                                                        b"%s should have been a list of key => values like %s = ( \"...\" => \"...\", \"...\" => \"...\" )\0"
                                                            as *const u8 as *const libc::c_char,
                                                        (*cpk_3.offset(i as isize)).k,
                                                        (*cpk_3.offset(i as isize)).k,
                                                    );
                                                    rc = 0 as libc::c_int;
                                                    current_block_37 = 11174649648027449784;
                                                } else {
                                                    current_block_37 = 7494008139977416618;
                                                }
                                            }
                                            _ => {
                                                if array_is_kvstring((*cpv).v.a) == 0 {
                                                    log_error(
                                                        (*srv).errh,
                                                        b"/home/kkysen/work/rust/lighttpd/src/configfile-glue.c\0"
                                                            as *const u8 as *const libc::c_char,
                                                        158 as libc::c_int as libc::c_uint,
                                                        b"%s should have been a list of key => string values like %s = ( \"...\" => \"...\", \"...\" => \"...\" )\0"
                                                            as *const u8 as *const libc::c_char,
                                                        (*cpk_3.offset(i as isize)).k,
                                                        (*cpk_3.offset(i as isize)).k,
                                                    );
                                                    rc = 0 as libc::c_int;
                                                    current_block_37 = 11174649648027449784;
                                                } else {
                                                    current_block_37 = 7494008139977416618;
                                                }
                                            }
                                        }
                                    }
                                    8 => {
                                        current_block_37 = 2973921165121704668;
                                        match current_block_37 {
                                            15359267663982909818 => {
                                                if array_is_vlist((*cpv).v.a) == 0 {
                                                    log_error(
                                                        (*srv).errh,
                                                        b"/home/kkysen/work/rust/lighttpd/src/configfile-glue.c\0"
                                                            as *const u8 as *const libc::c_char,
                                                        168 as libc::c_int as libc::c_uint,
                                                        b"%s should have been a list of string values like %s = ( \"...\", \"...\" )\0"
                                                            as *const u8 as *const libc::c_char,
                                                        (*cpk_3.offset(i as isize)).k,
                                                        (*cpk_3.offset(i as isize)).k,
                                                    );
                                                    rc = 0 as libc::c_int;
                                                    current_block_37 = 11174649648027449784;
                                                } else {
                                                    current_block_37 = 7494008139977416618;
                                                }
                                            }
                                            14601221856387937457 => {
                                                if array_is_kvarray((*cpv).v.a) == 0 {
                                                    log_error(
                                                        (*srv).errh,
                                                        b"/home/kkysen/work/rust/lighttpd/src/configfile-glue.c\0"
                                                            as *const u8 as *const libc::c_char,
                                                        148 as libc::c_int as libc::c_uint,
                                                        b"%s should have been a list of key => list like %s = ( \"...\" => ( \"...\" => \"...\" ) )\0"
                                                            as *const u8 as *const libc::c_char,
                                                        (*cpk_3.offset(i as isize)).k,
                                                        (*cpk_3.offset(i as isize)).k,
                                                    );
                                                    rc = 0 as libc::c_int;
                                                    current_block_37 = 11174649648027449784;
                                                } else {
                                                    current_block_37 = 7494008139977416618;
                                                }
                                            }
                                            18094548196697502083 => {
                                                if array_is_kvany((*cpv).v.a) == 0 {
                                                    log_error(
                                                        (*srv).errh,
                                                        b"/home/kkysen/work/rust/lighttpd/src/configfile-glue.c\0"
                                                            as *const u8 as *const libc::c_char,
                                                        138 as libc::c_int as libc::c_uint,
                                                        b"%s should have been a list of key => values like %s = ( \"...\" => \"...\", \"...\" => \"...\" )\0"
                                                            as *const u8 as *const libc::c_char,
                                                        (*cpk_3.offset(i as isize)).k,
                                                        (*cpk_3.offset(i as isize)).k,
                                                    );
                                                    rc = 0 as libc::c_int;
                                                    current_block_37 = 11174649648027449784;
                                                } else {
                                                    current_block_37 = 7494008139977416618;
                                                }
                                            }
                                            _ => {
                                                if array_is_kvstring((*cpv).v.a) == 0 {
                                                    log_error(
                                                        (*srv).errh,
                                                        b"/home/kkysen/work/rust/lighttpd/src/configfile-glue.c\0"
                                                            as *const u8 as *const libc::c_char,
                                                        158 as libc::c_int as libc::c_uint,
                                                        b"%s should have been a list of key => string values like %s = ( \"...\" => \"...\", \"...\" => \"...\" )\0"
                                                            as *const u8 as *const libc::c_char,
                                                        (*cpk_3.offset(i as isize)).k,
                                                        (*cpk_3.offset(i as isize)).k,
                                                    );
                                                    rc = 0 as libc::c_int;
                                                    current_block_37 = 11174649648027449784;
                                                } else {
                                                    current_block_37 = 7494008139977416618;
                                                }
                                            }
                                        }
                                    }
                                    9 => {
                                        current_block_37 = 15359267663982909818;
                                        match current_block_37 {
                                            15359267663982909818 => {
                                                if array_is_vlist((*cpv).v.a) == 0 {
                                                    log_error(
                                                        (*srv).errh,
                                                        b"/home/kkysen/work/rust/lighttpd/src/configfile-glue.c\0"
                                                            as *const u8 as *const libc::c_char,
                                                        168 as libc::c_int as libc::c_uint,
                                                        b"%s should have been a list of string values like %s = ( \"...\", \"...\" )\0"
                                                            as *const u8 as *const libc::c_char,
                                                        (*cpk_3.offset(i as isize)).k,
                                                        (*cpk_3.offset(i as isize)).k,
                                                    );
                                                    rc = 0 as libc::c_int;
                                                    current_block_37 = 11174649648027449784;
                                                } else {
                                                    current_block_37 = 7494008139977416618;
                                                }
                                            }
                                            14601221856387937457 => {
                                                if array_is_kvarray((*cpv).v.a) == 0 {
                                                    log_error(
                                                        (*srv).errh,
                                                        b"/home/kkysen/work/rust/lighttpd/src/configfile-glue.c\0"
                                                            as *const u8 as *const libc::c_char,
                                                        148 as libc::c_int as libc::c_uint,
                                                        b"%s should have been a list of key => list like %s = ( \"...\" => ( \"...\" => \"...\" ) )\0"
                                                            as *const u8 as *const libc::c_char,
                                                        (*cpk_3.offset(i as isize)).k,
                                                        (*cpk_3.offset(i as isize)).k,
                                                    );
                                                    rc = 0 as libc::c_int;
                                                    current_block_37 = 11174649648027449784;
                                                } else {
                                                    current_block_37 = 7494008139977416618;
                                                }
                                            }
                                            18094548196697502083 => {
                                                if array_is_kvany((*cpv).v.a) == 0 {
                                                    log_error(
                                                        (*srv).errh,
                                                        b"/home/kkysen/work/rust/lighttpd/src/configfile-glue.c\0"
                                                            as *const u8 as *const libc::c_char,
                                                        138 as libc::c_int as libc::c_uint,
                                                        b"%s should have been a list of key => values like %s = ( \"...\" => \"...\", \"...\" => \"...\" )\0"
                                                            as *const u8 as *const libc::c_char,
                                                        (*cpk_3.offset(i as isize)).k,
                                                        (*cpk_3.offset(i as isize)).k,
                                                    );
                                                    rc = 0 as libc::c_int;
                                                    current_block_37 = 11174649648027449784;
                                                } else {
                                                    current_block_37 = 7494008139977416618;
                                                }
                                            }
                                            _ => {
                                                if array_is_kvstring((*cpv).v.a) == 0 {
                                                    log_error(
                                                        (*srv).errh,
                                                        b"/home/kkysen/work/rust/lighttpd/src/configfile-glue.c\0"
                                                            as *const u8 as *const libc::c_char,
                                                        158 as libc::c_int as libc::c_uint,
                                                        b"%s should have been a list of key => string values like %s = ( \"...\" => \"...\", \"...\" => \"...\" )\0"
                                                            as *const u8 as *const libc::c_char,
                                                        (*cpk_3.offset(i as isize)).k,
                                                        (*cpk_3.offset(i as isize)).k,
                                                    );
                                                    rc = 0 as libc::c_int;
                                                    current_block_37 = 11174649648027449784;
                                                } else {
                                                    current_block_37 = 7494008139977416618;
                                                }
                                            }
                                        }
                                    }
                                    _ => {
                                        current_block_37 = 7494008139977416618;
                                    }
                                }
                            } else {
                                log_error(
                                    (*srv).errh,
                                    b"/home/kkysen/work/rust/lighttpd/src/configfile-glue.c\0"
                                        as *const u8
                                        as *const libc::c_char,
                                    129 as libc::c_int as libc::c_uint,
                                    b"%s should have been a list like %s = ( \"...\" )\0"
                                        as *const u8
                                        as *const libc::c_char,
                                    (*cpk_3.offset(i as isize)).k,
                                    (*cpk_3.offset(i as isize)).k,
                                );
                                rc = 0 as libc::c_int;
                                current_block_37 = 11174649648027449784;
                            }
                        }
                        4711845900019386151 => {
                            log_error(
                                (*srv).errh,
                                b"/home/kkysen/work/rust/lighttpd/src/configfile-glue.c\0"
                                    as *const u8
                                    as *const libc::c_char,
                                272 as libc::c_int as libc::c_uint,
                                b"ERROR: found unsupported key: %s (%s)\0" as *const u8
                                    as *const libc::c_char,
                                (*cpk_3.offset(i as isize)).k,
                                mname,
                            );
                            (*srv).srvconf.config_unsupported = 1 as libc::c_int as libc::c_uchar;
                            current_block_37 = 11174649648027449784;
                        }
                        8566665978537710866 => {
                            log_error(
                                (*srv).errh,
                                b"/home/kkysen/work/rust/lighttpd/src/configfile-glue.c\0"
                                    as *const u8
                                    as *const libc::c_char,
                                277 as libc::c_int as libc::c_uint,
                                b"ERROR: found deprecated key: %s (%s)\0" as *const u8
                                    as *const libc::c_char,
                                (*cpk_3.offset(i as isize)).k,
                                mname,
                            );
                            (*srv).srvconf.config_deprecated = 1 as libc::c_int as libc::c_uchar;
                            current_block_37 = 11174649648027449784;
                        }
                        _ => {}
                    }
                    match current_block_37 {
                        11174649648027449784 => {}
                        _ => {
                            cpv = cpv.offset(1);
                        }
                    }
                }
                11 => {
                    current_block_37 = 8566665978537710866;
                    match current_block_37 {
                        7343950298149844727 => {
                            let mut v_1: libc::c_int =
                                config_plugin_value_tobool(du, -(1 as libc::c_int));
                            if -(1 as libc::c_int) == v_1 {
                                log_error(
                                    (*srv).errh,
                                    b"/home/kkysen/work/rust/lighttpd/src/configfile-glue.c\0"
                                        as *const u8 as *const libc::c_char,
                                    259 as libc::c_int as libc::c_uint,
                                    b"ERROR: unexpected type for key: %s (string) \"(enable|disable)\"\0"
                                        as *const u8 as *const libc::c_char,
                                    (*cpk_3.offset(i as isize)).k,
                                );
                                rc = 0 as libc::c_int;
                                current_block_37 = 11174649648027449784;
                            } else {
                                (*cpv).v.u = v_1 as libc::c_uint;
                                current_block_37 = 7494008139977416618;
                            }
                        }
                        16999457480941319821 => match (*du).type_0 as libc::c_uint {
                            2 => {
                                (*cpv).v.u = (*(du as *const data_integer)).value as libc::c_uint;
                                current_block_37 = 7494008139977416618;
                            }
                            0 => {
                                let v_0: *const libc::c_char =
                                    (*(du as *const data_string)).value.ptr;
                                if !v_0.is_null() && *v_0 as libc::c_int != 0 {
                                    let mut e_0: *mut libc::c_char = 0 as *mut libc::c_char;
                                    let mut l_0: libc::c_long =
                                        strtol(v_0, &mut e_0, 10 as libc::c_int);
                                    if e_0 != v_0 as *mut libc::c_char
                                        && *e_0 == 0
                                        && l_0 >= 0 as libc::c_int as libc::c_long
                                    {
                                        (*cpv).v.shrt = l_0 as libc::c_uint as libc::c_ushort;
                                        current_block_37 = 7494008139977416618;
                                    } else {
                                        current_block_37 = 5891011138178424807;
                                    }
                                } else {
                                    current_block_37 = 5891011138178424807;
                                }
                                match current_block_37 {
                                    7494008139977416618 => {}
                                    _ => {
                                        log_error(
                                                (*srv).errh,
                                                b"/home/kkysen/work/rust/lighttpd/src/configfile-glue.c\0"
                                                    as *const u8 as *const libc::c_char,
                                                242 as libc::c_int as libc::c_uint,
                                                b"got a string but expected an integer: %s %s\0"
                                                    as *const u8 as *const libc::c_char,
                                                (*cpk_3.offset(i as isize)).k,
                                                v_0,
                                            );
                                        rc = 0 as libc::c_int;
                                        current_block_37 = 11174649648027449784;
                                    }
                                }
                            }
                            _ => {
                                log_error(
                                        (*srv).errh,
                                        b"/home/kkysen/work/rust/lighttpd/src/configfile-glue.c\0"
                                            as *const u8 as *const libc::c_char,
                                        248 as libc::c_int as libc::c_uint,
                                        b"unexpected type for key: %s %d expected an integer, range 0 ... 4294967295\0"
                                            as *const u8 as *const libc::c_char,
                                        (*cpk_3.offset(i as isize)).k,
                                        (*du).type_0 as libc::c_uint,
                                    );
                                rc = 0 as libc::c_int;
                                current_block_37 = 11174649648027449784;
                            }
                        },
                        8415733402176751844 => match (*du).type_0 as libc::c_uint {
                            2 => {
                                (*cpv).v.shrt =
                                    (*(du as *const data_integer)).value as libc::c_ushort;
                                current_block_37 = 7494008139977416618;
                            }
                            0 => {
                                let v: *const libc::c_char =
                                    (*(du as *const data_string)).value.ptr;
                                if !v.is_null() && *v as libc::c_int != 0 {
                                    let mut e: *mut libc::c_char = 0 as *mut libc::c_char;
                                    let mut l: libc::c_long = strtol(v, &mut e, 10 as libc::c_int);
                                    if e != v as *mut libc::c_char
                                        && *e == 0
                                        && l >= 0 as libc::c_int as libc::c_long
                                        && l <= 65535 as libc::c_int as libc::c_long
                                    {
                                        (*cpv).v.shrt = l as libc::c_ushort;
                                        current_block_37 = 7494008139977416618;
                                    } else {
                                        current_block_37 = 3123434771885419771;
                                    }
                                } else {
                                    current_block_37 = 3123434771885419771;
                                }
                                match current_block_37 {
                                    7494008139977416618 => {}
                                    _ => {
                                        log_error(
                                                (*srv).errh,
                                                b"/home/kkysen/work/rust/lighttpd/src/configfile-glue.c\0"
                                                    as *const u8 as *const libc::c_char,
                                                214 as libc::c_int as libc::c_uint,
                                                b"got a string but expected a short: %s %s\0" as *const u8
                                                    as *const libc::c_char,
                                                (*cpk_3.offset(i as isize)).k,
                                                v,
                                            );
                                        rc = 0 as libc::c_int;
                                        current_block_37 = 11174649648027449784;
                                    }
                                }
                            }
                            _ => {
                                log_error(
                                        (*srv).errh,
                                        b"/home/kkysen/work/rust/lighttpd/src/configfile-glue.c\0"
                                            as *const u8 as *const libc::c_char,
                                        220 as libc::c_int as libc::c_uint,
                                        b"unexpected type for key: %s %d expected a short integer, range 0 ... 65535\0"
                                            as *const u8 as *const libc::c_char,
                                        (*cpk_3.offset(i as isize)).k,
                                        (*du).type_0 as libc::c_uint,
                                    );
                                rc = 0 as libc::c_int;
                                current_block_37 = 11174649648027449784;
                            }
                        },
                        711017519835216269 => {
                            if (*du).type_0 as libc::c_uint
                                == TYPE_STRING as libc::c_int as libc::c_uint
                            {
                                (*cpv).v.b = &(*(du as *const data_string)).value;
                                current_block_37 = 7494008139977416618;
                            } else {
                                log_error(
                                    (*srv).errh,
                                    b"/home/kkysen/work/rust/lighttpd/src/configfile-glue.c\0"
                                        as *const u8
                                        as *const libc::c_char,
                                    186 as libc::c_int as libc::c_uint,
                                    b"%s should have been a string like ... = \"...\"\0"
                                        as *const u8
                                        as *const libc::c_char,
                                    (*cpk_3.offset(i as isize)).k,
                                );
                                rc = 0 as libc::c_int;
                                current_block_37 = 11174649648027449784;
                            }
                        }
                        5772900442197213762 => {
                            if (*du).type_0 as libc::c_uint
                                == TYPE_ARRAY as libc::c_int as libc::c_uint
                            {
                                (*cpv).v.a = &(*(du as *const data_array)).value;
                                match (*cpk_3.offset(i as isize)).ktype as libc::c_int {
                                    6 => {
                                        current_block_37 = 18094548196697502083;
                                        match current_block_37 {
                                            15359267663982909818 => {
                                                if array_is_vlist((*cpv).v.a) == 0 {
                                                    log_error(
                                                        (*srv).errh,
                                                        b"/home/kkysen/work/rust/lighttpd/src/configfile-glue.c\0"
                                                            as *const u8 as *const libc::c_char,
                                                        168 as libc::c_int as libc::c_uint,
                                                        b"%s should have been a list of string values like %s = ( \"...\", \"...\" )\0"
                                                            as *const u8 as *const libc::c_char,
                                                        (*cpk_3.offset(i as isize)).k,
                                                        (*cpk_3.offset(i as isize)).k,
                                                    );
                                                    rc = 0 as libc::c_int;
                                                    current_block_37 = 11174649648027449784;
                                                } else {
                                                    current_block_37 = 7494008139977416618;
                                                }
                                            }
                                            14601221856387937457 => {
                                                if array_is_kvarray((*cpv).v.a) == 0 {
                                                    log_error(
                                                        (*srv).errh,
                                                        b"/home/kkysen/work/rust/lighttpd/src/configfile-glue.c\0"
                                                            as *const u8 as *const libc::c_char,
                                                        148 as libc::c_int as libc::c_uint,
                                                        b"%s should have been a list of key => list like %s = ( \"...\" => ( \"...\" => \"...\" ) )\0"
                                                            as *const u8 as *const libc::c_char,
                                                        (*cpk_3.offset(i as isize)).k,
                                                        (*cpk_3.offset(i as isize)).k,
                                                    );
                                                    rc = 0 as libc::c_int;
                                                    current_block_37 = 11174649648027449784;
                                                } else {
                                                    current_block_37 = 7494008139977416618;
                                                }
                                            }
                                            18094548196697502083 => {
                                                if array_is_kvany((*cpv).v.a) == 0 {
                                                    log_error(
                                                        (*srv).errh,
                                                        b"/home/kkysen/work/rust/lighttpd/src/configfile-glue.c\0"
                                                            as *const u8 as *const libc::c_char,
                                                        138 as libc::c_int as libc::c_uint,
                                                        b"%s should have been a list of key => values like %s = ( \"...\" => \"...\", \"...\" => \"...\" )\0"
                                                            as *const u8 as *const libc::c_char,
                                                        (*cpk_3.offset(i as isize)).k,
                                                        (*cpk_3.offset(i as isize)).k,
                                                    );
                                                    rc = 0 as libc::c_int;
                                                    current_block_37 = 11174649648027449784;
                                                } else {
                                                    current_block_37 = 7494008139977416618;
                                                }
                                            }
                                            _ => {
                                                if array_is_kvstring((*cpv).v.a) == 0 {
                                                    log_error(
                                                        (*srv).errh,
                                                        b"/home/kkysen/work/rust/lighttpd/src/configfile-glue.c\0"
                                                            as *const u8 as *const libc::c_char,
                                                        158 as libc::c_int as libc::c_uint,
                                                        b"%s should have been a list of key => string values like %s = ( \"...\" => \"...\", \"...\" => \"...\" )\0"
                                                            as *const u8 as *const libc::c_char,
                                                        (*cpk_3.offset(i as isize)).k,
                                                        (*cpk_3.offset(i as isize)).k,
                                                    );
                                                    rc = 0 as libc::c_int;
                                                    current_block_37 = 11174649648027449784;
                                                } else {
                                                    current_block_37 = 7494008139977416618;
                                                }
                                            }
                                        }
                                    }
                                    7 => {
                                        current_block_37 = 14601221856387937457;
                                        match current_block_37 {
                                            15359267663982909818 => {
                                                if array_is_vlist((*cpv).v.a) == 0 {
                                                    log_error(
                                                        (*srv).errh,
                                                        b"/home/kkysen/work/rust/lighttpd/src/configfile-glue.c\0"
                                                            as *const u8 as *const libc::c_char,
                                                        168 as libc::c_int as libc::c_uint,
                                                        b"%s should have been a list of string values like %s = ( \"...\", \"...\" )\0"
                                                            as *const u8 as *const libc::c_char,
                                                        (*cpk_3.offset(i as isize)).k,
                                                        (*cpk_3.offset(i as isize)).k,
                                                    );
                                                    rc = 0 as libc::c_int;
                                                    current_block_37 = 11174649648027449784;
                                                } else {
                                                    current_block_37 = 7494008139977416618;
                                                }
                                            }
                                            14601221856387937457 => {
                                                if array_is_kvarray((*cpv).v.a) == 0 {
                                                    log_error(
                                                        (*srv).errh,
                                                        b"/home/kkysen/work/rust/lighttpd/src/configfile-glue.c\0"
                                                            as *const u8 as *const libc::c_char,
                                                        148 as libc::c_int as libc::c_uint,
                                                        b"%s should have been a list of key => list like %s = ( \"...\" => ( \"...\" => \"...\" ) )\0"
                                                            as *const u8 as *const libc::c_char,
                                                        (*cpk_3.offset(i as isize)).k,
                                                        (*cpk_3.offset(i as isize)).k,
                                                    );
                                                    rc = 0 as libc::c_int;
                                                    current_block_37 = 11174649648027449784;
                                                } else {
                                                    current_block_37 = 7494008139977416618;
                                                }
                                            }
                                            18094548196697502083 => {
                                                if array_is_kvany((*cpv).v.a) == 0 {
                                                    log_error(
                                                        (*srv).errh,
                                                        b"/home/kkysen/work/rust/lighttpd/src/configfile-glue.c\0"
                                                            as *const u8 as *const libc::c_char,
                                                        138 as libc::c_int as libc::c_uint,
                                                        b"%s should have been a list of key => values like %s = ( \"...\" => \"...\", \"...\" => \"...\" )\0"
                                                            as *const u8 as *const libc::c_char,
                                                        (*cpk_3.offset(i as isize)).k,
                                                        (*cpk_3.offset(i as isize)).k,
                                                    );
                                                    rc = 0 as libc::c_int;
                                                    current_block_37 = 11174649648027449784;
                                                } else {
                                                    current_block_37 = 7494008139977416618;
                                                }
                                            }
                                            _ => {
                                                if array_is_kvstring((*cpv).v.a) == 0 {
                                                    log_error(
                                                        (*srv).errh,
                                                        b"/home/kkysen/work/rust/lighttpd/src/configfile-glue.c\0"
                                                            as *const u8 as *const libc::c_char,
                                                        158 as libc::c_int as libc::c_uint,
                                                        b"%s should have been a list of key => string values like %s = ( \"...\" => \"...\", \"...\" => \"...\" )\0"
                                                            as *const u8 as *const libc::c_char,
                                                        (*cpk_3.offset(i as isize)).k,
                                                        (*cpk_3.offset(i as isize)).k,
                                                    );
                                                    rc = 0 as libc::c_int;
                                                    current_block_37 = 11174649648027449784;
                                                } else {
                                                    current_block_37 = 7494008139977416618;
                                                }
                                            }
                                        }
                                    }
                                    8 => {
                                        current_block_37 = 2973921165121704668;
                                        match current_block_37 {
                                            15359267663982909818 => {
                                                if array_is_vlist((*cpv).v.a) == 0 {
                                                    log_error(
                                                        (*srv).errh,
                                                        b"/home/kkysen/work/rust/lighttpd/src/configfile-glue.c\0"
                                                            as *const u8 as *const libc::c_char,
                                                        168 as libc::c_int as libc::c_uint,
                                                        b"%s should have been a list of string values like %s = ( \"...\", \"...\" )\0"
                                                            as *const u8 as *const libc::c_char,
                                                        (*cpk_3.offset(i as isize)).k,
                                                        (*cpk_3.offset(i as isize)).k,
                                                    );
                                                    rc = 0 as libc::c_int;
                                                    current_block_37 = 11174649648027449784;
                                                } else {
                                                    current_block_37 = 7494008139977416618;
                                                }
                                            }
                                            14601221856387937457 => {
                                                if array_is_kvarray((*cpv).v.a) == 0 {
                                                    log_error(
                                                        (*srv).errh,
                                                        b"/home/kkysen/work/rust/lighttpd/src/configfile-glue.c\0"
                                                            as *const u8 as *const libc::c_char,
                                                        148 as libc::c_int as libc::c_uint,
                                                        b"%s should have been a list of key => list like %s = ( \"...\" => ( \"...\" => \"...\" ) )\0"
                                                            as *const u8 as *const libc::c_char,
                                                        (*cpk_3.offset(i as isize)).k,
                                                        (*cpk_3.offset(i as isize)).k,
                                                    );
                                                    rc = 0 as libc::c_int;
                                                    current_block_37 = 11174649648027449784;
                                                } else {
                                                    current_block_37 = 7494008139977416618;
                                                }
                                            }
                                            18094548196697502083 => {
                                                if array_is_kvany((*cpv).v.a) == 0 {
                                                    log_error(
                                                        (*srv).errh,
                                                        b"/home/kkysen/work/rust/lighttpd/src/configfile-glue.c\0"
                                                            as *const u8 as *const libc::c_char,
                                                        138 as libc::c_int as libc::c_uint,
                                                        b"%s should have been a list of key => values like %s = ( \"...\" => \"...\", \"...\" => \"...\" )\0"
                                                            as *const u8 as *const libc::c_char,
                                                        (*cpk_3.offset(i as isize)).k,
                                                        (*cpk_3.offset(i as isize)).k,
                                                    );
                                                    rc = 0 as libc::c_int;
                                                    current_block_37 = 11174649648027449784;
                                                } else {
                                                    current_block_37 = 7494008139977416618;
                                                }
                                            }
                                            _ => {
                                                if array_is_kvstring((*cpv).v.a) == 0 {
                                                    log_error(
                                                        (*srv).errh,
                                                        b"/home/kkysen/work/rust/lighttpd/src/configfile-glue.c\0"
                                                            as *const u8 as *const libc::c_char,
                                                        158 as libc::c_int as libc::c_uint,
                                                        b"%s should have been a list of key => string values like %s = ( \"...\" => \"...\", \"...\" => \"...\" )\0"
                                                            as *const u8 as *const libc::c_char,
                                                        (*cpk_3.offset(i as isize)).k,
                                                        (*cpk_3.offset(i as isize)).k,
                                                    );
                                                    rc = 0 as libc::c_int;
                                                    current_block_37 = 11174649648027449784;
                                                } else {
                                                    current_block_37 = 7494008139977416618;
                                                }
                                            }
                                        }
                                    }
                                    9 => {
                                        current_block_37 = 15359267663982909818;
                                        match current_block_37 {
                                            15359267663982909818 => {
                                                if array_is_vlist((*cpv).v.a) == 0 {
                                                    log_error(
                                                        (*srv).errh,
                                                        b"/home/kkysen/work/rust/lighttpd/src/configfile-glue.c\0"
                                                            as *const u8 as *const libc::c_char,
                                                        168 as libc::c_int as libc::c_uint,
                                                        b"%s should have been a list of string values like %s = ( \"...\", \"...\" )\0"
                                                            as *const u8 as *const libc::c_char,
                                                        (*cpk_3.offset(i as isize)).k,
                                                        (*cpk_3.offset(i as isize)).k,
                                                    );
                                                    rc = 0 as libc::c_int;
                                                    current_block_37 = 11174649648027449784;
                                                } else {
                                                    current_block_37 = 7494008139977416618;
                                                }
                                            }
                                            14601221856387937457 => {
                                                if array_is_kvarray((*cpv).v.a) == 0 {
                                                    log_error(
                                                        (*srv).errh,
                                                        b"/home/kkysen/work/rust/lighttpd/src/configfile-glue.c\0"
                                                            as *const u8 as *const libc::c_char,
                                                        148 as libc::c_int as libc::c_uint,
                                                        b"%s should have been a list of key => list like %s = ( \"...\" => ( \"...\" => \"...\" ) )\0"
                                                            as *const u8 as *const libc::c_char,
                                                        (*cpk_3.offset(i as isize)).k,
                                                        (*cpk_3.offset(i as isize)).k,
                                                    );
                                                    rc = 0 as libc::c_int;
                                                    current_block_37 = 11174649648027449784;
                                                } else {
                                                    current_block_37 = 7494008139977416618;
                                                }
                                            }
                                            18094548196697502083 => {
                                                if array_is_kvany((*cpv).v.a) == 0 {
                                                    log_error(
                                                        (*srv).errh,
                                                        b"/home/kkysen/work/rust/lighttpd/src/configfile-glue.c\0"
                                                            as *const u8 as *const libc::c_char,
                                                        138 as libc::c_int as libc::c_uint,
                                                        b"%s should have been a list of key => values like %s = ( \"...\" => \"...\", \"...\" => \"...\" )\0"
                                                            as *const u8 as *const libc::c_char,
                                                        (*cpk_3.offset(i as isize)).k,
                                                        (*cpk_3.offset(i as isize)).k,
                                                    );
                                                    rc = 0 as libc::c_int;
                                                    current_block_37 = 11174649648027449784;
                                                } else {
                                                    current_block_37 = 7494008139977416618;
                                                }
                                            }
                                            _ => {
                                                if array_is_kvstring((*cpv).v.a) == 0 {
                                                    log_error(
                                                        (*srv).errh,
                                                        b"/home/kkysen/work/rust/lighttpd/src/configfile-glue.c\0"
                                                            as *const u8 as *const libc::c_char,
                                                        158 as libc::c_int as libc::c_uint,
                                                        b"%s should have been a list of key => string values like %s = ( \"...\" => \"...\", \"...\" => \"...\" )\0"
                                                            as *const u8 as *const libc::c_char,
                                                        (*cpk_3.offset(i as isize)).k,
                                                        (*cpk_3.offset(i as isize)).k,
                                                    );
                                                    rc = 0 as libc::c_int;
                                                    current_block_37 = 11174649648027449784;
                                                } else {
                                                    current_block_37 = 7494008139977416618;
                                                }
                                            }
                                        }
                                    }
                                    _ => {
                                        current_block_37 = 7494008139977416618;
                                    }
                                }
                            } else {
                                log_error(
                                    (*srv).errh,
                                    b"/home/kkysen/work/rust/lighttpd/src/configfile-glue.c\0"
                                        as *const u8
                                        as *const libc::c_char,
                                    129 as libc::c_int as libc::c_uint,
                                    b"%s should have been a list like %s = ( \"...\" )\0"
                                        as *const u8
                                        as *const libc::c_char,
                                    (*cpk_3.offset(i as isize)).k,
                                    (*cpk_3.offset(i as isize)).k,
                                );
                                rc = 0 as libc::c_int;
                                current_block_37 = 11174649648027449784;
                            }
                        }
                        4711845900019386151 => {
                            log_error(
                                (*srv).errh,
                                b"/home/kkysen/work/rust/lighttpd/src/configfile-glue.c\0"
                                    as *const u8
                                    as *const libc::c_char,
                                272 as libc::c_int as libc::c_uint,
                                b"ERROR: found unsupported key: %s (%s)\0" as *const u8
                                    as *const libc::c_char,
                                (*cpk_3.offset(i as isize)).k,
                                mname,
                            );
                            (*srv).srvconf.config_unsupported = 1 as libc::c_int as libc::c_uchar;
                            current_block_37 = 11174649648027449784;
                        }
                        8566665978537710866 => {
                            log_error(
                                (*srv).errh,
                                b"/home/kkysen/work/rust/lighttpd/src/configfile-glue.c\0"
                                    as *const u8
                                    as *const libc::c_char,
                                277 as libc::c_int as libc::c_uint,
                                b"ERROR: found deprecated key: %s (%s)\0" as *const u8
                                    as *const libc::c_char,
                                (*cpk_3.offset(i as isize)).k,
                                mname,
                            );
                            (*srv).srvconf.config_deprecated = 1 as libc::c_int as libc::c_uchar;
                            current_block_37 = 11174649648027449784;
                        }
                        _ => {}
                    }
                    match current_block_37 {
                        11174649648027449784 => {}
                        _ => {
                            cpv = cpv.offset(1);
                        }
                    }
                }
                _ => {
                    current_block_37 = 7494008139977416618;
                    match current_block_37 {
                        7343950298149844727 => {
                            let mut v_1: libc::c_int =
                                config_plugin_value_tobool(du, -(1 as libc::c_int));
                            if -(1 as libc::c_int) == v_1 {
                                log_error(
                                    (*srv).errh,
                                    b"/home/kkysen/work/rust/lighttpd/src/configfile-glue.c\0"
                                        as *const u8 as *const libc::c_char,
                                    259 as libc::c_int as libc::c_uint,
                                    b"ERROR: unexpected type for key: %s (string) \"(enable|disable)\"\0"
                                        as *const u8 as *const libc::c_char,
                                    (*cpk_3.offset(i as isize)).k,
                                );
                                rc = 0 as libc::c_int;
                                current_block_37 = 11174649648027449784;
                            } else {
                                (*cpv).v.u = v_1 as libc::c_uint;
                                current_block_37 = 7494008139977416618;
                            }
                        }
                        16999457480941319821 => match (*du).type_0 as libc::c_uint {
                            2 => {
                                (*cpv).v.u = (*(du as *const data_integer)).value as libc::c_uint;
                                current_block_37 = 7494008139977416618;
                            }
                            0 => {
                                let v_0: *const libc::c_char =
                                    (*(du as *const data_string)).value.ptr;
                                if !v_0.is_null() && *v_0 as libc::c_int != 0 {
                                    let mut e_0: *mut libc::c_char = 0 as *mut libc::c_char;
                                    let mut l_0: libc::c_long =
                                        strtol(v_0, &mut e_0, 10 as libc::c_int);
                                    if e_0 != v_0 as *mut libc::c_char
                                        && *e_0 == 0
                                        && l_0 >= 0 as libc::c_int as libc::c_long
                                    {
                                        (*cpv).v.shrt = l_0 as libc::c_uint as libc::c_ushort;
                                        current_block_37 = 7494008139977416618;
                                    } else {
                                        current_block_37 = 5891011138178424807;
                                    }
                                } else {
                                    current_block_37 = 5891011138178424807;
                                }
                                match current_block_37 {
                                    7494008139977416618 => {}
                                    _ => {
                                        log_error(
                                                (*srv).errh,
                                                b"/home/kkysen/work/rust/lighttpd/src/configfile-glue.c\0"
                                                    as *const u8 as *const libc::c_char,
                                                242 as libc::c_int as libc::c_uint,
                                                b"got a string but expected an integer: %s %s\0"
                                                    as *const u8 as *const libc::c_char,
                                                (*cpk_3.offset(i as isize)).k,
                                                v_0,
                                            );
                                        rc = 0 as libc::c_int;
                                        current_block_37 = 11174649648027449784;
                                    }
                                }
                            }
                            _ => {
                                log_error(
                                        (*srv).errh,
                                        b"/home/kkysen/work/rust/lighttpd/src/configfile-glue.c\0"
                                            as *const u8 as *const libc::c_char,
                                        248 as libc::c_int as libc::c_uint,
                                        b"unexpected type for key: %s %d expected an integer, range 0 ... 4294967295\0"
                                            as *const u8 as *const libc::c_char,
                                        (*cpk_3.offset(i as isize)).k,
                                        (*du).type_0 as libc::c_uint,
                                    );
                                rc = 0 as libc::c_int;
                                current_block_37 = 11174649648027449784;
                            }
                        },
                        8415733402176751844 => match (*du).type_0 as libc::c_uint {
                            2 => {
                                (*cpv).v.shrt =
                                    (*(du as *const data_integer)).value as libc::c_ushort;
                                current_block_37 = 7494008139977416618;
                            }
                            0 => {
                                let v: *const libc::c_char =
                                    (*(du as *const data_string)).value.ptr;
                                if !v.is_null() && *v as libc::c_int != 0 {
                                    let mut e: *mut libc::c_char = 0 as *mut libc::c_char;
                                    let mut l: libc::c_long = strtol(v, &mut e, 10 as libc::c_int);
                                    if e != v as *mut libc::c_char
                                        && *e == 0
                                        && l >= 0 as libc::c_int as libc::c_long
                                        && l <= 65535 as libc::c_int as libc::c_long
                                    {
                                        (*cpv).v.shrt = l as libc::c_ushort;
                                        current_block_37 = 7494008139977416618;
                                    } else {
                                        current_block_37 = 3123434771885419771;
                                    }
                                } else {
                                    current_block_37 = 3123434771885419771;
                                }
                                match current_block_37 {
                                    7494008139977416618 => {}
                                    _ => {
                                        log_error(
                                                (*srv).errh,
                                                b"/home/kkysen/work/rust/lighttpd/src/configfile-glue.c\0"
                                                    as *const u8 as *const libc::c_char,
                                                214 as libc::c_int as libc::c_uint,
                                                b"got a string but expected a short: %s %s\0" as *const u8
                                                    as *const libc::c_char,
                                                (*cpk_3.offset(i as isize)).k,
                                                v,
                                            );
                                        rc = 0 as libc::c_int;
                                        current_block_37 = 11174649648027449784;
                                    }
                                }
                            }
                            _ => {
                                log_error(
                                        (*srv).errh,
                                        b"/home/kkysen/work/rust/lighttpd/src/configfile-glue.c\0"
                                            as *const u8 as *const libc::c_char,
                                        220 as libc::c_int as libc::c_uint,
                                        b"unexpected type for key: %s %d expected a short integer, range 0 ... 65535\0"
                                            as *const u8 as *const libc::c_char,
                                        (*cpk_3.offset(i as isize)).k,
                                        (*du).type_0 as libc::c_uint,
                                    );
                                rc = 0 as libc::c_int;
                                current_block_37 = 11174649648027449784;
                            }
                        },
                        711017519835216269 => {
                            if (*du).type_0 as libc::c_uint
                                == TYPE_STRING as libc::c_int as libc::c_uint
                            {
                                (*cpv).v.b = &(*(du as *const data_string)).value;
                                current_block_37 = 7494008139977416618;
                            } else {
                                log_error(
                                    (*srv).errh,
                                    b"/home/kkysen/work/rust/lighttpd/src/configfile-glue.c\0"
                                        as *const u8
                                        as *const libc::c_char,
                                    186 as libc::c_int as libc::c_uint,
                                    b"%s should have been a string like ... = \"...\"\0"
                                        as *const u8
                                        as *const libc::c_char,
                                    (*cpk_3.offset(i as isize)).k,
                                );
                                rc = 0 as libc::c_int;
                                current_block_37 = 11174649648027449784;
                            }
                        }
                        5772900442197213762 => {
                            if (*du).type_0 as libc::c_uint
                                == TYPE_ARRAY as libc::c_int as libc::c_uint
                            {
                                (*cpv).v.a = &(*(du as *const data_array)).value;
                                match (*cpk_3.offset(i as isize)).ktype as libc::c_int {
                                    6 => {
                                        current_block_37 = 18094548196697502083;
                                        match current_block_37 {
                                            15359267663982909818 => {
                                                if array_is_vlist((*cpv).v.a) == 0 {
                                                    log_error(
                                                        (*srv).errh,
                                                        b"/home/kkysen/work/rust/lighttpd/src/configfile-glue.c\0"
                                                            as *const u8 as *const libc::c_char,
                                                        168 as libc::c_int as libc::c_uint,
                                                        b"%s should have been a list of string values like %s = ( \"...\", \"...\" )\0"
                                                            as *const u8 as *const libc::c_char,
                                                        (*cpk_3.offset(i as isize)).k,
                                                        (*cpk_3.offset(i as isize)).k,
                                                    );
                                                    rc = 0 as libc::c_int;
                                                    current_block_37 = 11174649648027449784;
                                                } else {
                                                    current_block_37 = 7494008139977416618;
                                                }
                                            }
                                            14601221856387937457 => {
                                                if array_is_kvarray((*cpv).v.a) == 0 {
                                                    log_error(
                                                        (*srv).errh,
                                                        b"/home/kkysen/work/rust/lighttpd/src/configfile-glue.c\0"
                                                            as *const u8 as *const libc::c_char,
                                                        148 as libc::c_int as libc::c_uint,
                                                        b"%s should have been a list of key => list like %s = ( \"...\" => ( \"...\" => \"...\" ) )\0"
                                                            as *const u8 as *const libc::c_char,
                                                        (*cpk_3.offset(i as isize)).k,
                                                        (*cpk_3.offset(i as isize)).k,
                                                    );
                                                    rc = 0 as libc::c_int;
                                                    current_block_37 = 11174649648027449784;
                                                } else {
                                                    current_block_37 = 7494008139977416618;
                                                }
                                            }
                                            18094548196697502083 => {
                                                if array_is_kvany((*cpv).v.a) == 0 {
                                                    log_error(
                                                        (*srv).errh,
                                                        b"/home/kkysen/work/rust/lighttpd/src/configfile-glue.c\0"
                                                            as *const u8 as *const libc::c_char,
                                                        138 as libc::c_int as libc::c_uint,
                                                        b"%s should have been a list of key => values like %s = ( \"...\" => \"...\", \"...\" => \"...\" )\0"
                                                            as *const u8 as *const libc::c_char,
                                                        (*cpk_3.offset(i as isize)).k,
                                                        (*cpk_3.offset(i as isize)).k,
                                                    );
                                                    rc = 0 as libc::c_int;
                                                    current_block_37 = 11174649648027449784;
                                                } else {
                                                    current_block_37 = 7494008139977416618;
                                                }
                                            }
                                            _ => {
                                                if array_is_kvstring((*cpv).v.a) == 0 {
                                                    log_error(
                                                        (*srv).errh,
                                                        b"/home/kkysen/work/rust/lighttpd/src/configfile-glue.c\0"
                                                            as *const u8 as *const libc::c_char,
                                                        158 as libc::c_int as libc::c_uint,
                                                        b"%s should have been a list of key => string values like %s = ( \"...\" => \"...\", \"...\" => \"...\" )\0"
                                                            as *const u8 as *const libc::c_char,
                                                        (*cpk_3.offset(i as isize)).k,
                                                        (*cpk_3.offset(i as isize)).k,
                                                    );
                                                    rc = 0 as libc::c_int;
                                                    current_block_37 = 11174649648027449784;
                                                } else {
                                                    current_block_37 = 7494008139977416618;
                                                }
                                            }
                                        }
                                    }
                                    7 => {
                                        current_block_37 = 14601221856387937457;
                                        match current_block_37 {
                                            15359267663982909818 => {
                                                if array_is_vlist((*cpv).v.a) == 0 {
                                                    log_error(
                                                        (*srv).errh,
                                                        b"/home/kkysen/work/rust/lighttpd/src/configfile-glue.c\0"
                                                            as *const u8 as *const libc::c_char,
                                                        168 as libc::c_int as libc::c_uint,
                                                        b"%s should have been a list of string values like %s = ( \"...\", \"...\" )\0"
                                                            as *const u8 as *const libc::c_char,
                                                        (*cpk_3.offset(i as isize)).k,
                                                        (*cpk_3.offset(i as isize)).k,
                                                    );
                                                    rc = 0 as libc::c_int;
                                                    current_block_37 = 11174649648027449784;
                                                } else {
                                                    current_block_37 = 7494008139977416618;
                                                }
                                            }
                                            14601221856387937457 => {
                                                if array_is_kvarray((*cpv).v.a) == 0 {
                                                    log_error(
                                                        (*srv).errh,
                                                        b"/home/kkysen/work/rust/lighttpd/src/configfile-glue.c\0"
                                                            as *const u8 as *const libc::c_char,
                                                        148 as libc::c_int as libc::c_uint,
                                                        b"%s should have been a list of key => list like %s = ( \"...\" => ( \"...\" => \"...\" ) )\0"
                                                            as *const u8 as *const libc::c_char,
                                                        (*cpk_3.offset(i as isize)).k,
                                                        (*cpk_3.offset(i as isize)).k,
                                                    );
                                                    rc = 0 as libc::c_int;
                                                    current_block_37 = 11174649648027449784;
                                                } else {
                                                    current_block_37 = 7494008139977416618;
                                                }
                                            }
                                            18094548196697502083 => {
                                                if array_is_kvany((*cpv).v.a) == 0 {
                                                    log_error(
                                                        (*srv).errh,
                                                        b"/home/kkysen/work/rust/lighttpd/src/configfile-glue.c\0"
                                                            as *const u8 as *const libc::c_char,
                                                        138 as libc::c_int as libc::c_uint,
                                                        b"%s should have been a list of key => values like %s = ( \"...\" => \"...\", \"...\" => \"...\" )\0"
                                                            as *const u8 as *const libc::c_char,
                                                        (*cpk_3.offset(i as isize)).k,
                                                        (*cpk_3.offset(i as isize)).k,
                                                    );
                                                    rc = 0 as libc::c_int;
                                                    current_block_37 = 11174649648027449784;
                                                } else {
                                                    current_block_37 = 7494008139977416618;
                                                }
                                            }
                                            _ => {
                                                if array_is_kvstring((*cpv).v.a) == 0 {
                                                    log_error(
                                                        (*srv).errh,
                                                        b"/home/kkysen/work/rust/lighttpd/src/configfile-glue.c\0"
                                                            as *const u8 as *const libc::c_char,
                                                        158 as libc::c_int as libc::c_uint,
                                                        b"%s should have been a list of key => string values like %s = ( \"...\" => \"...\", \"...\" => \"...\" )\0"
                                                            as *const u8 as *const libc::c_char,
                                                        (*cpk_3.offset(i as isize)).k,
                                                        (*cpk_3.offset(i as isize)).k,
                                                    );
                                                    rc = 0 as libc::c_int;
                                                    current_block_37 = 11174649648027449784;
                                                } else {
                                                    current_block_37 = 7494008139977416618;
                                                }
                                            }
                                        }
                                    }
                                    8 => {
                                        current_block_37 = 2973921165121704668;
                                        match current_block_37 {
                                            15359267663982909818 => {
                                                if array_is_vlist((*cpv).v.a) == 0 {
                                                    log_error(
                                                        (*srv).errh,
                                                        b"/home/kkysen/work/rust/lighttpd/src/configfile-glue.c\0"
                                                            as *const u8 as *const libc::c_char,
                                                        168 as libc::c_int as libc::c_uint,
                                                        b"%s should have been a list of string values like %s = ( \"...\", \"...\" )\0"
                                                            as *const u8 as *const libc::c_char,
                                                        (*cpk_3.offset(i as isize)).k,
                                                        (*cpk_3.offset(i as isize)).k,
                                                    );
                                                    rc = 0 as libc::c_int;
                                                    current_block_37 = 11174649648027449784;
                                                } else {
                                                    current_block_37 = 7494008139977416618;
                                                }
                                            }
                                            14601221856387937457 => {
                                                if array_is_kvarray((*cpv).v.a) == 0 {
                                                    log_error(
                                                        (*srv).errh,
                                                        b"/home/kkysen/work/rust/lighttpd/src/configfile-glue.c\0"
                                                            as *const u8 as *const libc::c_char,
                                                        148 as libc::c_int as libc::c_uint,
                                                        b"%s should have been a list of key => list like %s = ( \"...\" => ( \"...\" => \"...\" ) )\0"
                                                            as *const u8 as *const libc::c_char,
                                                        (*cpk_3.offset(i as isize)).k,
                                                        (*cpk_3.offset(i as isize)).k,
                                                    );
                                                    rc = 0 as libc::c_int;
                                                    current_block_37 = 11174649648027449784;
                                                } else {
                                                    current_block_37 = 7494008139977416618;
                                                }
                                            }
                                            18094548196697502083 => {
                                                if array_is_kvany((*cpv).v.a) == 0 {
                                                    log_error(
                                                        (*srv).errh,
                                                        b"/home/kkysen/work/rust/lighttpd/src/configfile-glue.c\0"
                                                            as *const u8 as *const libc::c_char,
                                                        138 as libc::c_int as libc::c_uint,
                                                        b"%s should have been a list of key => values like %s = ( \"...\" => \"...\", \"...\" => \"...\" )\0"
                                                            as *const u8 as *const libc::c_char,
                                                        (*cpk_3.offset(i as isize)).k,
                                                        (*cpk_3.offset(i as isize)).k,
                                                    );
                                                    rc = 0 as libc::c_int;
                                                    current_block_37 = 11174649648027449784;
                                                } else {
                                                    current_block_37 = 7494008139977416618;
                                                }
                                            }
                                            _ => {
                                                if array_is_kvstring((*cpv).v.a) == 0 {
                                                    log_error(
                                                        (*srv).errh,
                                                        b"/home/kkysen/work/rust/lighttpd/src/configfile-glue.c\0"
                                                            as *const u8 as *const libc::c_char,
                                                        158 as libc::c_int as libc::c_uint,
                                                        b"%s should have been a list of key => string values like %s = ( \"...\" => \"...\", \"...\" => \"...\" )\0"
                                                            as *const u8 as *const libc::c_char,
                                                        (*cpk_3.offset(i as isize)).k,
                                                        (*cpk_3.offset(i as isize)).k,
                                                    );
                                                    rc = 0 as libc::c_int;
                                                    current_block_37 = 11174649648027449784;
                                                } else {
                                                    current_block_37 = 7494008139977416618;
                                                }
                                            }
                                        }
                                    }
                                    9 => {
                                        current_block_37 = 15359267663982909818;
                                        match current_block_37 {
                                            15359267663982909818 => {
                                                if array_is_vlist((*cpv).v.a) == 0 {
                                                    log_error(
                                                        (*srv).errh,
                                                        b"/home/kkysen/work/rust/lighttpd/src/configfile-glue.c\0"
                                                            as *const u8 as *const libc::c_char,
                                                        168 as libc::c_int as libc::c_uint,
                                                        b"%s should have been a list of string values like %s = ( \"...\", \"...\" )\0"
                                                            as *const u8 as *const libc::c_char,
                                                        (*cpk_3.offset(i as isize)).k,
                                                        (*cpk_3.offset(i as isize)).k,
                                                    );
                                                    rc = 0 as libc::c_int;
                                                    current_block_37 = 11174649648027449784;
                                                } else {
                                                    current_block_37 = 7494008139977416618;
                                                }
                                            }
                                            14601221856387937457 => {
                                                if array_is_kvarray((*cpv).v.a) == 0 {
                                                    log_error(
                                                        (*srv).errh,
                                                        b"/home/kkysen/work/rust/lighttpd/src/configfile-glue.c\0"
                                                            as *const u8 as *const libc::c_char,
                                                        148 as libc::c_int as libc::c_uint,
                                                        b"%s should have been a list of key => list like %s = ( \"...\" => ( \"...\" => \"...\" ) )\0"
                                                            as *const u8 as *const libc::c_char,
                                                        (*cpk_3.offset(i as isize)).k,
                                                        (*cpk_3.offset(i as isize)).k,
                                                    );
                                                    rc = 0 as libc::c_int;
                                                    current_block_37 = 11174649648027449784;
                                                } else {
                                                    current_block_37 = 7494008139977416618;
                                                }
                                            }
                                            18094548196697502083 => {
                                                if array_is_kvany((*cpv).v.a) == 0 {
                                                    log_error(
                                                        (*srv).errh,
                                                        b"/home/kkysen/work/rust/lighttpd/src/configfile-glue.c\0"
                                                            as *const u8 as *const libc::c_char,
                                                        138 as libc::c_int as libc::c_uint,
                                                        b"%s should have been a list of key => values like %s = ( \"...\" => \"...\", \"...\" => \"...\" )\0"
                                                            as *const u8 as *const libc::c_char,
                                                        (*cpk_3.offset(i as isize)).k,
                                                        (*cpk_3.offset(i as isize)).k,
                                                    );
                                                    rc = 0 as libc::c_int;
                                                    current_block_37 = 11174649648027449784;
                                                } else {
                                                    current_block_37 = 7494008139977416618;
                                                }
                                            }
                                            _ => {
                                                if array_is_kvstring((*cpv).v.a) == 0 {
                                                    log_error(
                                                        (*srv).errh,
                                                        b"/home/kkysen/work/rust/lighttpd/src/configfile-glue.c\0"
                                                            as *const u8 as *const libc::c_char,
                                                        158 as libc::c_int as libc::c_uint,
                                                        b"%s should have been a list of key => string values like %s = ( \"...\" => \"...\", \"...\" => \"...\" )\0"
                                                            as *const u8 as *const libc::c_char,
                                                        (*cpk_3.offset(i as isize)).k,
                                                        (*cpk_3.offset(i as isize)).k,
                                                    );
                                                    rc = 0 as libc::c_int;
                                                    current_block_37 = 11174649648027449784;
                                                } else {
                                                    current_block_37 = 7494008139977416618;
                                                }
                                            }
                                        }
                                    }
                                    _ => {
                                        current_block_37 = 7494008139977416618;
                                    }
                                }
                            } else {
                                log_error(
                                    (*srv).errh,
                                    b"/home/kkysen/work/rust/lighttpd/src/configfile-glue.c\0"
                                        as *const u8
                                        as *const libc::c_char,
                                    129 as libc::c_int as libc::c_uint,
                                    b"%s should have been a list like %s = ( \"...\" )\0"
                                        as *const u8
                                        as *const libc::c_char,
                                    (*cpk_3.offset(i as isize)).k,
                                    (*cpk_3.offset(i as isize)).k,
                                );
                                rc = 0 as libc::c_int;
                                current_block_37 = 11174649648027449784;
                            }
                        }
                        4711845900019386151 => {
                            log_error(
                                (*srv).errh,
                                b"/home/kkysen/work/rust/lighttpd/src/configfile-glue.c\0"
                                    as *const u8
                                    as *const libc::c_char,
                                272 as libc::c_int as libc::c_uint,
                                b"ERROR: found unsupported key: %s (%s)\0" as *const u8
                                    as *const libc::c_char,
                                (*cpk_3.offset(i as isize)).k,
                                mname,
                            );
                            (*srv).srvconf.config_unsupported = 1 as libc::c_int as libc::c_uchar;
                            current_block_37 = 11174649648027449784;
                        }
                        8566665978537710866 => {
                            log_error(
                                (*srv).errh,
                                b"/home/kkysen/work/rust/lighttpd/src/configfile-glue.c\0"
                                    as *const u8
                                    as *const libc::c_char,
                                277 as libc::c_int as libc::c_uint,
                                b"ERROR: found deprecated key: %s (%s)\0" as *const u8
                                    as *const libc::c_char,
                                (*cpk_3.offset(i as isize)).k,
                                mname,
                            );
                            (*srv).srvconf.config_deprecated = 1 as libc::c_int as libc::c_uchar;
                            current_block_37 = 11174649648027449784;
                        }
                        _ => {}
                    }
                    match current_block_37 {
                        11174649648027449784 => {}
                        _ => {
                            cpv = cpv.offset(1);
                        }
                    }
                }
            }
        }
        i += 1;
    }
    (*cpv).k_id = -(1 as libc::c_int);
    return rc;
}
#[no_mangle]
#[cold]
pub unsafe extern "C" fn config_plugin_values_init(
    srv: *mut server,
    mut p_d: *mut libc::c_void,
    cpk_3: *const config_plugin_keys_t,
    mname: *const libc::c_char,
) -> libc::c_int {
    let p: *mut plugin_data_base = p_d as *mut plugin_data_base;
    let touched: *mut array = (*srv).srvconf.config_touched;
    let mut matches: [libc::c_uchar; 4096] = [0; 4096];
    let mut contexts: [libc::c_ushort; 4096] = [0; 4096];
    let mut n: uint32_t = 0 as libc::c_int as uint32_t;
    let mut rc: libc::c_int = 1 as libc::c_int;
    if !(::core::mem::size_of::<[libc::c_uchar; 4096]>() as libc::c_ulong
        >= (*(*srv).config_context).used as libc::c_ulong)
    {
        ck_assert_failed(
            b"/home/kkysen/work/rust/lighttpd/src/configfile-glue.c\0" as *const u8
                as *const libc::c_char,
            298 as libc::c_int as libc::c_uint,
            b"sizeof(matches) >= srv->config_context->used\0" as *const u8 as *const libc::c_char,
        );
    }
    config_reference.data = (*(*srv).config_context).data as *const *const data_config;
    config_reference.used = (*(*srv).config_context).used;
    let mut u: uint32_t = 0 as libc::c_int as uint32_t;
    while u < (*(*srv).config_context).used {
        let mut ca: *const array =
            (*(*((*(*srv).config_context).data).offset(u as isize) as *const data_config)).value;
        matches[n as usize] = 0 as libc::c_int as libc::c_uchar;
        let mut i: libc::c_int = 0 as libc::c_int;
        while (*cpk_3.offset(i as isize)).ktype as libc::c_int != T_CONFIG_UNSET as libc::c_int {
            let du: *const data_unset = array_get_element_klen(
                ca,
                (*cpk_3.offset(i as isize)).k,
                (*cpk_3.offset(i as isize)).klen as uint32_t,
            );
            if !du.is_null() {
                matches[n as usize] = (matches[n as usize]).wrapping_add(1);
                array_set_key_value(
                    touched,
                    (*cpk_3.offset(i as isize)).k,
                    (*cpk_3.offset(i as isize)).klen as uint32_t,
                    b"\0" as *const u8 as *const libc::c_char,
                    (::core::mem::size_of::<[libc::c_char; 1]>() as libc::c_ulong as uint32_t)
                        .wrapping_sub(1 as libc::c_int as libc::c_uint),
                );
                if (*cpk_3.offset(i as isize)).scope as libc::c_int
                    == T_CONFIG_SCOPE_SERVER as libc::c_int
                    && 0 as libc::c_int as libc::c_uint != u
                {
                    log_error(
                        (*srv).errh,
                        b"/home/kkysen/work/rust/lighttpd/src/configfile-glue.c\0" as *const u8
                            as *const libc::c_char,
                        323 as libc::c_int as libc::c_uint,
                        b"DEPRECATED: do not set server options in conditionals, variable: %s\0"
                            as *const u8 as *const libc::c_char,
                        (*cpk_3.offset(i as isize)).k,
                    );
                }
            }
            i += 1;
        }
        if matches[n as usize] != 0 {
            let fresh245 = n;
            n = n.wrapping_add(1);
            contexts[fresh245 as usize] = u as libc::c_ushort;
        }
        u = u.wrapping_add(1);
    }
    let mut elts: uint32_t = 0 as libc::c_int as uint32_t;
    let mut u_0: uint32_t = 0 as libc::c_int as uint32_t;
    while u_0 < n {
        elts = (elts as libc::c_uint).wrapping_add(matches[u_0 as usize] as libc::c_uint)
            as uint32_t as uint32_t;
        u_0 = u_0.wrapping_add(1);
    }
    (*p).nconfig = n as libc::c_int;
    (*p).cvlist = calloc(
        (1 as libc::c_int as libc::c_uint)
            .wrapping_add(n)
            .wrapping_add(n)
            .wrapping_add(elts) as libc::c_ulong,
        ::core::mem::size_of::<config_plugin_value_t>() as libc::c_ulong,
    ) as *mut config_plugin_value_t;
    if ((*p).cvlist).is_null() {
        ck_assert_failed(
            b"/home/kkysen/work/rust/lighttpd/src/configfile-glue.c\0" as *const u8
                as *const libc::c_char,
            338 as libc::c_int as libc::c_uint,
            b"p->cvlist\0" as *const u8 as *const libc::c_char,
        );
    }
    elts = (1 as libc::c_int as libc::c_uint).wrapping_add(n);
    let shft: uint32_t = (0 as libc::c_int as libc::c_uint != n
        && 0 as libc::c_int != contexts[0 as libc::c_int as usize] as libc::c_int)
        as libc::c_int as uint32_t;
    if shft != 0 {
        (*p).nconfig += 1;
    }
    let mut u_1: uint32_t = 0 as libc::c_int as uint32_t;
    while u_1 < n {
        let cpv: *mut config_plugin_value_t =
            ((*p).cvlist).offset(shft as isize).offset(u_1 as isize);
        (*cpv).k_id = contexts[u_1 as usize] as libc::c_int;
        (*cpv).v.u2[0 as libc::c_int as usize] = elts;
        (*cpv).v.u2[1 as libc::c_int as usize] = matches[u_1 as usize] as uint32_t;
        elts = (elts as libc::c_uint)
            .wrapping_add((matches[u_1 as usize] as libc::c_int + 1 as libc::c_int) as libc::c_uint)
            as uint32_t as uint32_t;
        u_1 = u_1.wrapping_add(1);
    }
    let mut u_2: uint32_t = 0 as libc::c_int as uint32_t;
    while u_2 < n {
        let mut ca_0: *const array = (*(*((*(*srv).config_context).data)
            .offset(contexts[u_2 as usize] as isize)
            as *const data_config))
            .value;
        let mut cpv_0: *mut config_plugin_value_t = ((*p).cvlist).offset(
            (*((*p).cvlist).offset(shft.wrapping_add(u_2) as isize))
                .v
                .u2[0 as libc::c_int as usize] as isize,
        );
        if config_plugin_values_init_block(srv, ca_0, cpk_3, mname, cpv_0) == 0 {
            rc = 0 as libc::c_int;
        }
        u_2 = u_2.wrapping_add(1);
    }
    return rc;
}
#[cold]
#[inline(never)]
unsafe extern "C" fn config_cond_result_trace(
    r: *mut request_st,
    dc: *const data_config,
    cached: libc::c_int,
) {
    let cache: *mut cond_cache_t =
        &mut *((*r).cond_cache).offset((*dc).context_ndx as isize) as *mut cond_cache_t;
    let mut msg: *const libc::c_char = 0 as *const libc::c_char;
    match (*cache).result as libc::c_int {
        0 => {
            msg = b"unset\0" as *const u8 as *const libc::c_char;
        }
        1 => {
            msg = b"skipped\0" as *const u8 as *const libc::c_char;
        }
        2 => {
            msg = b"false\0" as *const u8 as *const libc::c_char;
        }
        3 => {
            msg = b"true\0" as *const u8 as *const libc::c_char;
        }
        _ => {
            msg = b"invalid cond_result_t\0" as *const u8 as *const libc::c_char;
        }
    }
    log_error(
        (*r).conf.errh,
        b"/home/kkysen/work/rust/lighttpd/src/configfile-glue.c\0" as *const u8
            as *const libc::c_char,
        375 as libc::c_int as libc::c_uint,
        b"%d (%s) result: %s (cond: %s)\0" as *const u8 as *const libc::c_char,
        (*dc).context_ndx,
        &*(b"uncached\0" as *const u8 as *const libc::c_char).offset(
            (if cached != 0 {
                2 as libc::c_int
            } else {
                0 as libc::c_int
            }) as isize,
        ) as *const libc::c_char,
        msg,
        (*dc).key.ptr,
    );
}
unsafe extern "C" fn config_check_cond_nocache_calc(
    r: *mut request_st,
    dc: *const data_config,
    debug_cond: libc::c_int,
    cache: *mut cond_cache_t,
) -> cond_result_t {
    (*cache).result = config_check_cond_nocache(r, dc, debug_cond, cache) as int8_t;
    if debug_cond != 0 {
        config_cond_result_trace(r, dc, 0 as libc::c_int);
    }
    return (*cache).result as cond_result_t;
}
unsafe extern "C" fn config_check_cond_cached(
    r: *mut request_st,
    dc: *const data_config,
    debug_cond: libc::c_int,
) -> cond_result_t {
    let cache: *mut cond_cache_t =
        &mut *((*r).cond_cache).offset((*dc).context_ndx as isize) as *mut cond_cache_t;
    if COND_RESULT_UNSET as libc::c_int != (*cache).result as libc::c_int {
        if debug_cond != 0 {
            config_cond_result_trace(r, dc, 1 as libc::c_int);
        }
        return (*cache).result as cond_result_t;
    }
    return config_check_cond_nocache_calc(r, dc, debug_cond, cache);
}
unsafe extern "C" fn config_check_cond_nocache(
    r: *mut request_st,
    dc: *const data_config,
    debug_cond: libc::c_int,
    cache: *mut cond_cache_t,
) -> cond_result_t {
    if !((*dc).parent).is_null() && (*(*dc).parent).context_ndx != 0 {
        if debug_cond != 0 {
            log_error(
                (*r).conf.errh,
                b"/home/kkysen/work/rust/lighttpd/src/configfile-glue.c\0" as *const u8
                    as *const libc::c_char,
                409 as libc::c_int as libc::c_uint,
                b"go parent %s\0" as *const u8 as *const libc::c_char,
                (*(*dc).parent).key.ptr,
            );
        }
        match config_check_cond_cached(r, (*dc).parent, debug_cond) as libc::c_uint {
            0 => return COND_RESULT_UNSET,
            1 | 2 => return COND_RESULT_SKIP,
            3 | _ => {}
        }
    }
    if !((*dc).prev).is_null() {
        if debug_cond != 0 {
            log_error(
                (*r).conf.errh,
                b"/home/kkysen/work/rust/lighttpd/src/configfile-glue.c\0" as *const u8
                    as *const libc::c_char,
                432 as libc::c_int as libc::c_uint,
                b"go prev %s\0" as *const u8 as *const libc::c_char,
                (*(*dc).prev).key.ptr,
            );
        }
        match config_check_cond_cached(r, (*dc).prev, debug_cond) as libc::c_uint {
            0 => return COND_RESULT_UNSET,
            1 | 3 => return COND_RESULT_SKIP,
            2 | _ => {}
        }
    }
    if (*r).conditional_is_valid
        & ((1 as libc::c_int) << (*dc).comp as libc::c_uint) as libc::c_uint
        == 0
    {
        if debug_cond != 0 {
            log_error(
                (*r).conf.errh,
                b"/home/kkysen/work/rust/lighttpd/src/configfile-glue.c\0" as *const u8
                    as *const libc::c_char,
                452 as libc::c_int as libc::c_uint,
                b"%d %s not available yet\0" as *const u8 as *const libc::c_char,
                (*dc).comp as libc::c_uint,
                (*dc).key.ptr,
            );
        }
        return COND_RESULT_UNSET;
    }
    match (*cache).local_result as libc::c_int {
        3 | 2 => return (*cache).local_result as cond_result_t,
        _ => {}
    }
    if CONFIG_COND_ELSE as libc::c_int as libc::c_uint == (*dc).cond as libc::c_uint {
        (*cache).local_result = COND_RESULT_TRUE as libc::c_int as int8_t;
        return (*cache).local_result as cond_result_t;
    }
    return config_check_cond_nocache_eval(r, dc, debug_cond, cache);
}
unsafe extern "C" fn config_check_cond_nocache_eval(
    r: *mut request_st,
    dc: *const data_config,
    debug_cond: libc::c_int,
    cache: *mut cond_cache_t,
) -> cond_result_t {
    static mut empty_string: const_char_buffer = {
        let mut init = const_char_buffer {
            ptr: b"\0" as *const u8 as *const libc::c_char,
            used: 1 as libc::c_int as uint32_t,
            size: 0 as libc::c_int as uint32_t,
        };
        init
    };
    let mut l: *const buffer = 0 as *const buffer;
    match (*dc).comp as libc::c_uint {
        3 => {
            l = &mut (*r).uri.authority;
        }
        8 => {
            l = &mut (*(*r).con).dst_addr_buf;
        }
        10 => {
            l = &mut (*r).uri.scheme;
        }
        2 => {
            l = &mut (*r).uri.path;
        }
        9 => {
            l = &mut (*r).uri.query;
        }
        1 => {
            l = (*(*(*r).con).srv_socket).srv_token;
        }
        12 => {
            l = http_header_request_get(
                r,
                (*dc).ext as http_header_e,
                (*dc).comp_tag.ptr,
                buffer_clen(&(*dc).comp_tag),
            );
            if l.is_null() {
                l = &mut empty_string as *mut const_char_buffer as *mut buffer;
            }
        }
        11 => {
            l = http_method_buf((*r).http_method);
        }
        _ => {
            (*cache).local_result = COND_RESULT_FALSE as libc::c_int as int8_t;
            return (*cache).local_result as cond_result_t;
        }
    }
    if buffer_is_blank(l) as libc::c_long != 0 {
        l = &mut empty_string as *mut const_char_buffer as *mut buffer;
    }
    if debug_cond != 0 {
        log_error(
            (*r).conf.errh,
            b"/home/kkysen/work/rust/lighttpd/src/configfile-glue.c\0" as *const u8
                as *const libc::c_char,
            519 as libc::c_int as libc::c_uint,
            b"%s compare to %s\0" as *const u8 as *const libc::c_char,
            (*dc).comp_key,
            (*l).ptr,
        );
    }
    let mut match_0: libc::c_int = 0;
    let mut current_block_22: u64;
    match (*dc).cond as libc::c_uint {
        3 | 1 => {
            match_0 = ((*dc).cond as libc::c_uint == CONFIG_COND_EQ as libc::c_int as libc::c_uint)
                as libc::c_int;
            if (*dc).comp as libc::c_uint == COMP_HTTP_HOST as libc::c_int as libc::c_uint
                && *((*dc).string.ptr).offset(0 as libc::c_int as isize) as libc::c_int
                    != '/' as i32
            {
                let mut llen: uint_fast32_t = buffer_clen(l) as uint_fast32_t;
                let mut dlen: uint_fast32_t = buffer_clen(&(*dc).string) as uint_fast32_t;
                if llen != 0 && llen != dlen {
                    match_0 ^= ((if llen > dlen {
                        (*((*l).ptr).offset(dlen as isize) as libc::c_int == ':' as i32
                            && llen.wrapping_sub(dlen) <= 6 as libc::c_int as libc::c_ulong)
                            as libc::c_int
                    } else {
                        dlen = llen;
                        (*((*dc).string.ptr).offset(dlen as isize) as libc::c_int == ':' as i32)
                            as libc::c_int
                    }) != 0
                        && 0 as libc::c_int
                            == memcmp(
                                (*l).ptr as *const libc::c_void,
                                (*dc).string.ptr as *const libc::c_void,
                                dlen,
                            )) as libc::c_int;
                    current_block_22 = 17500079516916021833;
                } else {
                    current_block_22 = 14648156034262866959;
                }
            } else if (*dc).comp as libc::c_uint
                == COMP_HTTP_REMOTE_IP as libc::c_int as libc::c_uint
                && *((*dc).string.ptr).offset(0 as libc::c_int as isize) as libc::c_int
                    != '/' as i32
            {
                let addr: *const sock_addr = (((*dc).string.ptr as uintptr_t)
                    .wrapping_add((*dc).string.used as libc::c_ulong)
                    .wrapping_add(1 as libc::c_int as libc::c_ulong)
                    .wrapping_add(7 as libc::c_int as libc::c_ulong)
                    & !(7 as libc::c_int) as libc::c_ulong)
                    as *mut sock_addr;
                let mut bits: libc::c_int = *((*dc).string.ptr as *mut libc::c_uchar)
                    .offset((*dc).string.used as isize)
                    as libc::c_int;
                match_0 ^= if bits != 0 {
                    sock_addr_is_addr_eq_bits(addr, &mut (*(*r).con).dst_addr, bits)
                } else {
                    sock_addr_is_addr_eq(addr, &mut (*(*r).con).dst_addr)
                };
                current_block_22 = 17500079516916021833;
            } else {
                current_block_22 = 14648156034262866959;
            }
            match current_block_22 {
                17500079516916021833 => {}
                _ => {
                    match_0 ^= buffer_is_equal(l, &(*dc).string);
                }
            }
        }
        4 | 2 => {
            match_0 = ((*dc).cond as libc::c_uint
                == CONFIG_COND_MATCH as libc::c_int as libc::c_uint)
                as libc::c_int;
            match_0 ^= (config_pcre_match(r, dc, l) > 0 as libc::c_int) as libc::c_int;
        }
        _ => {
            match_0 = 1 as libc::c_int;
        }
    }
    (*cache).local_result = (if match_0 != 0 {
        COND_RESULT_FALSE as libc::c_int
    } else {
        COND_RESULT_TRUE as libc::c_int
    }) as int8_t;
    return (*cache).local_result as cond_result_t;
}
#[inline(never)]
unsafe extern "C" fn config_check_cond_calc(
    r: *mut request_st,
    context_ndx: libc::c_int,
    cache: *mut cond_cache_t,
) -> cond_result_t {
    let dc: *const data_config = *(config_reference.data).offset(context_ndx as isize);
    let debug_cond: libc::c_int = (*r).conf.log_condition_handling as libc::c_int;
    if debug_cond != 0 {
        log_error(
            (*r).conf.errh,
            b"/home/kkysen/work/rust/lighttpd/src/configfile-glue.c\0" as *const u8
                as *const libc::c_char,
            576 as libc::c_int as libc::c_uint,
            b"=== start of condition block ===\0" as *const u8 as *const libc::c_char,
        );
    }
    return config_check_cond_nocache_calc(r, dc, debug_cond, cache);
}
#[no_mangle]
pub unsafe extern "C" fn config_check_cond(
    r: *mut request_st,
    context_ndx: libc::c_int,
) -> libc::c_int {
    let cache: *mut cond_cache_t =
        &mut *((*r).cond_cache).offset(context_ndx as isize) as *mut cond_cache_t;
    return (COND_RESULT_TRUE as libc::c_int as libc::c_uint
        == (if COND_RESULT_UNSET as libc::c_int != (*cache).result as libc::c_int {
            (*cache).result as cond_result_t as libc::c_uint
        } else {
            config_check_cond_calc(r, context_ndx, cache) as libc::c_uint
        })) as libc::c_int;
}
unsafe extern "C" fn config_cond_clear_node(cond_cache: *mut cond_cache_t, dc: *const data_config) {
    if (*cond_cache.offset((*dc).context_ndx as isize)).result as libc::c_int
        != COND_RESULT_UNSET as libc::c_int
    {
        (*cond_cache.offset((*dc).context_ndx as isize)).result =
            COND_RESULT_UNSET as libc::c_int as int8_t;
        let mut i: uint32_t = 0 as libc::c_int as uint32_t;
        while (i as libc::c_ulong) < (*dc).children.used {
            let mut dc_child: *const data_config = *((*dc).children.data).offset(i as isize);
            if ((*dc_child).prev).is_null() {
                config_cond_clear_node(cond_cache, dc_child);
            }
            i = i.wrapping_add(1);
        }
        if !((*dc).next).is_null() {
            config_cond_clear_node(cond_cache, (*dc).next);
        }
    }
}
#[no_mangle]
pub unsafe extern "C" fn config_cond_cache_reset_item(r: *mut request_st, mut item: comp_key_t) {
    let cond_cache: *mut cond_cache_t = (*r).cond_cache;
    let data: *const *const data_config = config_reference.data;
    let used: uint32_t = config_reference.used;
    let mut i: uint32_t = 0 as libc::c_int as uint32_t;
    while i < used {
        let dc: *const data_config = *data.offset(i as isize);
        if item as libc::c_uint == (*dc).comp as libc::c_uint {
            (*cond_cache.offset(i as isize)).local_result =
                COND_RESULT_UNSET as libc::c_int as int8_t;
            config_cond_clear_node(cond_cache, dc);
        }
        i = i.wrapping_add(1);
    }
}
#[no_mangle]
pub unsafe extern "C" fn config_cond_cache_reset(r: *mut request_st) {
    let used: uint32_t = config_reference.used;
    if used > 1 as libc::c_int as libc::c_uint {
        memset(
            (*r).cond_cache as *mut libc::c_void,
            0 as libc::c_int,
            (used as libc::c_ulong)
                .wrapping_mul(::core::mem::size_of::<cond_cache_t>() as libc::c_ulong),
        );
    }
}
unsafe extern "C" fn config_pcre_match(
    r: *mut request_st,
    dc: *const data_config,
    b: *const buffer,
) -> libc::c_int {
    if (0 as libc::c_int == (*dc).capture_idx) as libc::c_int as libc::c_long != 0 {
        return pcre2_match_8(
            (*dc).code as *const pcre2_code_8,
            (*b).ptr as PCRE2_SPTR8,
            buffer_clen(b) as size_t,
            0 as libc::c_int as size_t,
            0 as libc::c_int as uint32_t,
            (*dc).match_data,
            0 as *mut pcre2_match_context_8,
        );
    }
    let capture_offset: libc::c_int = (*dc).capture_idx - 1 as libc::c_int;
    let ref mut fresh246 = *((*r).cond_match).offset(capture_offset as isize);
    *fresh246 = ((*r).cond_match_data).offset(capture_offset as isize);
    let cond_match: *mut cond_match_t = *fresh246;
    let mut match_data: *mut pcre2_match_data_8 = (*cond_match).match_data;
    if (0 as *mut libc::c_void as *mut pcre2_match_data_8 == match_data) as libc::c_int
        as libc::c_long
        != 0
    {
        (*cond_match).match_data = pcre2_match_data_create_from_pattern_8(
            (*dc).code as *const pcre2_code_8,
            0 as *mut pcre2_general_context_8,
        );
        match_data = (*cond_match).match_data;
        if match_data.is_null() {
            ck_assert_failed(
                b"/home/kkysen/work/rust/lighttpd/src/configfile-glue.c\0" as *const u8
                    as *const libc::c_char,
                674 as libc::c_int as libc::c_uint,
                b"match_data\0" as *const u8 as *const libc::c_char,
            );
        }
        (*cond_match).matches = pcre2_get_ovector_pointer_8(match_data) as *mut libc::c_void;
    }
    (*cond_match).comp_value = b;
    (*cond_match).captures = pcre2_match_8(
        (*dc).code as *const pcre2_code_8,
        (*b).ptr as PCRE2_SPTR8,
        buffer_clen(b) as size_t,
        0 as libc::c_int as size_t,
        0 as libc::c_int as uint32_t,
        match_data,
        0 as *mut pcre2_match_context_8,
    );
    return (*cond_match).captures;
}
#[no_mangle]
#[cold]
pub unsafe extern "C" fn http_response_buffer_append_authority(
    r: *mut request_st,
    o: *mut buffer,
) -> libc::c_int {
    if buffer_is_blank(&mut (*r).uri.authority) == 0 {
        buffer_append_buffer(o, &mut (*r).uri.authority);
    } else {
        let mut our_addr: sock_addr = sock_addr {
            ipv6: sockaddr_in6 {
                sin6_family: 0,
                sin6_port: 0,
                sin6_flowinfo: 0,
                sin6_addr: in6_addr {
                    __in6_u: C2RustUnnamed_0 {
                        __u6_addr8: [0; 16],
                    },
                },
                sin6_scope_id: 0,
            },
        };
        let mut our_addr_len: socklen_t = 0;
        our_addr.plain.sa_family = 0 as libc::c_int as sa_family_t;
        our_addr_len = ::core::mem::size_of::<sock_addr>() as libc::c_ulong as socklen_t;
        if -(1 as libc::c_int)
            == getsockname(
                (*(*r).con).fd,
                __SOCKADDR_ARG {
                    __sockaddr__: &mut our_addr as *mut sock_addr as *mut sockaddr,
                },
                &mut our_addr_len,
            )
            || our_addr_len > ::core::mem::size_of::<sock_addr>() as libc::c_ulong as socklen_t
        {
            (*r).http_status = 500 as libc::c_int;
            log_perror(
                (*r).conf.errh,
                b"/home/kkysen/work/rust/lighttpd/src/http-header-glue.c\0" as *const u8
                    as *const libc::c_char,
                49 as libc::c_int as libc::c_uint,
                b"can't get sockname\0" as *const u8 as *const libc::c_char,
            );
            return -(1 as libc::c_int);
        }
        if our_addr.plain.sa_family as libc::c_int == 2 as libc::c_int
            && our_addr.ipv4.sin_addr.s_addr == htonl(0x7f000001 as libc::c_int as in_addr_t)
        {
            static mut lhost_0: [libc::c_char; 32] = [0; 32];
            static mut lhost_len: size_t = 0 as libc::c_int as size_t;
            if 0 as libc::c_int as libc::c_ulong != lhost_len {
                buffer_append_string_len(o, lhost_0.as_mut_ptr(), lhost_len);
            } else {
                let mut olen: size_t = buffer_clen(o) as size_t;
                if 0 as libc::c_int
                    == sock_addr_nameinfo_append_buffer(o, &mut our_addr, (*r).conf.errh)
                {
                    lhost_len = (buffer_clen(o) as libc::c_ulong).wrapping_sub(olen);
                    if lhost_len < ::core::mem::size_of::<[libc::c_char; 32]>() as libc::c_ulong {
                        memcpy(
                            lhost_0.as_mut_ptr() as *mut libc::c_void,
                            ((*o).ptr).offset(olen as isize) as *const libc::c_void,
                            lhost_len.wrapping_add(1 as libc::c_int as libc::c_ulong),
                        );
                    } else {
                        lhost_len = 0 as libc::c_int as size_t;
                    }
                } else {
                    lhost_len = (::core::mem::size_of::<[libc::c_char; 10]>() as libc::c_ulong)
                        .wrapping_sub(1 as libc::c_int as libc::c_ulong);
                    memcpy(
                        lhost_0.as_mut_ptr() as *mut libc::c_void,
                        b"localhost\0" as *const u8 as *const libc::c_char as *const libc::c_void,
                        lhost_len.wrapping_add(1 as libc::c_int as libc::c_ulong),
                    );
                    buffer_append_string_len(o, lhost_0.as_mut_ptr(), lhost_len);
                }
            }
        } else if buffer_is_blank((*r).server_name) == 0 {
            buffer_append_buffer(o, (*r).server_name);
        } else if 0 as libc::c_int
            != sock_addr_nameinfo_append_buffer(o, &mut our_addr, (*r).conf.errh)
        {
            (*r).http_status = 500 as libc::c_int;
            return -(1 as libc::c_int);
        }
        let mut listen_port: libc::c_ushort = sock_addr_get_port(&mut our_addr);
        let mut default_port: libc::c_ushort = 80 as libc::c_int as libc::c_ushort;
        if buffer_eq_slen(
            &mut (*r).uri.scheme,
            b"https\0" as *const u8 as *const libc::c_char,
            (::core::mem::size_of::<[libc::c_char; 6]>() as libc::c_ulong as uint32_t)
                .wrapping_sub(1 as libc::c_int as libc::c_uint) as size_t,
        ) != 0
        {
            default_port = 443 as libc::c_int as libc::c_ushort;
        }
        if 0 as libc::c_int == listen_port as libc::c_int {
            listen_port = (*(*(*r).con).srv).srvconf.port;
        }
        if default_port as libc::c_int != listen_port as libc::c_int {
            buffer_append_string_len(
                o,
                b":\0" as *const u8 as *const libc::c_char,
                (::core::mem::size_of::<[libc::c_char; 2]>() as libc::c_ulong as uint32_t)
                    .wrapping_sub(1 as libc::c_int as libc::c_uint) as size_t,
            );
            buffer_append_int(o, listen_port as intmax_t);
        }
    }
    return 0 as libc::c_int;
}
#[no_mangle]
pub unsafe extern "C" fn http_response_redirect_to_directory(
    r: *mut request_st,
    mut status: libc::c_int,
) -> libc::c_int {
    let mut o: *mut buffer = (*r).tmp_buf;
    buffer_clear(o);
    if (*(*(*r).con).srv).srvconf.absolute_dir_redirect != 0 {
        buffer_append_str2(
            o,
            (*r).uri.scheme.ptr,
            buffer_clen(&mut (*r).uri.scheme) as size_t,
            b"://\0" as *const u8 as *const libc::c_char,
            (::core::mem::size_of::<[libc::c_char; 4]>() as libc::c_ulong as uint32_t)
                .wrapping_sub(1 as libc::c_int as libc::c_uint) as size_t,
        );
        if 0 as libc::c_int != http_response_buffer_append_authority(r, o) {
            return -(1 as libc::c_int);
        }
    }
    let mut vb: *mut buffer = 0 as *mut buffer;
    if status >= 300 as libc::c_int {
        (*r).http_status = status;
        (*r).resp_body_finished = 1 as libc::c_int as libc::c_char;
        vb = http_header_response_set_ptr(
            r,
            HTTP_HEADER_LOCATION,
            b"Location\0" as *const u8 as *const libc::c_char,
            (::core::mem::size_of::<[libc::c_char; 9]>() as libc::c_ulong as uint32_t)
                .wrapping_sub(1 as libc::c_int as libc::c_uint),
        );
    } else {
        vb = http_header_response_set_ptr(
            r,
            HTTP_HEADER_CONTENT_LOCATION,
            b"Content-Location\0" as *const u8 as *const libc::c_char,
            (::core::mem::size_of::<[libc::c_char; 17]>() as libc::c_ulong as uint32_t)
                .wrapping_sub(1 as libc::c_int as libc::c_uint),
        );
    }
    buffer_copy_buffer(vb, o);
    buffer_append_string_encoded(
        vb,
        (*r).uri.path.ptr,
        buffer_clen(&mut (*r).uri.path) as size_t,
        ENCODING_REL_URI,
    );
    buffer_append_string_len(
        vb,
        b"/\0" as *const u8 as *const libc::c_char,
        (::core::mem::size_of::<[libc::c_char; 2]>() as libc::c_ulong as uint32_t)
            .wrapping_sub(1 as libc::c_int as libc::c_uint) as size_t,
    );
    if buffer_is_blank(&mut (*r).uri.query) == 0 {
        buffer_append_str2(
            vb,
            b"?\0" as *const u8 as *const libc::c_char,
            (::core::mem::size_of::<[libc::c_char; 2]>() as libc::c_ulong as uint32_t)
                .wrapping_sub(1 as libc::c_int as libc::c_uint) as size_t,
            (*r).uri.query.ptr,
            buffer_clen(&mut (*r).uri.query) as size_t,
        );
    }
    return 0 as libc::c_int;
}
static mut mtime_cache: [mtime_cache_type; 16] = [mtime_cache_type {
    mtime: 0,
    str_0: buffer {
        ptr: 0 as *const libc::c_char as *mut libc::c_char,
        used: 0,
        size: 0,
    },
}; 16];
static mut mtime_cache_str: [[libc::c_char; 30]; 16] = [[0; 30]; 16];
#[no_mangle]
#[cold]
pub unsafe extern "C" fn strftime_cache_reset() {
    let mut i: libc::c_int = 0 as libc::c_int;
    while i < 16 as libc::c_int {
        mtime_cache[i as usize].mtime = -(1 as libc::c_int) as unix_time64_t;
        mtime_cache[i as usize].str_0.ptr = (mtime_cache_str[i as usize]).as_mut_ptr();
        mtime_cache[i as usize].str_0.used =
            ::core::mem::size_of::<[libc::c_char; 30]>() as libc::c_ulong as uint32_t;
        mtime_cache[i as usize].str_0.size =
            ::core::mem::size_of::<[libc::c_char; 30]>() as libc::c_ulong as uint32_t;
        i += 1;
    }
}
unsafe extern "C" fn strftime_cache_get(last_mod: unix_time64_t) -> *const buffer {
    static mut mtime_cache_idx: libc::c_int = 0;
    let mut j: libc::c_int = 0 as libc::c_int;
    while j < 16 as libc::c_int {
        if mtime_cache[j as usize].mtime == last_mod {
            return &mut (*mtime_cache.as_mut_ptr().offset(j as isize)).str_0;
        }
        j += 1;
    }
    mtime_cache_idx += 1;
    if mtime_cache_idx == 16 as libc::c_int {
        mtime_cache_idx = 0 as libc::c_int;
    }
    let i: libc::c_int = mtime_cache_idx;
    mtime_cache[i as usize].mtime = last_mod;
    http_date_time_to_str(
        mtime_cache[i as usize].str_0.ptr,
        ::core::mem::size_of::<[libc::c_char; 30]>() as libc::c_ulong,
        mtime_cache[i as usize].mtime,
    );
    return &mut (*mtime_cache.as_mut_ptr().offset(i as isize)).str_0;
}
#[no_mangle]
pub unsafe extern "C" fn http_response_set_last_modified(
    r: *mut request_st,
    lmtime: unix_time64_t,
) -> *const buffer {
    let vb: *mut buffer = http_header_response_set_ptr(
        r,
        HTTP_HEADER_LAST_MODIFIED,
        b"Last-Modified\0" as *const u8 as *const libc::c_char,
        (::core::mem::size_of::<[libc::c_char; 14]>() as libc::c_ulong as uint32_t)
            .wrapping_sub(1 as libc::c_int as libc::c_uint),
    );
    buffer_copy_buffer(vb, strftime_cache_get(lmtime));
    return vb;
}
unsafe extern "C" fn http_response_maybe_cachable(r: *const request_st) -> libc::c_int {
    return ((*r).rqst_htags
        & ((1 as libc::c_ulong) << HTTP_HEADER_IF_NONE_MATCH as libc::c_int
            | (1 as libc::c_ulong) << HTTP_HEADER_IF_MODIFIED_SINCE as libc::c_int))
        as libc::c_int;
}
#[no_mangle]
pub unsafe extern "C" fn http_response_handle_cachable(
    r: *mut request_st,
    mut lmod: *const buffer,
    lmtime: unix_time64_t,
) -> libc::c_int {
    if http_response_maybe_cachable(r) == 0 {
        return HANDLER_GO_ON as libc::c_int;
    }
    let mut vb: *const buffer = 0 as *const buffer;
    let mut etag: *const buffer = 0 as *const buffer;
    vb = http_header_request_get(
        r,
        HTTP_HEADER_IF_NONE_MATCH,
        b"If-None-Match\0" as *const u8 as *const libc::c_char,
        (::core::mem::size_of::<[libc::c_char; 14]>() as libc::c_ulong as uint32_t)
            .wrapping_sub(1 as libc::c_int as libc::c_uint),
    );
    if !vb.is_null() && {
        etag = http_header_response_get(
            r,
            HTTP_HEADER_ETAG,
            b"ETag\0" as *const u8 as *const libc::c_char,
            (::core::mem::size_of::<[libc::c_char; 5]>() as libc::c_ulong as uint32_t)
                .wrapping_sub(1 as libc::c_int as libc::c_uint),
        );
        !etag.is_null()
    } {
        let mut range_request: libc::c_int = (0 as libc::c_int as libc::c_ulong
            != (*r).rqst_htags & (1 as libc::c_ulong) << HTTP_HEADER_RANGE as libc::c_int)
            as libc::c_int;
        if http_etag_matches(etag, (*vb).ptr, (range_request == 0) as libc::c_int) != 0 {
            if (*r).http_method as libc::c_int <= HTTP_METHOD_HEAD as libc::c_int {
                (*r).http_status = 304 as libc::c_int;
                return HANDLER_FINISHED as libc::c_int;
            } else {
                (*r).http_status = 412 as libc::c_int;
                (*r).handler_module = 0 as *const plugin;
                return HANDLER_FINISHED as libc::c_int;
            }
        }
    } else if (*r).http_method as libc::c_int <= HTTP_METHOD_HEAD as libc::c_int
        && {
            vb = http_header_request_get(
                r,
                HTTP_HEADER_IF_MODIFIED_SINCE,
                b"If-Modified-Since\0" as *const u8 as *const libc::c_char,
                (::core::mem::size_of::<[libc::c_char; 18]>() as libc::c_ulong as uint32_t)
                    .wrapping_sub(1 as libc::c_int as libc::c_uint),
            );
            !vb.is_null()
        }
        && (!lmod.is_null() || {
            lmod = http_header_response_get(
                r,
                HTTP_HEADER_LAST_MODIFIED,
                b"Last-Modified\0" as *const u8 as *const libc::c_char,
                (::core::mem::size_of::<[libc::c_char; 14]>() as libc::c_ulong as uint32_t)
                    .wrapping_sub(1 as libc::c_int as libc::c_uint),
            );
            !lmod.is_null()
        })
    {
        if buffer_is_equal(lmod, vb) != 0
            || http_date_if_modified_since((*vb).ptr, buffer_clen(vb), lmtime) == 0
        {
            (*r).http_status = 304 as libc::c_int;
            return HANDLER_FINISHED as libc::c_int;
        }
    }
    return HANDLER_GO_ON as libc::c_int;
}
#[no_mangle]
pub unsafe extern "C" fn http_response_body_clear(
    r: *mut request_st,
    mut preserve_length: libc::c_int,
) {
    (*r).resp_send_chunked = 0 as libc::c_int as libc::c_char;
    (*r).resp_body_scratchpad = -(1 as libc::c_int) as off_t;
    if (*r).resp_htags & (1 as libc::c_ulong) << HTTP_HEADER_TRANSFER_ENCODING as libc::c_int != 0 {
        http_header_response_unset(
            r,
            HTTP_HEADER_TRANSFER_ENCODING,
            b"Transfer-Encoding\0" as *const u8 as *const libc::c_char,
            (::core::mem::size_of::<[libc::c_char; 18]>() as libc::c_ulong as uint32_t)
                .wrapping_sub(1 as libc::c_int as libc::c_uint),
        );
    }
    if preserve_length == 0 {
        if (*r).resp_htags & (1 as libc::c_ulong) << HTTP_HEADER_CONTENT_LENGTH as libc::c_int != 0
        {
            http_header_response_unset(
                r,
                HTTP_HEADER_CONTENT_LENGTH,
                b"Content-Length\0" as *const u8 as *const libc::c_char,
                (::core::mem::size_of::<[libc::c_char; 15]>() as libc::c_ulong as uint32_t)
                    .wrapping_sub(1 as libc::c_int as libc::c_uint),
            );
        }
        (*r).resp_decode_chunked = 0 as libc::c_int as libc::c_char;
        if !((*r).gw_dechunk).is_null() {
            free((*(*r).gw_dechunk).b.ptr as *mut libc::c_void);
            free((*r).gw_dechunk as *mut libc::c_void);
            (*r).gw_dechunk = 0 as *mut response_dechunk;
        }
    }
    chunkqueue_reset(&mut (*r).write_queue);
}
unsafe extern "C" fn http_response_header_clear(r: *mut request_st) {
    (*r).http_status = 0 as libc::c_int;
    (*r).resp_htags = 0 as libc::c_int as uint64_t;
    (*r).resp_header_len = 0 as libc::c_int as uint32_t;
    (*r).resp_header_repeated = 0 as libc::c_int as libc::c_char;
    array_reset_data_strings(&mut (*r).resp_headers);
    (*r).resp_send_chunked = 0 as libc::c_int as libc::c_char;
    (*r).resp_decode_chunked = 0 as libc::c_int as libc::c_char;
    (*r).resp_body_scratchpad = -(1 as libc::c_int) as off_t;
    if !((*r).gw_dechunk).is_null() {
        free((*(*r).gw_dechunk).b.ptr as *mut libc::c_void);
        free((*r).gw_dechunk as *mut libc::c_void);
        (*r).gw_dechunk = 0 as *mut response_dechunk;
    }
}
#[no_mangle]
pub unsafe extern "C" fn http_response_reset(r: *mut request_st) {
    (*r).http_status = 0 as libc::c_int;
    (*(*r).con).is_writable = 1 as libc::c_int as libc::c_schar;
    (*r).resp_body_finished = 0 as libc::c_int as libc::c_char;
    (*r).resp_body_started = 0 as libc::c_int as libc::c_char;
    (*r).handler_module = 0 as *const plugin;
    if !((*r).physical.path.ptr).is_null() {
        buffer_clear(&mut (*r).physical.doc_root);
        buffer_clear(&mut (*r).physical.basedir);
        buffer_reset(&mut (*r).physical.path);
        buffer_reset(&mut (*r).physical.rel_path);
    }
    (*r).resp_htags = 0 as libc::c_int as uint64_t;
    (*r).resp_header_len = 0 as libc::c_int as uint32_t;
    (*r).resp_header_repeated = 0 as libc::c_int as libc::c_char;
    array_reset_data_strings(&mut (*r).resp_headers);
    http_response_body_clear(r, 0 as libc::c_int);
}
#[no_mangle]
#[cold]
pub unsafe extern "C" fn http_response_reqbody_read_error(
    r: *mut request_st,
    mut http_status_0: libc::c_int,
) -> handler_t {
    (*r).keep_alive = 0 as libc::c_int as int8_t;
    if 0 as libc::c_int as libc::c_uint != (*r).resp_header_len {
        return HANDLER_ERROR;
    }
    http_response_body_clear(r, 0 as libc::c_int);
    (*r).http_status = http_status_0;
    (*r).handler_module = 0 as *const plugin;
    return HANDLER_FINISHED;
}
static mut octet_stream: buffer = buffer {
    ptr: 0 as *const libc::c_char as *mut libc::c_char,
    used: 0,
    size: 0,
};
#[no_mangle]
pub unsafe extern "C" fn http_response_send_file(
    r: *mut request_st,
    path: *const buffer,
    mut sce: *mut stat_cache_entry,
) {
    if (0 as *mut libc::c_void as *mut stat_cache_entry == sce) as libc::c_int as libc::c_long != 0
        || ((*sce).fd < 0 as libc::c_int) as libc::c_int as libc::c_long != 0
            && 0 as libc::c_int as libc::c_long != (*sce).st.st_size
    {
        sce = stat_cache_get_entry_open(path, (*r).conf.follow_symlink as libc::c_int);
        if sce.is_null() {
            (*r).http_status = if *__errno_location() == 2 as libc::c_int {
                404 as libc::c_int
            } else {
                403 as libc::c_int
            };
            log_error(
                (*r).conf.errh,
                b"/home/kkysen/work/rust/lighttpd/src/http-header-glue.c\0" as *const u8
                    as *const libc::c_char,
                326 as libc::c_int as libc::c_uint,
                b"not a regular file: %s -> %s\0" as *const u8 as *const libc::c_char,
                (*r).uri.path.ptr,
                (*path).ptr,
            );
            return;
        }
        if (*sce).fd < 0 as libc::c_int
            && (0 as libc::c_int as libc::c_long != (*sce).st.st_size) as libc::c_int
                as libc::c_long
                != 0
        {
            (*r).http_status = if *__errno_location() == 2 as libc::c_int {
                404 as libc::c_int
            } else {
                403 as libc::c_int
            };
            if (*r).conf.log_request_handling != 0 {
                log_perror(
                    (*r).conf.errh,
                    b"/home/kkysen/work/rust/lighttpd/src/http-header-glue.c\0" as *const u8
                        as *const libc::c_char,
                    333 as libc::c_int as libc::c_uint,
                    b"file open failed: %s\0" as *const u8 as *const libc::c_char,
                    (*path).ptr,
                );
            }
            return;
        }
    }
    if ((*r).conf.follow_symlink == 0) as libc::c_int as libc::c_long != 0
        && 0 as libc::c_int != stat_cache_path_contains_symlink(path, (*r).conf.errh)
    {
        (*r).http_status = 403 as libc::c_int;
        if (*r).conf.log_request_handling != 0 {
            log_error(
                (*r).conf.errh,
                b"/home/kkysen/work/rust/lighttpd/src/http-header-glue.c\0" as *const u8
                    as *const libc::c_char,
                344 as libc::c_int as libc::c_uint,
                b"-- access denied due symlink restriction\0" as *const u8 as *const libc::c_char,
            );
            log_error(
                (*r).conf.errh,
                b"/home/kkysen/work/rust/lighttpd/src/http-header-glue.c\0" as *const u8
                    as *const libc::c_char,
                346 as libc::c_int as libc::c_uint,
                b"Path         : %s\0" as *const u8 as *const libc::c_char,
                (*path).ptr,
            );
        }
        return;
    }
    if !((*sce).st.st_mode & 0o170000 as libc::c_int as libc::c_uint
        == 0o100000 as libc::c_int as libc::c_uint) as libc::c_int as libc::c_long
        != 0
    {
        (*r).http_status = 403 as libc::c_int;
        if (*r).conf.log_file_not_found != 0 {
            log_error(
                (*r).conf.errh,
                b"/home/kkysen/work/rust/lighttpd/src/http-header-glue.c\0" as *const u8
                    as *const libc::c_char,
                356 as libc::c_int as libc::c_uint,
                b"not a regular file: %s -> %s\0" as *const u8 as *const libc::c_char,
                (*r).uri.path.ptr,
                (*path).ptr,
            );
        }
        return;
    }
    let mut content_type: *const buffer = 0 as *const buffer;
    if ((*r).resp_htags & (1 as libc::c_ulong) << HTTP_HEADER_CONTENT_TYPE as libc::c_int == 0)
        as libc::c_int as libc::c_long
        != 0
    {
        content_type = stat_cache_content_type_get_by_ext(sce, (*r).conf.mimetypes);
        if content_type.is_null() as libc::c_int as libc::c_long != 0
            || buffer_is_blank(content_type) as libc::c_long != 0
        {
            content_type = &octet_stream;
        }
        http_header_response_set(
            r,
            HTTP_HEADER_CONTENT_TYPE,
            b"Content-Type\0" as *const u8 as *const libc::c_char,
            (::core::mem::size_of::<[libc::c_char; 13]>() as libc::c_ulong as uint32_t)
                .wrapping_sub(1 as libc::c_int as libc::c_uint),
            (*content_type).ptr,
            buffer_clen(content_type),
        );
    }
    let mut allow_caching: libc::c_int = (content_type != &octet_stream as *const buffer
        && (0 as libc::c_int == (*r).http_status || 200 as libc::c_int == (*r).http_status))
        as libc::c_int;
    if allow_caching as libc::c_long != 0 {
        if ((*r).resp_htags & (1 as libc::c_ulong) << HTTP_HEADER_ETAG as libc::c_int == 0)
            as libc::c_int as libc::c_long
            != 0
            && 0 as libc::c_int != (*r).conf.etag_flags as libc::c_int
        {
            let mut etag: *const buffer =
                stat_cache_etag_get(sce, (*r).conf.etag_flags as libc::c_int);
            if !etag.is_null() && buffer_is_blank(etag) == 0 {
                http_header_response_set(
                    r,
                    HTTP_HEADER_ETAG,
                    b"ETag\0" as *const u8 as *const libc::c_char,
                    (::core::mem::size_of::<[libc::c_char; 5]>() as libc::c_ulong as uint32_t)
                        .wrapping_sub(1 as libc::c_int as libc::c_uint),
                    (*etag).ptr,
                    buffer_clen(etag),
                );
            }
        }
        let lmod: *const buffer = if ((*r).resp_htags
            & (1 as libc::c_ulong) << HTTP_HEADER_LAST_MODIFIED as libc::c_int
            == 0) as libc::c_int as libc::c_long
            != 0
        {
            http_response_set_last_modified(r, (*sce).st.st_mtim.tv_sec)
        } else {
            0 as *const buffer
        };
        if http_response_maybe_cachable(r) != 0
            && HANDLER_FINISHED as libc::c_int
                == http_response_handle_cachable(r, lmod, (*sce).st.st_mtim.tv_sec)
        {
            return;
        }
    }
    if 0 as libc::c_int as libc::c_long == (*sce).st.st_size
        || 0 as libc::c_int == http_chunk_append_file_ref(r, sce)
    {
        (*r).http_status = 200 as libc::c_int;
        (*r).resp_body_finished = 1 as libc::c_int as libc::c_char;
        buffer_append_int(
            http_header_response_set_ptr(
                r,
                HTTP_HEADER_CONTENT_LENGTH,
                b"Content-Length\0" as *const u8 as *const libc::c_char,
                (::core::mem::size_of::<[libc::c_char; 15]>() as libc::c_ulong as uint32_t)
                    .wrapping_sub(1 as libc::c_int as libc::c_uint),
            ),
            (*sce).st.st_size,
        );
    } else {
        (*r).http_status = 500 as libc::c_int;
    };
}
unsafe extern "C" fn http_response_xsendfile(
    r: *mut request_st,
    path: *mut buffer,
    xdocroot: *const array,
) {
    let status: libc::c_int = (*r).http_status;
    let mut valid: libc::c_int = 1 as libc::c_int;
    if (*r).resp_htags & (1 as libc::c_ulong) << HTTP_HEADER_CONTENT_LENGTH as libc::c_int != 0 {
        http_header_response_unset(
            r,
            HTTP_HEADER_CONTENT_LENGTH,
            b"Content-Length\0" as *const u8 as *const libc::c_char,
            (::core::mem::size_of::<[libc::c_char; 15]>() as libc::c_ulong as uint32_t)
                .wrapping_sub(1 as libc::c_int as libc::c_uint),
        );
    }
    buffer_urldecode_path(path);
    if buffer_is_valid_UTF8(path) == 0 {
        log_error(
            (*r).conf.errh,
            b"/home/kkysen/work/rust/lighttpd/src/http-header-glue.c\0" as *const u8
                as *const libc::c_char,
            440 as libc::c_int as libc::c_uint,
            b"X-Sendfile invalid UTF-8 after url-decode: %s\0" as *const u8 as *const libc::c_char,
            (*path).ptr,
        );
        if (*r).http_status < 400 as libc::c_int {
            (*r).http_status = 502 as libc::c_int;
            (*r).handler_module = 0 as *const plugin;
        }
        return;
    }
    buffer_path_simplify(path);
    if (*r).conf.force_lowercase_filenames != 0 {
        buffer_to_lower(path);
    }
    if buffer_is_blank(path) != 0 {
        (*r).http_status = 502 as libc::c_int;
        valid = 0 as libc::c_int;
    }
    if !xdocroot.is_null() && (*xdocroot).used != 0 {
        let xval: *const buffer = if (*r).conf.force_lowercase_filenames == 0 {
            array_match_value_prefix(xdocroot, path)
        } else {
            array_match_value_prefix_nc(xdocroot, path)
        };
        if xval.is_null() {
            log_error(
                (*r).conf.errh,
                b"/home/kkysen/work/rust/lighttpd/src/http-header-glue.c\0" as *const u8
                    as *const libc::c_char,
                466 as libc::c_int as libc::c_uint,
                b"X-Sendfile (%s) not under configured x-sendfile-docroot(s)\0" as *const u8
                    as *const libc::c_char,
                (*path).ptr,
            );
            (*r).http_status = 403 as libc::c_int;
            valid = 0 as libc::c_int;
        }
    }
    if valid != 0 {
        http_response_send_file(r, path, 0 as *mut stat_cache_entry);
    }
    if (*r).http_status >= 400 as libc::c_int && status < 300 as libc::c_int {
        (*r).handler_module = 0 as *const plugin;
    } else if 0 as libc::c_int != status && 200 as libc::c_int != status {
        (*r).http_status = status;
    }
}
unsafe extern "C" fn http_response_xsendfile2(
    r: *mut request_st,
    value: *const buffer,
    xdocroot: *const array,
) {
    let mut current_block: u64;
    let mut pos: *const libc::c_char = (*value).ptr;
    let b: *mut buffer = (*r).tmp_buf;
    let status: libc::c_int = (*r).http_status;
    if (*r).resp_htags & (1 as libc::c_ulong) << HTTP_HEADER_CONTENT_LENGTH as libc::c_int != 0 {
        http_header_response_unset(
            r,
            HTTP_HEADER_CONTENT_LENGTH,
            b"Content-Length\0" as *const u8 as *const libc::c_char,
            (::core::mem::size_of::<[libc::c_char; 15]>() as libc::c_ulong as uint32_t)
                .wrapping_sub(1 as libc::c_int as libc::c_uint),
        );
    }
    while *pos != 0 {
        let mut filename: *const libc::c_char = 0 as *const libc::c_char;
        let mut range: *const libc::c_char = 0 as *const libc::c_char;
        let mut sce: *mut stat_cache_entry = 0 as *mut stat_cache_entry;
        let mut begin_range: off_t = 0;
        let mut end_range: off_t = 0;
        let mut range_len: off_t = 0;
        while ' ' as i32 == *pos as libc::c_int {
            pos = pos.offset(1);
        }
        if *pos == 0 {
            break;
        }
        filename = pos;
        range = strchr(pos, ' ' as i32);
        if range.is_null() {
            log_error(
                (*r).conf.errh,
                b"/home/kkysen/work/rust/lighttpd/src/http-header-glue.c\0" as *const u8
                    as *const libc::c_char,
                505 as libc::c_int as libc::c_uint,
                b"Couldn't find range after filename: %s\0" as *const u8 as *const libc::c_char,
                filename,
            );
            (*r).http_status = 502 as libc::c_int;
            break;
        } else {
            buffer_copy_string_len(
                b,
                filename,
                range.offset_from(filename) as libc::c_long as size_t,
            );
            range = range.offset(1);
            pos = range;
            while *pos as libc::c_int != 0
                && *pos as libc::c_int != ' ' as i32
                && *pos as libc::c_int != ',' as i32
            {
                pos = pos.offset(1);
            }
            buffer_urldecode_path(b);
            if buffer_is_valid_UTF8(b) == 0 {
                log_error(
                    (*r).conf.errh,
                    b"/home/kkysen/work/rust/lighttpd/src/http-header-glue.c\0" as *const u8
                        as *const libc::c_char,
                    517 as libc::c_int as libc::c_uint,
                    b"X-Sendfile2 invalid UTF-8 after url-decode: %s\0" as *const u8
                        as *const libc::c_char,
                    (*b).ptr,
                );
                (*r).http_status = 502 as libc::c_int;
                break;
            } else {
                buffer_path_simplify(b);
                if (*r).conf.force_lowercase_filenames != 0 {
                    buffer_to_lower(b);
                }
                if buffer_is_blank(b) != 0 {
                    (*r).http_status = 502 as libc::c_int;
                    break;
                } else {
                    if !xdocroot.is_null() && (*xdocroot).used != 0 {
                        let xval: *const buffer = if (*r).conf.force_lowercase_filenames == 0 {
                            array_match_value_prefix(xdocroot, b)
                        } else {
                            array_match_value_prefix_nc(xdocroot, b)
                        };
                        if xval.is_null() {
                            log_error(
                                (*r).conf.errh,
                                b"/home/kkysen/work/rust/lighttpd/src/http-header-glue.c\0"
                                    as *const u8
                                    as *const libc::c_char,
                                535 as libc::c_int as libc::c_uint,
                                b"X-Sendfile2 (%s) not under configured x-sendfile-docroot(s)\0"
                                    as *const u8
                                    as *const libc::c_char,
                                (*b).ptr,
                            );
                            (*r).http_status = 403 as libc::c_int;
                            break;
                        }
                    }
                    sce = stat_cache_get_entry_open(b, (*r).conf.follow_symlink as libc::c_int);
                    if sce.is_null() {
                        log_error(
                            (*r).conf.errh,
                            b"/home/kkysen/work/rust/lighttpd/src/http-header-glue.c\0" as *const u8
                                as *const libc::c_char,
                            545 as libc::c_int as libc::c_uint,
                            b"send-file error: couldn't get stat_cache entry for X-Sendfile2: %s\0"
                                as *const u8 as *const libc::c_char,
                            (*b).ptr,
                        );
                        (*r).http_status = 404 as libc::c_int;
                        break;
                    } else if !((*sce).st.st_mode & 0o170000 as libc::c_int as libc::c_uint
                        == 0o100000 as libc::c_int as libc::c_uint)
                    {
                        log_error(
                            (*r).conf.errh,
                            b"/home/kkysen/work/rust/lighttpd/src/http-header-glue.c\0" as *const u8
                                as *const libc::c_char,
                            551 as libc::c_int as libc::c_uint,
                            b"send-file error: wrong filetype for X-Sendfile2: %s\0" as *const u8
                                as *const libc::c_char,
                            (*b).ptr,
                        );
                        (*r).http_status = 502 as libc::c_int;
                        break;
                    } else {
                        end_range = (*sce).st.st_size - 1 as libc::c_int as libc::c_long;
                        let mut rpos: *mut libc::c_char = 0 as *mut libc::c_char;
                        *__errno_location() = 0 as libc::c_int;
                        begin_range = strtoll(range, &mut rpos, 10 as libc::c_int) as off_t;
                        if !(*__errno_location() != 0 as libc::c_int
                            || begin_range < 0 as libc::c_int as libc::c_long
                            || rpos == range as *mut libc::c_char)
                        {
                            let fresh247 = rpos;
                            rpos = rpos.offset(1);
                            if !('-' as i32 != *fresh247 as libc::c_int) {
                                if rpos != pos as *mut libc::c_char {
                                    range = rpos;
                                    end_range =
                                        strtoll(range, &mut rpos, 10 as libc::c_int) as off_t;
                                    if *__errno_location() != 0 as libc::c_int
                                        || end_range < 0 as libc::c_int as libc::c_long
                                        || rpos == range as *mut libc::c_char
                                    {
                                        current_block = 16985124469527263507;
                                    } else {
                                        current_block = 17784502470059252271;
                                    }
                                } else {
                                    current_block = 17784502470059252271;
                                }
                                match current_block {
                                    16985124469527263507 => {}
                                    _ => {
                                        if !(rpos != pos as *mut libc::c_char) {
                                            while *pos as libc::c_int == ' ' as i32 {
                                                pos = pos.offset(1);
                                            }
                                            if *pos as libc::c_int != '\0' as i32
                                                && *pos as libc::c_int != ',' as i32
                                            {
                                                (*r).http_status = 502 as libc::c_int;
                                                break;
                                            } else {
                                                range_len = end_range - begin_range
                                                    + 1 as libc::c_int as libc::c_long;
                                                if range_len < 0 as libc::c_int as libc::c_long {
                                                    (*r).http_status = 502 as libc::c_int;
                                                    break;
                                                } else {
                                                    if range_len != 0 as libc::c_int as libc::c_long
                                                    {
                                                        http_chunk_append_file_ref_range(
                                                            r,
                                                            sce,
                                                            begin_range,
                                                            range_len,
                                                        );
                                                    }
                                                    if *pos as libc::c_int == ',' as i32 {
                                                        pos = pos.offset(1);
                                                    }
                                                    continue;
                                                }
                                            }
                                        }
                                    }
                                }
                            }
                        }
                        log_error(
                            (*r).conf.errh,
                            b"/home/kkysen/work/rust/lighttpd/src/http-header-glue.c\0" as *const u8
                                as *const libc::c_char,
                            578 as libc::c_int as libc::c_uint,
                            b"Couldn't decode range after filename: %s\0" as *const u8
                                as *const libc::c_char,
                            filename,
                        );
                        (*r).http_status = 502 as libc::c_int;
                        break;
                    }
                }
            }
        }
    }
    if (*r).http_status >= 400 as libc::c_int && status < 300 as libc::c_int {
        (*r).handler_module = 0 as *const plugin;
    } else if 0 as libc::c_int != status && 200 as libc::c_int != status {
        (*r).http_status = status;
    }
}
#[no_mangle]
pub unsafe extern "C" fn http_response_backend_error(r: *mut request_st) {
    if (*r).resp_body_started != 0 {
        (*r).handler_module = 0 as *const plugin;
        (*r).keep_alive = 0 as libc::c_int as int8_t;
        (*r).resp_body_finished = 1 as libc::c_int as libc::c_char;
    }
}
#[no_mangle]
pub unsafe extern "C" fn http_response_backend_done(r: *mut request_st) {
    let mut current_block_8: u64;
    match (*r).state as libc::c_uint {
        5 | 4 => {
            if (*r).resp_body_started == 0 {
                if (*r).http_status < 500 as libc::c_int && (*r).http_status != 400 as libc::c_int {
                    (*r).http_status = 500 as libc::c_int;
                }
                (*r).handler_module = 0 as *const plugin;
                current_block_8 = 2868539653012386629;
            } else {
                current_block_8 = 2913502095247331681;
            }
        }
        7 => {
            current_block_8 = 2913502095247331681;
        }
        _ => {
            current_block_8 = 2868539653012386629;
        }
    }
    match current_block_8 {
        2913502095247331681 => {
            if (*r).resp_body_finished == 0 {
                if (*r).http_version as libc::c_int == HTTP_VERSION_1_1 as libc::c_int {
                    http_chunk_close(r);
                }
                (*r).resp_body_finished = 1 as libc::c_int as libc::c_char;
            }
        }
        _ => {}
    };
}
#[no_mangle]
pub unsafe extern "C" fn http_response_upgrade_read_body_unknown(r: *mut request_st) {
    if (*r).conf.stream_request_body as libc::c_int & (1 as libc::c_int) << 0 as libc::c_int == 0 {
        (*r).conf.stream_request_body = ((*r).conf.stream_request_body as libc::c_int
            | ((1 as libc::c_int) << 1 as libc::c_int | (1 as libc::c_int) << 0 as libc::c_int))
            as libc::c_ushort;
    }
    if (*r).conf.stream_response_body as libc::c_int & (1 as libc::c_int) << 0 as libc::c_int == 0 {
        (*r).conf.stream_response_body = ((*r).conf.stream_response_body as libc::c_int
            | ((1 as libc::c_int) << 1 as libc::c_int | (1 as libc::c_int) << 0 as libc::c_int))
            as libc::c_ushort;
    }
    (*r).conf.stream_request_body = ((*r).conf.stream_request_body as libc::c_int
        | (1 as libc::c_int) << 15 as libc::c_int)
        as libc::c_ushort;
    (*r).reqbody_length = -(2 as libc::c_int) as off_t;
    (*r).resp_body_scratchpad = -(1 as libc::c_int) as off_t;
    (*r).keep_alive = 0 as libc::c_int as int8_t;
}
unsafe extern "C" fn http_response_append_buffer_simple_accum(
    r: *const request_st,
    len: off_t,
) -> libc::c_int {
    return (len < 32768 as libc::c_int as libc::c_long
        && !((*r).write_queue.last).is_null()
        && (*(*r).write_queue.last).file.is_temp != 0) as libc::c_int;
}
unsafe extern "C" fn http_response_append_buffer(
    r: *mut request_st,
    mem: *mut buffer,
    simple_accum: libc::c_int,
) -> libc::c_int {
    if (*r).resp_decode_chunked != 0 {
        return http_chunk_decode_append_buffer(r, mem);
    }
    if (*r).resp_body_scratchpad > 0 as libc::c_int as libc::c_long {
        let mut len: off_t = buffer_clen(mem) as off_t;
        (*r).resp_body_scratchpad -= len;
        if (*r).resp_body_scratchpad > 0 as libc::c_int as libc::c_long {
            if simple_accum != 0 && http_response_append_buffer_simple_accum(r, len) != 0 {
                (*r).resp_body_scratchpad += len;
                return 0 as libc::c_int;
            }
        } else {
            (*r).resp_body_finished = 1 as libc::c_int as libc::c_char;
            if ((*r).resp_body_scratchpad < 0 as libc::c_int as libc::c_long) as libc::c_int
                as libc::c_long
                != 0
            {
                len += (*r).resp_body_scratchpad;
                (*r).resp_body_scratchpad = 0 as libc::c_int as off_t;
                buffer_truncate(mem, len as uint32_t);
            }
        }
    } else if 0 as libc::c_int as libc::c_long == (*r).resp_body_scratchpad {
        buffer_clear(mem);
        return 0 as libc::c_int;
    } else {
        if simple_accum != 0
            && http_response_append_buffer_simple_accum(r, buffer_clen(mem) as off_t) != 0
        {
            return 0 as libc::c_int;
        }
    }
    return http_chunk_append_buffer(r, mem);
}
unsafe extern "C" fn http_response_append_splice(
    r: *mut request_st,
    opts: *mut http_response_opts,
    b: *mut buffer,
    fd: libc::c_int,
    mut toread: libc::c_uint,
) -> libc::c_int {
    if (*r).resp_body_scratchpad >= toread as libc::c_long
        && (toread > 32768 as libc::c_int as libc::c_uint
            || toread >= 8192 as libc::c_int as libc::c_uint
                && !((*r).write_queue.last).is_null()
                && (*(*r).write_queue.last).file.is_temp != 0)
    {
        if buffer_is_blank(b) == 0 {
            let mut rc: libc::c_int = http_response_append_buffer(r, b, 0 as libc::c_int);
            chunk_buffer_yield(b);
            if (0 as libc::c_int != rc) as libc::c_int as libc::c_long != 0 {
                return -(1 as libc::c_int);
            }
        }
        let mut n: ssize_t = if (*opts).fdfmt == 0o140000 as libc::c_int {
            chunkqueue_append_splice_sock_tempfile(
                &mut (*r).write_queue,
                fd,
                toread,
                (*r).conf.errh,
            )
        } else {
            chunkqueue_append_splice_pipe_tempfile(
                &mut (*r).write_queue,
                fd,
                toread,
                (*r).conf.errh,
            )
        };
        if (n >= 0 as libc::c_int as libc::c_long) as libc::c_int as libc::c_long != 0 {
            (*r).resp_body_scratchpad -= n;
            if 0 as libc::c_int as libc::c_long == (*r).resp_body_scratchpad {
                (*r).resp_body_finished = 1 as libc::c_int as libc::c_char;
            }
            return 1 as libc::c_int;
        } else {
            if n != -(22 as libc::c_int) as libc::c_long {
                return -(1 as libc::c_int);
            }
        }
    }
    return 0 as libc::c_int;
}
unsafe extern "C" fn http_response_append_mem(
    r: *mut request_st,
    mem: *const libc::c_char,
    mut len: size_t,
) -> libc::c_int {
    if (*r).resp_decode_chunked != 0 {
        return http_chunk_decode_append_mem(r, mem, len);
    }
    if (*r).resp_body_scratchpad > 0 as libc::c_int as libc::c_long {
        (*r).resp_body_scratchpad -= len as off_t;
        if (*r).resp_body_scratchpad <= 0 as libc::c_int as libc::c_long {
            (*r).resp_body_finished = 1 as libc::c_int as libc::c_char;
            if ((*r).resp_body_scratchpad < 0 as libc::c_int as libc::c_long) as libc::c_int
                as libc::c_long
                != 0
            {
                len = ((*r).resp_body_scratchpad + len as off_t) as size_t;
                (*r).resp_body_scratchpad = 0 as libc::c_int as off_t;
            }
        }
    } else if 0 as libc::c_int as libc::c_long == (*r).resp_body_scratchpad {
        return 0 as libc::c_int;
    }
    return http_chunk_append_mem(r, mem, len);
}
#[no_mangle]
pub unsafe extern "C" fn http_response_transfer_cqlen(
    r: *mut request_st,
    cq: *mut chunkqueue,
    mut len: size_t,
) -> libc::c_int {
    if 0 as libc::c_int as libc::c_ulong == len {
        return 0 as libc::c_int;
    }
    if ((*r).resp_decode_chunked == 0) as libc::c_int as libc::c_long != 0 {
        let olen: size_t = len;
        if (*r).resp_body_scratchpad >= 0 as libc::c_int as libc::c_long {
            (*r).resp_body_scratchpad -= len as off_t;
            if ((*r).resp_body_scratchpad < 0 as libc::c_int as libc::c_long) as libc::c_int
                as libc::c_long
                != 0
            {
                len = ((*r).resp_body_scratchpad + len as off_t) as size_t;
                (*r).resp_body_scratchpad = 0 as libc::c_int as off_t;
            }
        }
        let mut rc: libc::c_int = http_chunk_transfer_cqlen(r, cq, len);
        if (0 as libc::c_int != rc) as libc::c_int as libc::c_long != 0 {
            return -(1 as libc::c_int);
        }
        if (olen != len) as libc::c_int as libc::c_long != 0 {
            chunkqueue_mark_written(cq, olen.wrapping_sub(len) as off_t);
        }
    } else {
        let mut remain: uint32_t = len as uint32_t;
        let mut wr: uint32_t = 0;
        let mut c: *const chunk = (*cq).first;
        while !c.is_null() && remain != 0 {
            wr = (buffer_clen((*c).mem) as libc::c_long - (*c).offset) as uint32_t;
            if wr > remain {
                wr = remain;
            }
            if 0 as libc::c_int
                != http_chunk_decode_append_mem(
                    r,
                    ((*(*c).mem).ptr).offset((*c).offset as isize),
                    wr as size_t,
                )
            {
                return -(1 as libc::c_int);
            }
            c = (*c).next;
            remain = (remain as libc::c_uint).wrapping_sub(wr) as uint32_t as uint32_t;
        }
        chunkqueue_mark_written(cq, len as off_t);
    }
    return 0 as libc::c_int;
}
unsafe extern "C" fn http_response_process_headers(
    r: *mut request_st,
    opts: *mut http_response_opts,
    s: *mut libc::c_char,
    mut hoff: *const libc::c_ushort,
    is_nph: libc::c_int,
) -> libc::c_int {
    let mut i: libc::c_int = 1 as libc::c_int;
    if is_nph != 0 {
        if *s.offset(12 as libc::c_int as isize) as libc::c_int == '\r' as i32
            || *s.offset(12 as libc::c_int as isize) as libc::c_int == '\n' as i32
        {
            *s.offset(12 as libc::c_int as isize) = '\0' as i32 as libc::c_char;
        }
        if (*s.offset(5 as libc::c_int as isize) as libc::c_int == '1' as i32
            || (*opts).backend != BACKEND_PROXY as libc::c_int)
            && *s.offset(6 as libc::c_int as isize) as libc::c_int == '.' as i32
            && (*s.offset(7 as libc::c_int as isize) as libc::c_int == '1' as i32
                || *s.offset(7 as libc::c_int as isize) as libc::c_int == '0' as i32)
            && *s.offset(8 as libc::c_int as isize) as libc::c_int == ' ' as i32
        {
            let mut status: libc::c_int =
                http_header_str_to_code(s.offset(9 as libc::c_int as isize));
            if status >= 100 as libc::c_int && status < 1000 as libc::c_int {
                (*r).http_status = status;
                (*opts).local_redir = 0 as libc::c_int as uint8_t;
                i = 2 as libc::c_int;
            }
        }
        if 0 as libc::c_int == (*r).http_status {
            log_error(
                (*r).conf.errh,
                b"/home/kkysen/work/rust/lighttpd/src/http-header-glue.c\0" as *const u8
                    as *const libc::c_char,
                874 as libc::c_int as libc::c_uint,
                b"invalid HTTP status line: %s\0" as *const u8 as *const libc::c_char,
                s,
            );
            (*r).http_status = 502 as libc::c_int;
            (*r).handler_module = 0 as *const plugin;
            return 0 as libc::c_int;
        }
    } else if ((*opts).backend == BACKEND_PROXY as libc::c_int) as libc::c_int as libc::c_long != 0
    {
        (*r).http_status = 502 as libc::c_int;
        (*r).handler_module = 0 as *const plugin;
        return 0 as libc::c_int;
    }
    let mut current_block_64: u64;
    while i < *hoff.offset(0 as libc::c_int as isize) as libc::c_int {
        let mut k: *const libc::c_char = s.offset(*hoff.offset(i as isize) as libc::c_int as isize);
        let mut value: *const libc::c_char = 0 as *const libc::c_char;
        let mut end: *mut libc::c_char = s
            .offset(*hoff.offset((i + 1 as libc::c_int) as isize) as libc::c_int as isize)
            .offset(-(1 as libc::c_int as isize));
        value = memchr(
            k as *const libc::c_void,
            ':' as i32,
            end.offset_from(k) as libc::c_long as libc::c_ulong,
        ) as *const libc::c_char;
        if !value.is_null() {
            let klen: uint32_t = value.offset_from(k) as libc::c_long as uint32_t;
            if !(0 as libc::c_int as libc::c_uint == klen) {
                let id: http_header_e = http_header_hkey_get(k, klen as size_t);
                loop {
                    value = value.offset(1);
                    if !(*value as libc::c_int == ' ' as i32
                        || *value as libc::c_int == '\t' as i32)
                    {
                        break;
                    }
                }
                if end > value as *mut libc::c_char
                    && *end.offset(-(1 as libc::c_int) as isize) as libc::c_int == '\r' as i32
                {
                    end = end.offset(-1);
                }
                if (*opts).authorizer != 0
                    && (0 as libc::c_int == (*r).http_status
                        || 200 as libc::c_int == (*r).http_status)
                {
                    if id as libc::c_uint == HTTP_HEADER_STATUS as libc::c_int as libc::c_uint {
                        *end.offset(0 as libc::c_int as isize) = '\0' as i32 as libc::c_char;
                        let mut status_0: libc::c_int = http_header_str_to_code(value);
                        if status_0 >= 100 as libc::c_int && status_0 < 1000 as libc::c_int {
                            (*r).http_status = status_0;
                            (*opts).local_redir = 0 as libc::c_int as uint8_t;
                        } else {
                            (*r).http_status = 502 as libc::c_int;
                            break;
                        }
                    } else if id as libc::c_uint == HTTP_HEADER_OTHER as libc::c_int as libc::c_uint
                        && klen > 9 as libc::c_int as libc::c_uint
                        && *k.offset(0 as libc::c_int as isize) as libc::c_int & 0xdf as libc::c_int
                            == 'V' as i32
                        && buffer_eq_icase_ssn(
                            k,
                            b"Variable-\0" as *const u8 as *const libc::c_char,
                            (::core::mem::size_of::<[libc::c_char; 10]>() as libc::c_ulong
                                as uint32_t)
                                .wrapping_sub(1 as libc::c_int as libc::c_uint)
                                as size_t,
                        ) != 0
                    {
                        http_header_env_append(
                            r,
                            k.offset(9 as libc::c_int as isize),
                            klen.wrapping_sub(9 as libc::c_int as libc::c_uint),
                            value,
                            end.offset_from(value) as libc::c_long as uint32_t,
                        );
                    }
                } else {
                    match id as libc::c_uint {
                        45 => {
                            current_block_64 = 208407439755130729;
                            match current_block_64 {
                                13346926342236971390 => {
                                    if *value as libc::c_int == '+' as i32 {
                                        value = value.offset(1);
                                    }
                                    if (*r).resp_decode_chunked == 0
                                        && (*r).resp_htags
                                            & (1 as libc::c_ulong)
                                                << HTTP_HEADER_CONTENT_LENGTH as libc::c_int
                                            == 0
                                    {
                                        let mut err: *const libc::c_char = end;
                                        while err > value
                                            && (*err.offset(-(1 as libc::c_int) as isize)
                                                as libc::c_int
                                                == ' ' as i32
                                                || *err.offset(-(1 as libc::c_int) as isize)
                                                    as libc::c_int
                                                    == '\t' as i32)
                                        {
                                            err = err.offset(-1);
                                        }
                                        if err <= value {
                                            current_block_64 = 15652330335145281839;
                                        } else {
                                            let mut vlen: uint32_t =
                                                err.offset_from(value) as libc::c_long as uint32_t;
                                            (*r).resp_body_scratchpad =
                                                li_restricted_strtoint64(value, vlen, &mut err);
                                            if err != value.offset(vlen as isize) {
                                                (*r).resp_body_scratchpad =
                                                    -(1 as libc::c_int) as off_t;
                                            }
                                            current_block_64 = 919954187481050311;
                                        }
                                    } else {
                                        current_block_64 = 15652330335145281839;
                                    }
                                }
                                12682439727101678803 => {
                                    if (*opts).backend == BACKEND_PROXY as libc::c_int {
                                        current_block_64 = 15652330335145281839;
                                    } else {
                                        if http_header_str_contains_token(
                                            value,
                                            end.offset_from(value) as libc::c_long as uint32_t,
                                            b"close\0" as *const u8 as *const libc::c_char,
                                            (::core::mem::size_of::<[libc::c_char; 6]>()
                                                as libc::c_ulong
                                                as uint32_t)
                                                .wrapping_sub(1 as libc::c_int as libc::c_uint),
                                        ) != 0
                                        {
                                            (*r).keep_alive = 0 as libc::c_int as int8_t;
                                        }
                                        if (*r).http_version as libc::c_int
                                            >= HTTP_VERSION_2 as libc::c_int
                                        {
                                            current_block_64 = 15652330335145281839;
                                        } else {
                                            current_block_64 = 919954187481050311;
                                        }
                                    }
                                }
                                16015584448552882337 => {
                                    if (*opts).backend != BACKEND_PROXY as libc::c_int
                                        && (*opts).backend != BACKEND_CGI as libc::c_int
                                    {
                                        current_block_64 = 15652330335145281839;
                                    } else if (*r).http_version as libc::c_int
                                        >= HTTP_VERSION_2 as libc::c_int
                                    {
                                        current_block_64 = 15652330335145281839;
                                    } else {
                                        current_block_64 = 919954187481050311;
                                    }
                                }
                                208407439755130729 => {
                                    if (*opts).backend != BACKEND_PROXY as libc::c_int {
                                        *end.offset(0 as libc::c_int as isize) =
                                            '\0' as i32 as libc::c_char;
                                        let mut status_1: libc::c_int =
                                            http_header_str_to_code(value);
                                        if status_1 >= 100 as libc::c_int
                                            && status_1 < 1000 as libc::c_int
                                        {
                                            (*r).http_status = status_1;
                                            (*opts).local_redir = 0 as libc::c_int as uint8_t;
                                        } else {
                                            (*r).http_status = 502 as libc::c_int;
                                            (*r).handler_module = 0 as *const plugin;
                                        }
                                        current_block_64 = 15652330335145281839;
                                    } else {
                                        current_block_64 = 919954187481050311;
                                    }
                                }
                                8961468526249777663 => {
                                    if (*r).resp_htags
                                        & (1 as libc::c_ulong)
                                            << HTTP_HEADER_CONTENT_LENGTH as libc::c_int
                                        != 0
                                    {
                                        (*r).resp_body_scratchpad = -(1 as libc::c_int) as off_t;
                                        http_header_response_unset(
                                            r,
                                            HTTP_HEADER_CONTENT_LENGTH,
                                            b"Content-Length\0" as *const u8 as *const libc::c_char,
                                            (::core::mem::size_of::<[libc::c_char; 15]>()
                                                as libc::c_ulong
                                                as uint32_t)
                                                .wrapping_sub(1 as libc::c_int as libc::c_uint),
                                        );
                                    }
                                    (*r).resp_decode_chunked = 1 as libc::c_int as libc::c_char;
                                    (*r).gw_dechunk = calloc(
                                        1 as libc::c_int as libc::c_ulong,
                                        ::core::mem::size_of::<response_dechunk>() as libc::c_ulong,
                                    )
                                        as *mut response_dechunk;
                                    if ((*r).gw_dechunk).is_null() {
                                        ck_assert_failed(
                                            b"/home/kkysen/work/rust/lighttpd/src/http-header-glue.c\0"
                                                as *const u8 as *const libc::c_char,
                                            999 as libc::c_int as libc::c_uint,
                                            b"r->gw_dechunk\0" as *const u8 as *const libc::c_char,
                                        );
                                    }
                                    current_block_64 = 15652330335145281839;
                                }
                                4056835913730949961 => {
                                    if *k
                                        .offset(klen.wrapping_sub(1 as libc::c_int as libc::c_uint)
                                            as isize)
                                        as libc::c_int
                                        == ' ' as i32
                                        || *k.offset(
                                            klen.wrapping_sub(1 as libc::c_int as libc::c_uint)
                                                as isize,
                                        ) as libc::c_int
                                            == '\t' as i32
                                    {
                                        current_block_64 = 15652330335145281839;
                                    } else {
                                        current_block_64 = 919954187481050311;
                                    }
                                }
                                _ => {}
                            }
                            match current_block_64 {
                                15652330335145281839 => {}
                                _ => {
                                    if end.offset_from(value) as libc::c_long != 0 {
                                        http_header_response_insert(
                                            r,
                                            id,
                                            k,
                                            klen,
                                            value,
                                            end.offset_from(value) as libc::c_long as uint32_t,
                                        );
                                    }
                                }
                            }
                        }
                        49 => {
                            current_block_64 = 16015584448552882337;
                            match current_block_64 {
                                13346926342236971390 => {
                                    if *value as libc::c_int == '+' as i32 {
                                        value = value.offset(1);
                                    }
                                    if (*r).resp_decode_chunked == 0
                                        && (*r).resp_htags
                                            & (1 as libc::c_ulong)
                                                << HTTP_HEADER_CONTENT_LENGTH as libc::c_int
                                            == 0
                                    {
                                        let mut err: *const libc::c_char = end;
                                        while err > value
                                            && (*err.offset(-(1 as libc::c_int) as isize)
                                                as libc::c_int
                                                == ' ' as i32
                                                || *err.offset(-(1 as libc::c_int) as isize)
                                                    as libc::c_int
                                                    == '\t' as i32)
                                        {
                                            err = err.offset(-1);
                                        }
                                        if err <= value {
                                            current_block_64 = 15652330335145281839;
                                        } else {
                                            let mut vlen: uint32_t =
                                                err.offset_from(value) as libc::c_long as uint32_t;
                                            (*r).resp_body_scratchpad =
                                                li_restricted_strtoint64(value, vlen, &mut err);
                                            if err != value.offset(vlen as isize) {
                                                (*r).resp_body_scratchpad =
                                                    -(1 as libc::c_int) as off_t;
                                            }
                                            current_block_64 = 919954187481050311;
                                        }
                                    } else {
                                        current_block_64 = 15652330335145281839;
                                    }
                                }
                                12682439727101678803 => {
                                    if (*opts).backend == BACKEND_PROXY as libc::c_int {
                                        current_block_64 = 15652330335145281839;
                                    } else {
                                        if http_header_str_contains_token(
                                            value,
                                            end.offset_from(value) as libc::c_long as uint32_t,
                                            b"close\0" as *const u8 as *const libc::c_char,
                                            (::core::mem::size_of::<[libc::c_char; 6]>()
                                                as libc::c_ulong
                                                as uint32_t)
                                                .wrapping_sub(1 as libc::c_int as libc::c_uint),
                                        ) != 0
                                        {
                                            (*r).keep_alive = 0 as libc::c_int as int8_t;
                                        }
                                        if (*r).http_version as libc::c_int
                                            >= HTTP_VERSION_2 as libc::c_int
                                        {
                                            current_block_64 = 15652330335145281839;
                                        } else {
                                            current_block_64 = 919954187481050311;
                                        }
                                    }
                                }
                                16015584448552882337 => {
                                    if (*opts).backend != BACKEND_PROXY as libc::c_int
                                        && (*opts).backend != BACKEND_CGI as libc::c_int
                                    {
                                        current_block_64 = 15652330335145281839;
                                    } else if (*r).http_version as libc::c_int
                                        >= HTTP_VERSION_2 as libc::c_int
                                    {
                                        current_block_64 = 15652330335145281839;
                                    } else {
                                        current_block_64 = 919954187481050311;
                                    }
                                }
                                208407439755130729 => {
                                    if (*opts).backend != BACKEND_PROXY as libc::c_int {
                                        *end.offset(0 as libc::c_int as isize) =
                                            '\0' as i32 as libc::c_char;
                                        let mut status_1: libc::c_int =
                                            http_header_str_to_code(value);
                                        if status_1 >= 100 as libc::c_int
                                            && status_1 < 1000 as libc::c_int
                                        {
                                            (*r).http_status = status_1;
                                            (*opts).local_redir = 0 as libc::c_int as uint8_t;
                                        } else {
                                            (*r).http_status = 502 as libc::c_int;
                                            (*r).handler_module = 0 as *const plugin;
                                        }
                                        current_block_64 = 15652330335145281839;
                                    } else {
                                        current_block_64 = 919954187481050311;
                                    }
                                }
                                8961468526249777663 => {
                                    if (*r).resp_htags
                                        & (1 as libc::c_ulong)
                                            << HTTP_HEADER_CONTENT_LENGTH as libc::c_int
                                        != 0
                                    {
                                        (*r).resp_body_scratchpad = -(1 as libc::c_int) as off_t;
                                        http_header_response_unset(
                                            r,
                                            HTTP_HEADER_CONTENT_LENGTH,
                                            b"Content-Length\0" as *const u8 as *const libc::c_char,
                                            (::core::mem::size_of::<[libc::c_char; 15]>()
                                                as libc::c_ulong
                                                as uint32_t)
                                                .wrapping_sub(1 as libc::c_int as libc::c_uint),
                                        );
                                    }
                                    (*r).resp_decode_chunked = 1 as libc::c_int as libc::c_char;
                                    (*r).gw_dechunk = calloc(
                                        1 as libc::c_int as libc::c_ulong,
                                        ::core::mem::size_of::<response_dechunk>() as libc::c_ulong,
                                    )
                                        as *mut response_dechunk;
                                    if ((*r).gw_dechunk).is_null() {
                                        ck_assert_failed(
                                            b"/home/kkysen/work/rust/lighttpd/src/http-header-glue.c\0"
                                                as *const u8 as *const libc::c_char,
                                            999 as libc::c_int as libc::c_uint,
                                            b"r->gw_dechunk\0" as *const u8 as *const libc::c_char,
                                        );
                                    }
                                    current_block_64 = 15652330335145281839;
                                }
                                4056835913730949961 => {
                                    if *k
                                        .offset(klen.wrapping_sub(1 as libc::c_int as libc::c_uint)
                                            as isize)
                                        as libc::c_int
                                        == ' ' as i32
                                        || *k.offset(
                                            klen.wrapping_sub(1 as libc::c_int as libc::c_uint)
                                                as isize,
                                        ) as libc::c_int
                                            == '\t' as i32
                                    {
                                        current_block_64 = 15652330335145281839;
                                    } else {
                                        current_block_64 = 919954187481050311;
                                    }
                                }
                                _ => {}
                            }
                            match current_block_64 {
                                15652330335145281839 => {}
                                _ => {
                                    if end.offset_from(value) as libc::c_long != 0 {
                                        http_header_response_insert(
                                            r,
                                            id,
                                            k,
                                            klen,
                                            value,
                                            end.offset_from(value) as libc::c_long as uint32_t,
                                        );
                                    }
                                }
                            }
                        }
                        12 => {
                            current_block_64 = 12682439727101678803;
                            match current_block_64 {
                                13346926342236971390 => {
                                    if *value as libc::c_int == '+' as i32 {
                                        value = value.offset(1);
                                    }
                                    if (*r).resp_decode_chunked == 0
                                        && (*r).resp_htags
                                            & (1 as libc::c_ulong)
                                                << HTTP_HEADER_CONTENT_LENGTH as libc::c_int
                                            == 0
                                    {
                                        let mut err: *const libc::c_char = end;
                                        while err > value
                                            && (*err.offset(-(1 as libc::c_int) as isize)
                                                as libc::c_int
                                                == ' ' as i32
                                                || *err.offset(-(1 as libc::c_int) as isize)
                                                    as libc::c_int
                                                    == '\t' as i32)
                                        {
                                            err = err.offset(-1);
                                        }
                                        if err <= value {
                                            current_block_64 = 15652330335145281839;
                                        } else {
                                            let mut vlen: uint32_t =
                                                err.offset_from(value) as libc::c_long as uint32_t;
                                            (*r).resp_body_scratchpad =
                                                li_restricted_strtoint64(value, vlen, &mut err);
                                            if err != value.offset(vlen as isize) {
                                                (*r).resp_body_scratchpad =
                                                    -(1 as libc::c_int) as off_t;
                                            }
                                            current_block_64 = 919954187481050311;
                                        }
                                    } else {
                                        current_block_64 = 15652330335145281839;
                                    }
                                }
                                12682439727101678803 => {
                                    if (*opts).backend == BACKEND_PROXY as libc::c_int {
                                        current_block_64 = 15652330335145281839;
                                    } else {
                                        if http_header_str_contains_token(
                                            value,
                                            end.offset_from(value) as libc::c_long as uint32_t,
                                            b"close\0" as *const u8 as *const libc::c_char,
                                            (::core::mem::size_of::<[libc::c_char; 6]>()
                                                as libc::c_ulong
                                                as uint32_t)
                                                .wrapping_sub(1 as libc::c_int as libc::c_uint),
                                        ) != 0
                                        {
                                            (*r).keep_alive = 0 as libc::c_int as int8_t;
                                        }
                                        if (*r).http_version as libc::c_int
                                            >= HTTP_VERSION_2 as libc::c_int
                                        {
                                            current_block_64 = 15652330335145281839;
                                        } else {
                                            current_block_64 = 919954187481050311;
                                        }
                                    }
                                }
                                16015584448552882337 => {
                                    if (*opts).backend != BACKEND_PROXY as libc::c_int
                                        && (*opts).backend != BACKEND_CGI as libc::c_int
                                    {
                                        current_block_64 = 15652330335145281839;
                                    } else if (*r).http_version as libc::c_int
                                        >= HTTP_VERSION_2 as libc::c_int
                                    {
                                        current_block_64 = 15652330335145281839;
                                    } else {
                                        current_block_64 = 919954187481050311;
                                    }
                                }
                                208407439755130729 => {
                                    if (*opts).backend != BACKEND_PROXY as libc::c_int {
                                        *end.offset(0 as libc::c_int as isize) =
                                            '\0' as i32 as libc::c_char;
                                        let mut status_1: libc::c_int =
                                            http_header_str_to_code(value);
                                        if status_1 >= 100 as libc::c_int
                                            && status_1 < 1000 as libc::c_int
                                        {
                                            (*r).http_status = status_1;
                                            (*opts).local_redir = 0 as libc::c_int as uint8_t;
                                        } else {
                                            (*r).http_status = 502 as libc::c_int;
                                            (*r).handler_module = 0 as *const plugin;
                                        }
                                        current_block_64 = 15652330335145281839;
                                    } else {
                                        current_block_64 = 919954187481050311;
                                    }
                                }
                                8961468526249777663 => {
                                    if (*r).resp_htags
                                        & (1 as libc::c_ulong)
                                            << HTTP_HEADER_CONTENT_LENGTH as libc::c_int
                                        != 0
                                    {
                                        (*r).resp_body_scratchpad = -(1 as libc::c_int) as off_t;
                                        http_header_response_unset(
                                            r,
                                            HTTP_HEADER_CONTENT_LENGTH,
                                            b"Content-Length\0" as *const u8 as *const libc::c_char,
                                            (::core::mem::size_of::<[libc::c_char; 15]>()
                                                as libc::c_ulong
                                                as uint32_t)
                                                .wrapping_sub(1 as libc::c_int as libc::c_uint),
                                        );
                                    }
                                    (*r).resp_decode_chunked = 1 as libc::c_int as libc::c_char;
                                    (*r).gw_dechunk = calloc(
                                        1 as libc::c_int as libc::c_ulong,
                                        ::core::mem::size_of::<response_dechunk>() as libc::c_ulong,
                                    )
                                        as *mut response_dechunk;
                                    if ((*r).gw_dechunk).is_null() {
                                        ck_assert_failed(
                                            b"/home/kkysen/work/rust/lighttpd/src/http-header-glue.c\0"
                                                as *const u8 as *const libc::c_char,
                                            999 as libc::c_int as libc::c_uint,
                                            b"r->gw_dechunk\0" as *const u8 as *const libc::c_char,
                                        );
                                    }
                                    current_block_64 = 15652330335145281839;
                                }
                                4056835913730949961 => {
                                    if *k
                                        .offset(klen.wrapping_sub(1 as libc::c_int as libc::c_uint)
                                            as isize)
                                        as libc::c_int
                                        == ' ' as i32
                                        || *k.offset(
                                            klen.wrapping_sub(1 as libc::c_int as libc::c_uint)
                                                as isize,
                                        ) as libc::c_int
                                            == '\t' as i32
                                    {
                                        current_block_64 = 15652330335145281839;
                                    } else {
                                        current_block_64 = 919954187481050311;
                                    }
                                }
                                _ => {}
                            }
                            match current_block_64 {
                                15652330335145281839 => {}
                                _ => {
                                    if end.offset_from(value) as libc::c_long != 0 {
                                        http_header_response_insert(
                                            r,
                                            id,
                                            k,
                                            klen,
                                            value,
                                            end.offset_from(value) as libc::c_long as uint32_t,
                                        );
                                    }
                                }
                            }
                        }
                        14 => {
                            current_block_64 = 13346926342236971390;
                            match current_block_64 {
                                13346926342236971390 => {
                                    if *value as libc::c_int == '+' as i32 {
                                        value = value.offset(1);
                                    }
                                    if (*r).resp_decode_chunked == 0
                                        && (*r).resp_htags
                                            & (1 as libc::c_ulong)
                                                << HTTP_HEADER_CONTENT_LENGTH as libc::c_int
                                            == 0
                                    {
                                        let mut err: *const libc::c_char = end;
                                        while err > value
                                            && (*err.offset(-(1 as libc::c_int) as isize)
                                                as libc::c_int
                                                == ' ' as i32
                                                || *err.offset(-(1 as libc::c_int) as isize)
                                                    as libc::c_int
                                                    == '\t' as i32)
                                        {
                                            err = err.offset(-1);
                                        }
                                        if err <= value {
                                            current_block_64 = 15652330335145281839;
                                        } else {
                                            let mut vlen: uint32_t =
                                                err.offset_from(value) as libc::c_long as uint32_t;
                                            (*r).resp_body_scratchpad =
                                                li_restricted_strtoint64(value, vlen, &mut err);
                                            if err != value.offset(vlen as isize) {
                                                (*r).resp_body_scratchpad =
                                                    -(1 as libc::c_int) as off_t;
                                            }
                                            current_block_64 = 919954187481050311;
                                        }
                                    } else {
                                        current_block_64 = 15652330335145281839;
                                    }
                                }
                                12682439727101678803 => {
                                    if (*opts).backend == BACKEND_PROXY as libc::c_int {
                                        current_block_64 = 15652330335145281839;
                                    } else {
                                        if http_header_str_contains_token(
                                            value,
                                            end.offset_from(value) as libc::c_long as uint32_t,
                                            b"close\0" as *const u8 as *const libc::c_char,
                                            (::core::mem::size_of::<[libc::c_char; 6]>()
                                                as libc::c_ulong
                                                as uint32_t)
                                                .wrapping_sub(1 as libc::c_int as libc::c_uint),
                                        ) != 0
                                        {
                                            (*r).keep_alive = 0 as libc::c_int as int8_t;
                                        }
                                        if (*r).http_version as libc::c_int
                                            >= HTTP_VERSION_2 as libc::c_int
                                        {
                                            current_block_64 = 15652330335145281839;
                                        } else {
                                            current_block_64 = 919954187481050311;
                                        }
                                    }
                                }
                                16015584448552882337 => {
                                    if (*opts).backend != BACKEND_PROXY as libc::c_int
                                        && (*opts).backend != BACKEND_CGI as libc::c_int
                                    {
                                        current_block_64 = 15652330335145281839;
                                    } else if (*r).http_version as libc::c_int
                                        >= HTTP_VERSION_2 as libc::c_int
                                    {
                                        current_block_64 = 15652330335145281839;
                                    } else {
                                        current_block_64 = 919954187481050311;
                                    }
                                }
                                208407439755130729 => {
                                    if (*opts).backend != BACKEND_PROXY as libc::c_int {
                                        *end.offset(0 as libc::c_int as isize) =
                                            '\0' as i32 as libc::c_char;
                                        let mut status_1: libc::c_int =
                                            http_header_str_to_code(value);
                                        if status_1 >= 100 as libc::c_int
                                            && status_1 < 1000 as libc::c_int
                                        {
                                            (*r).http_status = status_1;
                                            (*opts).local_redir = 0 as libc::c_int as uint8_t;
                                        } else {
                                            (*r).http_status = 502 as libc::c_int;
                                            (*r).handler_module = 0 as *const plugin;
                                        }
                                        current_block_64 = 15652330335145281839;
                                    } else {
                                        current_block_64 = 919954187481050311;
                                    }
                                }
                                8961468526249777663 => {
                                    if (*r).resp_htags
                                        & (1 as libc::c_ulong)
                                            << HTTP_HEADER_CONTENT_LENGTH as libc::c_int
                                        != 0
                                    {
                                        (*r).resp_body_scratchpad = -(1 as libc::c_int) as off_t;
                                        http_header_response_unset(
                                            r,
                                            HTTP_HEADER_CONTENT_LENGTH,
                                            b"Content-Length\0" as *const u8 as *const libc::c_char,
                                            (::core::mem::size_of::<[libc::c_char; 15]>()
                                                as libc::c_ulong
                                                as uint32_t)
                                                .wrapping_sub(1 as libc::c_int as libc::c_uint),
                                        );
                                    }
                                    (*r).resp_decode_chunked = 1 as libc::c_int as libc::c_char;
                                    (*r).gw_dechunk = calloc(
                                        1 as libc::c_int as libc::c_ulong,
                                        ::core::mem::size_of::<response_dechunk>() as libc::c_ulong,
                                    )
                                        as *mut response_dechunk;
                                    if ((*r).gw_dechunk).is_null() {
                                        ck_assert_failed(
                                            b"/home/kkysen/work/rust/lighttpd/src/http-header-glue.c\0"
                                                as *const u8 as *const libc::c_char,
                                            999 as libc::c_int as libc::c_uint,
                                            b"r->gw_dechunk\0" as *const u8 as *const libc::c_char,
                                        );
                                    }
                                    current_block_64 = 15652330335145281839;
                                }
                                4056835913730949961 => {
                                    if *k
                                        .offset(klen.wrapping_sub(1 as libc::c_int as libc::c_uint)
                                            as isize)
                                        as libc::c_int
                                        == ' ' as i32
                                        || *k.offset(
                                            klen.wrapping_sub(1 as libc::c_int as libc::c_uint)
                                                as isize,
                                        ) as libc::c_int
                                            == '\t' as i32
                                    {
                                        current_block_64 = 15652330335145281839;
                                    } else {
                                        current_block_64 = 919954187481050311;
                                    }
                                }
                                _ => {}
                            }
                            match current_block_64 {
                                15652330335145281839 => {}
                                _ => {
                                    if end.offset_from(value) as libc::c_long != 0 {
                                        http_header_response_insert(
                                            r,
                                            id,
                                            k,
                                            klen,
                                            value,
                                            end.offset_from(value) as libc::c_long as uint32_t,
                                        );
                                    }
                                }
                            }
                        }
                        48 => {
                            current_block_64 = 8961468526249777663;
                            match current_block_64 {
                                13346926342236971390 => {
                                    if *value as libc::c_int == '+' as i32 {
                                        value = value.offset(1);
                                    }
                                    if (*r).resp_decode_chunked == 0
                                        && (*r).resp_htags
                                            & (1 as libc::c_ulong)
                                                << HTTP_HEADER_CONTENT_LENGTH as libc::c_int
                                            == 0
                                    {
                                        let mut err: *const libc::c_char = end;
                                        while err > value
                                            && (*err.offset(-(1 as libc::c_int) as isize)
                                                as libc::c_int
                                                == ' ' as i32
                                                || *err.offset(-(1 as libc::c_int) as isize)
                                                    as libc::c_int
                                                    == '\t' as i32)
                                        {
                                            err = err.offset(-1);
                                        }
                                        if err <= value {
                                            current_block_64 = 15652330335145281839;
                                        } else {
                                            let mut vlen: uint32_t =
                                                err.offset_from(value) as libc::c_long as uint32_t;
                                            (*r).resp_body_scratchpad =
                                                li_restricted_strtoint64(value, vlen, &mut err);
                                            if err != value.offset(vlen as isize) {
                                                (*r).resp_body_scratchpad =
                                                    -(1 as libc::c_int) as off_t;
                                            }
                                            current_block_64 = 919954187481050311;
                                        }
                                    } else {
                                        current_block_64 = 15652330335145281839;
                                    }
                                }
                                12682439727101678803 => {
                                    if (*opts).backend == BACKEND_PROXY as libc::c_int {
                                        current_block_64 = 15652330335145281839;
                                    } else {
                                        if http_header_str_contains_token(
                                            value,
                                            end.offset_from(value) as libc::c_long as uint32_t,
                                            b"close\0" as *const u8 as *const libc::c_char,
                                            (::core::mem::size_of::<[libc::c_char; 6]>()
                                                as libc::c_ulong
                                                as uint32_t)
                                                .wrapping_sub(1 as libc::c_int as libc::c_uint),
                                        ) != 0
                                        {
                                            (*r).keep_alive = 0 as libc::c_int as int8_t;
                                        }
                                        if (*r).http_version as libc::c_int
                                            >= HTTP_VERSION_2 as libc::c_int
                                        {
                                            current_block_64 = 15652330335145281839;
                                        } else {
                                            current_block_64 = 919954187481050311;
                                        }
                                    }
                                }
                                16015584448552882337 => {
                                    if (*opts).backend != BACKEND_PROXY as libc::c_int
                                        && (*opts).backend != BACKEND_CGI as libc::c_int
                                    {
                                        current_block_64 = 15652330335145281839;
                                    } else if (*r).http_version as libc::c_int
                                        >= HTTP_VERSION_2 as libc::c_int
                                    {
                                        current_block_64 = 15652330335145281839;
                                    } else {
                                        current_block_64 = 919954187481050311;
                                    }
                                }
                                208407439755130729 => {
                                    if (*opts).backend != BACKEND_PROXY as libc::c_int {
                                        *end.offset(0 as libc::c_int as isize) =
                                            '\0' as i32 as libc::c_char;
                                        let mut status_1: libc::c_int =
                                            http_header_str_to_code(value);
                                        if status_1 >= 100 as libc::c_int
                                            && status_1 < 1000 as libc::c_int
                                        {
                                            (*r).http_status = status_1;
                                            (*opts).local_redir = 0 as libc::c_int as uint8_t;
                                        } else {
                                            (*r).http_status = 502 as libc::c_int;
                                            (*r).handler_module = 0 as *const plugin;
                                        }
                                        current_block_64 = 15652330335145281839;
                                    } else {
                                        current_block_64 = 919954187481050311;
                                    }
                                }
                                8961468526249777663 => {
                                    if (*r).resp_htags
                                        & (1 as libc::c_ulong)
                                            << HTTP_HEADER_CONTENT_LENGTH as libc::c_int
                                        != 0
                                    {
                                        (*r).resp_body_scratchpad = -(1 as libc::c_int) as off_t;
                                        http_header_response_unset(
                                            r,
                                            HTTP_HEADER_CONTENT_LENGTH,
                                            b"Content-Length\0" as *const u8 as *const libc::c_char,
                                            (::core::mem::size_of::<[libc::c_char; 15]>()
                                                as libc::c_ulong
                                                as uint32_t)
                                                .wrapping_sub(1 as libc::c_int as libc::c_uint),
                                        );
                                    }
                                    (*r).resp_decode_chunked = 1 as libc::c_int as libc::c_char;
                                    (*r).gw_dechunk = calloc(
                                        1 as libc::c_int as libc::c_ulong,
                                        ::core::mem::size_of::<response_dechunk>() as libc::c_ulong,
                                    )
                                        as *mut response_dechunk;
                                    if ((*r).gw_dechunk).is_null() {
                                        ck_assert_failed(
                                            b"/home/kkysen/work/rust/lighttpd/src/http-header-glue.c\0"
                                                as *const u8 as *const libc::c_char,
                                            999 as libc::c_int as libc::c_uint,
                                            b"r->gw_dechunk\0" as *const u8 as *const libc::c_char,
                                        );
                                    }
                                    current_block_64 = 15652330335145281839;
                                }
                                4056835913730949961 => {
                                    if *k
                                        .offset(klen.wrapping_sub(1 as libc::c_int as libc::c_uint)
                                            as isize)
                                        as libc::c_int
                                        == ' ' as i32
                                        || *k.offset(
                                            klen.wrapping_sub(1 as libc::c_int as libc::c_uint)
                                                as isize,
                                        ) as libc::c_int
                                            == '\t' as i32
                                    {
                                        current_block_64 = 15652330335145281839;
                                    } else {
                                        current_block_64 = 919954187481050311;
                                    }
                                }
                                _ => {}
                            }
                            match current_block_64 {
                                15652330335145281839 => {}
                                _ => {
                                    if end.offset_from(value) as libc::c_long != 0 {
                                        http_header_response_insert(
                                            r,
                                            id,
                                            k,
                                            klen,
                                            value,
                                            end.offset_from(value) as libc::c_long as uint32_t,
                                        );
                                    }
                                }
                            }
                        }
                        28 => {}
                        0 => {
                            current_block_64 = 4056835913730949961;
                            match current_block_64 {
                                13346926342236971390 => {
                                    if *value as libc::c_int == '+' as i32 {
                                        value = value.offset(1);
                                    }
                                    if (*r).resp_decode_chunked == 0
                                        && (*r).resp_htags
                                            & (1 as libc::c_ulong)
                                                << HTTP_HEADER_CONTENT_LENGTH as libc::c_int
                                            == 0
                                    {
                                        let mut err: *const libc::c_char = end;
                                        while err > value
                                            && (*err.offset(-(1 as libc::c_int) as isize)
                                                as libc::c_int
                                                == ' ' as i32
                                                || *err.offset(-(1 as libc::c_int) as isize)
                                                    as libc::c_int
                                                    == '\t' as i32)
                                        {
                                            err = err.offset(-1);
                                        }
                                        if err <= value {
                                            current_block_64 = 15652330335145281839;
                                        } else {
                                            let mut vlen: uint32_t =
                                                err.offset_from(value) as libc::c_long as uint32_t;
                                            (*r).resp_body_scratchpad =
                                                li_restricted_strtoint64(value, vlen, &mut err);
                                            if err != value.offset(vlen as isize) {
                                                (*r).resp_body_scratchpad =
                                                    -(1 as libc::c_int) as off_t;
                                            }
                                            current_block_64 = 919954187481050311;
                                        }
                                    } else {
                                        current_block_64 = 15652330335145281839;
                                    }
                                }
                                12682439727101678803 => {
                                    if (*opts).backend == BACKEND_PROXY as libc::c_int {
                                        current_block_64 = 15652330335145281839;
                                    } else {
                                        if http_header_str_contains_token(
                                            value,
                                            end.offset_from(value) as libc::c_long as uint32_t,
                                            b"close\0" as *const u8 as *const libc::c_char,
                                            (::core::mem::size_of::<[libc::c_char; 6]>()
                                                as libc::c_ulong
                                                as uint32_t)
                                                .wrapping_sub(1 as libc::c_int as libc::c_uint),
                                        ) != 0
                                        {
                                            (*r).keep_alive = 0 as libc::c_int as int8_t;
                                        }
                                        if (*r).http_version as libc::c_int
                                            >= HTTP_VERSION_2 as libc::c_int
                                        {
                                            current_block_64 = 15652330335145281839;
                                        } else {
                                            current_block_64 = 919954187481050311;
                                        }
                                    }
                                }
                                16015584448552882337 => {
                                    if (*opts).backend != BACKEND_PROXY as libc::c_int
                                        && (*opts).backend != BACKEND_CGI as libc::c_int
                                    {
                                        current_block_64 = 15652330335145281839;
                                    } else if (*r).http_version as libc::c_int
                                        >= HTTP_VERSION_2 as libc::c_int
                                    {
                                        current_block_64 = 15652330335145281839;
                                    } else {
                                        current_block_64 = 919954187481050311;
                                    }
                                }
                                208407439755130729 => {
                                    if (*opts).backend != BACKEND_PROXY as libc::c_int {
                                        *end.offset(0 as libc::c_int as isize) =
                                            '\0' as i32 as libc::c_char;
                                        let mut status_1: libc::c_int =
                                            http_header_str_to_code(value);
                                        if status_1 >= 100 as libc::c_int
                                            && status_1 < 1000 as libc::c_int
                                        {
                                            (*r).http_status = status_1;
                                            (*opts).local_redir = 0 as libc::c_int as uint8_t;
                                        } else {
                                            (*r).http_status = 502 as libc::c_int;
                                            (*r).handler_module = 0 as *const plugin;
                                        }
                                        current_block_64 = 15652330335145281839;
                                    } else {
                                        current_block_64 = 919954187481050311;
                                    }
                                }
                                8961468526249777663 => {
                                    if (*r).resp_htags
                                        & (1 as libc::c_ulong)
                                            << HTTP_HEADER_CONTENT_LENGTH as libc::c_int
                                        != 0
                                    {
                                        (*r).resp_body_scratchpad = -(1 as libc::c_int) as off_t;
                                        http_header_response_unset(
                                            r,
                                            HTTP_HEADER_CONTENT_LENGTH,
                                            b"Content-Length\0" as *const u8 as *const libc::c_char,
                                            (::core::mem::size_of::<[libc::c_char; 15]>()
                                                as libc::c_ulong
                                                as uint32_t)
                                                .wrapping_sub(1 as libc::c_int as libc::c_uint),
                                        );
                                    }
                                    (*r).resp_decode_chunked = 1 as libc::c_int as libc::c_char;
                                    (*r).gw_dechunk = calloc(
                                        1 as libc::c_int as libc::c_ulong,
                                        ::core::mem::size_of::<response_dechunk>() as libc::c_ulong,
                                    )
                                        as *mut response_dechunk;
                                    if ((*r).gw_dechunk).is_null() {
                                        ck_assert_failed(
                                            b"/home/kkysen/work/rust/lighttpd/src/http-header-glue.c\0"
                                                as *const u8 as *const libc::c_char,
                                            999 as libc::c_int as libc::c_uint,
                                            b"r->gw_dechunk\0" as *const u8 as *const libc::c_char,
                                        );
                                    }
                                    current_block_64 = 15652330335145281839;
                                }
                                4056835913730949961 => {
                                    if *k
                                        .offset(klen.wrapping_sub(1 as libc::c_int as libc::c_uint)
                                            as isize)
                                        as libc::c_int
                                        == ' ' as i32
                                        || *k.offset(
                                            klen.wrapping_sub(1 as libc::c_int as libc::c_uint)
                                                as isize,
                                        ) as libc::c_int
                                            == '\t' as i32
                                    {
                                        current_block_64 = 15652330335145281839;
                                    } else {
                                        current_block_64 = 919954187481050311;
                                    }
                                }
                                _ => {}
                            }
                            match current_block_64 {
                                15652330335145281839 => {}
                                _ => {
                                    if end.offset_from(value) as libc::c_long != 0 {
                                        http_header_response_insert(
                                            r,
                                            id,
                                            k,
                                            klen,
                                            value,
                                            end.offset_from(value) as libc::c_long as uint32_t,
                                        );
                                    }
                                }
                            }
                        }
                        _ => {
                            current_block_64 = 919954187481050311;
                            match current_block_64 {
                                13346926342236971390 => {
                                    if *value as libc::c_int == '+' as i32 {
                                        value = value.offset(1);
                                    }
                                    if (*r).resp_decode_chunked == 0
                                        && (*r).resp_htags
                                            & (1 as libc::c_ulong)
                                                << HTTP_HEADER_CONTENT_LENGTH as libc::c_int
                                            == 0
                                    {
                                        let mut err: *const libc::c_char = end;
                                        while err > value
                                            && (*err.offset(-(1 as libc::c_int) as isize)
                                                as libc::c_int
                                                == ' ' as i32
                                                || *err.offset(-(1 as libc::c_int) as isize)
                                                    as libc::c_int
                                                    == '\t' as i32)
                                        {
                                            err = err.offset(-1);
                                        }
                                        if err <= value {
                                            current_block_64 = 15652330335145281839;
                                        } else {
                                            let mut vlen: uint32_t =
                                                err.offset_from(value) as libc::c_long as uint32_t;
                                            (*r).resp_body_scratchpad =
                                                li_restricted_strtoint64(value, vlen, &mut err);
                                            if err != value.offset(vlen as isize) {
                                                (*r).resp_body_scratchpad =
                                                    -(1 as libc::c_int) as off_t;
                                            }
                                            current_block_64 = 919954187481050311;
                                        }
                                    } else {
                                        current_block_64 = 15652330335145281839;
                                    }
                                }
                                12682439727101678803 => {
                                    if (*opts).backend == BACKEND_PROXY as libc::c_int {
                                        current_block_64 = 15652330335145281839;
                                    } else {
                                        if http_header_str_contains_token(
                                            value,
                                            end.offset_from(value) as libc::c_long as uint32_t,
                                            b"close\0" as *const u8 as *const libc::c_char,
                                            (::core::mem::size_of::<[libc::c_char; 6]>()
                                                as libc::c_ulong
                                                as uint32_t)
                                                .wrapping_sub(1 as libc::c_int as libc::c_uint),
                                        ) != 0
                                        {
                                            (*r).keep_alive = 0 as libc::c_int as int8_t;
                                        }
                                        if (*r).http_version as libc::c_int
                                            >= HTTP_VERSION_2 as libc::c_int
                                        {
                                            current_block_64 = 15652330335145281839;
                                        } else {
                                            current_block_64 = 919954187481050311;
                                        }
                                    }
                                }
                                16015584448552882337 => {
                                    if (*opts).backend != BACKEND_PROXY as libc::c_int
                                        && (*opts).backend != BACKEND_CGI as libc::c_int
                                    {
                                        current_block_64 = 15652330335145281839;
                                    } else if (*r).http_version as libc::c_int
                                        >= HTTP_VERSION_2 as libc::c_int
                                    {
                                        current_block_64 = 15652330335145281839;
                                    } else {
                                        current_block_64 = 919954187481050311;
                                    }
                                }
                                208407439755130729 => {
                                    if (*opts).backend != BACKEND_PROXY as libc::c_int {
                                        *end.offset(0 as libc::c_int as isize) =
                                            '\0' as i32 as libc::c_char;
                                        let mut status_1: libc::c_int =
                                            http_header_str_to_code(value);
                                        if status_1 >= 100 as libc::c_int
                                            && status_1 < 1000 as libc::c_int
                                        {
                                            (*r).http_status = status_1;
                                            (*opts).local_redir = 0 as libc::c_int as uint8_t;
                                        } else {
                                            (*r).http_status = 502 as libc::c_int;
                                            (*r).handler_module = 0 as *const plugin;
                                        }
                                        current_block_64 = 15652330335145281839;
                                    } else {
                                        current_block_64 = 919954187481050311;
                                    }
                                }
                                8961468526249777663 => {
                                    if (*r).resp_htags
                                        & (1 as libc::c_ulong)
                                            << HTTP_HEADER_CONTENT_LENGTH as libc::c_int
                                        != 0
                                    {
                                        (*r).resp_body_scratchpad = -(1 as libc::c_int) as off_t;
                                        http_header_response_unset(
                                            r,
                                            HTTP_HEADER_CONTENT_LENGTH,
                                            b"Content-Length\0" as *const u8 as *const libc::c_char,
                                            (::core::mem::size_of::<[libc::c_char; 15]>()
                                                as libc::c_ulong
                                                as uint32_t)
                                                .wrapping_sub(1 as libc::c_int as libc::c_uint),
                                        );
                                    }
                                    (*r).resp_decode_chunked = 1 as libc::c_int as libc::c_char;
                                    (*r).gw_dechunk = calloc(
                                        1 as libc::c_int as libc::c_ulong,
                                        ::core::mem::size_of::<response_dechunk>() as libc::c_ulong,
                                    )
                                        as *mut response_dechunk;
                                    if ((*r).gw_dechunk).is_null() {
                                        ck_assert_failed(
                                            b"/home/kkysen/work/rust/lighttpd/src/http-header-glue.c\0"
                                                as *const u8 as *const libc::c_char,
                                            999 as libc::c_int as libc::c_uint,
                                            b"r->gw_dechunk\0" as *const u8 as *const libc::c_char,
                                        );
                                    }
                                    current_block_64 = 15652330335145281839;
                                }
                                4056835913730949961 => {
                                    if *k
                                        .offset(klen.wrapping_sub(1 as libc::c_int as libc::c_uint)
                                            as isize)
                                        as libc::c_int
                                        == ' ' as i32
                                        || *k.offset(
                                            klen.wrapping_sub(1 as libc::c_int as libc::c_uint)
                                                as isize,
                                        ) as libc::c_int
                                            == '\t' as i32
                                    {
                                        current_block_64 = 15652330335145281839;
                                    } else {
                                        current_block_64 = 919954187481050311;
                                    }
                                }
                                _ => {}
                            }
                            match current_block_64 {
                                15652330335145281839 => {}
                                _ => {
                                    if end.offset_from(value) as libc::c_long != 0 {
                                        http_header_response_insert(
                                            r,
                                            id,
                                            k,
                                            klen,
                                            value,
                                            end.offset_from(value) as libc::c_long as uint32_t,
                                        );
                                    }
                                }
                            }
                        }
                    }
                }
            }
        }
        i += 1;
    }
    if 0 as libc::c_int == (*r).http_status
        && (*r).resp_htags & (1 as libc::c_ulong) << HTTP_HEADER_LOCATION as libc::c_int != 0
    {
        (*r).http_status = 302 as libc::c_int;
    }
    return 0 as libc::c_int;
}
static mut http_response_send_1xx_h1: http_response_send_1xx_cb = None;
static mut http_response_send_1xx_h2: http_response_send_1xx_cb = None;
#[no_mangle]
#[cold]
pub unsafe extern "C" fn http_response_send_1xx_cb_set(
    mut fn_0: http_response_send_1xx_cb,
    mut vers: libc::c_int,
) {
    if vers >= HTTP_VERSION_2 as libc::c_int {
        http_response_send_1xx_h2 = fn_0;
    } else if vers == HTTP_VERSION_1_1 as libc::c_int {
        http_response_send_1xx_h1 = fn_0;
    }
}
#[no_mangle]
pub unsafe extern "C" fn http_response_read(
    r: *mut request_st,
    opts: *mut http_response_opts,
    b: *mut buffer,
    fdn: *mut fdnode,
) -> handler_t {
    let fd: libc::c_int = (*fdn).fd;
    let mut n: ssize_t = 0;
    let mut avail: size_t = 0;
    loop {
        let mut toread: libc::c_uint = 0 as libc::c_int as libc::c_uint;
        avail = buffer_string_space(b) as size_t;
        if 0 as libc::c_int
            == fdevent_ioctl_fionread(
                fd,
                (*opts).fdfmt,
                &mut toread as *mut libc::c_uint as *mut libc::c_int,
            )
        {
            if (*opts).simple_accum != 0 {
                let mut rc: libc::c_int = http_response_append_splice(r, opts, b, fd, toread);
                if rc != 0 {
                    if (rc > 0 as libc::c_int) as libc::c_int as libc::c_long != 0 {
                        break;
                    }
                    return HANDLER_ERROR;
                }
            }
            if avail < toread as libc::c_ulong {
                let mut blen: uint32_t = buffer_clen(b);
                if toread.wrapping_add(blen) < 4096 as libc::c_int as libc::c_uint {
                    toread = (4095 as libc::c_int as libc::c_uint).wrapping_sub(blen);
                } else if toread > (*opts).max_per_read {
                    toread = (*opts).max_per_read;
                }
                if toread > 8192 as libc::c_int as libc::c_uint && (*r).resp_body_started == 0 {
                    toread = 8192 as libc::c_int as libc::c_uint;
                }
            } else if 0 as libc::c_int as libc::c_uint == toread {
                if (if !fdn.is_null() {
                    (*fdn).events
                } else {
                    0 as libc::c_int
                }) & 0x1 as libc::c_int
                    == 0
                {
                    if (*r).conf.stream_response_body as libc::c_int
                        & (1 as libc::c_int) << 15 as libc::c_int
                        == 0
                    {
                        return HANDLER_GO_ON;
                    }
                }
                if 0 as libc::c_int as libc::c_ulong == avail {
                    toread = 1024 as libc::c_int as libc::c_uint;
                }
            }
        } else if avail < 1024 as libc::c_int as libc::c_ulong {
            toread = (4095 as libc::c_int as libc::c_ulong).wrapping_sub(avail) as libc::c_uint;
        }
        if (*r).conf.stream_response_body as libc::c_int & (1 as libc::c_int) << 1 as libc::c_int
            != 0
        {
            let mut cqlen: off_t = chunkqueue_length(&mut (*r).write_queue);
            if cqlen + toread as off_t
                > (65536 as libc::c_int - 4096 as libc::c_int) as libc::c_long
            {
                if (*(*r).con).is_writable == 0 {
                    fdevent_fdnode_event_clr((*(*(*r).con).srv).ev, fdn, 0x1 as libc::c_int);
                }
                if cqlen >= (65536 as libc::c_int - 1 as libc::c_int) as libc::c_long {
                    if buffer_is_blank(b) != 0 {
                        chunk_buffer_yield(b);
                    }
                    return HANDLER_GO_ON;
                }
                toread = ((65536 as libc::c_int - 1 as libc::c_int) as libc::c_uint)
                    .wrapping_sub(cqlen as libc::c_uint);
            }
        }
        if avail < toread as libc::c_ulong {
            avail = if toread < (*opts).max_per_read && avail != 0 {
                avail
                    .wrapping_sub(1 as libc::c_int as libc::c_ulong)
                    .wrapping_add(toread as libc::c_ulong)
            } else {
                toread as libc::c_ulong
            };
            avail = chunk_buffer_prepare_append(b, avail);
        }
        n = read(
            fd,
            ((*b).ptr).offset(buffer_clen(b) as isize) as *mut libc::c_void,
            avail,
        );
        if n < 0 as libc::c_int as libc::c_long {
            match *__errno_location() {
                11 | 4 => {
                    if buffer_is_blank(b) != 0 {
                        chunk_buffer_yield(b);
                    }
                    return HANDLER_GO_ON;
                }
                _ => {
                    log_perror(
                        (*r).conf.errh,
                        b"/home/kkysen/work/rust/lighttpd/src/http-header-glue.c\0" as *const u8
                            as *const libc::c_char,
                        1331 as libc::c_int as libc::c_uint,
                        b"read() %d %d\0" as *const u8 as *const libc::c_char,
                        (*(*r).con).fd,
                        fd,
                    );
                    return HANDLER_ERROR;
                }
            }
        }
        buffer_commit(b, n as size_t);
        if ((*opts).parse).is_some() {
            let mut rc_0: handler_t =
                ((*opts).parse).expect("non-null function pointer")(r, opts, b, n as size_t);
            if rc_0 as libc::c_uint != HANDLER_GO_ON as libc::c_int as libc::c_uint {
                return rc_0;
            }
        } else if 0 as libc::c_int as libc::c_long == n {
            if buffer_is_blank(b) != 0 {
                chunk_buffer_yield(b);
            } else if (*opts).simple_accum != 0 {
                let mut rc_1: libc::c_int = http_response_append_buffer(r, b, 0 as libc::c_int);
                chunk_buffer_yield(b);
                if (0 as libc::c_int != rc_1) as libc::c_int as libc::c_long != 0 {
                    return HANDLER_ERROR;
                }
            }
            return HANDLER_FINISHED;
        } else {
            if 0 as libc::c_int == (*r).resp_body_started as libc::c_int {
                let mut rc_2: handler_t = http_response_parse_headers(r, opts, b);
                if rc_2 as libc::c_uint != HANDLER_GO_ON as libc::c_int as libc::c_uint {
                    return rc_2;
                }
                if (*r).resp_body_started != 0 {
                    buffer_clear(b);
                    if 0 as libc::c_int as libc::c_long == (*r).resp_body_scratchpad {
                        (*r).resp_body_finished = 1 as libc::c_int as libc::c_char;
                    } else if (*r).resp_decode_chunked == 0
                        && (*r).conf.stream_response_body as libc::c_int
                            & (1 as libc::c_int) << 1 as libc::c_int
                            == 0
                    {
                        (*opts).simple_accum = 1 as libc::c_int as uint8_t;
                    }
                }
            } else {
                let mut simple_accum: libc::c_int = ((*opts).simple_accum as libc::c_int != 0
                    && ((*r).conf.stream_response_body as libc::c_int
                        & (1 as libc::c_int) << 0 as libc::c_int
                        == 0
                        || (*(*r).con).is_writable == 0))
                    as libc::c_int;
                let mut rc_3: libc::c_int = http_response_append_buffer(r, b, simple_accum);
                if (0 as libc::c_int != rc_3) as libc::c_int as libc::c_long != 0 {
                    return HANDLER_ERROR;
                }
            }
        }
        if (*r).conf.stream_response_body as libc::c_int & (1 as libc::c_int) << 1 as libc::c_int
            != 0
        {
            if chunkqueue_length(&mut (*r).write_queue)
                > (65536 as libc::c_int - 4096 as libc::c_int) as libc::c_long
            {
                if (*(*r).con).is_writable == 0 {
                    fdevent_fdnode_event_clr((*(*(*r).con).srv).ev, fdn, 0x1 as libc::c_int);
                }
                break;
            }
        }
        if !((*r).resp_body_started == 0) {
            break;
        }
    }
    if buffer_is_blank(b) != 0 {
        chunk_buffer_yield(b);
    }
    return (if (*r).resp_body_finished == 0 {
        HANDLER_GO_ON as libc::c_int
    } else {
        HANDLER_FINISHED as libc::c_int
    }) as handler_t;
}
#[cold]
#[inline(never)]
unsafe extern "C" fn http_response_check_1xx(
    r: *mut request_st,
    b: *mut buffer,
    mut hlen: uint32_t,
    mut dlen: uint32_t,
) -> libc::c_int {
    if 0 as libc::c_int == (*r).http_status || 101 as libc::c_int == (*r).http_status {
        return 0 as libc::c_int;
    }
    if dlen != 0 {
        memmove(
            (*b).ptr as *mut libc::c_void,
            ((*b).ptr).offset(hlen as isize) as *const libc::c_void,
            dlen as libc::c_ulong,
        );
    }
    buffer_truncate(b, dlen);
    return http_response_send_1xx(r);
}
#[no_mangle]
pub unsafe extern "C" fn http_response_send_1xx(r: *mut request_st) -> libc::c_int {
    let mut http_response_send_1xx_fn: http_response_send_1xx_cb = None;
    if (*r).http_version as libc::c_int >= HTTP_VERSION_2 as libc::c_int {
        http_response_send_1xx_fn = http_response_send_1xx_h2;
    } else if (*r).http_version as libc::c_int == HTTP_VERSION_1_1 as libc::c_int {
        http_response_send_1xx_fn = http_response_send_1xx_h1;
    }
    if http_response_send_1xx_fn.is_some()
        && http_response_send_1xx_fn.expect("non-null function pointer")(r, (*r).con) == 0
    {
        return 0 as libc::c_int;
    }
    http_response_header_clear(r);
    return 1 as libc::c_int;
}
#[no_mangle]
#[inline(never)]
pub unsafe extern "C" fn http_response_parse_headers(
    r: *mut request_st,
    opts: *mut http_response_opts,
    b: *mut buffer,
) -> handler_t {
    let mut bstart: *const libc::c_char = 0 as *const libc::c_char;
    let mut blen: uint32_t = 0;
    loop {
        let mut header_len: uint32_t = 0;
        let mut is_nph: uint32_t = 0 as libc::c_int as uint32_t;
        let mut hoff: [libc::c_ushort; 8192] = [0; 8192];
        hoff[0 as libc::c_int as usize] = 1 as libc::c_int as libc::c_ushort;
        hoff[1 as libc::c_int as usize] = 0 as libc::c_int as libc::c_ushort;
        hoff[2 as libc::c_int as usize] = 0 as libc::c_int as libc::c_ushort;
        blen = buffer_clen(b);
        header_len = http_header_parse_hoff((*b).ptr, blen, hoff.as_mut_ptr());
        if (if header_len != 0 { header_len } else { blen }) > 65535 as libc::c_int as libc::c_uint
        {
            log_error(
                (*r).conf.errh,
                b"/home/kkysen/work/rust/lighttpd/src/http-header-glue.c\0" as *const u8
                    as *const libc::c_char,
                1118 as libc::c_int as libc::c_uint,
                b"response headers too large for %s\0" as *const u8 as *const libc::c_char,
                (*r).uri.path.ptr,
            );
            (*r).http_status = 502 as libc::c_int;
            (*r).handler_module = 0 as *const plugin;
            return HANDLER_FINISHED;
        }
        if hoff[2 as libc::c_int as usize] != 0 {
            is_nph = (hoff[2 as libc::c_int as usize] as libc::c_int >= 12 as libc::c_int
                && 0 as libc::c_int
                    == memcmp(
                        (*b).ptr as *const libc::c_void,
                        b"HTTP/\0" as *const u8 as *const libc::c_char as *const libc::c_void,
                        5 as libc::c_int as libc::c_ulong,
                    )) as libc::c_int as uint32_t;
            if is_nph == 0 {
                let mut colon: *const libc::c_char = memchr(
                    (*b).ptr as *const libc::c_void,
                    ':' as i32,
                    (hoff[2 as libc::c_int as usize] as libc::c_int - 1 as libc::c_int)
                        as libc::c_ulong,
                ) as *const libc::c_char;
                if (0 as *mut libc::c_void as *const libc::c_char == colon) as libc::c_int
                    as libc::c_long
                    != 0
                {
                    if hoff[2 as libc::c_int as usize] as libc::c_int <= 2 as libc::c_int
                        && (1 as libc::c_int == hoff[2 as libc::c_int as usize] as libc::c_int
                            || *((*b).ptr).offset(0 as libc::c_int as isize) as libc::c_int
                                == '\r' as i32)
                    {
                    } else if (*opts).backend == BACKEND_CGI as libc::c_int {
                        if 0 as libc::c_int != http_chunk_append_buffer(r, b) {
                            return HANDLER_ERROR;
                        }
                        (*r).http_status = 200 as libc::c_int;
                        (*r).resp_body_started = 1 as libc::c_int as libc::c_char;
                        return HANDLER_GO_ON;
                    } else {
                        (*r).http_status = 502 as libc::c_int;
                        (*r).handler_module = 0 as *const plugin;
                        return HANDLER_FINISHED;
                    }
                }
            }
        }
        if 0 as libc::c_int as libc::c_uint == header_len {
            return HANDLER_GO_ON;
        }
        bstart = ((*b).ptr).offset(header_len as isize);
        blen = (blen as libc::c_uint).wrapping_sub(header_len) as uint32_t as uint32_t;
        if 0 as libc::c_int
            != http_response_process_headers(
                r,
                opts,
                (*b).ptr,
                hoff.as_mut_ptr() as *const libc::c_ushort,
                is_nph as libc::c_int,
            )
        {
            return HANDLER_ERROR;
        }
        if !((*r).http_status < 200 as libc::c_int
            && http_response_check_1xx(
                r,
                b,
                bstart.offset_from((*b).ptr) as libc::c_long as uint32_t,
                blen,
            ) != 0)
        {
            break;
        }
    }
    (*r).resp_body_started = 1 as libc::c_int as libc::c_char;
    if (*opts).authorizer != 0
        && ((*r).http_status == 0 as libc::c_int || (*r).http_status == 200 as libc::c_int)
    {
        return HANDLER_GO_ON;
    }
    if ((*r).handler_module).is_null() {
        return HANDLER_FINISHED;
    }
    if (*opts).local_redir as libc::c_int != 0
        && (*r).http_status >= 300 as libc::c_int
        && (*r).http_status < 400 as libc::c_int
        && 0 as libc::c_int as libc::c_uint == blen
    {
        let mut rc: handler_t = http_cgi_local_redir(r);
        if rc as libc::c_uint != HANDLER_GO_ON as libc::c_int as libc::c_uint {
            return rc;
        }
    }
    if (*opts).xsendfile_allow != 0 {
        let mut vb: *mut buffer = 0 as *mut buffer;
        if (*opts).backend == BACKEND_FASTCGI as libc::c_int && {
            vb = http_header_response_get(
                r,
                HTTP_HEADER_OTHER,
                b"X-Sendfile2\0" as *const u8 as *const libc::c_char,
                (::core::mem::size_of::<[libc::c_char; 12]>() as libc::c_ulong as uint32_t)
                    .wrapping_sub(1 as libc::c_int as libc::c_uint),
            );
            !vb.is_null()
        } {
            http_response_xsendfile2(r, vb, (*opts).xsendfile_docroot);
            buffer_clear(vb);
            if ((*r).handler_module).is_null() {
                (*r).resp_body_started = 0 as libc::c_int as libc::c_char;
            }
            return HANDLER_FINISHED;
        } else {
            vb = http_header_response_get(
                r,
                HTTP_HEADER_OTHER,
                b"X-Sendfile\0" as *const u8 as *const libc::c_char,
                (::core::mem::size_of::<[libc::c_char; 11]>() as libc::c_ulong as uint32_t)
                    .wrapping_sub(1 as libc::c_int as libc::c_uint),
            );
            if !vb.is_null()
                || (*opts).backend == BACKEND_FASTCGI as libc::c_int && {
                    vb = http_header_response_get(
                        r,
                        HTTP_HEADER_OTHER,
                        b"X-LIGHTTPD-send-file\0" as *const u8 as *const libc::c_char,
                        (::core::mem::size_of::<[libc::c_char; 21]>() as libc::c_ulong as uint32_t)
                            .wrapping_sub(1 as libc::c_int as libc::c_uint),
                    );
                    !vb.is_null()
                }
            {
                http_response_xsendfile(r, vb, (*opts).xsendfile_docroot);
                buffer_clear(vb);
                if ((*r).handler_module).is_null() {
                    (*r).resp_body_started = 0 as libc::c_int as libc::c_char;
                }
                return HANDLER_FINISHED;
            }
        }
    }
    if blen > 0 as libc::c_int as libc::c_uint {
        let mut rc_0: libc::c_int = http_response_append_mem(r, bstart, blen as size_t);
        if (0 as libc::c_int != rc_0) as libc::c_int as libc::c_long != 0 {
            return HANDLER_ERROR;
        }
    }
    return (if ((*opts).headers).is_some() {
        ((*opts).headers).expect("non-null function pointer")(r, opts) as libc::c_uint
    } else {
        HANDLER_GO_ON as libc::c_int as libc::c_uint
    }) as handler_t;
}
#[no_mangle]
pub unsafe extern "C" fn http_cgi_local_redir(r: *mut request_st) -> handler_t {
    let mut ulen: size_t = buffer_clen(&mut (*r).uri.path) as size_t;
    let mut vb: *const buffer = http_header_response_get(
        r,
        HTTP_HEADER_LOCATION,
        b"Location\0" as *const u8 as *const libc::c_char,
        (::core::mem::size_of::<[libc::c_char; 9]>() as libc::c_ulong as uint32_t)
            .wrapping_sub(1 as libc::c_int as libc::c_uint),
    );
    if !vb.is_null()
        && *((*vb).ptr).offset(0 as libc::c_int as isize) as libc::c_int == '/' as i32
        && (0 as libc::c_int != strncmp((*vb).ptr, (*r).uri.path.ptr, ulen)
            || *((*vb).ptr).offset(ulen as isize) as libc::c_int != '\0' as i32
                && *((*vb).ptr).offset(ulen as isize) as libc::c_int != '/' as i32
                && *((*vb).ptr).offset(ulen as isize) as libc::c_int != '?' as i32)
        && 1 as libc::c_int as libc::c_uint == (*r).resp_headers.used
        && (*r).http_status >= 300 as libc::c_int
        && (*r).http_status < 400 as libc::c_int
    {
        (*r).loops_per_request += 1;
        if (*r).loops_per_request as libc::c_int > 5 as libc::c_int {
            log_error(
                (*r).conf.errh,
                b"/home/kkysen/work/rust/lighttpd/src/http_cgi.c\0" as *const u8
                    as *const libc::c_char,
                58 as libc::c_int as libc::c_uint,
                b"too many internal loops while processing request: %s\0" as *const u8
                    as *const libc::c_char,
                (*r).target_orig.ptr,
            );
            (*r).http_status = 500 as libc::c_int;
            (*r).resp_body_started = 0 as libc::c_int as libc::c_char;
            (*r).handler_module = 0 as *const plugin;
            return HANDLER_FINISHED;
        }
        buffer_copy_buffer(&mut (*r).target, vb);
        if (*r).reqbody_length != 0 {
            if (*r).reqbody_length != (*r).reqbody_queue.bytes_in {
                (*r).keep_alive = 0 as libc::c_int as int8_t;
            }
            (*r).reqbody_length = 0 as libc::c_int as off_t;
            chunkqueue_reset(&mut (*r).reqbody_queue);
        }
        if (*r).http_status != 307 as libc::c_int && (*r).http_status != 308 as libc::c_int {
            (*r).http_method = HTTP_METHOD_GET;
        }
        return HANDLER_COMEBACK;
    }
    return HANDLER_GO_ON;
}
unsafe extern "C" fn http_cgi_encode_varname(
    b: *mut buffer,
    s: *const libc::c_char,
    len: size_t,
    is_http_header: libc::c_int,
) {
    let p: *mut libc::c_char =
        buffer_string_prepare_copy(b, len.wrapping_add(5 as libc::c_int as libc::c_ulong));
    let mut i: size_t = 0;
    let mut j: size_t = 0 as libc::c_int as size_t;
    if is_http_header != 0 {
        memcpy(
            p as *mut libc::c_void,
            b"HTTP_\0" as *const u8 as *const libc::c_char as *const libc::c_void,
            5 as libc::c_int as libc::c_ulong,
        );
        j = 5 as libc::c_int as size_t;
    }
    i = 0 as libc::c_int as size_t;
    while i < len {
        let c: libc::c_uchar = *s.offset(i as isize) as libc::c_uchar;
        let fresh248 = j;
        j = j.wrapping_add(1);
        *p.offset(fresh248 as isize) = (if light_isalpha(c as libc::c_int) != 0 {
            c as libc::c_int & !(0x20 as libc::c_int)
        } else if light_isdigit(c as libc::c_int) != 0 {
            c as libc::c_int
        } else {
            '_' as i32
        }) as libc::c_char;
        i = i.wrapping_add(1);
    }
    buffer_truncate(b, j as uint32_t);
}
#[no_mangle]
pub unsafe extern "C" fn http_cgi_headers(
    r: *mut request_st,
    opts: *mut http_cgi_opts,
    mut cb: http_cgi_header_append_cb,
    mut vdata: *mut libc::c_void,
) -> libc::c_int {
    let mut rc: libc::c_int = 0 as libc::c_int;
    let mut len: uint32_t = 0;
    let tb: *mut buffer = (*r).tmp_buf;
    let mut s: *const libc::c_char = 0 as *const libc::c_char;
    let mut n: size_t = 0;
    let mut buf: [libc::c_char; 47] = [0; 47];
    if (*opts).authorizer == 0 {
        rc |= cb.expect("non-null function pointer")(
            vdata,
            b"CONTENT_LENGTH\0" as *const u8 as *const libc::c_char,
            (::core::mem::size_of::<[libc::c_char; 15]>() as libc::c_ulong as uint32_t)
                .wrapping_sub(1 as libc::c_int as libc::c_uint) as size_t,
            buf.as_mut_ptr(),
            li_itostrn(
                buf.as_mut_ptr(),
                ::core::mem::size_of::<[libc::c_char; 47]>() as libc::c_ulong,
                (*r).reqbody_length,
            ),
        );
    }
    n = buffer_clen(&mut (*r).uri.query) as size_t;
    rc |= cb.expect("non-null function pointer")(
        vdata,
        b"QUERY_STRING\0" as *const u8 as *const libc::c_char,
        (::core::mem::size_of::<[libc::c_char; 13]>() as libc::c_ulong as uint32_t)
            .wrapping_sub(1 as libc::c_int as libc::c_uint) as size_t,
        if n != 0 {
            (*r).uri.query.ptr as *const libc::c_char
        } else {
            b"\0" as *const u8 as *const libc::c_char
        },
        n,
    );
    s = (*r).target_orig.ptr;
    n = buffer_clen(&mut (*r).target_orig) as size_t;
    len = if !((*opts).strip_request_uri).is_null() {
        buffer_clen((*opts).strip_request_uri)
    } else {
        0 as libc::c_int as libc::c_uint
    };
    if len != 0 {
        if n < len as libc::c_ulong
            || 0 as libc::c_int
                != memcmp(
                    s as *const libc::c_void,
                    (*(*opts).strip_request_uri).ptr as *const libc::c_void,
                    len as libc::c_ulong,
                )
            || *s.offset(len as isize) as libc::c_int != '/' as i32
        {
            len = 0 as libc::c_int as uint32_t;
        }
    }
    rc |= cb.expect("non-null function pointer")(
        vdata,
        b"REQUEST_URI\0" as *const u8 as *const libc::c_char,
        (::core::mem::size_of::<[libc::c_char; 12]>() as libc::c_ulong as uint32_t)
            .wrapping_sub(1 as libc::c_int as libc::c_uint) as size_t,
        s.offset(len as isize),
        n.wrapping_sub(len as libc::c_ulong),
    );
    if buffer_is_equal(&mut (*r).target, &mut (*r).target_orig) == 0 {
        rc |= cb.expect("non-null function pointer")(
            vdata,
            b"REDIRECT_URI\0" as *const u8 as *const libc::c_char,
            (::core::mem::size_of::<[libc::c_char; 13]>() as libc::c_ulong as uint32_t)
                .wrapping_sub(1 as libc::c_int as libc::c_uint) as size_t,
            (*r).target.ptr,
            buffer_clen(&mut (*r).target) as size_t,
        );
    }
    if 0 as libc::c_int == (*r).error_handler_saved_status {
        rc |= cb.expect("non-null function pointer")(
            vdata,
            b"REDIRECT_STATUS\0" as *const u8 as *const libc::c_char,
            (::core::mem::size_of::<[libc::c_char; 16]>() as libc::c_ulong as uint32_t)
                .wrapping_sub(1 as libc::c_int as libc::c_uint) as size_t,
            b"200\0" as *const u8 as *const libc::c_char,
            (::core::mem::size_of::<[libc::c_char; 4]>() as libc::c_ulong as uint32_t)
                .wrapping_sub(1 as libc::c_int as libc::c_uint) as size_t,
        );
    }
    if (*opts).authorizer == 0 {
        rc |= cb.expect("non-null function pointer")(
            vdata,
            b"SCRIPT_NAME\0" as *const u8 as *const libc::c_char,
            (::core::mem::size_of::<[libc::c_char; 12]>() as libc::c_ulong as uint32_t)
                .wrapping_sub(1 as libc::c_int as libc::c_uint) as size_t,
            (*r).uri.path.ptr,
            buffer_clen(&mut (*r).uri.path) as size_t,
        );
        if buffer_is_blank(&mut (*r).pathinfo) == 0 {
            rc |= cb.expect("non-null function pointer")(
                vdata,
                b"PATH_INFO\0" as *const u8 as *const libc::c_char,
                (::core::mem::size_of::<[libc::c_char; 10]>() as libc::c_ulong as uint32_t)
                    .wrapping_sub(1 as libc::c_int as libc::c_uint) as size_t,
                (*r).pathinfo.ptr,
                buffer_clen(&mut (*r).pathinfo) as size_t,
            );
            let bd: *const buffer = if !((*opts).docroot).is_null() {
                (*opts).docroot
            } else {
                &mut (*r).physical.basedir as *mut buffer as *const buffer
            };
            buffer_copy_path_len2(
                tb,
                (*bd).ptr,
                buffer_clen(bd) as size_t,
                (*r).pathinfo.ptr,
                buffer_clen(&mut (*r).pathinfo) as size_t,
            );
            rc |= cb.expect("non-null function pointer")(
                vdata,
                b"PATH_TRANSLATED\0" as *const u8 as *const libc::c_char,
                (::core::mem::size_of::<[libc::c_char; 16]>() as libc::c_ulong as uint32_t)
                    .wrapping_sub(1 as libc::c_int as libc::c_uint) as size_t,
                (*tb).ptr,
                buffer_clen(tb) as size_t,
            );
        }
    }
    if !((*opts).docroot).is_null() {
        buffer_copy_path_len2(
            tb,
            (*(*opts).docroot).ptr,
            buffer_clen((*opts).docroot) as size_t,
            (*r).uri.path.ptr,
            buffer_clen(&mut (*r).uri.path) as size_t,
        );
        rc |= cb.expect("non-null function pointer")(
            vdata,
            b"SCRIPT_FILENAME\0" as *const u8 as *const libc::c_char,
            (::core::mem::size_of::<[libc::c_char; 16]>() as libc::c_ulong as uint32_t)
                .wrapping_sub(1 as libc::c_int as libc::c_uint) as size_t,
            (*tb).ptr,
            buffer_clen(tb) as size_t,
        );
        rc |= cb.expect("non-null function pointer")(
            vdata,
            b"DOCUMENT_ROOT\0" as *const u8 as *const libc::c_char,
            (::core::mem::size_of::<[libc::c_char; 14]>() as libc::c_ulong as uint32_t)
                .wrapping_sub(1 as libc::c_int as libc::c_uint) as size_t,
            (*(*opts).docroot).ptr,
            buffer_clen((*opts).docroot) as size_t,
        );
    } else {
        if (*opts).break_scriptfilename_for_php != 0 {
            buffer_copy_path_len2(
                tb,
                (*r).physical.path.ptr,
                buffer_clen(&mut (*r).physical.path) as size_t,
                (*r).pathinfo.ptr,
                buffer_clen(&mut (*r).pathinfo) as size_t,
            );
            rc |= cb.expect("non-null function pointer")(
                vdata,
                b"SCRIPT_FILENAME\0" as *const u8 as *const libc::c_char,
                (::core::mem::size_of::<[libc::c_char; 16]>() as libc::c_ulong as uint32_t)
                    .wrapping_sub(1 as libc::c_int as libc::c_uint) as size_t,
                (*tb).ptr,
                buffer_clen(tb) as size_t,
            );
        } else {
            rc |= cb.expect("non-null function pointer")(
                vdata,
                b"SCRIPT_FILENAME\0" as *const u8 as *const libc::c_char,
                (::core::mem::size_of::<[libc::c_char; 16]>() as libc::c_ulong as uint32_t)
                    .wrapping_sub(1 as libc::c_int as libc::c_uint) as size_t,
                (*r).physical.path.ptr,
                buffer_clen(&mut (*r).physical.path) as size_t,
            );
        }
        rc |= cb.expect("non-null function pointer")(
            vdata,
            b"DOCUMENT_ROOT\0" as *const u8 as *const libc::c_char,
            (::core::mem::size_of::<[libc::c_char; 14]>() as libc::c_ulong as uint32_t)
                .wrapping_sub(1 as libc::c_int as libc::c_uint) as size_t,
            (*r).physical.basedir.ptr,
            buffer_clen(&mut (*r).physical.basedir) as size_t,
        );
    }
    let m: *const buffer = http_method_buf((*r).http_method);
    rc |= cb.expect("non-null function pointer")(
        vdata,
        b"REQUEST_METHOD\0" as *const u8 as *const libc::c_char,
        (::core::mem::size_of::<[libc::c_char; 15]>() as libc::c_ulong as uint32_t)
            .wrapping_sub(1 as libc::c_int as libc::c_uint) as size_t,
        (*m).ptr,
        buffer_clen(m) as size_t,
    );
    s = get_http_version_name((*r).http_version as libc::c_int);
    if s.is_null() {
        ck_assert_failed(
            b"/home/kkysen/work/rust/lighttpd/src/http_cgi.c\0" as *const u8 as *const libc::c_char,
            227 as libc::c_int as libc::c_uint,
            b"s\0" as *const u8 as *const libc::c_char,
        );
    }
    rc |= cb.expect("non-null function pointer")(
        vdata,
        b"SERVER_PROTOCOL\0" as *const u8 as *const libc::c_char,
        (::core::mem::size_of::<[libc::c_char; 16]>() as libc::c_ulong as uint32_t)
            .wrapping_sub(1 as libc::c_int as libc::c_uint) as size_t,
        s,
        strlen(s),
    );
    if !((*r).conf.server_tag).is_null() {
        s = (*(*r).conf.server_tag).ptr;
        n = buffer_clen((*r).conf.server_tag) as size_t;
    } else {
        s = b"\0" as *const u8 as *const libc::c_char;
        n = 0 as libc::c_int as size_t;
    }
    rc |= cb.expect("non-null function pointer")(
        vdata,
        b"SERVER_SOFTWARE\0" as *const u8 as *const libc::c_char,
        (::core::mem::size_of::<[libc::c_char; 16]>() as libc::c_ulong as uint32_t)
            .wrapping_sub(1 as libc::c_int as libc::c_uint) as size_t,
        s,
        n,
    );
    rc |= cb.expect("non-null function pointer")(
        vdata,
        b"GATEWAY_INTERFACE\0" as *const u8 as *const libc::c_char,
        (::core::mem::size_of::<[libc::c_char; 18]>() as libc::c_ulong as uint32_t)
            .wrapping_sub(1 as libc::c_int as libc::c_uint) as size_t,
        b"CGI/1.1\0" as *const u8 as *const libc::c_char,
        (::core::mem::size_of::<[libc::c_char; 8]>() as libc::c_ulong as uint32_t)
            .wrapping_sub(1 as libc::c_int as libc::c_uint) as size_t,
    );
    rc |= cb.expect("non-null function pointer")(
        vdata,
        b"REQUEST_SCHEME\0" as *const u8 as *const libc::c_char,
        (::core::mem::size_of::<[libc::c_char; 15]>() as libc::c_ulong as uint32_t)
            .wrapping_sub(1 as libc::c_int as libc::c_uint) as size_t,
        (*r).uri.scheme.ptr,
        buffer_clen(&mut (*r).uri.scheme) as size_t,
    );
    if buffer_eq_slen(
        &mut (*r).uri.scheme,
        b"https\0" as *const u8 as *const libc::c_char,
        (::core::mem::size_of::<[libc::c_char; 6]>() as libc::c_ulong as uint32_t)
            .wrapping_sub(1 as libc::c_int as libc::c_uint) as size_t,
    ) != 0
    {
        rc |= cb.expect("non-null function pointer")(
            vdata,
            b"HTTPS\0" as *const u8 as *const libc::c_char,
            (::core::mem::size_of::<[libc::c_char; 6]>() as libc::c_ulong as uint32_t)
                .wrapping_sub(1 as libc::c_int as libc::c_uint) as size_t,
            b"on\0" as *const u8 as *const libc::c_char,
            (::core::mem::size_of::<[libc::c_char; 3]>() as libc::c_ulong as uint32_t)
                .wrapping_sub(1 as libc::c_int as libc::c_uint) as size_t,
        );
    }
    let con: *const connection = (*r).con;
    let srv_sock: *const server_socket = (*con).srv_socket;
    let tlen: size_t = buffer_clen((*srv_sock).srv_token) as size_t;
    n = (*srv_sock).srv_token_colon as size_t;
    if n < tlen {
        s = ((*(*srv_sock).srv_token).ptr)
            .offset(n as isize)
            .offset(1 as libc::c_int as isize);
        n = tlen.wrapping_sub(n.wrapping_add(1 as libc::c_int as libc::c_ulong));
    } else {
        s = b"0\0" as *const u8 as *const libc::c_char;
        n = 1 as libc::c_int as size_t;
    }
    rc |= cb.expect("non-null function pointer")(
        vdata,
        b"SERVER_PORT\0" as *const u8 as *const libc::c_char,
        (::core::mem::size_of::<[libc::c_char; 12]>() as libc::c_ulong as uint32_t)
            .wrapping_sub(1 as libc::c_int as libc::c_uint) as size_t,
        s,
        n,
    );
    n = 0 as libc::c_int as size_t;
    match sock_addr_get_family(&(*srv_sock).addr) {
        2 | 10 => {
            if sock_addr_is_addr_wildcard(&(*srv_sock).addr) != 0 {
                let mut addrbuf: sock_addr = sock_addr {
                    ipv6: sockaddr_in6 {
                        sin6_family: 0,
                        sin6_port: 0,
                        sin6_flowinfo: 0,
                        sin6_addr: in6_addr {
                            __in6_u: C2RustUnnamed_0 {
                                __u6_addr8: [0; 16],
                            },
                        },
                        sin6_scope_id: 0,
                    },
                };
                let mut addrlen: socklen_t =
                    ::core::mem::size_of::<sock_addr>() as libc::c_ulong as socklen_t;
                if 0 as libc::c_int
                    == getsockname(
                        (*con).fd,
                        __SOCKADDR_ARG {
                            __sockaddr__: &mut addrbuf as *mut sock_addr as *mut sockaddr,
                        },
                        &mut addrlen,
                    )
                {
                    s = sock_addr_inet_ntop(
                        &mut addrbuf,
                        buf.as_mut_ptr(),
                        ::core::mem::size_of::<[libc::c_char; 47]>() as libc::c_ulong as socklen_t,
                    );
                    if !s.is_null() {
                        n = strlen(s);
                    } else {
                        s = b"\0" as *const u8 as *const libc::c_char;
                    }
                } else {
                    s = b"\0" as *const u8 as *const libc::c_char;
                }
            } else {
                s = (*(*srv_sock).srv_token).ptr;
                n = (*srv_sock).srv_token_colon as size_t;
            }
        }
        _ => {
            s = b"\0" as *const u8 as *const libc::c_char;
        }
    }
    rc |= cb.expect("non-null function pointer")(
        vdata,
        b"SERVER_ADDR\0" as *const u8 as *const libc::c_char,
        (::core::mem::size_of::<[libc::c_char; 12]>() as libc::c_ulong as uint32_t)
            .wrapping_sub(1 as libc::c_int as libc::c_uint) as size_t,
        s,
        n,
    );
    n = buffer_clen((*r).server_name) as size_t;
    if n != 0 {
        s = (*(*r).server_name).ptr;
        if *s.offset(0 as libc::c_int as isize) as libc::c_int == '[' as i32 {
            let mut colon: *const libc::c_char =
                strstr(s, b"]:\0" as *const u8 as *const libc::c_char);
            if !colon.is_null() {
                n = colon.offset(1 as libc::c_int as isize).offset_from(s) as libc::c_long
                    as size_t;
            }
        } else {
            let mut colon_0: *const libc::c_char = strchr(s, ':' as i32);
            if !colon_0.is_null() {
                n = colon_0.offset_from(s) as libc::c_long as size_t;
            }
        }
    }
    rc |= cb.expect("non-null function pointer")(
        vdata,
        b"SERVER_NAME\0" as *const u8 as *const libc::c_char,
        (::core::mem::size_of::<[libc::c_char; 12]>() as libc::c_ulong as uint32_t)
            .wrapping_sub(1 as libc::c_int as libc::c_uint) as size_t,
        s,
        n,
    );
    rc |= cb.expect("non-null function pointer")(
        vdata,
        b"REMOTE_ADDR\0" as *const u8 as *const libc::c_char,
        (::core::mem::size_of::<[libc::c_char; 12]>() as libc::c_ulong as uint32_t)
            .wrapping_sub(1 as libc::c_int as libc::c_uint) as size_t,
        (*con).dst_addr_buf.ptr,
        buffer_clen(&(*con).dst_addr_buf) as size_t,
    );
    rc |= cb.expect("non-null function pointer")(
        vdata,
        b"REMOTE_PORT\0" as *const u8 as *const libc::c_char,
        (::core::mem::size_of::<[libc::c_char; 12]>() as libc::c_ulong as uint32_t)
            .wrapping_sub(1 as libc::c_int as libc::c_uint) as size_t,
        buf.as_mut_ptr(),
        li_utostrn(
            buf.as_mut_ptr(),
            ::core::mem::size_of::<[libc::c_char; 47]>() as libc::c_ulong,
            sock_addr_get_port(&(*con).dst_addr) as uintmax_t,
        ),
    );
    n = 0 as libc::c_int as size_t;
    while n < (*r).rqst_headers.used as libc::c_ulong {
        let mut ds: *mut data_string =
            *((*r).rqst_headers.data).offset(n as isize) as *mut data_string;
        if buffer_is_blank(&mut (*ds).value) == 0 && buffer_is_unset(&mut (*ds).key) == 0 {
            if !((*ds).ext == HTTP_HEADER_OTHER as libc::c_int
                && buffer_eq_icase_slen(
                    &mut (*ds).key,
                    b"Proxy\0" as *const u8 as *const libc::c_char,
                    (::core::mem::size_of::<[libc::c_char; 6]>() as libc::c_ulong as uint32_t)
                        .wrapping_sub(1 as libc::c_int as libc::c_uint)
                        as size_t,
                ) != 0)
            {
                if (*ds).ext == HTTP_HEADER_CONTENT_TYPE as libc::c_int {
                    buffer_copy_string_len(
                        tb,
                        b"CONTENT_TYPE\0" as *const u8 as *const libc::c_char,
                        (::core::mem::size_of::<[libc::c_char; 13]>() as libc::c_ulong as uint32_t)
                            .wrapping_sub(1 as libc::c_int as libc::c_uint)
                            as size_t,
                    );
                } else {
                    http_cgi_encode_varname(
                        tb,
                        (*ds).key.ptr,
                        buffer_clen(&mut (*ds).key) as size_t,
                        1 as libc::c_int,
                    );
                }
                rc |= cb.expect("non-null function pointer")(
                    vdata,
                    (*tb).ptr,
                    buffer_clen(tb) as size_t,
                    (*ds).value.ptr,
                    buffer_clen(&mut (*ds).value) as size_t,
                );
            }
        }
        n = n.wrapping_add(1);
    }
    ((*(*con).srv).request_env).expect("non-null function pointer")(r);
    n = 0 as libc::c_int as size_t;
    while n < (*r).env.used as libc::c_ulong {
        let mut ds_0: *mut data_string = *((*r).env.data).offset(n as isize) as *mut data_string;
        if buffer_is_unset(&mut (*ds_0).value) == 0 && buffer_is_unset(&mut (*ds_0).key) == 0 {
            http_cgi_encode_varname(
                tb,
                (*ds_0).key.ptr,
                buffer_clen(&mut (*ds_0).key) as size_t,
                0 as libc::c_int,
            );
            rc |= cb.expect("non-null function pointer")(
                vdata,
                (*tb).ptr,
                buffer_clen(tb) as size_t,
                (*ds_0).value.ptr,
                buffer_clen(&mut (*ds_0).value) as size_t,
            );
        }
        n = n.wrapping_add(1);
    }
    return rc;
}
static mut datestrs: [libc::c_char; 68] = unsafe {
    *::core::mem::transmute::<&[u8; 68], &[libc::c_char; 68]>(
        b"\0\n\x14\x1E(2<FPZSunMonTueWedThuFriSatJanFebMarAprMayJunJulAugSepOctNovDec\0",
    )
};
#[cold]
unsafe extern "C" fn http_date_parse_RFC_850(
    mut s: *const libc::c_char,
    tm: *mut tm,
) -> *const libc::c_char {
    static mut tm_year_last_check: unix_time64_t = 0;
    static mut tm_year_cur: libc::c_int = 0;
    static mut tm_year_base: libc::c_int = 0;
    if log_epoch_secs >= tm_year_last_check + 60 as libc::c_int as libc::c_long {
        let mut tm_cur: tm = tm {
            tm_sec: 0,
            tm_min: 0,
            tm_hour: 0,
            tm_mday: 0,
            tm_mon: 0,
            tm_year: 0,
            tm_wday: 0,
            tm_yday: 0,
            tm_isdst: 0,
            tm_gmtoff: 0,
            tm_zone: 0 as *const libc::c_char,
        };
        if !(gmtime_r(&mut log_epoch_secs, &mut tm_cur)).is_null() {
            tm_year_last_check = log_epoch_secs;
            if tm_cur.tm_year != tm_year_cur {
                tm_year_cur = tm_cur.tm_year;
                tm_year_base = tm_year_cur - tm_year_cur % 100 as libc::c_int;
            }
        }
    }
    (*tm).tm_isdst = 0 as libc::c_int;
    (*tm).tm_yday = 0 as libc::c_int;
    (*tm).tm_wday = 0 as libc::c_int;
    (*tm).tm_mon = 0 as libc::c_int;
    let tens: *const libc::c_char = datestrs.as_ptr();
    let mut p: *const libc::c_char = tens.offset(10 as libc::c_int as isize);
    while !(*s.offset(0 as libc::c_int as isize) as libc::c_int
        == *p.offset(0 as libc::c_int as isize) as libc::c_int
        && *s.offset(1 as libc::c_int as isize) as libc::c_int
            == *p.offset(1 as libc::c_int as isize) as libc::c_int
        && *s.offset(2 as libc::c_int as isize) as libc::c_int
            == *p.offset(2 as libc::c_int as isize) as libc::c_int)
    {
        p = p.offset(3 as libc::c_int as isize);
        (*tm).tm_wday += 1;
        if !((*tm).tm_wday < 7 as libc::c_int) {
            break;
        }
    }
    if 7 as libc::c_int == (*tm).tm_wday {
        return 0 as *const libc::c_char;
    }
    s = s.offset(3 as libc::c_int as isize);
    while *s as libc::c_int != ',' as i32 && *s as libc::c_int != '\0' as i32 {
        s = s.offset(1);
    }
    if *s.offset(0 as libc::c_int as isize) as libc::c_int != ',' as i32
        || *s.offset(1 as libc::c_int as isize) as libc::c_int != ' ' as i32
        || light_isdigit(*s.offset(2 as libc::c_int as isize) as libc::c_int) == 0
        || light_isdigit(*s.offset(3 as libc::c_int as isize) as libc::c_int) == 0
    {
        return 0 as *const libc::c_char;
    }
    (*tm).tm_mday = *tens
        .offset((*s.offset(2 as libc::c_int as isize) as libc::c_int - '0' as i32) as isize)
        as libc::c_int
        + (*s.offset(3 as libc::c_int as isize) as libc::c_int - '0' as i32);
    if *s.offset(4 as libc::c_int as isize) as libc::c_int != '-' as i32 {
        return 0 as *const libc::c_char;
    }
    p = tens
        .offset(10 as libc::c_int as isize)
        .offset(::core::mem::size_of::<[libc::c_char; 22]>() as libc::c_ulong as isize)
        .offset(-(1 as libc::c_int as isize));
    while !(*s.offset(5 as libc::c_int as isize) as libc::c_int
        == *p.offset(0 as libc::c_int as isize) as libc::c_int
        && *s.offset(6 as libc::c_int as isize) as libc::c_int
            == *p.offset(1 as libc::c_int as isize) as libc::c_int
        && *s.offset(7 as libc::c_int as isize) as libc::c_int
            == *p.offset(2 as libc::c_int as isize) as libc::c_int)
    {
        p = p.offset(3 as libc::c_int as isize);
        (*tm).tm_mon += 1;
        if !((*tm).tm_mon < 12 as libc::c_int) {
            break;
        }
    }
    if 12 as libc::c_int == (*tm).tm_mon {
        return 0 as *const libc::c_char;
    }
    if *s.offset(8 as libc::c_int as isize) as libc::c_int != '-' as i32
        || light_isdigit(*s.offset(9 as libc::c_int as isize) as libc::c_int) == 0
        || light_isdigit(*s.offset(10 as libc::c_int as isize) as libc::c_int) == 0
    {
        return 0 as *const libc::c_char;
    }
    (*tm).tm_year = *tens
        .offset((*s.offset(9 as libc::c_int as isize) as libc::c_int - '0' as i32) as isize)
        as libc::c_int
        + (*s.offset(10 as libc::c_int as isize) as libc::c_int - '0' as i32)
        + tm_year_base;
    if (*tm).tm_year > tm_year_cur + 50 as libc::c_int {
        (*tm).tm_year -= 100 as libc::c_int;
    }
    if *s.offset(11 as libc::c_int as isize) as libc::c_int != ' ' as i32
        || light_isdigit(*s.offset(12 as libc::c_int as isize) as libc::c_int) == 0
        || light_isdigit(*s.offset(13 as libc::c_int as isize) as libc::c_int) == 0
    {
        return 0 as *const libc::c_char;
    }
    (*tm).tm_hour = *tens
        .offset((*s.offset(12 as libc::c_int as isize) as libc::c_int - '0' as i32) as isize)
        as libc::c_int
        + (*s.offset(13 as libc::c_int as isize) as libc::c_int - '0' as i32);
    if *s.offset(14 as libc::c_int as isize) as libc::c_int != ':' as i32
        || light_isdigit(*s.offset(15 as libc::c_int as isize) as libc::c_int) == 0
        || light_isdigit(*s.offset(16 as libc::c_int as isize) as libc::c_int) == 0
    {
        return 0 as *const libc::c_char;
    }
    (*tm).tm_min = *tens
        .offset((*s.offset(15 as libc::c_int as isize) as libc::c_int - '0' as i32) as isize)
        as libc::c_int
        + (*s.offset(16 as libc::c_int as isize) as libc::c_int - '0' as i32);
    if *s.offset(17 as libc::c_int as isize) as libc::c_int != ':' as i32
        || light_isdigit(*s.offset(18 as libc::c_int as isize) as libc::c_int) == 0
        || light_isdigit(*s.offset(19 as libc::c_int as isize) as libc::c_int) == 0
    {
        return 0 as *const libc::c_char;
    }
    (*tm).tm_sec = *tens
        .offset((*s.offset(18 as libc::c_int as isize) as libc::c_int - '0' as i32) as isize)
        as libc::c_int
        + (*s.offset(19 as libc::c_int as isize) as libc::c_int - '0' as i32);
    if *s.offset(20 as libc::c_int as isize) as libc::c_int != ' ' as i32
        || *s.offset(21 as libc::c_int as isize) as libc::c_int != 'G' as i32
        || *s.offset(22 as libc::c_int as isize) as libc::c_int != 'M' as i32
        || *s.offset(23 as libc::c_int as isize) as libc::c_int != 'T' as i32
    {
        return 0 as *const libc::c_char;
    }
    return s.offset(24 as libc::c_int as isize);
}
#[cold]
unsafe extern "C" fn http_date_parse_asctime(
    s: *const libc::c_char,
    tm: *mut tm,
) -> *const libc::c_char {
    (*tm).tm_isdst = 0 as libc::c_int;
    (*tm).tm_yday = 0 as libc::c_int;
    (*tm).tm_wday = 0 as libc::c_int;
    (*tm).tm_mon = 0 as libc::c_int;
    let tens: *const libc::c_char = datestrs.as_ptr();
    let mut p: *const libc::c_char = tens.offset(10 as libc::c_int as isize);
    while !(*s.offset(0 as libc::c_int as isize) as libc::c_int
        == *p.offset(0 as libc::c_int as isize) as libc::c_int
        && *s.offset(1 as libc::c_int as isize) as libc::c_int
            == *p.offset(1 as libc::c_int as isize) as libc::c_int
        && *s.offset(2 as libc::c_int as isize) as libc::c_int
            == *p.offset(2 as libc::c_int as isize) as libc::c_int)
    {
        p = p.offset(3 as libc::c_int as isize);
        (*tm).tm_wday += 1;
        if !((*tm).tm_wday < 7 as libc::c_int) {
            break;
        }
    }
    if 7 as libc::c_int == (*tm).tm_wday {
        return 0 as *const libc::c_char;
    }
    if *s.offset(3 as libc::c_int as isize) as libc::c_int != ' ' as i32 {
        return 0 as *const libc::c_char;
    }
    p = tens
        .offset(10 as libc::c_int as isize)
        .offset(::core::mem::size_of::<[libc::c_char; 22]>() as libc::c_ulong as isize)
        .offset(-(1 as libc::c_int as isize));
    while !(*s.offset(4 as libc::c_int as isize) as libc::c_int
        == *p.offset(0 as libc::c_int as isize) as libc::c_int
        && *s.offset(5 as libc::c_int as isize) as libc::c_int
            == *p.offset(1 as libc::c_int as isize) as libc::c_int
        && *s.offset(6 as libc::c_int as isize) as libc::c_int
            == *p.offset(2 as libc::c_int as isize) as libc::c_int)
    {
        p = p.offset(3 as libc::c_int as isize);
        (*tm).tm_mon += 1;
        if !((*tm).tm_mon < 12 as libc::c_int) {
            break;
        }
    }
    if 12 as libc::c_int == (*tm).tm_mon {
        return 0 as *const libc::c_char;
    }
    if *s.offset(7 as libc::c_int as isize) as libc::c_int != ' ' as i32
        || *s.offset(8 as libc::c_int as isize) as libc::c_int != ' ' as i32
            && light_isdigit(*s.offset(8 as libc::c_int as isize) as libc::c_int) == 0
        || light_isdigit(*s.offset(9 as libc::c_int as isize) as libc::c_int) == 0
    {
        return 0 as *const libc::c_char;
    }
    (*tm).tm_mday = (if *s.offset(8 as libc::c_int as isize) as libc::c_int == ' ' as i32 {
        0 as libc::c_int
    } else {
        *tens.offset((*s.offset(8 as libc::c_int as isize) as libc::c_int - '0' as i32) as isize)
            as libc::c_int
    }) + (*s.offset(9 as libc::c_int as isize) as libc::c_int - '0' as i32);
    if *s.offset(10 as libc::c_int as isize) as libc::c_int != ' ' as i32
        || light_isdigit(*s.offset(11 as libc::c_int as isize) as libc::c_int) == 0
        || light_isdigit(*s.offset(12 as libc::c_int as isize) as libc::c_int) == 0
    {
        return 0 as *const libc::c_char;
    }
    (*tm).tm_hour = *tens
        .offset((*s.offset(11 as libc::c_int as isize) as libc::c_int - '0' as i32) as isize)
        as libc::c_int
        + (*s.offset(12 as libc::c_int as isize) as libc::c_int - '0' as i32);
    if *s.offset(13 as libc::c_int as isize) as libc::c_int != ':' as i32
        || light_isdigit(*s.offset(14 as libc::c_int as isize) as libc::c_int) == 0
        || light_isdigit(*s.offset(15 as libc::c_int as isize) as libc::c_int) == 0
    {
        return 0 as *const libc::c_char;
    }
    (*tm).tm_min = *tens
        .offset((*s.offset(14 as libc::c_int as isize) as libc::c_int - '0' as i32) as isize)
        as libc::c_int
        + (*s.offset(15 as libc::c_int as isize) as libc::c_int - '0' as i32);
    if *s.offset(16 as libc::c_int as isize) as libc::c_int != ':' as i32
        || light_isdigit(*s.offset(17 as libc::c_int as isize) as libc::c_int) == 0
        || light_isdigit(*s.offset(18 as libc::c_int as isize) as libc::c_int) == 0
    {
        return 0 as *const libc::c_char;
    }
    (*tm).tm_sec = *tens
        .offset((*s.offset(17 as libc::c_int as isize) as libc::c_int - '0' as i32) as isize)
        as libc::c_int
        + (*s.offset(18 as libc::c_int as isize) as libc::c_int - '0' as i32);
    if *s.offset(19 as libc::c_int as isize) as libc::c_int != ' ' as i32
        || light_isdigit(*s.offset(20 as libc::c_int as isize) as libc::c_int) == 0
        || light_isdigit(*s.offset(21 as libc::c_int as isize) as libc::c_int) == 0
        || light_isdigit(*s.offset(22 as libc::c_int as isize) as libc::c_int) == 0
        || light_isdigit(*s.offset(23 as libc::c_int as isize) as libc::c_int) == 0
    {
        return 0 as *const libc::c_char;
    }
    (*tm).tm_year = (*tens
        .offset((*s.offset(20 as libc::c_int as isize) as libc::c_int - '0' as i32) as isize)
        as libc::c_int
        + (*s.offset(21 as libc::c_int as isize) as libc::c_int - '0' as i32))
        * 100 as libc::c_int
        + *tens.offset((*s.offset(22 as libc::c_int as isize) as libc::c_int - '0' as i32) as isize)
            as libc::c_int
        + (*s.offset(23 as libc::c_int as isize) as libc::c_int - '0' as i32)
        - 1900 as libc::c_int;
    return s.offset(24 as libc::c_int as isize);
}
unsafe extern "C" fn http_date_parse_IMF_fixdate(
    s: *const libc::c_char,
    tm: *mut tm,
) -> *const libc::c_char {
    (*tm).tm_isdst = 0 as libc::c_int;
    (*tm).tm_yday = 0 as libc::c_int;
    (*tm).tm_wday = 0 as libc::c_int;
    (*tm).tm_mon = 0 as libc::c_int;
    let tens: *const libc::c_char = datestrs.as_ptr();
    let mut p: *const libc::c_char = tens.offset(10 as libc::c_int as isize);
    while !(*s.offset(0 as libc::c_int as isize) as libc::c_int
        == *p.offset(0 as libc::c_int as isize) as libc::c_int
        && *s.offset(1 as libc::c_int as isize) as libc::c_int
            == *p.offset(1 as libc::c_int as isize) as libc::c_int
        && *s.offset(2 as libc::c_int as isize) as libc::c_int
            == *p.offset(2 as libc::c_int as isize) as libc::c_int)
    {
        p = p.offset(3 as libc::c_int as isize);
        (*tm).tm_wday += 1;
        if !((*tm).tm_wday < 7 as libc::c_int) {
            break;
        }
    }
    if 7 as libc::c_int == (*tm).tm_wday {
        return 0 as *const libc::c_char;
    }
    if *s.offset(3 as libc::c_int as isize) as libc::c_int != ',' as i32
        || *s.offset(4 as libc::c_int as isize) as libc::c_int != ' ' as i32
        || light_isdigit(*s.offset(5 as libc::c_int as isize) as libc::c_int) == 0
        || light_isdigit(*s.offset(6 as libc::c_int as isize) as libc::c_int) == 0
    {
        return 0 as *const libc::c_char;
    }
    (*tm).tm_mday = *tens
        .offset((*s.offset(5 as libc::c_int as isize) as libc::c_int - '0' as i32) as isize)
        as libc::c_int
        + (*s.offset(6 as libc::c_int as isize) as libc::c_int - '0' as i32);
    if *s.offset(7 as libc::c_int as isize) as libc::c_int != ' ' as i32 {
        return 0 as *const libc::c_char;
    }
    p = tens
        .offset(10 as libc::c_int as isize)
        .offset(::core::mem::size_of::<[libc::c_char; 22]>() as libc::c_ulong as isize)
        .offset(-(1 as libc::c_int as isize));
    while !(*s.offset(8 as libc::c_int as isize) as libc::c_int
        == *p.offset(0 as libc::c_int as isize) as libc::c_int
        && *s.offset(9 as libc::c_int as isize) as libc::c_int
            == *p.offset(1 as libc::c_int as isize) as libc::c_int
        && *s.offset(10 as libc::c_int as isize) as libc::c_int
            == *p.offset(2 as libc::c_int as isize) as libc::c_int)
    {
        p = p.offset(3 as libc::c_int as isize);
        (*tm).tm_mon += 1;
        if !((*tm).tm_mon < 12 as libc::c_int) {
            break;
        }
    }
    if 12 as libc::c_int == (*tm).tm_mon {
        return 0 as *const libc::c_char;
    }
    if *s.offset(11 as libc::c_int as isize) as libc::c_int != ' ' as i32
        || light_isdigit(*s.offset(12 as libc::c_int as isize) as libc::c_int) == 0
        || light_isdigit(*s.offset(13 as libc::c_int as isize) as libc::c_int) == 0
        || light_isdigit(*s.offset(14 as libc::c_int as isize) as libc::c_int) == 0
        || light_isdigit(*s.offset(15 as libc::c_int as isize) as libc::c_int) == 0
    {
        return 0 as *const libc::c_char;
    }
    (*tm).tm_year = (*tens
        .offset((*s.offset(12 as libc::c_int as isize) as libc::c_int - '0' as i32) as isize)
        as libc::c_int
        + (*s.offset(13 as libc::c_int as isize) as libc::c_int - '0' as i32))
        * 100 as libc::c_int
        + *tens.offset((*s.offset(14 as libc::c_int as isize) as libc::c_int - '0' as i32) as isize)
            as libc::c_int
        + (*s.offset(15 as libc::c_int as isize) as libc::c_int - '0' as i32)
        - 1900 as libc::c_int;
    if *s.offset(16 as libc::c_int as isize) as libc::c_int != ' ' as i32
        || light_isdigit(*s.offset(17 as libc::c_int as isize) as libc::c_int) == 0
        || light_isdigit(*s.offset(18 as libc::c_int as isize) as libc::c_int) == 0
    {
        return 0 as *const libc::c_char;
    }
    (*tm).tm_hour = *tens
        .offset((*s.offset(17 as libc::c_int as isize) as libc::c_int - '0' as i32) as isize)
        as libc::c_int
        + (*s.offset(18 as libc::c_int as isize) as libc::c_int - '0' as i32);
    if *s.offset(19 as libc::c_int as isize) as libc::c_int != ':' as i32
        || light_isdigit(*s.offset(20 as libc::c_int as isize) as libc::c_int) == 0
        || light_isdigit(*s.offset(21 as libc::c_int as isize) as libc::c_int) == 0
    {
        return 0 as *const libc::c_char;
    }
    (*tm).tm_min = *tens
        .offset((*s.offset(20 as libc::c_int as isize) as libc::c_int - '0' as i32) as isize)
        as libc::c_int
        + (*s.offset(21 as libc::c_int as isize) as libc::c_int - '0' as i32);
    if *s.offset(22 as libc::c_int as isize) as libc::c_int != ':' as i32
        || light_isdigit(*s.offset(23 as libc::c_int as isize) as libc::c_int) == 0
        || light_isdigit(*s.offset(24 as libc::c_int as isize) as libc::c_int) == 0
    {
        return 0 as *const libc::c_char;
    }
    (*tm).tm_sec = *tens
        .offset((*s.offset(23 as libc::c_int as isize) as libc::c_int - '0' as i32) as isize)
        as libc::c_int
        + (*s.offset(24 as libc::c_int as isize) as libc::c_int - '0' as i32);
    if *s.offset(25 as libc::c_int as isize) as libc::c_int != ' ' as i32
        || *s.offset(26 as libc::c_int as isize) as libc::c_int != 'G' as i32
        || *s.offset(27 as libc::c_int as isize) as libc::c_int != 'M' as i32
        || *s.offset(28 as libc::c_int as isize) as libc::c_int != 'T' as i32
    {
        return 0 as *const libc::c_char;
    }
    return s.offset(29 as libc::c_int as isize);
}
unsafe extern "C" fn http_date_str_to_tm(
    s: *const libc::c_char,
    len: uint32_t,
    tm: *mut tm,
) -> *const libc::c_char {
    if len == 29 as libc::c_int as libc::c_uint {
        return http_date_parse_IMF_fixdate(s, tm);
    } else if len > 29 as libc::c_int as libc::c_uint {
        return http_date_parse_RFC_850(s, tm);
    } else {
        return http_date_parse_asctime(s, tm);
    };
}
#[no_mangle]
pub unsafe extern "C" fn http_date_time_to_str(
    s: *mut libc::c_char,
    sz: size_t,
    t: unix_time64_t,
) -> uint32_t {
    let mut tm: tm = tm {
        tm_sec: 0,
        tm_min: 0,
        tm_hour: 0,
        tm_mday: 0,
        tm_mon: 0,
        tm_year: 0,
        tm_wday: 0,
        tm_yday: 0,
        tm_isdst: 0,
        tm_gmtoff: 0,
        tm_zone: 0 as *const libc::c_char,
    };
    let fmt: [libc::c_char; 20] =
        *::core::mem::transmute::<&[u8; 20], &[libc::c_char; 20]>(b"%a, %d %b %Y %T GMT\0");
    return if (0 as *mut libc::c_void as *mut tm != gmtime_r(&t, &mut tm)) as libc::c_int
        as libc::c_long
        != 0
    {
        strftime(s, sz, fmt.as_ptr(), &mut tm) as uint32_t
    } else {
        0 as libc::c_int as libc::c_uint
    };
}
#[no_mangle]
pub unsafe extern "C" fn http_date_if_modified_since(
    ifmod: *const libc::c_char,
    ifmodlen: uint32_t,
    lmtime: unix_time64_t,
) -> libc::c_int {
    let mut ifmodtm: tm = tm {
        tm_sec: 0,
        tm_min: 0,
        tm_hour: 0,
        tm_mday: 0,
        tm_mon: 0,
        tm_year: 0,
        tm_wday: 0,
        tm_yday: 0,
        tm_isdst: 0,
        tm_gmtoff: 0,
        tm_zone: 0 as *const libc::c_char,
    };
    if (http_date_str_to_tm(ifmod, ifmodlen, &mut ifmodtm)).is_null() {
        return 1 as libc::c_int;
    }
    let ifmtime: time_t = timegm(&mut ifmodtm);
    return (lmtime > ifmtime) as libc::c_int;
}
#[inline(never)]
unsafe extern "C" fn http_request_check_uri_strict(
    s: *const uint8_t,
    len: uint_fast32_t,
) -> *const libc::c_char {
    let mut i: uint_fast32_t = 0 as libc::c_int as uint_fast32_t;
    while i < len {
        if (*s.offset(i as isize) as libc::c_int <= 32 as libc::c_int) as libc::c_int
            as libc::c_long
            != 0
        {
            return (s as *const libc::c_char).offset(i as isize);
        }
        if (*s.offset(i as isize) as libc::c_int == 127 as libc::c_int) as libc::c_int
            as libc::c_long
            != 0
        {
            return (s as *const libc::c_char).offset(i as isize);
        }
        if (*s.offset(i as isize) as libc::c_int == 255 as libc::c_int) as libc::c_int
            as libc::c_long
            != 0
        {
            return (s as *const libc::c_char).offset(i as isize);
        }
        i = i.wrapping_add(1);
    }
    return 0 as *const libc::c_char;
}
unsafe extern "C" fn http_request_check_line_strict(
    s: *const libc::c_char,
    len: uint_fast32_t,
) -> *const libc::c_char {
    let mut i: uint_fast32_t = 0 as libc::c_int as uint_fast32_t;
    while i < len {
        if ((*(s as *const uint8_t).offset(i as isize) as libc::c_int) < 32 as libc::c_int)
            as libc::c_int as libc::c_long
            != 0
            && *s.offset(i as isize) as libc::c_int != '\t' as i32
        {
            return s.offset(i as isize);
        }
        if (*s.offset(i as isize) as libc::c_int == 127 as libc::c_int) as libc::c_int
            as libc::c_long
            != 0
        {
            return s.offset(i as isize);
        }
        i = i.wrapping_add(1);
    }
    return 0 as *const libc::c_char;
}
unsafe extern "C" fn http_request_check_line_minimal(
    s: *const libc::c_char,
    len: uint_fast32_t,
) -> *const libc::c_char {
    let mut i: uint_fast32_t = 0 as libc::c_int as uint_fast32_t;
    while i < len {
        if (*s.offset(i as isize) as libc::c_int == '\0' as i32) as libc::c_int as libc::c_long != 0
        {
            return s.offset(i as isize);
        }
        if (*s.offset(i as isize) as libc::c_int == '\n' as i32) as libc::c_int as libc::c_long != 0
        {
            return s.offset(i as isize);
        }
        i = i.wrapping_add(1);
    }
    return 0 as *const libc::c_char;
}
unsafe extern "C" fn request_check_hostname(host: *mut buffer) -> libc::c_int {
    let mut h: *const libc::c_char = (*host).ptr;
    if *h as libc::c_int != '[' as i32 {
        let mut len: uint32_t = buffer_clen(host);
        let colon: *const libc::c_char =
            memchr(h as *const libc::c_void, ':' as i32, len as libc::c_ulong)
                as *const libc::c_char;
        let mut hlen: uint32_t = if !colon.is_null() {
            colon.offset_from(h) as libc::c_long as uint32_t
        } else {
            len
        };
        if (0 as libc::c_int as libc::c_uint == hlen) as libc::c_int as libc::c_long != 0 {
            return -(1 as libc::c_int);
        }
        if (*h.offset(hlen.wrapping_sub(1 as libc::c_int as libc::c_uint) as isize) as libc::c_int
            == '.' as i32) as libc::c_int as libc::c_long
            != 0
        {
            hlen = hlen.wrapping_sub(1);
            if hlen == 0 as libc::c_int as libc::c_uint {
                return -(1 as libc::c_int);
            }
            len = len.wrapping_sub(1);
            if !colon.is_null() {
                memmove(
                    ((*host).ptr).offset(hlen as isize) as *mut libc::c_void,
                    colon as *const libc::c_void,
                    len.wrapping_sub(hlen) as libc::c_ulong,
                );
            }
            buffer_truncate(host, len);
        }
        let mut label_len: libc::c_int = 0 as libc::c_int;
        let mut allnumeric: libc::c_int = 1 as libc::c_int;
        let mut numeric: libc::c_int = 1 as libc::c_int;
        let mut level: libc::c_int = 0 as libc::c_int;
        let mut i: uint32_t = 0 as libc::c_int as uint32_t;
        while i < hlen {
            let ch: libc::c_int = *h.offset(i as isize) as libc::c_int;
            label_len += 1;
            if !(light_isdigit(ch) != 0) {
                if light_isalpha(ch) != 0
                    || ch == '-' as i32 && i != 0 as libc::c_int as libc::c_uint
                {
                    numeric = 0 as libc::c_int;
                } else if ch == '.' as i32
                    && 1 as libc::c_int != label_len
                    && '-' as i32
                        != *h.offset(i.wrapping_add(1 as libc::c_int as libc::c_uint) as isize)
                            as libc::c_int
                {
                    allnumeric &= numeric;
                    numeric = 1 as libc::c_int;
                    label_len = 0 as libc::c_int;
                    level += 1;
                } else {
                    return -(1 as libc::c_int);
                }
            }
            i = i.wrapping_add(1);
        }
        if 0 as libc::c_int == label_len
            || numeric != 0 && (level != 3 as libc::c_int || allnumeric == 0)
        {
            return -(1 as libc::c_int);
        }
        h = h.offset(hlen as isize);
    } else {
        h = h.offset(1);
        let mut cnt: libc::c_int = 0 as libc::c_int;
        while light_isxdigit(*h as libc::c_int) != 0
            || *h as libc::c_int == '.' as i32
            || *h as libc::c_int == ':' as i32 && {
                cnt += 1;
                cnt < 8 as libc::c_int
            }
        {
            h = h.offset(1);
        }
        if *h as libc::c_int != ']' as i32
            || h.offset_from((*host).ptr) as libc::c_long == 1 as libc::c_int as libc::c_long
        {
            return -(1 as libc::c_int);
        }
        h = h.offset(1);
    }
    if *h as libc::c_int == ':' as i32 {
        if (*h.offset(1 as libc::c_int as isize) as libc::c_int == '\0' as i32) as libc::c_int
            as libc::c_long
            != 0
        {
            buffer_truncate(host, h.offset_from((*host).ptr) as libc::c_long as uint32_t);
        }
        loop {
            h = h.offset(1);
            if !(light_isdigit(*h as libc::c_int) != 0) {
                break;
            }
        }
    }
    return if *h as libc::c_int == '\0' as i32 {
        0 as libc::c_int
    } else {
        -(1 as libc::c_int)
    };
}
#[no_mangle]
pub unsafe extern "C" fn http_request_host_normalize(
    b: *mut buffer,
    scheme_port: libc::c_int,
) -> libc::c_int {
    let p: *const libc::c_char = (*b).ptr;
    let blen: size_t = buffer_clen(b) as size_t;
    let mut port: libc::c_long = 0 as libc::c_int as libc::c_long;
    if *p as libc::c_int != '[' as i32 {
        let colon: *mut libc::c_char =
            memchr(p as *const libc::c_void, ':' as i32, blen) as *mut libc::c_char;
        if !colon.is_null() {
            if *p as libc::c_int == ':' as i32 {
                return -(1 as libc::c_int);
            }
            if *colon.offset(1 as libc::c_int as isize) as libc::c_int != '\0' as i32 {
                let mut e: *mut libc::c_char = 0 as *mut libc::c_char;
                port = strtol(
                    colon.offset(1 as libc::c_int as isize),
                    &mut e,
                    0 as libc::c_int,
                );
                if (0 as libc::c_int as libc::c_long) < port
                    && port
                        <= (32767 as libc::c_int * 2 as libc::c_int + 1 as libc::c_int)
                            as libc::c_long
                    && *e as libc::c_int == '\0' as i32
                {
                } else {
                    return -(1 as libc::c_int);
                }
            }
            buffer_truncate(
                b,
                colon.offset_from(p) as libc::c_long as size_t as uint32_t,
            );
        }
        if light_isdigit(*p as libc::c_int) != 0 {
            static mut laddr: C2RustUnnamed_8 = C2RustUnnamed_8 { s: [0; 16], n: 0 };
            let mut n: size_t = if !colon.is_null() {
                colon.offset_from(p) as libc::c_long as size_t
            } else {
                blen
            };
            let mut addr: sock_addr = sock_addr {
                ipv6: sockaddr_in6 {
                    sin6_family: 0,
                    sin6_port: 0,
                    sin6_flowinfo: 0,
                    sin6_addr: in6_addr {
                        __in6_u: C2RustUnnamed_0 {
                            __u6_addr8: [0; 16],
                        },
                    },
                    sin6_scope_id: 0,
                },
            };
            if !(n == laddr.n
                && 0 as libc::c_int
                    == memcmp(
                        p as *const libc::c_void,
                        (laddr.s).as_mut_ptr() as *const libc::c_void,
                        n,
                    ))
            {
                if 1 as libc::c_int
                    == sock_addr_inet_pton(
                        &mut addr,
                        p,
                        2 as libc::c_int,
                        0 as libc::c_int as libc::c_ushort,
                    )
                {
                    sock_addr_inet_ntop_copy_buffer(b, &mut addr);
                    n = buffer_clen(b) as size_t;
                    if n < ::core::mem::size_of::<[libc::c_char; 16]>() as libc::c_ulong {
                        laddr.n = n;
                        memcpy(
                            (laddr.s).as_mut_ptr() as *mut libc::c_void,
                            (*b).ptr as *const libc::c_void,
                            laddr.n,
                        );
                    }
                }
            }
        }
    } else {
        static mut laddr_0: C2RustUnnamed_7 = C2RustUnnamed_7 { s: [0; 46], n: 0 };
        let mut addr_0: sock_addr = sock_addr {
            ipv6: sockaddr_in6 {
                sin6_family: 0,
                sin6_port: 0,
                sin6_flowinfo: 0,
                sin6_addr: in6_addr {
                    __in6_u: C2RustUnnamed_0 {
                        __u6_addr8: [0; 16],
                    },
                },
                sin6_scope_id: 0,
            },
        };
        let mut bracket: *mut libc::c_char = ((*b).ptr)
            .offset(blen as isize)
            .offset(-(1 as libc::c_int as isize));
        let mut percent: *mut libc::c_char =
            strchr(((*b).ptr).offset(1 as libc::c_int as isize), '%' as i32);
        let mut len: size_t = 0;
        let mut rc: libc::c_int = 0;
        let mut buf: [libc::c_char; 62] = [0; 62];
        if blen <= 2 as libc::c_int as libc::c_ulong {
            return -(1 as libc::c_int);
        }
        if *bracket as libc::c_int != ']' as i32 {
            bracket = memchr(
                ((*b).ptr).offset(1 as libc::c_int as isize) as *const libc::c_void,
                ']' as i32,
                blen.wrapping_sub(1 as libc::c_int as libc::c_ulong),
            ) as *mut libc::c_char;
            if bracket.is_null()
                || *bracket.offset(1 as libc::c_int as isize) as libc::c_int != ':' as i32
                || bracket.offset_from((*b).ptr) as libc::c_long == 1 as libc::c_int as libc::c_long
            {
                return -(1 as libc::c_int);
            }
            if *bracket.offset(2 as libc::c_int as isize) as libc::c_int != '\0' as i32 {
                let mut e_0: *mut libc::c_char = 0 as *mut libc::c_char;
                port = strtol(
                    bracket.offset(2 as libc::c_int as isize),
                    &mut e_0,
                    0 as libc::c_int,
                );
                if (0 as libc::c_int as libc::c_long) < port
                    && port
                        <= (32767 as libc::c_int * 2 as libc::c_int + 1 as libc::c_int)
                            as libc::c_long
                    && *e_0 as libc::c_int == '\0' as i32
                {
                } else {
                    return -(1 as libc::c_int);
                }
            }
        }
        len = (if !percent.is_null() { percent } else { bracket })
            .offset_from(((*b).ptr).offset(1 as libc::c_int as isize)) as libc::c_long
            as size_t;
        if laddr_0.n == len
            && 0 as libc::c_int
                == memcmp(
                    (laddr_0.s).as_mut_ptr() as *const libc::c_void,
                    ((*b).ptr).offset(1 as libc::c_int as isize) as *const libc::c_void,
                    len,
                )
        {
            buffer_truncate(
                b,
                (bracket.offset_from((*b).ptr) as libc::c_long + 1 as libc::c_int as libc::c_long)
                    as size_t as uint32_t,
            );
        } else {
            *bracket = '\0' as i32 as libc::c_char;
            if !percent.is_null() {
                *percent = '\0' as i32 as libc::c_char;
            }
            rc = sock_addr_inet_pton(
                &mut addr_0,
                ((*b).ptr).offset(1 as libc::c_int as isize),
                10 as libc::c_int,
                0 as libc::c_int as libc::c_ushort,
            );
            if !percent.is_null() {
                *percent = '%' as i32 as libc::c_char;
            }
            *bracket = ']' as i32 as libc::c_char;
            if 1 as libc::c_int != rc {
                return -(1 as libc::c_int);
            }
            sock_addr_inet_ntop(
                &mut addr_0,
                buf.as_mut_ptr(),
                ::core::mem::size_of::<[libc::c_char; 62]>() as libc::c_ulong as socklen_t,
            );
            len = strlen(buf.as_mut_ptr());
            if !percent.is_null() {
                if percent > bracket {
                    return -(1 as libc::c_int);
                }
                if len.wrapping_add(bracket.offset_from(percent) as libc::c_long as size_t)
                    >= ::core::mem::size_of::<[libc::c_char; 62]>() as libc::c_ulong
                {
                    return -(1 as libc::c_int);
                }
                if len < ::core::mem::size_of::<[libc::c_char; 46]>() as libc::c_ulong {
                    laddr_0.n = len;
                    memcpy(
                        (laddr_0.s).as_mut_ptr() as *mut libc::c_void,
                        buf.as_mut_ptr() as *const libc::c_void,
                        laddr_0.n,
                    );
                }
                memcpy(
                    buf.as_mut_ptr().offset(len as isize) as *mut libc::c_void,
                    percent as *const libc::c_void,
                    bracket.offset_from(percent) as libc::c_long as size_t,
                );
                len = (len as libc::c_ulong)
                    .wrapping_add(bracket.offset_from(percent) as libc::c_long as size_t)
                    as size_t as size_t;
            }
            buffer_truncate(b, 1 as libc::c_int as uint32_t);
            buffer_append_str2(
                b,
                buf.as_mut_ptr(),
                len,
                b"]\0" as *const u8 as *const libc::c_char,
                (::core::mem::size_of::<[libc::c_char; 2]>() as libc::c_ulong as uint32_t)
                    .wrapping_sub(1 as libc::c_int as libc::c_uint) as size_t,
            );
        }
    }
    if 0 as libc::c_int as libc::c_long != port && port != scheme_port as libc::c_long {
        buffer_append_string_len(
            b,
            b":\0" as *const u8 as *const libc::c_char,
            (::core::mem::size_of::<[libc::c_char; 2]>() as libc::c_ulong as uint32_t)
                .wrapping_sub(1 as libc::c_int as libc::c_uint) as size_t,
        );
        buffer_append_int(b, port as libc::c_int as intmax_t);
    }
    return 0 as libc::c_int;
}
#[no_mangle]
pub unsafe extern "C" fn http_request_host_policy(
    b: *mut buffer,
    http_parseopts: libc::c_uint,
    scheme_port: libc::c_int,
) -> libc::c_int {
    return ((if http_parseopts & HTTP_PARSEOPT_HOST_STRICT as libc::c_int as libc::c_uint != 0 {
        (0 as libc::c_int != request_check_hostname(b)) as libc::c_int
    } else {
        (0 as *mut libc::c_void as *const libc::c_char
            != http_request_check_line_minimal((*b).ptr, buffer_clen(b) as uint_fast32_t))
            as libc::c_int
    }) != 0
        || http_parseopts & HTTP_PARSEOPT_HOST_NORMALIZE as libc::c_int as libc::c_uint != 0
            && 0 as libc::c_int != http_request_host_normalize(b, scheme_port))
        as libc::c_int;
}
#[cold]
#[inline(never)]
unsafe extern "C" fn http_request_header_line_invalid(
    r: *mut request_st,
    status: libc::c_int,
    msg: *const libc::c_char,
) -> libc::c_int {
    if (*r).conf.log_request_header_on_error != 0 {
        if !msg.is_null() {
            log_error(
                (*r).conf.errh,
                b"/home/kkysen/work/rust/lighttpd/src/request.c\0" as *const u8
                    as *const libc::c_char,
                278 as libc::c_int as libc::c_uint,
                b"%s\0" as *const u8 as *const libc::c_char,
                msg,
            );
        }
    }
    return status;
}
#[cold]
#[inline(never)]
unsafe extern "C" fn http_request_header_char_invalid(
    r: *mut request_st,
    ch: libc::c_char,
    msg: *const libc::c_char,
) -> libc::c_int {
    if (*r).conf.log_request_header_on_error != 0 {
        if ch as libc::c_uchar as libc::c_int > 32 as libc::c_int
            && ch as libc::c_int != 127 as libc::c_int
        {
            log_error(
                (*r).conf.errh,
                b"/home/kkysen/work/rust/lighttpd/src/request.c\0" as *const u8
                    as *const libc::c_char,
                288 as libc::c_int as libc::c_uint,
                b"%s ('%c')\0" as *const u8 as *const libc::c_char,
                msg,
                ch as libc::c_int,
            );
        } else {
            log_error(
                (*r).conf.errh,
                b"/home/kkysen/work/rust/lighttpd/src/request.c\0" as *const u8
                    as *const libc::c_char,
                291 as libc::c_int as libc::c_uint,
                b"%s (0x%x)\0" as *const u8 as *const libc::c_char,
                msg,
                ch as libc::c_int,
            );
        }
    }
    return 400 as libc::c_int;
}
#[inline(never)]
unsafe extern "C" fn http_request_header_set_Host(
    r: *mut request_st,
    h: *const libc::c_char,
    mut hlen: size_t,
) {
    (*r).http_host = http_header_request_set_ptr(
        r,
        HTTP_HEADER_HOST,
        b"Host\0" as *const u8 as *const libc::c_char,
        (::core::mem::size_of::<[libc::c_char; 5]>() as libc::c_ulong as uint32_t)
            .wrapping_sub(1 as libc::c_int as libc::c_uint),
    );
    buffer_copy_string_len_lc((*r).http_host, h, hlen);
}
#[no_mangle]
pub unsafe extern "C" fn li_restricted_strtoint64(
    mut v: *const libc::c_char,
    vlen: uint32_t,
    err: *mut *const libc::c_char,
) -> int64_t {
    let mut rv: int64_t = 0 as libc::c_int as int64_t;
    let mut i: uint32_t = 0;
    i = 0 as libc::c_int as uint32_t;
    while i < vlen {
        let c: uint8_t =
            (*(v as *mut uint8_t).offset(i as isize) as libc::c_int - '0' as i32) as uint8_t;
        if c as libc::c_int > 9 as libc::c_int {
            break;
        }
        if rv > 9223372036854775807 as libc::c_long / 10 as libc::c_int as libc::c_long {
            break;
        }
        rv *= 10 as libc::c_int as libc::c_long;
        if rv > 9223372036854775807 as libc::c_long - c as libc::c_long {
            break;
        }
        rv += c as libc::c_long;
        i = i.wrapping_add(1);
    }
    *err = v.offset(i as isize);
    return rv;
}
#[cold]
unsafe extern "C" fn http_request_parse_duplicate(
    r: *mut request_st,
    id: http_header_e,
    k: *const libc::c_char,
    klen: size_t,
    v: *const libc::c_char,
    vlen: size_t,
) -> libc::c_int {
    let vb: *const buffer = http_header_request_get(r, id, k, klen as uint32_t);
    if !vb.is_null() && buffer_eq_icase_slen(vb, v, vlen) != 0 {
        return 0 as libc::c_int;
    }
    let mut errmsg: *const libc::c_char = 0 as *const libc::c_char;
    match id as libc::c_uint {
        27 => {
            errmsg = b"duplicate Host header -> 400\0" as *const u8 as *const libc::c_char;
        }
        18 => {
            errmsg = b"duplicate Content-Type header -> 400\0" as *const u8 as *const libc::c_char;
        }
        30 => {
            errmsg =
                b"duplicate If-Modified-Since header -> 400\0" as *const u8 as *const libc::c_char;
        }
        28 => {
            errmsg =
                b"duplicate HTTP2-Settings header -> 400\0" as *const u8 as *const libc::c_char;
        }
        31 => return 0 as libc::c_int,
        _ => {
            errmsg = b"duplicate header -> 400\0" as *const u8 as *const libc::c_char;
        }
    }
    return http_request_header_line_invalid(r, 400 as libc::c_int, errmsg);
}
unsafe extern "C" fn http_request_parse_single_header(
    r: *mut request_st,
    id: http_header_e,
    k: *const libc::c_char,
    klen: size_t,
    v: *const libc::c_char,
    vlen: size_t,
) -> libc::c_int {
    let mut current_block_32: u64;
    match id as libc::c_uint {
        27 => {
            if (*r).rqst_htags & (1 as libc::c_ulong) << HTTP_HEADER_HOST as libc::c_int == 0 {
                if vlen >= 1024 as libc::c_int as libc::c_ulong {
                    return http_request_header_line_invalid(
                        r,
                        400 as libc::c_int,
                        b"uri-authority too long -> 400\0" as *const u8 as *const libc::c_char,
                    );
                }
                http_request_header_set_Host(r, v, vlen);
                return 0 as libc::c_int;
            } else {
                if !((*r).http_host).is_null()
                    && buffer_eq_slen((*r).http_host, v, vlen) as libc::c_long != 0
                {
                    return 0 as libc::c_int;
                }
            }
            current_block_32 = 17088196663730009508;
        }
        30 | 31 | 18 | 28 => {
            current_block_32 = 17088196663730009508;
        }
        12 => {
            if vlen == 5 as libc::c_int as libc::c_ulong
                && buffer_eq_icase_ssn(
                    v,
                    b"close\0" as *const u8 as *const libc::c_char,
                    (::core::mem::size_of::<[libc::c_char; 6]>() as libc::c_ulong as uint32_t)
                        .wrapping_sub(1 as libc::c_int as libc::c_uint)
                        as size_t,
                ) != 0
                || http_header_str_contains_token(
                    v,
                    vlen as uint32_t,
                    b"close\0" as *const u8 as *const libc::c_char,
                    (::core::mem::size_of::<[libc::c_char; 6]>() as libc::c_ulong as uint32_t)
                        .wrapping_sub(1 as libc::c_int as libc::c_uint),
                ) != 0
            {
                (*r).keep_alive = 0 as libc::c_int as int8_t;
            } else if http_header_str_contains_token(
                v,
                vlen as uint32_t,
                b"keep-alive\0" as *const u8 as *const libc::c_char,
                (::core::mem::size_of::<[libc::c_char; 11]>() as libc::c_ulong as uint32_t)
                    .wrapping_sub(1 as libc::c_int as libc::c_uint),
            ) != 0
            {
                (*r).keep_alive = 1 as libc::c_int as int8_t;
            }
            current_block_32 = 2891135413264362348;
        }
        14 => {
            if (*r).rqst_htags & (1 as libc::c_ulong) << HTTP_HEADER_CONTENT_LENGTH as libc::c_int
                == 0
            {
                let mut err: *const libc::c_char = 0 as *const libc::c_char;
                let mut clen: off_t = li_restricted_strtoint64(v, vlen as uint32_t, &mut err);
                if err == v.offset(vlen as isize) {
                    if 0 as libc::c_int as libc::c_long == (*r).reqbody_length {
                        (*r).reqbody_length = clen;
                    }
                } else {
                    return http_request_header_line_invalid(
                        r,
                        400 as libc::c_int,
                        b"invalid Content-Length header -> 400\0" as *const u8
                            as *const libc::c_char,
                    );
                }
            } else {
                return http_request_header_line_invalid(
                    r,
                    400 as libc::c_int,
                    b"duplicate Content-Length header -> 400\0" as *const u8 as *const libc::c_char,
                );
            }
            current_block_32 = 2891135413264362348;
        }
        48 => {
            if HTTP_VERSION_1_1 as libc::c_int != (*r).http_version as libc::c_int {
                return http_request_header_line_invalid(
                    r,
                    400 as libc::c_int,
                    if HTTP_VERSION_1_0 as libc::c_int == (*r).http_version as libc::c_int {
                        b"HTTP/1.0 with Transfer-Encoding (bad HTTP/1.0 proxy?) -> 400\0"
                            as *const u8 as *const libc::c_char
                    } else {
                        b"HTTP/2 with Transfer-Encoding is invalid -> 400\0" as *const u8
                            as *const libc::c_char
                    },
                );
            }
            if buffer_eq_icase_ss(
                v,
                vlen,
                b"chunked\0" as *const u8 as *const libc::c_char,
                (::core::mem::size_of::<[libc::c_char; 8]>() as libc::c_ulong as uint32_t)
                    .wrapping_sub(1 as libc::c_int as libc::c_uint) as size_t,
            ) == 0
            {
                return http_request_header_line_invalid(
                    r,
                    501 as libc::c_int,
                    0 as *const libc::c_char,
                );
            }
            (*r).reqbody_length = -(1 as libc::c_int) as off_t;
            return 0 as libc::c_int;
        }
        _ => {
            current_block_32 = 2891135413264362348;
        }
    }
    match current_block_32 {
        17088196663730009508 => {
            if (*r).rqst_htags & (1 as libc::c_ulong) << id as libc::c_uint != 0 {
                return http_request_parse_duplicate(r, id, k, klen, v, vlen);
            }
        }
        _ => {}
    }
    http_header_request_append(r, id, k, klen as uint32_t, v, vlen as uint32_t);
    return 0 as libc::c_int;
}
#[cold]
unsafe extern "C" fn http_request_parse_proto_loose(
    r: *mut request_st,
    ptr: *const libc::c_char,
    len: size_t,
    http_parseopts: libc::c_uint,
) -> libc::c_int {
    let mut proto: *const libc::c_char =
        memchr(ptr as *const libc::c_void, ' ' as i32, len) as *const libc::c_char;
    if proto.is_null() {
        return http_request_header_line_invalid(
            r,
            400 as libc::c_int,
            b"incomplete request line -> 400\0" as *const u8 as *const libc::c_char,
        );
    }
    proto =
        memchr(
            proto.offset(1 as libc::c_int as isize) as *const libc::c_void,
            ' ' as i32,
            len.wrapping_sub(proto.offset(1 as libc::c_int as isize).offset_from(ptr)
                as libc::c_long as libc::c_ulong),
        ) as *const libc::c_char;
    if proto.is_null() {
        return http_request_header_line_invalid(
            r,
            400 as libc::c_int,
            b"incomplete request line -> 400\0" as *const u8 as *const libc::c_char,
        );
    }
    proto = proto.offset(1);
    if *proto.offset(0 as libc::c_int as isize) as libc::c_int == 'H' as i32
        && *proto.offset(1 as libc::c_int as isize) as libc::c_int == 'T' as i32
        && *proto.offset(2 as libc::c_int as isize) as libc::c_int == 'T' as i32
        && *proto.offset(3 as libc::c_int as isize) as libc::c_int == 'P' as i32
        && *proto.offset(4 as libc::c_int as isize) as libc::c_int == '/' as i32
    {
        if *proto.offset(5 as libc::c_int as isize) as libc::c_int == '1' as i32
            && *proto.offset(6 as libc::c_int as isize) as libc::c_int == '.' as i32
            && (*proto.offset(7 as libc::c_int as isize) as libc::c_int == '1' as i32
                || *proto.offset(7 as libc::c_int as isize) as libc::c_int == '0' as i32)
        {
            if http_parseopts & HTTP_PARSEOPT_HEADER_STRICT as libc::c_int as libc::c_uint != 0 {
                return http_request_header_line_invalid(
                    r,
                    400 as libc::c_int,
                    b"incomplete request line -> 400\0" as *const u8 as *const libc::c_char,
                );
            }
            (*r).http_version =
                (if *proto.offset(7 as libc::c_int as isize) as libc::c_int == '1' as i32 {
                    HTTP_VERSION_1_1 as libc::c_int
                } else {
                    HTTP_VERSION_1_0 as libc::c_int
                }) as http_version_t;
        } else {
            return http_request_header_line_invalid(
                r,
                505 as libc::c_int,
                b"unknown HTTP version -> 505\0" as *const u8 as *const libc::c_char,
            );
        }
    } else {
        return http_request_header_line_invalid(
            r,
            400 as libc::c_int,
            b"unknown protocol -> 400\0" as *const u8 as *const libc::c_char,
        );
    }
    (*r).keep_alive = (HTTP_VERSION_1_0 as libc::c_int != (*r).http_version as libc::c_int)
        as libc::c_int as int8_t;
    return 0 as libc::c_int;
}
#[cold]
unsafe extern "C" fn http_request_parse_reqline_uri(
    r: *mut request_st,
    uri: *const libc::c_char,
    len: size_t,
    http_parseopts: libc::c_uint,
) -> *const libc::c_char {
    let mut nuri: *const libc::c_char = 0 as *const libc::c_char;
    if len > 7 as libc::c_int as libc::c_ulong
        && buffer_eq_icase_ssn(
            uri,
            b"http://\0" as *const u8 as *const libc::c_char,
            7 as libc::c_int as size_t,
        ) != 0
        && {
            nuri = memchr(
                uri.offset(7 as libc::c_int as isize) as *const libc::c_void,
                '/' as i32,
                len.wrapping_sub(7 as libc::c_int as libc::c_ulong),
            ) as *const libc::c_char;
            !nuri.is_null()
        }
        || len > 8 as libc::c_int as libc::c_ulong
            && buffer_eq_icase_ssn(
                uri,
                b"https://\0" as *const u8 as *const libc::c_char,
                8 as libc::c_int as size_t,
            ) != 0
            && {
                nuri = memchr(
                    uri.offset(8 as libc::c_int as isize) as *const libc::c_void,
                    '/' as i32,
                    len.wrapping_sub(8 as libc::c_int as libc::c_ulong),
                ) as *const libc::c_char;
                !nuri.is_null()
            }
    {
        let host: *const libc::c_char = uri.offset(
            (if *uri.offset(4 as libc::c_int as isize) as libc::c_int == ':' as i32 {
                7 as libc::c_int
            } else {
                8 as libc::c_int
            }) as isize,
        );
        let hostlen: size_t = nuri.offset_from(host) as libc::c_long as size_t;
        if 0 as libc::c_int as libc::c_ulong == hostlen
            || hostlen >= 1024 as libc::c_int as libc::c_ulong
        {
            http_request_header_line_invalid(
                r,
                400 as libc::c_int,
                b"uri-authority empty or too long -> 400\0" as *const u8 as *const libc::c_char,
            );
            return 0 as *const libc::c_char;
        }
        http_request_header_set_Host(r, host, hostlen);
        return nuri;
    } else if http_parseopts & HTTP_PARSEOPT_HEADER_STRICT as libc::c_int as libc::c_uint == 0
        || HTTP_METHOD_CONNECT as libc::c_int == (*r).http_method as libc::c_int
            && (*uri.offset(0 as libc::c_int as isize) as libc::c_int == ':' as i32
                || light_isdigit(*uri.offset(0 as libc::c_int as isize) as libc::c_int) != 0)
        || HTTP_METHOD_OPTIONS as libc::c_int == (*r).http_method as libc::c_int
            && *uri.offset(0 as libc::c_int as isize) as libc::c_int == '*' as i32
            && 1 as libc::c_int as libc::c_ulong == len
    {
        return uri;
    } else {
        http_request_header_line_invalid(
            r,
            400 as libc::c_int,
            b"request-URI parse error -> 400\0" as *const u8 as *const libc::c_char,
        );
        return 0 as *const libc::c_char;
    };
}
#[no_mangle]
pub unsafe extern "C" fn http_request_validate_pseudohdrs(
    r: *mut request_st,
    scheme: libc::c_int,
    http_parseopts: libc::c_uint,
) -> libc::c_int {
    if HTTP_METHOD_UNSET as libc::c_int == (*r).http_method as libc::c_int {
        return http_request_header_line_invalid(
            r,
            400 as libc::c_int,
            b"missing pseudo-header method -> 400\0" as *const u8 as *const libc::c_char,
        );
    }
    if (HTTP_METHOD_CONNECT as libc::c_int != (*r).http_method as libc::c_int) as libc::c_int
        as libc::c_long
        != 0
    {
        if scheme == 0 {
            return http_request_header_line_invalid(
                r,
                400 as libc::c_int,
                b"missing pseudo-header scheme -> 400\0" as *const u8 as *const libc::c_char,
            );
        }
        if buffer_is_blank(&mut (*r).target) != 0 {
            return http_request_header_line_invalid(
                r,
                400 as libc::c_int,
                b"missing pseudo-header path -> 400\0" as *const u8 as *const libc::c_char,
            );
        }
        let uri: *const libc::c_char = (*r).target.ptr;
        if *uri as libc::c_int != '/' as i32 {
            if *uri.offset(0 as libc::c_int as isize) as libc::c_int != '*' as i32
                || *uri.offset(1 as libc::c_int as isize) as libc::c_int != '\0' as i32
                || HTTP_METHOD_OPTIONS as libc::c_int != (*r).http_method as libc::c_int
            {
                return http_request_header_line_invalid(
                    r,
                    400 as libc::c_int,
                    b"invalid pseudo-header path -> 400\0" as *const u8 as *const libc::c_char,
                );
            }
        }
    } else {
        if ((*r).http_host).is_null() {
            return http_request_header_line_invalid(
                r,
                400 as libc::c_int,
                b"missing pseudo-header authority -> 400\0" as *const u8 as *const libc::c_char,
            );
        }
        if buffer_is_blank(&mut (*r).target) == 0 || scheme != 0 {
            return http_request_header_line_invalid(
                r,
                400 as libc::c_int,
                b"invalid pseudo-header with CONNECT -> 400\0" as *const u8 as *const libc::c_char,
            );
        }
        buffer_copy_buffer(&mut (*r).target, (*r).http_host);
    }
    buffer_copy_buffer(&mut (*r).target_orig, &mut (*r).target);
    let len: uint32_t = buffer_clen(&mut (*r).target);
    let x: *const libc::c_char = if http_parseopts
        & HTTP_PARSEOPT_HEADER_STRICT as libc::c_int as libc::c_uint
        != 0
    {
        if http_parseopts & HTTP_PARSEOPT_URL_NORMALIZE_CTRLS_REJECT as libc::c_int as libc::c_uint
            != 0
        {
            0 as *const libc::c_char
        } else {
            http_request_check_uri_strict((*r).target.ptr as *const uint8_t, len as uint_fast32_t)
        }
    } else {
        http_request_check_line_minimal((*r).target.ptr, len as uint_fast32_t)
    };
    return if x.is_null() {
        0 as libc::c_int
    } else {
        http_request_header_char_invalid(
            r,
            *x,
            b"invalid character in URI -> 400\0" as *const u8 as *const libc::c_char,
        )
    };
}
#[no_mangle]
pub unsafe extern "C" fn http_request_parse_header(
    r: *mut request_st,
    hpctx: *mut http_header_parse_ctx,
) -> libc::c_int {
    let k: *const libc::c_char = (*hpctx).k;
    let v: *const libc::c_char = (*hpctx).v;
    let klen: uint32_t = (*hpctx).klen;
    let vlen: uint32_t = (*hpctx).vlen;
    if 0 as libc::c_int as libc::c_uint == klen {
        return http_request_header_line_invalid(
            r,
            400 as libc::c_int,
            b"invalid header key -> 400\0" as *const u8 as *const libc::c_char,
        );
    }
    (*hpctx).hlen = ((*hpctx).hlen as libc::c_uint).wrapping_add(
        klen.wrapping_add(vlen)
            .wrapping_add(4 as libc::c_int as libc::c_uint),
    ) as uint32_t as uint32_t;
    if (*hpctx).hlen > (*hpctx).max_request_field_size {
        log_error(
            (*r).conf.errh,
            b"/home/kkysen/work/rust/lighttpd/src/request.c\0" as *const u8 as *const libc::c_char,
            604 as libc::c_int as libc::c_uint,
            b"oversized request header -> 431\0" as *const u8 as *const libc::c_char,
        );
        return 431 as libc::c_int;
    }
    if (*hpctx).trailers == 0 {
        if *k as libc::c_int == ':' as i32 {
            if (*hpctx).pseudo == 0 {
                return http_request_header_line_invalid(
                    r,
                    400 as libc::c_int,
                    b"invalid pseudo-header -> 400\0" as *const u8 as *const libc::c_char,
                );
            }
            if 0 as libc::c_int as libc::c_uint == vlen {
                return http_request_header_line_invalid(
                    r,
                    400 as libc::c_int,
                    b"invalid header value -> 400\0" as *const u8 as *const libc::c_char,
                );
            }
            if ((*hpctx).id as libc::c_int == HTTP_HEADER_H2_UNKNOWN as libc::c_int) as libc::c_int
                as libc::c_long
                != 0
            {
                match klen.wrapping_sub(1 as libc::c_int as libc::c_uint) {
                    4 => {
                        if 0 as libc::c_int
                            == memcmp(
                                k.offset(1 as libc::c_int as isize) as *const libc::c_void,
                                b"path\0" as *const u8 as *const libc::c_char
                                    as *const libc::c_void,
                                4 as libc::c_int as libc::c_ulong,
                            )
                        {
                            (*hpctx).id = HTTP_HEADER_H2_PATH as libc::c_int as int8_t;
                        }
                    }
                    6 => {
                        if 0 as libc::c_int
                            == memcmp(
                                k.offset(1 as libc::c_int as isize) as *const libc::c_void,
                                b"method\0" as *const u8 as *const libc::c_char
                                    as *const libc::c_void,
                                6 as libc::c_int as libc::c_ulong,
                            )
                        {
                            (*hpctx).id = HTTP_HEADER_H2_METHOD_GET as libc::c_int as int8_t;
                        } else if 0 as libc::c_int
                            == memcmp(
                                k.offset(1 as libc::c_int as isize) as *const libc::c_void,
                                b"scheme\0" as *const u8 as *const libc::c_char
                                    as *const libc::c_void,
                                6 as libc::c_int as libc::c_ulong,
                            )
                        {
                            (*hpctx).id = HTTP_HEADER_H2_SCHEME_HTTP as libc::c_int as int8_t;
                        }
                    }
                    9 => {
                        if 0 as libc::c_int
                            == memcmp(
                                k.offset(1 as libc::c_int as isize) as *const libc::c_void,
                                b"authority\0" as *const u8 as *const libc::c_char
                                    as *const libc::c_void,
                                9 as libc::c_int as libc::c_ulong,
                            )
                        {
                            (*hpctx).id = HTTP_HEADER_H2_AUTHORITY as libc::c_int as int8_t;
                        }
                    }
                    _ => {}
                }
                if (*hpctx).id as libc::c_int >= HTTP_HEADER_H2_UNKNOWN as libc::c_int {
                    return http_request_header_line_invalid(
                        r,
                        400 as libc::c_int,
                        b"invalid pseudo-header -> 400\0" as *const u8 as *const libc::c_char,
                    );
                }
            }
            match (*hpctx).id as libc::c_int {
                -2 => {
                    if !(((*r).http_host != 0 as *mut libc::c_void as *mut buffer) as libc::c_int
                        as libc::c_long
                        != 0)
                    {
                        if vlen >= 1024 as libc::c_int as libc::c_uint {
                            return http_request_header_line_invalid(
                                r,
                                400 as libc::c_int,
                                b"invalid pseudo-header authority too long -> 400\0" as *const u8
                                    as *const libc::c_char,
                            );
                        }
                        http_request_header_set_Host(r, v, vlen as size_t);
                        return 0 as libc::c_int;
                    }
                }
                -3 | -4 => {
                    if !((HTTP_METHOD_UNSET as libc::c_int != (*r).http_method as libc::c_int)
                        as libc::c_int as libc::c_long
                        != 0)
                    {
                        (*r).http_method = get_http_method_key(v, vlen as size_t);
                        if HTTP_METHOD_UNSET as libc::c_int >= (*r).http_method as libc::c_int {
                            return http_request_header_line_invalid(
                                r,
                                501 as libc::c_int,
                                b"unknown http-method -> 501\0" as *const u8 as *const libc::c_char,
                            );
                        }
                        return 0 as libc::c_int;
                    }
                }
                -5 | -6 => {
                    if !((buffer_is_blank(&mut (*r).target) == 0) as libc::c_int as libc::c_long
                        != 0)
                    {
                        buffer_copy_string_len(&mut (*r).target, v, vlen as size_t);
                        return 0 as libc::c_int;
                    }
                }
                -7 | -8 => {
                    if !((*hpctx).scheme as libc::c_long != 0) {
                        (*hpctx).scheme = 1 as libc::c_int as uint8_t;
                        return 0 as libc::c_int;
                    }
                }
                _ => {
                    return http_request_header_line_invalid(
                        r,
                        400 as libc::c_int,
                        b"invalid pseudo-header -> 400\0" as *const u8 as *const libc::c_char,
                    );
                }
            }
            return http_request_header_line_invalid(
                r,
                400 as libc::c_int,
                b"repeated pseudo-header -> 400\0" as *const u8 as *const libc::c_char,
            );
        } else {
            if (*hpctx).pseudo != 0 {
                (*hpctx).pseudo = 0 as libc::c_int as uint8_t;
                let mut status: libc::c_int = http_request_validate_pseudohdrs(
                    r,
                    (*hpctx).scheme as libc::c_int,
                    (*hpctx).http_parseopts,
                );
                if 0 as libc::c_int != status {
                    return status;
                }
            }
            if 0 as libc::c_int as libc::c_uint == vlen {
                return 0 as libc::c_int;
            }
            let http_header_strict: libc::c_uint = (*hpctx).http_parseopts
                & HTTP_PARSEOPT_HEADER_STRICT as libc::c_int as libc::c_uint;
            let x: *const libc::c_char = if http_header_strict != 0 {
                http_request_check_line_strict(v, vlen as uint_fast32_t)
            } else {
                http_request_check_line_minimal(v, vlen as uint_fast32_t)
            };
            if !x.is_null() {
                return http_request_header_char_invalid(
                    r,
                    *x,
                    b"invalid character in header -> 400\0" as *const u8 as *const libc::c_char,
                );
            }
            if ((*hpctx).id as libc::c_int == HTTP_HEADER_H2_UNKNOWN as libc::c_int) as libc::c_int
                as libc::c_long
                != 0
            {
                let mut j: uint32_t = 0 as libc::c_int as uint32_t;
                while j < klen
                    && ((*k.offset(j as isize) as uint32_t)
                        .wrapping_sub('a' as i32 as libc::c_uint)
                        <= ('z' as i32 - 'a' as i32) as libc::c_uint
                        || *k.offset(j as isize) as libc::c_int == '-' as i32)
                {
                    j = j.wrapping_add(1);
                }
                if (j != klen) as libc::c_int as libc::c_long != 0 {
                    if (*k.offset(j as isize) as uint32_t).wrapping_sub('A' as i32 as libc::c_uint)
                        <= ('Z' as i32 - 'A' as i32) as libc::c_uint
                    {
                        return 400 as libc::c_int;
                    }
                    if 0 as libc::c_int
                        != http_request_parse_header_other(
                            r,
                            k.offset(j as isize),
                            klen.wrapping_sub(j) as libc::c_int,
                            http_header_strict,
                        )
                    {
                        return 400 as libc::c_int;
                    }
                }
                (*hpctx).id = http_header_hkey_get_lc(k, klen as size_t) as int8_t;
            }
            let id: http_header_e = (*hpctx).id as http_header_e;
            if (id as libc::c_uint == HTTP_HEADER_TE as libc::c_int as libc::c_uint) as libc::c_int
                as libc::c_long
                != 0
                && buffer_eq_icase_ss(
                    v,
                    vlen as size_t,
                    b"trailers\0" as *const u8 as *const libc::c_char,
                    (::core::mem::size_of::<[libc::c_char; 9]>() as libc::c_ulong as uint32_t)
                        .wrapping_sub(1 as libc::c_int as libc::c_uint)
                        as size_t,
                ) == 0
            {
                return http_request_header_line_invalid(
                    r,
                    400 as libc::c_int,
                    b"invalid TE header value with HTTP/2 -> 400\0" as *const u8
                        as *const libc::c_char,
                );
            }
            return http_request_parse_single_header(r, id, k, klen as size_t, v, vlen as size_t);
        }
    } else {
        if *k as libc::c_int == ':' as i32 {
            return http_request_header_line_invalid(
                r,
                400 as libc::c_int,
                b"invalid pseudo-header in trailers -> 400\0" as *const u8 as *const libc::c_char,
            );
        }
        return 0 as libc::c_int;
    };
}
unsafe extern "C" fn http_request_parse_reqline(
    r: *mut request_st,
    ptr: *const libc::c_char,
    hoff: *const libc::c_ushort,
    http_parseopts: libc::c_uint,
) -> libc::c_int {
    let mut len: size_t = *hoff.offset(2 as libc::c_int as isize) as size_t;
    if len < 13 as libc::c_int as libc::c_ulong {
        return http_request_header_line_invalid(
            r,
            400 as libc::c_int,
            b"invalid request line (too short) -> 400\0" as *const u8 as *const libc::c_char,
        );
    }
    if *ptr.offset(len.wrapping_sub(2 as libc::c_int as libc::c_ulong) as isize) as libc::c_int
        == '\r' as i32
    {
        len = (len as libc::c_ulong).wrapping_sub(2 as libc::c_int as libc::c_ulong) as size_t
            as size_t;
    } else if http_parseopts & HTTP_PARSEOPT_HEADER_STRICT as libc::c_int as libc::c_uint == 0 {
        len = (len as libc::c_ulong).wrapping_sub(1 as libc::c_int as libc::c_ulong) as size_t
            as size_t;
    } else {
        return http_request_header_line_invalid(
            r,
            400 as libc::c_int,
            b"missing CR before LF in header -> 400\0" as *const u8 as *const libc::c_char,
        );
    }
    static mut http_1_1: proto_un = proto_un {
        c: [
            'H' as i32 as libc::c_char,
            'T' as i32 as libc::c_char,
            'T' as i32 as libc::c_char,
            'P' as i32 as libc::c_char,
            '/' as i32 as libc::c_char,
            '1' as i32 as libc::c_char,
            '.' as i32 as libc::c_char,
            '1' as i32 as libc::c_char,
        ],
    };
    static mut http_1_0: proto_un = proto_un {
        c: [
            'H' as i32 as libc::c_char,
            'T' as i32 as libc::c_char,
            'T' as i32 as libc::c_char,
            'P' as i32 as libc::c_char,
            '/' as i32 as libc::c_char,
            '1' as i32 as libc::c_char,
            '.' as i32 as libc::c_char,
            '0' as i32 as libc::c_char,
        ],
    };
    let mut p: *const libc::c_char = ptr
        .offset(len as isize)
        .offset(-(8 as libc::c_int as isize));
    let mut proto8: proto_un = proto_un { c: [0; 8] };
    proto8.c[0 as libc::c_int as usize] = *p.offset(0 as libc::c_int as isize);
    proto8.c[1 as libc::c_int as usize] = *p.offset(1 as libc::c_int as isize);
    proto8.c[2 as libc::c_int as usize] = *p.offset(2 as libc::c_int as isize);
    proto8.c[3 as libc::c_int as usize] = *p.offset(3 as libc::c_int as isize);
    proto8.c[4 as libc::c_int as usize] = *p.offset(4 as libc::c_int as isize);
    proto8.c[5 as libc::c_int as usize] = *p.offset(5 as libc::c_int as isize);
    proto8.c[6 as libc::c_int as usize] = *p.offset(6 as libc::c_int as isize);
    proto8.c[7 as libc::c_int as usize] = *p.offset(7 as libc::c_int as isize);
    if *p.offset(-(1 as libc::c_int) as isize) as libc::c_int == ' ' as i32
        && http_1_1.u == proto8.u
    {
        (*r).http_version = HTTP_VERSION_1_1;
        (*r).keep_alive = 1 as libc::c_int as int8_t;
    } else if *p.offset(-(1 as libc::c_int) as isize) as libc::c_int == ' ' as i32
        && http_1_0.u == proto8.u
    {
        (*r).http_version = HTTP_VERSION_1_0;
        (*r).keep_alive = 0 as libc::c_int as int8_t;
    } else {
        let mut status: libc::c_int = http_request_parse_proto_loose(r, ptr, len, http_parseopts);
        if 0 as libc::c_int != status {
            return status;
        }
        p = ptr
            .offset(len as isize)
            .offset(-(9 as libc::c_int as isize));
        while *p.offset(-(1 as libc::c_int) as isize) as libc::c_int != ' ' as i32 {
            p = p.offset(-1);
        }
    }
    let mut i: size_t = 0 as libc::c_int as size_t;
    while *ptr.offset(i as isize) as libc::c_int != ' ' as i32 {
        i = i.wrapping_add(1);
    }
    (*r).http_method = get_http_method_key(ptr, i);
    if HTTP_METHOD_UNSET as libc::c_int >= (*r).http_method as libc::c_int {
        return http_request_header_line_invalid(
            r,
            501 as libc::c_int,
            b"unknown http-method -> 501\0" as *const u8 as *const libc::c_char,
        );
    }
    let mut uri: *const libc::c_char = ptr.offset(i as isize).offset(1 as libc::c_int as isize);
    if uri == p {
        return http_request_header_line_invalid(
            r,
            400 as libc::c_int,
            b"no uri specified -> 400\0" as *const u8 as *const libc::c_char,
        );
    }
    len = (p.offset_from(uri) as libc::c_long - 1 as libc::c_int as libc::c_long) as size_t;
    if *uri as libc::c_int != '/' as i32 {
        uri = http_request_parse_reqline_uri(r, uri, len, http_parseopts);
        if uri.is_null() {
            return 400 as libc::c_int;
        }
        len = (p.offset_from(uri) as libc::c_long - 1 as libc::c_int as libc::c_long) as size_t;
    }
    if 0 as libc::c_int as libc::c_ulong == len {
        return http_request_header_line_invalid(
            r,
            400 as libc::c_int,
            b"no uri specified -> 400\0" as *const u8 as *const libc::c_char,
        );
    }
    let x: *const libc::c_char =
        (if http_parseopts & HTTP_PARSEOPT_HEADER_STRICT as libc::c_int as libc::c_uint != 0 {
            (if http_parseopts
                & HTTP_PARSEOPT_URL_NORMALIZE_CTRLS_REJECT as libc::c_int as libc::c_uint
                != 0
            {
                0 as *const libc::c_char
            } else {
                http_request_check_uri_strict(uri as *const uint8_t, len)
            }) as *const libc::c_void
        } else {
            memchr(
                ptr as *const libc::c_void,
                '\0' as i32,
                *hoff.offset(*hoff.offset(0 as libc::c_int as isize) as isize) as libc::c_ulong,
            )
        }) as *const libc::c_char;
    if !x.is_null() {
        http_request_header_char_invalid(
            r,
            *x,
            b"invalid character in URI -> 400\0" as *const u8 as *const libc::c_char,
        );
    }
    buffer_copy_string_len(&mut (*r).target, uri, len);
    buffer_copy_string_len(&mut (*r).target_orig, uri, len);
    return 0 as libc::c_int;
}
#[no_mangle]
pub unsafe extern "C" fn http_request_parse_target(
    r: *mut request_st,
    mut scheme_port: libc::c_int,
) -> libc::c_int {
    buffer_copy_string_len(
        &mut (*r).uri.scheme,
        b"https\0" as *const u8 as *const libc::c_char,
        (if scheme_port == 443 as libc::c_int {
            5 as libc::c_int
        } else {
            4 as libc::c_int
        }) as size_t,
    );
    let target: *mut buffer = &mut (*r).target;
    if (*r).http_method as libc::c_int == HTTP_METHOD_CONNECT as libc::c_int
        || (*r).http_method as libc::c_int == HTTP_METHOD_OPTIONS as libc::c_int
            && *((*target).ptr).offset(0 as libc::c_int as isize) as libc::c_int == '*' as i32
            && *((*target).ptr).offset(1 as libc::c_int as isize) as libc::c_int == '\0' as i32
    {
        buffer_copy_buffer(&mut (*r).uri.path, target);
        buffer_clear(&mut (*r).uri.query);
        return 0 as libc::c_int;
    }
    let mut qstr: *mut libc::c_char = 0 as *mut libc::c_char;
    if (*r).conf.http_parseopts & HTTP_PARSEOPT_URL_NORMALIZE as libc::c_int as libc::c_uint != 0 {
        let mut qs: libc::c_int = burl_normalize(
            target,
            (*r).tmp_buf,
            (*r).conf.http_parseopts as libc::c_int,
        );
        if -(2 as libc::c_int) == qs {
            return http_request_header_line_invalid(
                r,
                400 as libc::c_int,
                b"invalid character in URI -> 400\0" as *const u8 as *const libc::c_char,
            );
        }
        qstr = if -(1 as libc::c_int) == qs {
            0 as *mut libc::c_char
        } else {
            ((*target).ptr).offset(qs as isize)
        };
    } else {
        let mut rlen: size_t = buffer_clen(target) as size_t;
        qstr = memchr((*target).ptr as *const libc::c_void, '#' as i32, rlen) as *mut libc::c_char;
        if !qstr.is_null() {
            rlen = qstr.offset_from((*target).ptr) as libc::c_long as size_t;
            buffer_truncate(target, rlen as uint32_t);
        }
        qstr = memchr((*target).ptr as *const libc::c_void, '?' as i32, rlen) as *mut libc::c_char;
    }
    let pstr: *const libc::c_char = (*target).ptr;
    let rlen_0: uint32_t = buffer_clen(target);
    let mut plen: uint32_t = 0;
    if !qstr.is_null() {
        plen = qstr.offset_from(pstr) as libc::c_long as uint32_t;
        buffer_copy_string_len(
            &mut (*r).uri.query,
            qstr.offset(1 as libc::c_int as isize),
            rlen_0
                .wrapping_sub(plen)
                .wrapping_sub(1 as libc::c_int as libc::c_uint) as size_t,
        );
    } else {
        plen = rlen_0;
        buffer_clear(&mut (*r).uri.query);
    }
    buffer_copy_string_len(&mut (*r).uri.path, pstr, plen as size_t);
    buffer_urldecode_path(&mut (*r).uri.path);
    buffer_path_simplify(&mut (*r).uri.path);
    if *((*r).uri.path.ptr).offset(0 as libc::c_int as isize) as libc::c_int != '/' as i32 {
        return http_request_header_line_invalid(
            r,
            400 as libc::c_int,
            b"uri-path does not begin with '/' -> 400\0" as *const u8 as *const libc::c_char,
        );
    }
    return 0 as libc::c_int;
}
#[cold]
#[inline(never)]
unsafe extern "C" fn http_request_parse_header_other(
    r: *mut request_st,
    k: *const libc::c_char,
    klen: libc::c_int,
    http_header_strict: libc::c_uint,
) -> libc::c_int {
    let mut i: libc::c_int = 0 as libc::c_int;
    while i < klen {
        if !(light_isalpha(*k.offset(i as isize) as libc::c_int) != 0
            || *k.offset(i as isize) as libc::c_int == '-' as i32)
        {
            match *k.offset(i as isize) as libc::c_int {
                32 | 9 => {
                    return http_request_header_line_invalid(
                        r,
                        400 as libc::c_int,
                        b"WS character in key -> 400\0" as *const u8 as *const libc::c_char,
                    );
                }
                13 | 10 | 40 | 41 | 60 | 62 | 64 | 44 | 58 | 59 | 92 | 34 | 47 | 91 | 93 | 63
                | 61 | 123 | 125 => {
                    return http_request_header_char_invalid(
                        r,
                        *k.offset(i as isize),
                        b"invalid character in header key -> 400\0" as *const u8
                            as *const libc::c_char,
                    );
                }
                _ => {
                    if if http_header_strict != 0 {
                        ((*k.offset(i as isize) as libc::c_int) < 32 as libc::c_int
                            || *(k as *mut libc::c_uchar).offset(i as isize) as libc::c_int
                                >= 127 as libc::c_int) as libc::c_int
                    } else {
                        (*k.offset(i as isize) as libc::c_int == '\0' as i32) as libc::c_int
                    } != 0
                    {
                        return http_request_header_char_invalid(
                            r,
                            *k.offset(i as isize),
                            b"invalid character in header key -> 400\0" as *const u8
                                as *const libc::c_char,
                        );
                    }
                }
            }
        }
        i += 1;
    }
    return 0 as libc::c_int;
}
unsafe extern "C" fn http_request_parse_headers(
    r: *mut request_st,
    ptr: *mut libc::c_char,
    hoff: *const libc::c_ushort,
    http_parseopts: libc::c_uint,
) -> libc::c_int {
    let http_header_strict: libc::c_uint =
        http_parseopts & HTTP_PARSEOPT_HEADER_STRICT as libc::c_int as libc::c_uint;
    let mut i: libc::c_int = 2 as libc::c_int;
    while i < *hoff.offset(0 as libc::c_int as isize) as libc::c_int {
        let mut k: *const libc::c_char =
            ptr.offset(*hoff.offset(i as isize) as libc::c_int as isize);
        let mut end: *mut libc::c_char =
            ptr.offset(*hoff.offset((i + 1 as libc::c_int) as isize) as libc::c_int as isize);
        let mut colon: *const libc::c_char = memchr(
            k as *const libc::c_void,
            ':' as i32,
            end.offset_from(k) as libc::c_long as libc::c_ulong,
        ) as *const libc::c_char;
        if colon.is_null() {
            return http_request_header_line_invalid(
                r,
                400 as libc::c_int,
                b"invalid header missing ':' -> 400\0" as *const u8 as *const libc::c_char,
            );
        }
        let mut v: *const libc::c_char = colon.offset(1 as libc::c_int as isize);
        if *colon.offset(-(1 as libc::c_int) as isize) as libc::c_int == ' ' as i32
            || *colon.offset(-(1 as libc::c_int) as isize) as libc::c_int == '\t' as i32
        {
            if http_header_strict != 0 {
                return http_request_header_line_invalid(
                    r,
                    400 as libc::c_int,
                    b"invalid whitespace between field-name and colon -> 400\0" as *const u8
                        as *const libc::c_char,
                );
            } else {
                loop {
                    colon = colon.offset(-1);
                    if !(*colon.offset(-(1 as libc::c_int) as isize) as libc::c_int == ' ' as i32
                        || *colon.offset(-(1 as libc::c_int) as isize) as libc::c_int
                            == '\t' as i32)
                    {
                        break;
                    }
                }
            }
        }
        let klen: libc::c_int = colon.offset_from(k) as libc::c_long as libc::c_int;
        if 0 as libc::c_int == klen {
            return http_request_header_line_invalid(
                r,
                400 as libc::c_int,
                b"invalid header key -> 400\0" as *const u8 as *const libc::c_char,
            );
        }
        let id: http_header_e = http_header_hkey_get(k, klen as size_t);
        if id as libc::c_uint == HTTP_HEADER_OTHER as libc::c_int as libc::c_uint {
            let mut j: libc::c_int = 0 as libc::c_int;
            while j < klen {
                if light_isalpha(*k.offset(j as isize) as libc::c_int) != 0
                    || *k.offset(j as isize) as libc::c_int == '-' as i32
                {
                    j += 1;
                } else {
                    if 0 as libc::c_int
                        != http_request_parse_header_other(
                            r,
                            k.offset(j as isize),
                            klen - j,
                            http_header_strict,
                        )
                    {
                        return 400 as libc::c_int;
                    }
                    break;
                }
            }
        }
        while *v as libc::c_int == ' ' as i32 || *v as libc::c_int == '\t' as i32 {
            v = v.offset(1);
        }
        while i + 1 as libc::c_int <= *hoff.offset(0 as libc::c_int as isize) as libc::c_int {
            end = ptr.offset(*hoff.offset((i + 1 as libc::c_int) as isize) as libc::c_int as isize);
            if *end.offset(0 as libc::c_int as isize) as libc::c_int != ' ' as i32
                && *end.offset(0 as libc::c_int as isize) as libc::c_int != '\t' as i32
            {
                break;
            }
            if *end.offset(-(2 as libc::c_int) as isize) as libc::c_int == '\r' as i32 {
                *end.offset(-(2 as libc::c_int) as isize) = ' ' as i32 as libc::c_char;
            } else if http_header_strict != 0 {
                return http_request_header_line_invalid(
                    r,
                    400 as libc::c_int,
                    b"missing CR before LF in header -> 400\0" as *const u8 as *const libc::c_char,
                );
            }
            *end.offset(-(1 as libc::c_int) as isize) = ' ' as i32 as libc::c_char;
            i += 1;
        }
        if *end.offset(-(2 as libc::c_int) as isize) as libc::c_int == '\r' as i32 {
            end = end.offset(-1);
        } else if http_header_strict != 0 {
            return http_request_header_line_invalid(
                r,
                400 as libc::c_int,
                b"missing CR before LF in header -> 400\0" as *const u8 as *const libc::c_char,
            );
        }
        loop {
            end = end.offset(-1);
            if !(*end.offset(-(1 as libc::c_int) as isize) as libc::c_int == ' ' as i32
                || *end.offset(-(1 as libc::c_int) as isize) as libc::c_int == '\t' as i32)
            {
                break;
            }
        }
        let vlen: libc::c_int = end.offset_from(v) as libc::c_long as libc::c_int;
        if !(vlen <= 0 as libc::c_int) {
            if http_header_strict != 0 {
                let x: *const libc::c_char =
                    http_request_check_line_strict(v, vlen as uint_fast32_t);
                if !x.is_null() {
                    return http_request_header_char_invalid(
                        r,
                        *x,
                        b"invalid character in header -> 400\0" as *const u8 as *const libc::c_char,
                    );
                }
            }
            let mut status: libc::c_int =
                http_request_parse_single_header(r, id, k, klen as size_t, v, vlen as size_t);
            if 0 as libc::c_int != status {
                return status;
            }
        }
        i += 1;
    }
    return 0 as libc::c_int;
}
unsafe extern "C" fn http_request_parse(
    r: *mut request_st,
    scheme_port: libc::c_int,
) -> libc::c_int {
    let mut status: libc::c_int = http_request_parse_target(r, scheme_port);
    if 0 as libc::c_int != status {
        return status;
    }
    let http_parseopts: libc::c_uint = (*r).conf.http_parseopts;
    if ((*r).http_host != 0 as *mut libc::c_void as *mut buffer) as libc::c_int as libc::c_long != 0
    {
        if 0 as libc::c_int != http_request_host_policy((*r).http_host, http_parseopts, scheme_port)
        {
            return http_request_header_line_invalid(
                r,
                400 as libc::c_int,
                b"Invalid Hostname -> 400\0" as *const u8 as *const libc::c_char,
            );
        }
        buffer_copy_buffer(&mut (*r).uri.authority, (*r).http_host);
    } else {
        buffer_copy_string_len(
            &mut (*r).uri.authority,
            b"\0" as *const u8 as *const libc::c_char,
            (::core::mem::size_of::<[libc::c_char; 1]>() as libc::c_ulong as uint32_t)
                .wrapping_sub(1 as libc::c_int as libc::c_uint) as size_t,
        );
        if (*r).http_version as libc::c_int >= HTTP_VERSION_1_1 as libc::c_int {
            return http_request_header_line_invalid(
                r,
                400 as libc::c_int,
                b"HTTP/1.1 but Host missing -> 400\0" as *const u8 as *const libc::c_char,
            );
        }
    }
    if HTTP_VERSION_1_1 as libc::c_int != (*r).http_version as libc::c_int
        && (*r).rqst_htags
            & ((1 as libc::c_ulong) << HTTP_HEADER_UPGRADE as libc::c_int
                | (1 as libc::c_ulong) << HTTP_HEADER_HTTP2_SETTINGS as libc::c_int)
            != 0
    {
        return http_request_header_line_invalid(
            r,
            400 as libc::c_int,
            b"invalid hop-by-hop header w/o HTTP/1.1 -> 400\0" as *const u8 as *const libc::c_char,
        );
    }
    if 0 as libc::c_int as libc::c_long == (*r).reqbody_length {
        if HTTP_METHOD_POST as libc::c_int == (*r).http_method as libc::c_int
            && (*r).rqst_htags & (1 as libc::c_ulong) << HTTP_HEADER_CONTENT_LENGTH as libc::c_int
                == 0
        {
            return http_request_header_line_invalid(
                r,
                411 as libc::c_int,
                b"POST-request, but content-length missing -> 411\0" as *const u8
                    as *const libc::c_char,
            );
        }
    } else {
        if -(1 as libc::c_int) as libc::c_long == (*r).reqbody_length
            && (*r).rqst_htags & (1 as libc::c_ulong) << HTTP_HEADER_CONTENT_LENGTH as libc::c_int
                != 0
        {
            let http_header_strict: libc::c_uint =
                http_parseopts & HTTP_PARSEOPT_HEADER_STRICT as libc::c_int as libc::c_uint;
            if http_header_strict != 0 {
                return http_request_header_line_invalid(
                    r,
                    400 as libc::c_int,
                    b"invalid Transfer-Encoding + Content-Length -> 400\0" as *const u8
                        as *const libc::c_char,
                );
            } else {
                http_header_request_unset(
                    r,
                    HTTP_HEADER_CONTENT_LENGTH,
                    b"Content-Length\0" as *const u8 as *const libc::c_char,
                    (::core::mem::size_of::<[libc::c_char; 15]>() as libc::c_ulong as uint32_t)
                        .wrapping_sub(1 as libc::c_int as libc::c_uint),
                );
            }
        }
        if (*r).http_method as libc::c_int <= HTTP_METHOD_HEAD as libc::c_int
            && http_parseopts & HTTP_PARSEOPT_METHOD_GET_BODY as libc::c_int as libc::c_uint == 0
        {
            return http_request_header_line_invalid(
                r,
                400 as libc::c_int,
                b"GET/HEAD with content-length -> 400\0" as *const u8 as *const libc::c_char,
            );
        }
    }
    return 0 as libc::c_int;
}
unsafe extern "C" fn http_request_parse_hoff(
    r: *mut request_st,
    hdrs: *mut libc::c_char,
    hoff: *const libc::c_ushort,
    scheme_port: libc::c_int,
) -> libc::c_int {
    let mut status: libc::c_int = 0;
    let http_parseopts: libc::c_uint = (*r).conf.http_parseopts;
    status = http_request_parse_reqline(r, hdrs, hoff, http_parseopts);
    if 0 as libc::c_int != status {
        return status;
    }
    status = http_request_parse_headers(r, hdrs, hoff, http_parseopts);
    if 0 as libc::c_int != status {
        return status;
    }
    return http_request_parse(r, scheme_port);
}
unsafe extern "C" fn http_request_headers_fin(r: *mut request_st) {
    if 0 as libc::c_int == (*r).http_status {
        (*r).conditional_is_valid = !(0 as libc::c_uint);
    } else {
        (*r).keep_alive = 0 as libc::c_int as int8_t;
        (*r).reqbody_length = 0 as libc::c_int as off_t;
    };
}
#[no_mangle]
pub unsafe extern "C" fn http_request_headers_process(
    r: *mut request_st,
    hdrs: *mut libc::c_char,
    hoff: *const libc::c_ushort,
    scheme_port: libc::c_int,
) {
    (*r).http_status = http_request_parse_hoff(r, hdrs, hoff, scheme_port);
    http_request_headers_fin(r);
    if (0 as libc::c_int != (*r).http_status) as libc::c_int as libc::c_long != 0 {
        if (*r).conf.log_request_header_on_error != 0 {
            log_error_multiline(
                (*r).conf.errh,
                b"/home/kkysen/work/rust/lighttpd/src/request.c\0" as *const u8
                    as *const libc::c_char,
                1277 as libc::c_int as libc::c_uint,
                hdrs,
                (*r).rqst_header_len as size_t,
                b"rqst: \0" as *const u8 as *const libc::c_char,
            );
        }
    }
}
#[no_mangle]
pub unsafe extern "C" fn http_request_headers_process_h2(
    r: *mut request_st,
    scheme_port: libc::c_int,
) {
    if 0 as libc::c_int == (*r).http_status {
        (*r).http_status = http_request_parse(r, scheme_port);
    }
    if 0 as libc::c_int == (*r).http_status {
        if (*r).rqst_htags & (1 as libc::c_ulong) << HTTP_HEADER_CONNECTION as libc::c_int != 0 {
            (*r).http_status = http_request_header_line_invalid(
                r,
                400 as libc::c_int,
                b"invalid Connection header with HTTP/2 -> 400\0" as *const u8
                    as *const libc::c_char,
            );
        }
    }
    http_request_headers_fin(r);
    if (0 as libc::c_int != (*r).http_status) as libc::c_int as libc::c_long != 0 {
        if (*r).conf.log_request_header_on_error != 0 {
            log_error(
                (*r).conf.errh,
                b"/home/kkysen/work/rust/lighttpd/src/request.c\0" as *const u8
                    as *const libc::c_char,
                1301 as libc::c_int as libc::c_uint,
                b"request-header:\n:authority: %s\n:method: %s\n:path: %s\0" as *const u8
                    as *const libc::c_char,
                if !((*r).http_host).is_null() {
                    (*(*r).http_host).ptr as *const libc::c_char
                } else {
                    b"\0" as *const u8 as *const libc::c_char
                },
                (*http_method_buf((*r).http_method)).ptr,
                if buffer_is_blank(&mut (*r).target) == 0 {
                    (*r).target.ptr as *const libc::c_char
                } else {
                    b"\0" as *const u8 as *const libc::c_char
                },
            );
        }
    }
    if (*r).rqst_htags & (1 as libc::c_ulong) << HTTP_HEADER_UPGRADE as libc::c_int != 0 {
        http_header_request_unset(
            r,
            HTTP_HEADER_UPGRADE,
            b"upgrade\0" as *const u8 as *const libc::c_char,
            (::core::mem::size_of::<[libc::c_char; 8]>() as libc::c_ulong as uint32_t)
                .wrapping_sub(1 as libc::c_int as libc::c_uint),
        );
    }
}
#[no_mangle]
pub unsafe extern "C" fn sock_addr_is_port_eq(
    mut saddr1: *const sock_addr,
    mut saddr2: *const sock_addr,
) -> libc::c_int {
    if sock_addr_is_family_eq(saddr1, saddr2) == 0 {
        return 0 as libc::c_int;
    }
    match (*saddr1).plain.sa_family as libc::c_int {
        2 => {
            return ((*saddr1).ipv4.sin_port as libc::c_int
                == (*saddr2).ipv4.sin_port as libc::c_int) as libc::c_int;
        }
        10 => {
            return ((*saddr1).ipv6.sin6_port as libc::c_int
                == (*saddr2).ipv6.sin6_port as libc::c_int) as libc::c_int;
        }
        1 => return 1 as libc::c_int,
        _ => return 0 as libc::c_int,
    };
}
#[no_mangle]
pub unsafe extern "C" fn sock_addr_get_port(mut saddr: *const sock_addr) -> libc::c_ushort {
    match (*saddr).plain.sa_family as libc::c_int {
        2 => return ntohs((*saddr).ipv4.sin_port),
        10 => return ntohs((*saddr).ipv6.sin6_port),
        _ => return 0 as libc::c_int as libc::c_ushort,
    };
}
#[no_mangle]
pub unsafe extern "C" fn sock_addr_is_family_eq(
    mut saddr1: *const sock_addr,
    mut saddr2: *const sock_addr,
) -> libc::c_int {
    return ((*saddr1).plain.sa_family as libc::c_int == (*saddr2).plain.sa_family as libc::c_int)
        as libc::c_int;
}
#[no_mangle]
pub unsafe extern "C" fn sock_addr_is_addr_wildcard(mut saddr: *const sock_addr) -> libc::c_int {
    match (*saddr).plain.sa_family as libc::c_int {
        2 => {
            return ((*saddr).ipv4.sin_addr.s_addr == 0 as libc::c_int as in_addr_t) as libc::c_int;
        }
        10 => {
            return (memcmp(
                &(*saddr).ipv6.sin6_addr as *const in6_addr as *const libc::c_void,
                &in6addr_any as *const in6_addr as *const libc::c_void,
                ::core::mem::size_of::<in6_addr>() as libc::c_ulong,
            ) == 0) as libc::c_int;
        }
        _ => return 0 as libc::c_int,
    };
}
#[no_mangle]
pub unsafe extern "C" fn sock_addr_is_addr_eq(
    mut saddr1: *const sock_addr,
    mut saddr2: *const sock_addr,
) -> libc::c_int {
    if sock_addr_is_family_eq(saddr1, saddr2) == 0 {
        return 0 as libc::c_int;
    }
    match (*saddr1).plain.sa_family as libc::c_int {
        2 => {
            return ((*saddr1).ipv4.sin_addr.s_addr == (*saddr2).ipv4.sin_addr.s_addr)
                as libc::c_int;
        }
        10 => {
            return (0 as libc::c_int
                == memcmp(
                    &(*saddr1).ipv6.sin6_addr as *const in6_addr as *const libc::c_void,
                    &(*saddr2).ipv6.sin6_addr as *const in6_addr as *const libc::c_void,
                    ::core::mem::size_of::<in6_addr>() as libc::c_ulong,
                )) as libc::c_int;
        }
        1 => {
            return (0 as libc::c_int
                == strcmp(
                    ((*saddr1).un.sun_path).as_ptr(),
                    ((*saddr2).un.sun_path).as_ptr(),
                )) as libc::c_int;
        }
        _ => return 0 as libc::c_int,
    };
}
#[no_mangle]
pub unsafe extern "C" fn sock_addr_is_addr_eq_bits(
    mut a: *const sock_addr,
    mut b: *const sock_addr,
    mut bits: libc::c_int,
) -> libc::c_int {
    match (*a).plain.sa_family as libc::c_int {
        2 => {
            let mut nm: uint32_t = 0;
            if bits > 32 as libc::c_int {
                bits = 32 as libc::c_int;
            }
            nm = htonl(
                !((1 as libc::c_uint)
                    << 32 as libc::c_int
                        - (if 0 as libc::c_int != bits {
                            bits
                        } else {
                            32 as libc::c_int
                        }))
                .wrapping_sub(1 as libc::c_int as libc::c_uint),
            );
            if (*b).plain.sa_family as libc::c_int == 2 as libc::c_int {
                return ((*a).ipv4.sin_addr.s_addr & nm == (*b).ipv4.sin_addr.s_addr & nm)
                    as libc::c_int;
            } else {
                if (*b).plain.sa_family as libc::c_int == 10 as libc::c_int
                    && ({
                        let mut __a: *const in6_addr = &(*b).ipv6.sin6_addr as *const in6_addr;
                        ((*__a).__in6_u.__u6_addr32[0 as libc::c_int as usize]
                            == 0 as libc::c_int as libc::c_uint
                            && (*__a).__in6_u.__u6_addr32[1 as libc::c_int as usize]
                                == 0 as libc::c_int as libc::c_uint
                            && (*__a).__in6_u.__u6_addr32[2 as libc::c_int as usize]
                                == htonl(0xffff as libc::c_int as uint32_t))
                            as libc::c_int
                    }) != 0
                {
                    let mut x: in_addr_t =
                        (*b).ipv6.sin6_addr.__in6_u.__u6_addr32[3 as libc::c_int as usize];
                    return ((*a).ipv4.sin_addr.s_addr & nm == x & nm) as libc::c_int;
                }
            }
            return 0 as libc::c_int;
        }
        10 => {
            if bits > 128 as libc::c_int {
                bits = 128 as libc::c_int;
            }
            if (*b).plain.sa_family as libc::c_int == 10 as libc::c_int {
                let mut c: *mut uint8_t = &*((*a).ipv6.sin6_addr.__in6_u.__u6_addr8)
                    .as_ptr()
                    .offset(0 as libc::c_int as isize)
                    as *const uint8_t as *mut uint8_t;
                let mut d: *mut uint8_t = &*((*b).ipv6.sin6_addr.__in6_u.__u6_addr8)
                    .as_ptr()
                    .offset(0 as libc::c_int as isize)
                    as *const uint8_t as *mut uint8_t;
                let mut match_0: libc::c_int = 0;
                loop {
                    match_0 = if bits >= 8 as libc::c_int {
                        let fresh249 = c;
                        c = c.offset(1);
                        let fresh250 = d;
                        d = d.offset(1);
                        (*fresh249 as libc::c_int == *fresh250 as libc::c_int) as libc::c_int
                    } else {
                        (*c as libc::c_int >> 8 as libc::c_int - bits
                            == *d as libc::c_int >> 8 as libc::c_int - bits)
                            as libc::c_int
                    };
                    if !(match_0 != 0 && {
                        bits -= 8 as libc::c_int;
                        bits > 0 as libc::c_int
                    }) {
                        break;
                    }
                }
                return match_0;
            } else {
                if (*b).plain.sa_family as libc::c_int == 2 as libc::c_int
                    && ({
                        let mut __a: *const in6_addr = &(*a).ipv6.sin6_addr as *const in6_addr;
                        ((*__a).__in6_u.__u6_addr32[0 as libc::c_int as usize]
                            == 0 as libc::c_int as libc::c_uint
                            && (*__a).__in6_u.__u6_addr32[1 as libc::c_int as usize]
                                == 0 as libc::c_int as libc::c_uint
                            && (*__a).__in6_u.__u6_addr32[2 as libc::c_int as usize]
                                == htonl(0xffff as libc::c_int as uint32_t))
                            as libc::c_int
                    }) != 0
                {
                    let mut nm_0: uint32_t = if bits < 128 as libc::c_int {
                        htonl(
                            !(!(0 as libc::c_uint)
                                >> (if bits > 96 as libc::c_int {
                                    bits - 96 as libc::c_int
                                } else {
                                    0 as libc::c_int
                                })),
                        )
                    } else {
                        !(0 as libc::c_uint)
                    };
                    let mut x_0: in_addr_t =
                        (*a).ipv6.sin6_addr.__in6_u.__u6_addr32[3 as libc::c_int as usize];
                    return (x_0 & nm_0 == (*b).ipv4.sin_addr.s_addr & nm_0) as libc::c_int;
                }
            }
            return 0 as libc::c_int;
        }
        _ => return 0 as libc::c_int,
    };
}
#[no_mangle]
pub unsafe extern "C" fn sock_addr_set_port(saddr: *mut sock_addr, port: libc::c_ushort) {
    match (*saddr).plain.sa_family as libc::c_int {
        2 => {
            (*saddr).ipv4.sin_port = htons(port);
        }
        10 => {
            (*saddr).ipv6.sin6_port = htons(port);
        }
        _ => {}
    };
}
#[no_mangle]
pub unsafe extern "C" fn sock_addr_assign(
    saddr: *mut sock_addr,
    mut family: libc::c_int,
    mut nport: libc::c_ushort,
    naddr: *const libc::c_void,
) -> libc::c_int {
    match family {
        2 => {
            memset(
                &mut (*saddr).ipv4 as *mut sockaddr_in as *mut libc::c_void,
                0 as libc::c_int,
                ::core::mem::size_of::<sockaddr_in>() as libc::c_ulong,
            );
            (*saddr).ipv4.sin_family = 2 as libc::c_int as sa_family_t;
            (*saddr).ipv4.sin_port = nport;
            memcpy(
                &mut (*saddr).ipv4.sin_addr as *mut in_addr as *mut libc::c_void,
                naddr,
                4 as libc::c_int as libc::c_ulong,
            );
            return 0 as libc::c_int;
        }
        10 => {
            memset(
                &mut (*saddr).ipv6 as *mut sockaddr_in6 as *mut libc::c_void,
                0 as libc::c_int,
                ::core::mem::size_of::<sockaddr_in6>() as libc::c_ulong,
            );
            (*saddr).ipv6.sin6_family = 10 as libc::c_int as sa_family_t;
            (*saddr).ipv6.sin6_port = nport;
            memcpy(
                &mut (*saddr).ipv6.sin6_addr as *mut in6_addr as *mut libc::c_void,
                naddr,
                16 as libc::c_int as libc::c_ulong,
            );
            return 0 as libc::c_int;
        }
        1 => {
            let mut len: size_t = (strlen(naddr as *mut libc::c_char))
                .wrapping_add(1 as libc::c_int as libc::c_ulong);
            if len > ::core::mem::size_of::<[libc::c_char; 108]>() as libc::c_ulong {
                *__errno_location() = 36 as libc::c_int;
                return -(1 as libc::c_int);
            }
            memset(
                &mut (*saddr).un as *mut sockaddr_un as *mut libc::c_void,
                0 as libc::c_int,
                ::core::mem::size_of::<sockaddr_un>() as libc::c_ulong,
            );
            (*saddr).un.sun_family = 1 as libc::c_int as sa_family_t;
            memcpy(
                ((*saddr).un.sun_path).as_mut_ptr() as *mut libc::c_void,
                naddr,
                len,
            );
            return 0 as libc::c_int;
        }
        _ => {
            *__errno_location() = 97 as libc::c_int;
            return -(1 as libc::c_int);
        }
    };
}
#[no_mangle]
pub unsafe extern "C" fn sock_addr_inet_pton(
    saddr: *mut sock_addr,
    str: *const libc::c_char,
    mut family: libc::c_int,
    mut port: libc::c_ushort,
) -> libc::c_int {
    match family {
        2 => {
            memset(
                &mut (*saddr).ipv4 as *mut sockaddr_in as *mut libc::c_void,
                0 as libc::c_int,
                ::core::mem::size_of::<sockaddr_in>() as libc::c_ulong,
            );
            (*saddr).ipv4.sin_family = 2 as libc::c_int as sa_family_t;
            (*saddr).ipv4.sin_port = htons(port);
            return inet_pton(
                2 as libc::c_int,
                str,
                &mut (*saddr).ipv4.sin_addr as *mut in_addr as *mut libc::c_void,
            );
        }
        10 => {
            memset(
                &mut (*saddr).ipv6 as *mut sockaddr_in6 as *mut libc::c_void,
                0 as libc::c_int,
                ::core::mem::size_of::<sockaddr_in6>() as libc::c_ulong,
            );
            (*saddr).ipv6.sin6_family = 10 as libc::c_int as sa_family_t;
            (*saddr).ipv6.sin6_port = htons(port);
            return inet_pton(
                10 as libc::c_int,
                str,
                &mut (*saddr).ipv6.sin6_addr as *mut in6_addr as *mut libc::c_void,
            );
        }
        _ => {
            *__errno_location() = 97 as libc::c_int;
            return -(1 as libc::c_int);
        }
    };
}
#[no_mangle]
pub unsafe extern "C" fn sock_addr_inet_ntop(
    saddr: *const sock_addr,
    buf: *mut libc::c_char,
    mut sz: socklen_t,
) -> *const libc::c_char {
    match (*saddr).plain.sa_family as libc::c_int {
        2 => {
            return inet_ntop(
                2 as libc::c_int,
                &(*saddr).ipv4.sin_addr as *const in_addr as *const libc::c_void,
                buf,
                sz,
            );
        }
        10 => {
            return inet_ntop(
                10 as libc::c_int,
                &(*saddr).ipv6.sin6_addr as *const in6_addr as *const libc::c_void,
                buf,
                sz,
            );
        }
        1 => return ((*saddr).un.sun_path).as_ptr(),
        _ => {
            *__errno_location() = 97 as libc::c_int;
            return 0 as *const libc::c_char;
        }
    };
}
#[no_mangle]
pub unsafe extern "C" fn sock_addr_inet_ntop_copy_buffer(
    b: *mut buffer,
    saddr: *const sock_addr,
) -> libc::c_int {
    let mut buf: [libc::c_char; 108] = [0; 108];
    let mut s: *const libc::c_char = sock_addr_inet_ntop(
        saddr,
        buf.as_mut_ptr(),
        ::core::mem::size_of::<[libc::c_char; 108]>() as libc::c_ulong as socklen_t,
    );
    if s.is_null() {
        return -(1 as libc::c_int);
    }
    buffer_copy_string(b, s);
    return 0 as libc::c_int;
}
#[no_mangle]
pub unsafe extern "C" fn sock_addr_inet_ntop_append_buffer(
    b: *mut buffer,
    saddr: *const sock_addr,
) -> libc::c_int {
    let mut buf: [libc::c_char; 108] = [0; 108];
    let mut s: *const libc::c_char = sock_addr_inet_ntop(
        saddr,
        buf.as_mut_ptr(),
        ::core::mem::size_of::<[libc::c_char; 108]>() as libc::c_ulong as socklen_t,
    );
    if s.is_null() {
        return -(1 as libc::c_int);
    }
    buffer_append_string(b, s);
    return 0 as libc::c_int;
}
#[no_mangle]
pub unsafe extern "C" fn sock_addr_stringify_append_buffer(
    b: *mut buffer,
    saddr: *const sock_addr,
) -> libc::c_int {
    match (*saddr).plain.sa_family as libc::c_int {
        2 => {
            if 0 as libc::c_int != sock_addr_inet_ntop_append_buffer(b, saddr) {
                return -(1 as libc::c_int);
            }
            buffer_append_string_len(
                b,
                b":\0" as *const u8 as *const libc::c_char,
                (::core::mem::size_of::<[libc::c_char; 2]>() as libc::c_ulong as uint32_t)
                    .wrapping_sub(1 as libc::c_int as libc::c_uint) as size_t,
            );
            buffer_append_int(b, ntohs((*saddr).ipv4.sin_port) as intmax_t);
            return 0 as libc::c_int;
        }
        10 => {
            buffer_append_string_len(
                b,
                b"[\0" as *const u8 as *const libc::c_char,
                (::core::mem::size_of::<[libc::c_char; 2]>() as libc::c_ulong as uint32_t)
                    .wrapping_sub(1 as libc::c_int as libc::c_uint) as size_t,
            );
            if 0 as libc::c_int != sock_addr_inet_ntop_append_buffer(b, saddr) {
                buffer_truncate(
                    b,
                    (buffer_clen(b)).wrapping_sub(1 as libc::c_int as libc::c_uint),
                );
                return -(1 as libc::c_int);
            }
            buffer_append_string_len(
                b,
                b"]:\0" as *const u8 as *const libc::c_char,
                (::core::mem::size_of::<[libc::c_char; 3]>() as libc::c_ulong as uint32_t)
                    .wrapping_sub(1 as libc::c_int as libc::c_uint) as size_t,
            );
            buffer_append_int(b, ntohs((*saddr).ipv6.sin6_port) as intmax_t);
            return 0 as libc::c_int;
        }
        1 => {
            buffer_append_string(b, ((*saddr).un.sun_path).as_ptr());
            return 0 as libc::c_int;
        }
        _ => return 0 as libc::c_int,
    };
}
#[no_mangle]
pub unsafe extern "C" fn sock_addr_nameinfo_append_buffer(
    b: *mut buffer,
    saddr: *const sock_addr,
    errh: *mut log_error_st,
) -> libc::c_int {
    match (*saddr).plain.sa_family as libc::c_int {
        2 => {
            let mut hbuf: [libc::c_char; 256] = [0; 256];
            let mut rc: libc::c_int = getnameinfo(
                &(*saddr).ipv4 as *const sockaddr_in as *const sockaddr,
                ::core::mem::size_of::<sockaddr_in>() as libc::c_ulong as socklen_t,
                hbuf.as_mut_ptr(),
                ::core::mem::size_of::<[libc::c_char; 256]>() as libc::c_ulong as socklen_t,
                0 as *mut libc::c_char,
                0 as libc::c_int as socklen_t,
                0 as libc::c_int,
            );
            if 0 as libc::c_int != rc {
                log_error(
                    errh,
                    b"/home/kkysen/work/rust/lighttpd/src/sock_addr.c\0" as *const u8
                        as *const libc::c_char,
                    393 as libc::c_int as libc::c_uint,
                    b"NOTICE: getnameinfo failed; using ip-address instead: %s\0" as *const u8
                        as *const libc::c_char,
                    gai_strerror(rc),
                );
                sock_addr_inet_ntop_append_buffer(b, saddr);
            } else {
                buffer_append_string(b, hbuf.as_mut_ptr());
            }
            return 0 as libc::c_int;
        }
        10 => {
            let mut hbuf_0: [libc::c_char; 256] = [0; 256];
            let mut rc_0: libc::c_int = getnameinfo(
                &(*saddr).ipv6 as *const sockaddr_in6 as *const sockaddr,
                ::core::mem::size_of::<sockaddr_in6>() as libc::c_ulong as socklen_t,
                hbuf_0.as_mut_ptr(),
                ::core::mem::size_of::<[libc::c_char; 256]>() as libc::c_ulong as socklen_t,
                0 as *mut libc::c_char,
                0 as libc::c_int as socklen_t,
                0 as libc::c_int,
            );
            if 0 as libc::c_int != rc_0 {
                log_error(
                    errh,
                    b"/home/kkysen/work/rust/lighttpd/src/sock_addr.c\0" as *const u8
                        as *const libc::c_char,
                    410 as libc::c_int as libc::c_uint,
                    b"NOTICE: getnameinfo failed; using ip-address instead: %s\0" as *const u8
                        as *const libc::c_char,
                    gai_strerror(rc_0),
                );
                buffer_append_string_len(
                    b,
                    b"[\0" as *const u8 as *const libc::c_char,
                    (::core::mem::size_of::<[libc::c_char; 2]>() as libc::c_ulong as uint32_t)
                        .wrapping_sub(1 as libc::c_int as libc::c_uint)
                        as size_t,
                );
                sock_addr_inet_ntop_append_buffer(b, saddr);
                buffer_append_string_len(
                    b,
                    b"]\0" as *const u8 as *const libc::c_char,
                    (::core::mem::size_of::<[libc::c_char; 2]>() as libc::c_ulong as uint32_t)
                        .wrapping_sub(1 as libc::c_int as libc::c_uint)
                        as size_t,
                );
            } else {
                buffer_append_string(b, hbuf_0.as_mut_ptr());
            }
            return 0 as libc::c_int;
        }
        _ => {
            log_error(
                errh,
                b"/home/kkysen/work/rust/lighttpd/src/sock_addr.c\0" as *const u8
                    as *const libc::c_char,
                424 as libc::c_int as libc::c_uint,
                b"ERROR: unsupported address-type\0" as *const u8 as *const libc::c_char,
            );
            return -(1 as libc::c_int);
        }
    };
}
#[no_mangle]
pub unsafe extern "C" fn sock_addr_from_str_hints(
    saddr: *mut sock_addr,
    len: *mut socklen_t,
    str: *const libc::c_char,
    mut family: libc::c_int,
    mut port: libc::c_ushort,
    errh: *mut log_error_st,
) -> libc::c_int {
    match family {
        0 => {
            if 0 as libc::c_int == strcmp(str, b"localhost\0" as *const u8 as *const libc::c_char) {
                memset(
                    saddr as *mut libc::c_void,
                    0 as libc::c_int,
                    ::core::mem::size_of::<sockaddr_in>() as libc::c_ulong,
                );
                (*saddr).ipv4.sin_family = 2 as libc::c_int as sa_family_t;
                (*saddr).ipv4.sin_addr.s_addr = htonl(0x7f000001 as libc::c_int as in_addr_t);
                (*saddr).ipv4.sin_port = htons(port);
                *len = ::core::mem::size_of::<sockaddr_in>() as libc::c_ulong as socklen_t;
                return 1 as libc::c_int;
            } else {
                let mut hints: addrinfo = addrinfo {
                    ai_flags: 0,
                    ai_family: 0,
                    ai_socktype: 0,
                    ai_protocol: 0,
                    ai_addrlen: 0,
                    ai_addr: 0 as *mut sockaddr,
                    ai_canonname: 0 as *mut libc::c_char,
                    ai_next: 0 as *mut addrinfo,
                };
                let mut res: *mut addrinfo = 0 as *mut addrinfo;
                let mut rc: libc::c_int = 0;
                memset(
                    &mut hints as *mut addrinfo as *mut libc::c_void,
                    0 as libc::c_int,
                    ::core::mem::size_of::<addrinfo>() as libc::c_ulong,
                );
                hints.ai_family = 0 as libc::c_int;
                hints.ai_socktype = SOCK_STREAM as libc::c_int;
                hints.ai_protocol = IPPROTO_TCP as libc::c_int;
                rc = getaddrinfo(str, 0 as *const libc::c_char, &mut hints, &mut res);
                if 0 as libc::c_int != rc {
                    log_error(
                        errh,
                        b"/home/kkysen/work/rust/lighttpd/src/sock_addr.c\0" as *const u8
                            as *const libc::c_char,
                        454 as libc::c_int as libc::c_uint,
                        b"getaddrinfo failed: %s '%s'\0" as *const u8 as *const libc::c_char,
                        gai_strerror(rc),
                        str,
                    );
                    return 0 as libc::c_int;
                }
                memcpy(
                    saddr as *mut libc::c_void,
                    (*res).ai_addr as *const libc::c_void,
                    (*res).ai_addrlen as libc::c_ulong,
                );
                freeaddrinfo(res);
                if 10 as libc::c_int == (*saddr).plain.sa_family as libc::c_int {
                    (*saddr).ipv6.sin6_port = htons(port);
                    *len = ::core::mem::size_of::<sockaddr_in6>() as libc::c_ulong as socklen_t;
                } else {
                    (*saddr).ipv4.sin_port = htons(port);
                    *len = ::core::mem::size_of::<sockaddr_in>() as libc::c_ulong as socklen_t;
                }
                return 1 as libc::c_int;
            }
        }
        10 => {
            memset(
                saddr as *mut libc::c_void,
                0 as libc::c_int,
                ::core::mem::size_of::<sockaddr_in6>() as libc::c_ulong,
            );
            (*saddr).ipv6.sin6_family = 10 as libc::c_int as sa_family_t;
            if 0 as libc::c_int == strcmp(str, b"::\0" as *const u8 as *const libc::c_char) {
                (*saddr).ipv6.sin6_addr = in6addr_any;
            } else if 0 as libc::c_int == strcmp(str, b"::1\0" as *const u8 as *const libc::c_char)
            {
                (*saddr).ipv6.sin6_addr = in6addr_loopback;
            } else {
                let mut hints_0: addrinfo = addrinfo {
                    ai_flags: 0,
                    ai_family: 0,
                    ai_socktype: 0,
                    ai_protocol: 0,
                    ai_addrlen: 0,
                    ai_addr: 0 as *mut sockaddr,
                    ai_canonname: 0 as *mut libc::c_char,
                    ai_next: 0 as *mut addrinfo,
                };
                let mut res_0: *mut addrinfo = 0 as *mut addrinfo;
                let mut rc_0: libc::c_int = 0;
                memset(
                    &mut hints_0 as *mut addrinfo as *mut libc::c_void,
                    0 as libc::c_int,
                    ::core::mem::size_of::<addrinfo>() as libc::c_ulong,
                );
                hints_0.ai_family = 10 as libc::c_int;
                hints_0.ai_socktype = SOCK_STREAM as libc::c_int;
                hints_0.ai_protocol = IPPROTO_TCP as libc::c_int;
                rc_0 = getaddrinfo(str, 0 as *const libc::c_char, &mut hints_0, &mut res_0);
                if 0 as libc::c_int != rc_0 {
                    hints_0.ai_family = 2 as libc::c_int;
                    if -(9 as libc::c_int) == rc_0
                        && 0 as libc::c_int
                            == getaddrinfo(str, 0 as *const libc::c_char, &mut hints_0, &mut res_0)
                    {
                        memcpy(
                            saddr as *mut libc::c_void,
                            (*res_0).ai_addr as *const libc::c_void,
                            (*res_0).ai_addrlen as libc::c_ulong,
                        );
                        (*saddr).ipv4.sin_family = 2 as libc::c_int as sa_family_t;
                        (*saddr).ipv4.sin_port = htons(port);
                        *len = ::core::mem::size_of::<sockaddr_in>() as libc::c_ulong as socklen_t;
                        freeaddrinfo(res_0);
                        return 1 as libc::c_int;
                    }
                    log_error(
                        errh,
                        b"/home/kkysen/work/rust/lighttpd/src/sock_addr.c\0" as *const u8
                            as *const libc::c_char,
                        510 as libc::c_int as libc::c_uint,
                        b"getaddrinfo failed: %s '%s'\0" as *const u8 as *const libc::c_char,
                        gai_strerror(rc_0),
                        str,
                    );
                    return 0 as libc::c_int;
                }
                memcpy(
                    saddr as *mut libc::c_void,
                    (*res_0).ai_addr as *const libc::c_void,
                    (*res_0).ai_addrlen as libc::c_ulong,
                );
                freeaddrinfo(res_0);
            }
            (*saddr).ipv6.sin6_port = htons(port);
            *len = ::core::mem::size_of::<sockaddr_in6>() as libc::c_ulong as socklen_t;
            return 1 as libc::c_int;
        }
        2 => {
            memset(
                saddr as *mut libc::c_void,
                0 as libc::c_int,
                ::core::mem::size_of::<sockaddr_in>() as libc::c_ulong,
            );
            (*saddr).ipv4.sin_family = 2 as libc::c_int as sa_family_t;
            if 0 as libc::c_int == strcmp(str, b"0.0.0.0\0" as *const u8 as *const libc::c_char) {
                (*saddr).ipv4.sin_addr.s_addr = htonl(0 as libc::c_int as in_addr_t);
            } else if 0 as libc::c_int
                == strcmp(str, b"127.0.0.1\0" as *const u8 as *const libc::c_char)
            {
                (*saddr).ipv4.sin_addr.s_addr = htonl(0x7f000001 as libc::c_int as in_addr_t);
            } else {
                let mut hints_1: addrinfo = addrinfo {
                    ai_flags: 0,
                    ai_family: 0,
                    ai_socktype: 0,
                    ai_protocol: 0,
                    ai_addrlen: 0,
                    ai_addr: 0 as *mut sockaddr,
                    ai_canonname: 0 as *mut libc::c_char,
                    ai_next: 0 as *mut addrinfo,
                };
                let mut res_1: *mut addrinfo = 0 as *mut addrinfo;
                let mut rc_1: libc::c_int = 0;
                memset(
                    &mut hints_1 as *mut addrinfo as *mut libc::c_void,
                    0 as libc::c_int,
                    ::core::mem::size_of::<addrinfo>() as libc::c_ulong,
                );
                hints_1.ai_family = 2 as libc::c_int;
                hints_1.ai_socktype = SOCK_STREAM as libc::c_int;
                hints_1.ai_protocol = IPPROTO_TCP as libc::c_int;
                rc_1 = getaddrinfo(str, 0 as *const libc::c_char, &mut hints_1, &mut res_1);
                if 0 as libc::c_int != rc_1 {
                    log_error(
                        errh,
                        b"/home/kkysen/work/rust/lighttpd/src/sock_addr.c\0" as *const u8
                            as *const libc::c_char,
                        543 as libc::c_int as libc::c_uint,
                        b"getaddrinfo failed: %s '%s'\0" as *const u8 as *const libc::c_char,
                        gai_strerror(rc_1),
                        str,
                    );
                    return 0 as libc::c_int;
                }
                memcpy(
                    saddr as *mut libc::c_void,
                    (*res_1).ai_addr as *const libc::c_void,
                    (*res_1).ai_addrlen as libc::c_ulong,
                );
                freeaddrinfo(res_1);
            }
            (*saddr).ipv4.sin_port = htons(port);
            *len = ::core::mem::size_of::<sockaddr_in>() as libc::c_ulong as socklen_t;
            return 1 as libc::c_int;
        }
        1 => {
            memset(
                saddr as *mut libc::c_void,
                0 as libc::c_int,
                ::core::mem::size_of::<sockaddr_un>() as libc::c_ulong,
            );
            (*saddr).un.sun_family = 1 as libc::c_int as sa_family_t;
            let mut hostlen: size_t = (strlen(str)).wrapping_add(1 as libc::c_int as libc::c_ulong);
            if hostlen > ::core::mem::size_of::<[libc::c_char; 108]>() as libc::c_ulong {
                log_error(
                    errh,
                    b"/home/kkysen/work/rust/lighttpd/src/sock_addr.c\0" as *const u8
                        as *const libc::c_char,
                    584 as libc::c_int as libc::c_uint,
                    b"unix socket filename too long: %s\0" as *const u8 as *const libc::c_char,
                    str,
                );
                return 0 as libc::c_int;
            }
            memcpy(
                ((*saddr).un.sun_path).as_mut_ptr() as *mut libc::c_void,
                str as *const libc::c_void,
                hostlen,
            );
            *len = (((*(0 as *mut sockaddr_un)).sun_path).as_mut_ptr() as size_t)
                .wrapping_add(strlen(((*saddr).un.sun_path).as_mut_ptr()))
                .wrapping_add(1 as libc::c_int as libc::c_ulong) as socklen_t;
            return 1 as libc::c_int;
        }
        _ => {
            log_error(
                errh,
                b"/home/kkysen/work/rust/lighttpd/src/sock_addr.c\0" as *const u8
                    as *const libc::c_char,
                604 as libc::c_int as libc::c_uint,
                b"address family unsupported: %d\0" as *const u8 as *const libc::c_char,
                family,
            );
            return 0 as libc::c_int;
        }
    };
}
#[no_mangle]
pub unsafe extern "C" fn sock_addr_from_str_numeric(
    saddr: *mut sock_addr,
    str: *const libc::c_char,
    errh: *mut log_error_st,
) -> libc::c_int {
    let mut hints: addrinfo = addrinfo {
        ai_flags: 0,
        ai_family: 0,
        ai_socktype: 0,
        ai_protocol: 0,
        ai_addrlen: 0,
        ai_addr: 0 as *mut sockaddr,
        ai_canonname: 0 as *mut libc::c_char,
        ai_next: 0 as *mut addrinfo,
    };
    let mut addrlist: *mut addrinfo = 0 as *mut addrinfo;
    let mut result: libc::c_int = 0;
    memset(
        &mut hints as *mut addrinfo as *mut libc::c_void,
        0 as libc::c_int,
        ::core::mem::size_of::<addrinfo>() as libc::c_ulong,
    );
    hints.ai_flags = 0x4 as libc::c_int | 0x400 as libc::c_int;
    *__errno_location() = 0 as libc::c_int;
    result = getaddrinfo(str, 0 as *const libc::c_char, &mut hints, &mut addrlist);
    if result != 0 as libc::c_int {
        log_perror(
            errh,
            b"/home/kkysen/work/rust/lighttpd/src/sock_addr.c\0" as *const u8
                as *const libc::c_char,
            638 as libc::c_int as libc::c_uint,
            b"could not parse ip address %s because %s\0" as *const u8 as *const libc::c_char,
            str,
            gai_strerror(result),
        );
        return result;
    } else {
        if addrlist.is_null() {
            log_error(
                errh,
                b"/home/kkysen/work/rust/lighttpd/src/sock_addr.c\0" as *const u8
                    as *const libc::c_char,
                643 as libc::c_int as libc::c_uint,
                b"Problem in parsing ip address %s:succeeded, but no information returned\0"
                    as *const u8 as *const libc::c_char,
                str,
            );
            return -(1 as libc::c_int);
        } else {
            match (*addrlist).ai_family {
                2 => {
                    memcpy(
                        &mut (*saddr).ipv4 as *mut sockaddr_in as *mut libc::c_void,
                        (*addrlist).ai_addr as *const libc::c_void,
                        ::core::mem::size_of::<sockaddr_in>() as libc::c_ulong,
                    );
                    if !(2 as libc::c_int == (*saddr).plain.sa_family as libc::c_int) {
                        ck_assert_failed(
                            b"/home/kkysen/work/rust/lighttpd/src/sock_addr.c\0" as *const u8
                                as *const libc::c_char,
                            650 as libc::c_int as libc::c_uint,
                            b"2 == saddr->plain.sa_family\0" as *const u8 as *const libc::c_char,
                        );
                    }
                }
                10 => {
                    memcpy(
                        &mut (*saddr).ipv6 as *mut sockaddr_in6 as *mut libc::c_void,
                        (*addrlist).ai_addr as *const libc::c_void,
                        ::core::mem::size_of::<sockaddr_in6>() as libc::c_ulong,
                    );
                    if !(10 as libc::c_int == (*saddr).plain.sa_family as libc::c_int) {
                        ck_assert_failed(
                            b"/home/kkysen/work/rust/lighttpd/src/sock_addr.c\0" as *const u8
                                as *const libc::c_char,
                            654 as libc::c_int as libc::c_uint,
                            b"10 == saddr->plain.sa_family\0" as *const u8 as *const libc::c_char,
                        );
                    }
                }
                _ => {
                    log_error(
                        errh,
                        b"/home/kkysen/work/rust/lighttpd/src/sock_addr.c\0" as *const u8
                            as *const libc::c_char,
                        657 as libc::c_int as libc::c_uint,
                        b"Problem in parsing ip address %s:succeeded, but unknown family\0"
                            as *const u8 as *const libc::c_char,
                        str,
                    );
                    result = -(1 as libc::c_int);
                }
            }
        }
    }
    freeaddrinfo(addrlist);
    return (0 as libc::c_int == result) as libc::c_int;
}
#[no_mangle]
pub unsafe extern "C" fn li_rand_pseudo_bytes(mut buf: *mut libc::c_uchar, mut num: libc::c_int) {
    if li_rand_inited == 0 {
        li_rand_init();
    }
    let mut i: libc::c_int = 0 as libc::c_int;
    while i < num {
        *buf.offset(i as isize) = (li_rand_pseudo() & 0xff as libc::c_int) as libc::c_uchar;
        i += 1;
    }
}
unsafe extern "C" fn li_rand_device_bytes(
    mut buf: *mut libc::c_uchar,
    mut num: libc::c_int,
) -> libc::c_int {
    static mut devices: [*const libc::c_char; 2] = [
        b"/dev/urandom\0" as *const u8 as *const libc::c_char,
        b"/dev/random\0" as *const u8 as *const libc::c_char,
    ];
    if 0 as libc::c_int == li_getentropy(buf as *mut libc::c_void, num as size_t) {
        return 1 as libc::c_int;
    }
    let mut u: libc::c_uint = 0 as libc::c_int as libc::c_uint;
    while (u as libc::c_ulong)
        < (::core::mem::size_of::<[*const libc::c_char; 2]>() as libc::c_ulong)
            .wrapping_div(::core::mem::size_of::<*const libc::c_char>() as libc::c_ulong)
    {
        let mut fd: libc::c_int = fdevent_open_cloexec(
            devices[u as usize],
            1 as libc::c_int,
            0 as libc::c_int,
            0 as libc::c_int as mode_t,
        );
        if fd >= 0 as libc::c_int {
            let mut rd: ssize_t = 0 as libc::c_int as ssize_t;
            let mut entropy: libc::c_int = 0;
            if 0 as libc::c_int
                == ioctl(
                    fd,
                    ((2 as libc::c_uint)
                        << 0 as libc::c_int
                            + 8 as libc::c_int
                            + 8 as libc::c_int
                            + 14 as libc::c_int
                        | (('R' as i32) << 0 as libc::c_int + 8 as libc::c_int) as libc::c_uint
                        | ((0 as libc::c_int) << 0 as libc::c_int) as libc::c_uint)
                        as libc::c_ulong
                        | (::core::mem::size_of::<libc::c_int>() as libc::c_ulong)
                            << 0 as libc::c_int + 8 as libc::c_int + 8 as libc::c_int,
                    &mut entropy as *mut libc::c_int,
                )
                && entropy >= num * 8 as libc::c_int
            {
                rd = read(fd, buf as *mut libc::c_void, num as size_t);
            }
            close(fd);
            if rd == num as libc::c_long {
                return 1 as libc::c_int;
            }
        }
        u = u.wrapping_add(1);
    }
    return 0 as libc::c_int;
}
unsafe extern "C" fn li_getentropy(mut buf: *mut libc::c_void, mut buflen: size_t) -> libc::c_int {
    return getentropy(buf, buflen);
}
#[cold]
unsafe extern "C" fn li_rand_init() {
    let mut u: libc::c_uint = 0;
    li_rand_inited = 1 as libc::c_int;
    if 1 as libc::c_int
        == li_rand_device_bytes(
            xsubi.as_mut_ptr() as *mut libc::c_uchar,
            ::core::mem::size_of::<[libc::c_ushort; 3]>() as libc::c_ulong as libc::c_int,
        )
    {
        u = (xsubi[0 as libc::c_int as usize] as libc::c_uint) << 16 as libc::c_int
            | xsubi[1 as libc::c_int as usize] as libc::c_uint;
    } else {
        srand((time(0 as *mut time_t) ^ getpid() as libc::c_long) as libc::c_uint);
        u = 0 as libc::c_int as libc::c_uint;
        while (u as libc::c_ulong) < ::core::mem::size_of::<libc::c_ushort>() as libc::c_ulong {
            xsubi[u as usize] = (rand() & 0xffff as libc::c_int) as libc::c_ushort;
            u = u.wrapping_add(1);
        }
        u = (xsubi[0 as libc::c_int as usize] as libc::c_uint) << 16 as libc::c_int
            | xsubi[1 as libc::c_int as usize] as libc::c_uint;
    }
    srand(u);
    srandom(u);
}
#[no_mangle]
pub unsafe extern "C" fn li_rand_pseudo() -> libc::c_int {
    if li_rand_inited == 0 {
        li_rand_init();
    }
    return random() as libc::c_int;
}
static mut li_rand_inited: libc::c_int = 0;
#[no_mangle]
pub unsafe extern "C" fn li_rand_reseed() {
    if li_rand_inited != 0 {
        li_rand_init();
    }
}
static mut xsubi: [libc::c_ushort; 3] = [0; 3];
#[no_mangle]
pub unsafe extern "C" fn li_rand_bytes(
    mut buf: *mut libc::c_uchar,
    mut num: libc::c_int,
) -> libc::c_int {
    if 1 as libc::c_int == li_rand_device_bytes(buf, num) {
        return 1 as libc::c_int;
    } else {
        li_rand_pseudo_bytes(buf, num);
        return 0 as libc::c_int;
    };
}
#[no_mangle]
pub unsafe extern "C" fn li_rand_cleanup() {
    ck_memzero(
        xsubi.as_mut_ptr() as *mut libc::c_void,
        ::core::mem::size_of::<[libc::c_ushort; 3]>() as libc::c_ulong,
    );
}
static mut fdlog_files: fdlog_files_t = fdlog_files_t {
    ptr: 0 as *const *mut fdlog_st as *mut *mut fdlog_st,
    used: 0,
    size: 0,
};
static mut fdlog_pipes: fdlog_pipes_t = fdlog_pipes_t {
    ptr: 0 as *const fdlog_pipe as *mut fdlog_pipe,
    used: 0,
    size: 0,
};
unsafe extern "C" fn fdlog_pipe_spawn(fn_0: *const libc::c_char, rfd: libc::c_int) -> pid_t {
    let mut args: [*mut libc::c_char; 4] = [0 as *mut libc::c_char; 4];
    let mut devnull: libc::c_int = fdevent_open_devnull();
    let mut pid: pid_t = 0;
    if -(1 as libc::c_int) == devnull {
        return -(1 as libc::c_int);
    }
    let ref mut fresh251 = *(&mut *args.as_mut_ptr().offset(0 as libc::c_int as isize)
        as *mut *mut libc::c_char as *mut *const libc::c_char);
    *fresh251 = b"/bin/sh\0" as *const u8 as *const libc::c_char;
    let ref mut fresh252 = *(&mut *args.as_mut_ptr().offset(1 as libc::c_int as isize)
        as *mut *mut libc::c_char as *mut *const libc::c_char);
    *fresh252 = b"-c\0" as *const u8 as *const libc::c_char;
    let ref mut fresh253 = *(&mut *args.as_mut_ptr().offset(2 as libc::c_int as isize)
        as *mut *mut libc::c_char as *mut *const libc::c_char);
    *fresh253 = fn_0;
    args[3 as libc::c_int as usize] = 0 as *mut libc::c_char;
    pid = fdevent_fork_execve(
        args[0 as libc::c_int as usize],
        args.as_mut_ptr(),
        0 as *mut *mut libc::c_char,
        rfd,
        devnull,
        devnull,
        -(1 as libc::c_int),
    );
    if pid > 0 as libc::c_int {
        close(devnull);
    } else {
        let mut errnum: libc::c_int = *__errno_location();
        close(devnull);
        *__errno_location() = errnum;
    }
    return pid;
}
#[inline(never)]
unsafe extern "C" fn fdlog_pipe_restart(fdp: *mut fdlog_pipe, ts: unix_time64_t) -> libc::c_int {
    if ((*fdp).start + 5 as libc::c_int as libc::c_long) < ts {
        (*fdp).start = ts;
        (*fdp).pid = fdlog_pipe_spawn((*(*fdp).fdlog).fn_0, (*fdp).fd);
    }
    return if (*fdp).pid > 0 as libc::c_int {
        1 as libc::c_int
    } else {
        -(1 as libc::c_int)
    };
}
#[no_mangle]
#[cold]
pub unsafe extern "C" fn fdlog_pipes_restart(ts: unix_time64_t) {
    let mut i: uint32_t = 0 as libc::c_int as uint32_t;
    while i < fdlog_pipes.used {
        let fdp: *mut fdlog_pipe = (fdlog_pipes.ptr).offset(i as isize);
        if !((*fdp).pid > 0 as libc::c_int) {
            fdlog_pipe_restart(fdp, ts);
        }
        i = i.wrapping_add(1);
    }
}
#[no_mangle]
#[cold]
pub unsafe extern "C" fn fdlog_pipes_waitpid_cb(pid: pid_t) -> libc::c_int {
    let mut i: uint32_t = 0 as libc::c_int as uint32_t;
    while i < fdlog_pipes.used {
        let fdp: *mut fdlog_pipe = (fdlog_pipes.ptr).offset(i as isize);
        if (*fdp).pid != pid {
            i = i.wrapping_add(1);
        } else {
            (*fdp).pid = -(1 as libc::c_int);
            return fdlog_pipe_restart(fdp, log_monotonic_secs);
        }
    }
    return 0 as libc::c_int;
}
unsafe extern "C" fn fdlog_pipes_close(retain: *mut fdlog_st) {
    let mut i: uint32_t = 0 as libc::c_int as uint32_t;
    while i < fdlog_pipes.used {
        let fdp: *mut fdlog_pipe = (fdlog_pipes.ptr).offset(i as isize);
        let fdlog: *mut fdlog_st = (*fdp).fdlog;
        close((*fdp).fd);
        (*fdp).fd = -(1 as libc::c_int);
        if !(fdlog == retain) {
            fdlog_free(fdlog);
        }
        i = i.wrapping_add(1);
    }
    free(fdlog_pipes.ptr as *mut libc::c_void);
    fdlog_pipes.ptr = 0 as *mut fdlog_pipe;
    fdlog_pipes.used = 0 as libc::c_int as uint32_t;
    fdlog_pipes.size = 0 as libc::c_int as uint32_t;
}
#[no_mangle]
#[cold]
pub unsafe extern "C" fn fdlog_pipes_abandon_pids() {
    let mut i: uint32_t = 0 as libc::c_int as uint32_t;
    while i < fdlog_pipes.used {
        let fdp: *mut fdlog_pipe = (fdlog_pipes.ptr).offset(i as isize);
        (*fdp).pid = -(1 as libc::c_int);
        i = i.wrapping_add(1);
    }
}
#[no_mangle]
#[cold]
pub unsafe extern "C" fn fdlog_pipe_serrh(fd: libc::c_int) {
    let mut i: uint32_t = 0 as libc::c_int as uint32_t;
    while i < fdlog_pipes.used {
        let fdlog: *mut fdlog_st = (*(fdlog_pipes.ptr).offset(i as isize)).fdlog;
        if (*fdlog).fd != fd {
            i = i.wrapping_add(1);
        } else {
            (*fdlog).fd = 2 as libc::c_int;
            break;
        }
    }
}
unsafe extern "C" fn fdlog_pipe_init(
    fn_0: *const libc::c_char,
    mut fds: *const libc::c_int,
    pid: pid_t,
) -> *mut fdlog_st {
    if fdlog_pipes.used == fdlog_pipes.size {
        fdlog_pipes.size = (fdlog_pipes.size as libc::c_uint)
            .wrapping_add(4 as libc::c_int as libc::c_uint) as uint32_t
            as uint32_t;
        fdlog_pipes.ptr = realloc(
            fdlog_pipes.ptr as *mut libc::c_void,
            (fdlog_pipes.size as libc::c_ulong)
                .wrapping_mul(::core::mem::size_of::<fdlog_pipe>() as libc::c_ulong),
        ) as *mut fdlog_pipe;
        if (fdlog_pipes.ptr).is_null() {
            ck_assert_failed(
                b"/home/kkysen/work/rust/lighttpd/src/fdlog_maint.c\0" as *const u8
                    as *const libc::c_char,
                173 as libc::c_int as libc::c_uint,
                b"fdlog_pipes.ptr\0" as *const u8 as *const libc::c_char,
            );
        }
    }
    let fresh254 = fdlog_pipes.used;
    fdlog_pipes.used = (fdlog_pipes.used).wrapping_add(1);
    let fdp: *mut fdlog_pipe = (fdlog_pipes.ptr).offset(fresh254 as isize);
    (*fdp).fd = *fds.offset(0 as libc::c_int as isize);
    (*fdp).pid = pid;
    (*fdp).start = log_monotonic_secs;
    (*fdp).fdlog = fdlog_init(
        fn_0,
        *fds.offset(1 as libc::c_int as isize),
        FDLOG_PIPE as libc::c_int,
    );
    return (*fdp).fdlog;
}
unsafe extern "C" fn fdlog_pipe_open(fn_0: *const libc::c_char) -> *mut fdlog_st {
    let mut i: uint32_t = 0 as libc::c_int as uint32_t;
    while i < fdlog_pipes.used {
        let fdlog: *mut fdlog_st = (*(fdlog_pipes.ptr).offset(i as isize)).fdlog;
        if 0 as libc::c_int != strcmp((*fdlog).fn_0, fn_0) {
            i = i.wrapping_add(1);
        } else {
            return fdlog;
        }
    }
    let mut fds: [libc::c_int; 2] = [0; 2];
    if fdevent_pipe_cloexec(fds.as_mut_ptr(), 65536 as libc::c_int as libc::c_uint) != 0 {
        return 0 as *mut fdlog_st;
    }
    let mut pid: pid_t = fdlog_pipe_spawn(fn_0, fds[0 as libc::c_int as usize]);
    if pid > 0 as libc::c_int {
        0 as libc::c_int != fdevent_fcntl_set_nb(fds[1 as libc::c_int as usize]);
        return fdlog_pipe_init(fn_0, fds.as_mut_ptr() as *const libc::c_int, pid);
    } else {
        let mut errnum: libc::c_int = *__errno_location();
        close(fds[0 as libc::c_int as usize]);
        close(fds[1 as libc::c_int as usize]);
        *__errno_location() = errnum;
        return 0 as *mut fdlog_st;
    };
}
unsafe extern "C" fn fdlog_file_init(fn_0: *const libc::c_char, fd: libc::c_int) -> *mut fdlog_st {
    if fdlog_files.used == fdlog_files.size {
        fdlog_files.size = (fdlog_files.size as libc::c_uint)
            .wrapping_add(4 as libc::c_int as libc::c_uint) as uint32_t
            as uint32_t;
        fdlog_files.ptr = realloc(
            fdlog_files.ptr as *mut libc::c_void,
            (fdlog_files.size as libc::c_ulong)
                .wrapping_mul(::core::mem::size_of::<*mut fdlog_st>() as libc::c_ulong),
        ) as *mut *mut fdlog_st;
        if (fdlog_files.ptr).is_null() {
            ck_assert_failed(
                b"/home/kkysen/work/rust/lighttpd/src/fdlog_maint.c\0" as *const u8
                    as *const libc::c_char,
                219 as libc::c_int as libc::c_uint,
                b"fdlog_files.ptr\0" as *const u8 as *const libc::c_char,
            );
        }
    }
    let fresh255 = fdlog_files.used;
    fdlog_files.used = (fdlog_files.used).wrapping_add(1);
    let ref mut fresh256 = *(fdlog_files.ptr).offset(fresh255 as isize);
    *fresh256 = fdlog_init(fn_0, fd, FDLOG_FILE as libc::c_int);
    return *fresh256;
}
unsafe extern "C" fn fdlog_file_open_fd(fn_0: *const libc::c_char) -> libc::c_int {
    let mut flags: libc::c_int = 0o2000 as libc::c_int | 0o1 as libc::c_int | 0o100 as libc::c_int;
    return fdevent_open_cloexec(
        fn_0,
        1 as libc::c_int,
        flags,
        0o644 as libc::c_int as mode_t,
    );
}
unsafe extern "C" fn fdlog_file_open(fn_0: *const libc::c_char) -> *mut fdlog_st {
    let mut i: uint32_t = 0 as libc::c_int as uint32_t;
    while i < fdlog_files.used {
        let fdlog: *mut fdlog_st = *(fdlog_files.ptr).offset(i as isize);
        if 0 as libc::c_int != strcmp((*fdlog).fn_0, fn_0) {
            i = i.wrapping_add(1);
        } else {
            return fdlog;
        }
    }
    let mut fd: libc::c_int = fdlog_file_open_fd(fn_0);
    return if -(1 as libc::c_int) != fd {
        fdlog_file_init(fn_0, fd)
    } else {
        0 as *mut fdlog_st
    };
}
#[no_mangle]
#[cold]
pub unsafe extern "C" fn fdlog_open(fn_0: *const libc::c_char) -> *mut fdlog_st {
    return if *fn_0.offset(0 as libc::c_int as isize) as libc::c_int != '|' as i32 {
        fdlog_file_open(fn_0)
    } else {
        fdlog_pipe_open(fn_0.offset(1 as libc::c_int as isize))
    };
}
#[no_mangle]
#[cold]
pub unsafe extern "C" fn fdlog_files_flush(errh: *mut fdlog_st, memrel: libc::c_int) {
    let mut i: uint32_t = 0 as libc::c_int as uint32_t;
    while i < fdlog_files.used {
        let fdlog: *mut fdlog_st = *(fdlog_files.ptr).offset(i as isize);
        let b: *mut buffer = &mut (*fdlog).b;
        if buffer_is_blank(b) == 0 {
            let wr: ssize_t = write_all(
                (*fdlog).fd,
                (*b).ptr as *const libc::c_void,
                buffer_clen(b) as size_t,
            );
            buffer_clear(b);
            if -(1 as libc::c_int) as libc::c_long == wr {
                log_perror(
                    errh,
                    b"/home/kkysen/work/rust/lighttpd/src/fdlog_maint.c\0" as *const u8
                        as *const libc::c_char,
                    266 as libc::c_int as libc::c_uint,
                    b"error flushing log %s\0" as *const u8 as *const libc::c_char,
                    (*fdlog).fn_0,
                );
            }
        }
        if memrel != 0 && !((*b).ptr).is_null() {
            buffer_free_ptr(b);
        }
        i = i.wrapping_add(1);
    }
}
#[no_mangle]
#[cold]
pub unsafe extern "C" fn fdlog_files_cycle(errh: *mut fdlog_st) {
    fdlog_files_flush(errh, 0 as libc::c_int);
    let mut i: uint32_t = 0 as libc::c_int as uint32_t;
    while i < fdlog_files.used {
        let fdlog: *mut fdlog_st = *(fdlog_files.ptr).offset(i as isize);
        let mut fd: libc::c_int = fdlog_file_open_fd((*fdlog).fn_0);
        if -(1 as libc::c_int) != fd {
            if (*fdlog).fd > 2 as libc::c_int {
                close((*fdlog).fd);
                (*fdlog).fd = fd;
            } else {
                if (*fdlog).fd != dup2(fd, (*fdlog).fd) {
                    log_perror(
                        errh,
                        b"/home/kkysen/work/rust/lighttpd/src/fdlog_maint.c\0" as *const u8
                            as *const libc::c_char,
                        288 as libc::c_int as libc::c_uint,
                        b"dup2() %s to %d\0" as *const u8 as *const libc::c_char,
                        (*fdlog).fn_0,
                        (*fdlog).fd,
                    );
                }
                close(fd);
            }
        } else {
            log_perror(
                errh,
                b"/home/kkysen/work/rust/lighttpd/src/fdlog_maint.c\0" as *const u8
                    as *const libc::c_char,
                294 as libc::c_int as libc::c_uint,
                b"error cycling log %s\0" as *const u8 as *const libc::c_char,
                (*fdlog).fn_0,
            );
        }
        i = i.wrapping_add(1);
    }
}
unsafe extern "C" fn fdlog_files_close(retain: *mut fdlog_st) {
    fdlog_files_flush(retain, 0 as libc::c_int);
    let mut i: uint32_t = 0 as libc::c_int as uint32_t;
    while i < fdlog_files.used {
        let fdlog: *mut fdlog_st = *(fdlog_files.ptr).offset(i as isize);
        if !(fdlog == retain) {
            fdlog_free(fdlog);
        }
        i = i.wrapping_add(1);
    }
    free(fdlog_files.ptr as *mut libc::c_void);
    fdlog_files.ptr = 0 as *mut *mut fdlog_st;
    fdlog_files.used = 0 as libc::c_int as uint32_t;
    fdlog_files.size = 0 as libc::c_int as uint32_t;
}
#[no_mangle]
#[cold]
pub unsafe extern "C" fn fdlog_closeall(errh: *mut fdlog_st) {
    fdlog_files_close(errh);
    fdlog_pipes_close(errh);
}
#[no_mangle]
#[cold]
pub unsafe extern "C" fn fdlog_flushall(errh: *mut fdlog_st) {
    fdlog_files_flush(errh, 1 as libc::c_int);
    let mut i: uint32_t = 0 as libc::c_int as uint32_t;
    while i < fdlog_pipes.used {
        let b: *mut buffer = &mut (*(*(fdlog_pipes.ptr).offset(i as isize)).fdlog).b;
        if !((*b).ptr).is_null() {
            buffer_free_ptr(b);
        }
        i = i.wrapping_add(1);
    }
    if !((*errh).b.ptr).is_null() {
        buffer_free_ptr(&mut (*errh).b);
    }
}
#[no_mangle]
#[cold]
pub unsafe extern "C" fn fdlog_init(
    fn_0: *const libc::c_char,
    fd: libc::c_int,
    mode: libc::c_int,
) -> *mut fdlog_st {
    let fdlog: *mut fdlog_st = calloc(
        1 as libc::c_int as libc::c_ulong,
        ::core::mem::size_of::<fdlog_st>() as libc::c_ulong,
    ) as *mut fdlog_st;
    if fdlog.is_null() {
        ck_assert_failed(
            b"/home/kkysen/work/rust/lighttpd/src/fdlog.c\0" as *const u8 as *const libc::c_char,
            13 as libc::c_int as libc::c_uint,
            b"fdlog\0" as *const u8 as *const libc::c_char,
        );
    }
    (*fdlog).fn_0 = fn_0;
    (*fdlog).fd = if fd >= 0 as libc::c_int {
        fd
    } else {
        2 as libc::c_int
    };
    (*fdlog).mode = mode as C2RustUnnamed_1;
    return fdlog;
}
#[no_mangle]
#[cold]
pub unsafe extern "C" fn fdlog_free(fdlog: *mut fdlog_st) {
    if (*fdlog).fd > 2 as libc::c_int {
        close((*fdlog).fd);
    }
    free((*fdlog).b.ptr as *mut libc::c_void);
    free(fdlog as *mut libc::c_void);
}
#[no_mangle]
pub unsafe extern "C" fn ck_memclear_s(
    s: *mut libc::c_void,
    smax: rsize_t,
    mut n: rsize_t,
) -> errno_t {
    if s.is_null() {
        return 22 as libc::c_int;
    }
    if (18446744073709551615 as libc::c_ulong >> 1 as libc::c_int) < smax {
        return 7 as libc::c_int;
    }
    let mut rc: errno_t = 0 as libc::c_int;
    if (18446744073709551615 as libc::c_ulong >> 1 as libc::c_int) < n {
        rc = 22 as libc::c_int;
        n = smax;
    }
    if smax < n {
        rc = 75 as libc::c_int;
        n = smax;
    }
    explicit_bzero(s, n);
    return rc;
}
#[no_mangle]
pub unsafe extern "C" fn ck_strerror_s(
    s: *mut libc::c_char,
    maxsize: rsize_t,
    errnum: errno_t,
) -> errno_t {
    if s.is_null()
        || 0 as libc::c_int as libc::c_ulong == maxsize
        || (18446744073709551615 as libc::c_ulong >> 1 as libc::c_int) < maxsize
    {
        return 22 as libc::c_int;
    }
    let mut buf: [libc::c_char; 1024] = [0; 1024];
    let mut errstr: *const libc::c_char = strerror_r(
        errnum,
        buf.as_mut_ptr(),
        ::core::mem::size_of::<[libc::c_char; 1024]>() as libc::c_ulong,
    );
    if !errstr.is_null() {
        let errlen: size_t = strlen(errstr);
        if errlen < maxsize {
            memcpy(
                s as *mut libc::c_void,
                errstr as *const libc::c_void,
                errlen.wrapping_add(1 as libc::c_int as libc::c_ulong),
            );
            return 0 as libc::c_int;
        } else {
            memcpy(
                s as *mut libc::c_void,
                errstr as *const libc::c_void,
                maxsize.wrapping_sub(1 as libc::c_int as libc::c_ulong),
            );
            *s.offset(maxsize.wrapping_sub(1 as libc::c_int as libc::c_ulong) as isize) =
                '\0' as i32 as libc::c_char;
        }
    } else if (snprintf(
        s,
        maxsize,
        b"Unknown error %d\0" as *const u8 as *const libc::c_char,
        errnum,
    ) as rsize_t)
        < maxsize
    {
        return 0 as libc::c_int;
    }
    if maxsize > 3 as libc::c_int as libc::c_ulong {
        memcpy(
            s.offset(maxsize as isize)
                .offset(-(4 as libc::c_int as isize)) as *mut libc::c_void,
            b"...\0" as *const u8 as *const libc::c_char as *const libc::c_void,
            3 as libc::c_int as libc::c_ulong,
        );
    }
    return 34 as libc::c_int;
}
#[no_mangle]
pub unsafe extern "C" fn ck_memeq_const_time(
    mut a: *const libc::c_void,
    mut alen: size_t,
    mut b: *const libc::c_void,
    mut blen: size_t,
) -> libc::c_int {
    let av: *const libc::c_uchar = (if alen != 0 {
        a
    } else {
        b"\0" as *const u8 as *const libc::c_char as *const libc::c_void
    }) as *const libc::c_uchar;
    let bv: *const libc::c_uchar = (if blen != 0 {
        b
    } else {
        b"\0" as *const u8 as *const libc::c_char as *const libc::c_void
    }) as *const libc::c_uchar;
    let mut lim: size_t = (if alen >= blen { alen } else { blen })
        .wrapping_add(0x3f as libc::c_int as libc::c_ulong)
        & !(0x3f as libc::c_int) as libc::c_ulong;
    let mut diff: libc::c_int = (alen != blen) as libc::c_int;
    alen = (alen as libc::c_ulong)
        .wrapping_sub((alen != 0 as libc::c_int as libc::c_ulong) as libc::c_int as libc::c_ulong)
        as size_t as size_t;
    blen = (blen as libc::c_ulong)
        .wrapping_sub((blen != 0 as libc::c_int as libc::c_ulong) as libc::c_int as libc::c_ulong)
        as size_t as size_t;
    let mut i: size_t = 0 as libc::c_int as size_t;
    let mut j: size_t = 0 as libc::c_int as size_t;
    while lim != 0 {
        diff |= *av.offset(i as isize) as libc::c_int ^ *bv.offset(j as isize) as libc::c_int;
        i = (i as libc::c_ulong).wrapping_add((i < alen) as libc::c_int as libc::c_ulong) as size_t
            as size_t;
        j = (j as libc::c_ulong).wrapping_add((j < blen) as libc::c_int as libc::c_ulong) as size_t
            as size_t;
        lim = lim.wrapping_sub(1);
    }
    return (0 as libc::c_int == diff) as libc::c_int;
}
#[no_mangle]
pub unsafe extern "C" fn ck_memeq_const_time_fixed_len(
    mut a: *const libc::c_void,
    mut b: *const libc::c_void,
    len: size_t,
) -> libc::c_int {
    let av: *const libc::c_uchar = a as *const libc::c_uchar;
    let bv: *const libc::c_uchar = b as *const libc::c_uchar;
    let mut diff: libc::c_int = 0 as libc::c_int;
    let mut i: size_t = 0 as libc::c_int as size_t;
    while i < len {
        diff |= *av.offset(i as isize) as libc::c_int ^ *bv.offset(i as isize) as libc::c_int;
        i = i.wrapping_add(1);
    }
    return (0 as libc::c_int == diff) as libc::c_int;
}
#[inline(never)]
unsafe extern "C" fn ck_bt_stderr(
    mut filename: *const libc::c_char,
    mut line: libc::c_uint,
    mut msg: *const libc::c_char,
    mut fmt: *const libc::c_char,
) {
    fprintf(stderr, fmt, filename, line, msg);
    fflush(stderr);
}
#[no_mangle]
#[cold]
pub unsafe extern "C" fn ck_bt(
    mut filename: *const libc::c_char,
    mut line: libc::c_uint,
    mut msg: *const libc::c_char,
) {
    ck_bt_stderr(
        filename,
        line,
        msg,
        b"%s.%u: %s\n\0" as *const u8 as *const libc::c_char,
    );
}
#[no_mangle]
#[cold]
pub unsafe extern "C" fn ck_bt_abort(
    mut filename: *const libc::c_char,
    mut line: libc::c_uint,
    mut msg: *const libc::c_char,
) -> ! {
    ck_bt(filename, line, msg);
    abort();
}
#[no_mangle]
#[cold]
pub unsafe extern "C" fn ck_assert_failed(
    mut filename: *const libc::c_char,
    mut line: libc::c_uint,
    mut msg: *const libc::c_char,
) -> ! {
    ck_bt_stderr(
        filename,
        line,
        msg,
        b"%s.%u: assertion failed: %s\n\0" as *const u8 as *const libc::c_char,
    );
    abort();
}
pub fn main() {
    let mut args: Vec<*mut libc::c_char> = Vec::new();
    for arg in ::std::env::args() {
        args.push(
            (::std::ffi::CString::new(arg))
                .expect("Failed to convert argument into CString.")
                .into_raw(),
        );
    }
    args.push(::core::ptr::null_mut());
    unsafe {
        ::std::process::exit(main_0(
            (args.len() - 1) as libc::c_int,
            args.as_mut_ptr() as *mut *mut libc::c_char,
        ) as i32)
    }
}
unsafe extern "C" fn run_static_initializers() {
    sentinel = &log_con_jqueue as *const *mut connection as *mut *mut connection as uintptr_t
        as *mut connection;
    default_server_tag = {
        let mut init = buffer {
            ptr: b"lighttpd/1.4.64\0" as *const u8 as *const libc::c_char as *mut libc::c_char,
            used: (::core::mem::size_of::<[libc::c_char; 16]>() as libc::c_ulong as uint32_t)
                .wrapping_sub(1 as libc::c_int as libc::c_uint)
                .wrapping_add(1 as libc::c_int as libc::c_uint),
            size: 0 as libc::c_int as uint32_t,
        };
        init
    };
    static_table = [
        {
            let mut init = C2RustUnnamed_20 {
                name_len: (::core::mem::size_of::<[libc::c_char; 11]>() as libc::c_ulong)
                    .wrapping_sub(1 as libc::c_int as libc::c_ulong)
                    as libc::c_uint,
                val_len: (::core::mem::size_of::<[libc::c_char; 1]>() as libc::c_ulong)
                    .wrapping_sub(1 as libc::c_int as libc::c_ulong)
                    as libc::c_uint,
                name: b":authority\0" as *const u8 as *const libc::c_char,
                val: b"\0" as *const u8 as *const libc::c_char,
            };
            init
        },
        {
            let mut init = C2RustUnnamed_20 {
                name_len: (::core::mem::size_of::<[libc::c_char; 8]>() as libc::c_ulong)
                    .wrapping_sub(1 as libc::c_int as libc::c_ulong)
                    as libc::c_uint,
                val_len: (::core::mem::size_of::<[libc::c_char; 4]>() as libc::c_ulong)
                    .wrapping_sub(1 as libc::c_int as libc::c_ulong)
                    as libc::c_uint,
                name: b":method\0" as *const u8 as *const libc::c_char,
                val: b"GET\0" as *const u8 as *const libc::c_char,
            };
            init
        },
        {
            let mut init = C2RustUnnamed_20 {
                name_len: (::core::mem::size_of::<[libc::c_char; 8]>() as libc::c_ulong)
                    .wrapping_sub(1 as libc::c_int as libc::c_ulong)
                    as libc::c_uint,
                val_len: (::core::mem::size_of::<[libc::c_char; 5]>() as libc::c_ulong)
                    .wrapping_sub(1 as libc::c_int as libc::c_ulong)
                    as libc::c_uint,
                name: b":method\0" as *const u8 as *const libc::c_char,
                val: b"POST\0" as *const u8 as *const libc::c_char,
            };
            init
        },
        {
            let mut init = C2RustUnnamed_20 {
                name_len: (::core::mem::size_of::<[libc::c_char; 6]>() as libc::c_ulong)
                    .wrapping_sub(1 as libc::c_int as libc::c_ulong)
                    as libc::c_uint,
                val_len: (::core::mem::size_of::<[libc::c_char; 2]>() as libc::c_ulong)
                    .wrapping_sub(1 as libc::c_int as libc::c_ulong)
                    as libc::c_uint,
                name: b":path\0" as *const u8 as *const libc::c_char,
                val: b"/\0" as *const u8 as *const libc::c_char,
            };
            init
        },
        {
            let mut init = C2RustUnnamed_20 {
                name_len: (::core::mem::size_of::<[libc::c_char; 6]>() as libc::c_ulong)
                    .wrapping_sub(1 as libc::c_int as libc::c_ulong)
                    as libc::c_uint,
                val_len: (::core::mem::size_of::<[libc::c_char; 12]>() as libc::c_ulong)
                    .wrapping_sub(1 as libc::c_int as libc::c_ulong)
                    as libc::c_uint,
                name: b":path\0" as *const u8 as *const libc::c_char,
                val: b"/index.html\0" as *const u8 as *const libc::c_char,
            };
            init
        },
        {
            let mut init = C2RustUnnamed_20 {
                name_len: (::core::mem::size_of::<[libc::c_char; 8]>() as libc::c_ulong)
                    .wrapping_sub(1 as libc::c_int as libc::c_ulong)
                    as libc::c_uint,
                val_len: (::core::mem::size_of::<[libc::c_char; 5]>() as libc::c_ulong)
                    .wrapping_sub(1 as libc::c_int as libc::c_ulong)
                    as libc::c_uint,
                name: b":scheme\0" as *const u8 as *const libc::c_char,
                val: b"http\0" as *const u8 as *const libc::c_char,
            };
            init
        },
        {
            let mut init = C2RustUnnamed_20 {
                name_len: (::core::mem::size_of::<[libc::c_char; 8]>() as libc::c_ulong)
                    .wrapping_sub(1 as libc::c_int as libc::c_ulong)
                    as libc::c_uint,
                val_len: (::core::mem::size_of::<[libc::c_char; 6]>() as libc::c_ulong)
                    .wrapping_sub(1 as libc::c_int as libc::c_ulong)
                    as libc::c_uint,
                name: b":scheme\0" as *const u8 as *const libc::c_char,
                val: b"https\0" as *const u8 as *const libc::c_char,
            };
            init
        },
        {
            let mut init = C2RustUnnamed_20 {
                name_len: (::core::mem::size_of::<[libc::c_char; 8]>() as libc::c_ulong)
                    .wrapping_sub(1 as libc::c_int as libc::c_ulong)
                    as libc::c_uint,
                val_len: (::core::mem::size_of::<[libc::c_char; 4]>() as libc::c_ulong)
                    .wrapping_sub(1 as libc::c_int as libc::c_ulong)
                    as libc::c_uint,
                name: b":status\0" as *const u8 as *const libc::c_char,
                val: b"200\0" as *const u8 as *const libc::c_char,
            };
            init
        },
        {
            let mut init = C2RustUnnamed_20 {
                name_len: (::core::mem::size_of::<[libc::c_char; 8]>() as libc::c_ulong)
                    .wrapping_sub(1 as libc::c_int as libc::c_ulong)
                    as libc::c_uint,
                val_len: (::core::mem::size_of::<[libc::c_char; 4]>() as libc::c_ulong)
                    .wrapping_sub(1 as libc::c_int as libc::c_ulong)
                    as libc::c_uint,
                name: b":status\0" as *const u8 as *const libc::c_char,
                val: b"204\0" as *const u8 as *const libc::c_char,
            };
            init
        },
        {
            let mut init = C2RustUnnamed_20 {
                name_len: (::core::mem::size_of::<[libc::c_char; 8]>() as libc::c_ulong)
                    .wrapping_sub(1 as libc::c_int as libc::c_ulong)
                    as libc::c_uint,
                val_len: (::core::mem::size_of::<[libc::c_char; 4]>() as libc::c_ulong)
                    .wrapping_sub(1 as libc::c_int as libc::c_ulong)
                    as libc::c_uint,
                name: b":status\0" as *const u8 as *const libc::c_char,
                val: b"206\0" as *const u8 as *const libc::c_char,
            };
            init
        },
        {
            let mut init = C2RustUnnamed_20 {
                name_len: (::core::mem::size_of::<[libc::c_char; 8]>() as libc::c_ulong)
                    .wrapping_sub(1 as libc::c_int as libc::c_ulong)
                    as libc::c_uint,
                val_len: (::core::mem::size_of::<[libc::c_char; 4]>() as libc::c_ulong)
                    .wrapping_sub(1 as libc::c_int as libc::c_ulong)
                    as libc::c_uint,
                name: b":status\0" as *const u8 as *const libc::c_char,
                val: b"304\0" as *const u8 as *const libc::c_char,
            };
            init
        },
        {
            let mut init = C2RustUnnamed_20 {
                name_len: (::core::mem::size_of::<[libc::c_char; 8]>() as libc::c_ulong)
                    .wrapping_sub(1 as libc::c_int as libc::c_ulong)
                    as libc::c_uint,
                val_len: (::core::mem::size_of::<[libc::c_char; 4]>() as libc::c_ulong)
                    .wrapping_sub(1 as libc::c_int as libc::c_ulong)
                    as libc::c_uint,
                name: b":status\0" as *const u8 as *const libc::c_char,
                val: b"400\0" as *const u8 as *const libc::c_char,
            };
            init
        },
        {
            let mut init = C2RustUnnamed_20 {
                name_len: (::core::mem::size_of::<[libc::c_char; 8]>() as libc::c_ulong)
                    .wrapping_sub(1 as libc::c_int as libc::c_ulong)
                    as libc::c_uint,
                val_len: (::core::mem::size_of::<[libc::c_char; 4]>() as libc::c_ulong)
                    .wrapping_sub(1 as libc::c_int as libc::c_ulong)
                    as libc::c_uint,
                name: b":status\0" as *const u8 as *const libc::c_char,
                val: b"404\0" as *const u8 as *const libc::c_char,
            };
            init
        },
        {
            let mut init = C2RustUnnamed_20 {
                name_len: (::core::mem::size_of::<[libc::c_char; 8]>() as libc::c_ulong)
                    .wrapping_sub(1 as libc::c_int as libc::c_ulong)
                    as libc::c_uint,
                val_len: (::core::mem::size_of::<[libc::c_char; 4]>() as libc::c_ulong)
                    .wrapping_sub(1 as libc::c_int as libc::c_ulong)
                    as libc::c_uint,
                name: b":status\0" as *const u8 as *const libc::c_char,
                val: b"500\0" as *const u8 as *const libc::c_char,
            };
            init
        },
        {
            let mut init = C2RustUnnamed_20 {
                name_len: (::core::mem::size_of::<[libc::c_char; 15]>() as libc::c_ulong)
                    .wrapping_sub(1 as libc::c_int as libc::c_ulong)
                    as libc::c_uint,
                val_len: (::core::mem::size_of::<[libc::c_char; 1]>() as libc::c_ulong)
                    .wrapping_sub(1 as libc::c_int as libc::c_ulong)
                    as libc::c_uint,
                name: b"accept-charset\0" as *const u8 as *const libc::c_char,
                val: b"\0" as *const u8 as *const libc::c_char,
            };
            init
        },
        {
            let mut init = C2RustUnnamed_20 {
                name_len: (::core::mem::size_of::<[libc::c_char; 16]>() as libc::c_ulong)
                    .wrapping_sub(1 as libc::c_int as libc::c_ulong)
                    as libc::c_uint,
                val_len: (::core::mem::size_of::<[libc::c_char; 14]>() as libc::c_ulong)
                    .wrapping_sub(1 as libc::c_int as libc::c_ulong)
                    as libc::c_uint,
                name: b"accept-encoding\0" as *const u8 as *const libc::c_char,
                val: b"gzip, deflate\0" as *const u8 as *const libc::c_char,
            };
            init
        },
        {
            let mut init = C2RustUnnamed_20 {
                name_len: (::core::mem::size_of::<[libc::c_char; 16]>() as libc::c_ulong)
                    .wrapping_sub(1 as libc::c_int as libc::c_ulong)
                    as libc::c_uint,
                val_len: (::core::mem::size_of::<[libc::c_char; 1]>() as libc::c_ulong)
                    .wrapping_sub(1 as libc::c_int as libc::c_ulong)
                    as libc::c_uint,
                name: b"accept-language\0" as *const u8 as *const libc::c_char,
                val: b"\0" as *const u8 as *const libc::c_char,
            };
            init
        },
        {
            let mut init = C2RustUnnamed_20 {
                name_len: (::core::mem::size_of::<[libc::c_char; 14]>() as libc::c_ulong)
                    .wrapping_sub(1 as libc::c_int as libc::c_ulong)
                    as libc::c_uint,
                val_len: (::core::mem::size_of::<[libc::c_char; 1]>() as libc::c_ulong)
                    .wrapping_sub(1 as libc::c_int as libc::c_ulong)
                    as libc::c_uint,
                name: b"accept-ranges\0" as *const u8 as *const libc::c_char,
                val: b"\0" as *const u8 as *const libc::c_char,
            };
            init
        },
        {
            let mut init = C2RustUnnamed_20 {
                name_len: (::core::mem::size_of::<[libc::c_char; 7]>() as libc::c_ulong)
                    .wrapping_sub(1 as libc::c_int as libc::c_ulong)
                    as libc::c_uint,
                val_len: (::core::mem::size_of::<[libc::c_char; 1]>() as libc::c_ulong)
                    .wrapping_sub(1 as libc::c_int as libc::c_ulong)
                    as libc::c_uint,
                name: b"accept\0" as *const u8 as *const libc::c_char,
                val: b"\0" as *const u8 as *const libc::c_char,
            };
            init
        },
        {
            let mut init = C2RustUnnamed_20 {
                name_len: (::core::mem::size_of::<[libc::c_char; 28]>() as libc::c_ulong)
                    .wrapping_sub(1 as libc::c_int as libc::c_ulong)
                    as libc::c_uint,
                val_len: (::core::mem::size_of::<[libc::c_char; 1]>() as libc::c_ulong)
                    .wrapping_sub(1 as libc::c_int as libc::c_ulong)
                    as libc::c_uint,
                name: b"access-control-allow-origin\0" as *const u8 as *const libc::c_char,
                val: b"\0" as *const u8 as *const libc::c_char,
            };
            init
        },
        {
            let mut init = C2RustUnnamed_20 {
                name_len: (::core::mem::size_of::<[libc::c_char; 4]>() as libc::c_ulong)
                    .wrapping_sub(1 as libc::c_int as libc::c_ulong)
                    as libc::c_uint,
                val_len: (::core::mem::size_of::<[libc::c_char; 1]>() as libc::c_ulong)
                    .wrapping_sub(1 as libc::c_int as libc::c_ulong)
                    as libc::c_uint,
                name: b"age\0" as *const u8 as *const libc::c_char,
                val: b"\0" as *const u8 as *const libc::c_char,
            };
            init
        },
        {
            let mut init = C2RustUnnamed_20 {
                name_len: (::core::mem::size_of::<[libc::c_char; 6]>() as libc::c_ulong)
                    .wrapping_sub(1 as libc::c_int as libc::c_ulong)
                    as libc::c_uint,
                val_len: (::core::mem::size_of::<[libc::c_char; 1]>() as libc::c_ulong)
                    .wrapping_sub(1 as libc::c_int as libc::c_ulong)
                    as libc::c_uint,
                name: b"allow\0" as *const u8 as *const libc::c_char,
                val: b"\0" as *const u8 as *const libc::c_char,
            };
            init
        },
        {
            let mut init = C2RustUnnamed_20 {
                name_len: (::core::mem::size_of::<[libc::c_char; 14]>() as libc::c_ulong)
                    .wrapping_sub(1 as libc::c_int as libc::c_ulong)
                    as libc::c_uint,
                val_len: (::core::mem::size_of::<[libc::c_char; 1]>() as libc::c_ulong)
                    .wrapping_sub(1 as libc::c_int as libc::c_ulong)
                    as libc::c_uint,
                name: b"authorization\0" as *const u8 as *const libc::c_char,
                val: b"\0" as *const u8 as *const libc::c_char,
            };
            init
        },
        {
            let mut init = C2RustUnnamed_20 {
                name_len: (::core::mem::size_of::<[libc::c_char; 14]>() as libc::c_ulong)
                    .wrapping_sub(1 as libc::c_int as libc::c_ulong)
                    as libc::c_uint,
                val_len: (::core::mem::size_of::<[libc::c_char; 1]>() as libc::c_ulong)
                    .wrapping_sub(1 as libc::c_int as libc::c_ulong)
                    as libc::c_uint,
                name: b"cache-control\0" as *const u8 as *const libc::c_char,
                val: b"\0" as *const u8 as *const libc::c_char,
            };
            init
        },
        {
            let mut init = C2RustUnnamed_20 {
                name_len: (::core::mem::size_of::<[libc::c_char; 20]>() as libc::c_ulong)
                    .wrapping_sub(1 as libc::c_int as libc::c_ulong)
                    as libc::c_uint,
                val_len: (::core::mem::size_of::<[libc::c_char; 1]>() as libc::c_ulong)
                    .wrapping_sub(1 as libc::c_int as libc::c_ulong)
                    as libc::c_uint,
                name: b"content-disposition\0" as *const u8 as *const libc::c_char,
                val: b"\0" as *const u8 as *const libc::c_char,
            };
            init
        },
        {
            let mut init = C2RustUnnamed_20 {
                name_len: (::core::mem::size_of::<[libc::c_char; 17]>() as libc::c_ulong)
                    .wrapping_sub(1 as libc::c_int as libc::c_ulong)
                    as libc::c_uint,
                val_len: (::core::mem::size_of::<[libc::c_char; 1]>() as libc::c_ulong)
                    .wrapping_sub(1 as libc::c_int as libc::c_ulong)
                    as libc::c_uint,
                name: b"content-encoding\0" as *const u8 as *const libc::c_char,
                val: b"\0" as *const u8 as *const libc::c_char,
            };
            init
        },
        {
            let mut init = C2RustUnnamed_20 {
                name_len: (::core::mem::size_of::<[libc::c_char; 17]>() as libc::c_ulong)
                    .wrapping_sub(1 as libc::c_int as libc::c_ulong)
                    as libc::c_uint,
                val_len: (::core::mem::size_of::<[libc::c_char; 1]>() as libc::c_ulong)
                    .wrapping_sub(1 as libc::c_int as libc::c_ulong)
                    as libc::c_uint,
                name: b"content-language\0" as *const u8 as *const libc::c_char,
                val: b"\0" as *const u8 as *const libc::c_char,
            };
            init
        },
        {
            let mut init = C2RustUnnamed_20 {
                name_len: (::core::mem::size_of::<[libc::c_char; 15]>() as libc::c_ulong)
                    .wrapping_sub(1 as libc::c_int as libc::c_ulong)
                    as libc::c_uint,
                val_len: (::core::mem::size_of::<[libc::c_char; 1]>() as libc::c_ulong)
                    .wrapping_sub(1 as libc::c_int as libc::c_ulong)
                    as libc::c_uint,
                name: b"content-length\0" as *const u8 as *const libc::c_char,
                val: b"\0" as *const u8 as *const libc::c_char,
            };
            init
        },
        {
            let mut init = C2RustUnnamed_20 {
                name_len: (::core::mem::size_of::<[libc::c_char; 17]>() as libc::c_ulong)
                    .wrapping_sub(1 as libc::c_int as libc::c_ulong)
                    as libc::c_uint,
                val_len: (::core::mem::size_of::<[libc::c_char; 1]>() as libc::c_ulong)
                    .wrapping_sub(1 as libc::c_int as libc::c_ulong)
                    as libc::c_uint,
                name: b"content-location\0" as *const u8 as *const libc::c_char,
                val: b"\0" as *const u8 as *const libc::c_char,
            };
            init
        },
        {
            let mut init = C2RustUnnamed_20 {
                name_len: (::core::mem::size_of::<[libc::c_char; 14]>() as libc::c_ulong)
                    .wrapping_sub(1 as libc::c_int as libc::c_ulong)
                    as libc::c_uint,
                val_len: (::core::mem::size_of::<[libc::c_char; 1]>() as libc::c_ulong)
                    .wrapping_sub(1 as libc::c_int as libc::c_ulong)
                    as libc::c_uint,
                name: b"content-range\0" as *const u8 as *const libc::c_char,
                val: b"\0" as *const u8 as *const libc::c_char,
            };
            init
        },
        {
            let mut init = C2RustUnnamed_20 {
                name_len: (::core::mem::size_of::<[libc::c_char; 13]>() as libc::c_ulong)
                    .wrapping_sub(1 as libc::c_int as libc::c_ulong)
                    as libc::c_uint,
                val_len: (::core::mem::size_of::<[libc::c_char; 1]>() as libc::c_ulong)
                    .wrapping_sub(1 as libc::c_int as libc::c_ulong)
                    as libc::c_uint,
                name: b"content-type\0" as *const u8 as *const libc::c_char,
                val: b"\0" as *const u8 as *const libc::c_char,
            };
            init
        },
        {
            let mut init = C2RustUnnamed_20 {
                name_len: (::core::mem::size_of::<[libc::c_char; 7]>() as libc::c_ulong)
                    .wrapping_sub(1 as libc::c_int as libc::c_ulong)
                    as libc::c_uint,
                val_len: (::core::mem::size_of::<[libc::c_char; 1]>() as libc::c_ulong)
                    .wrapping_sub(1 as libc::c_int as libc::c_ulong)
                    as libc::c_uint,
                name: b"cookie\0" as *const u8 as *const libc::c_char,
                val: b"\0" as *const u8 as *const libc::c_char,
            };
            init
        },
        {
            let mut init = C2RustUnnamed_20 {
                name_len: (::core::mem::size_of::<[libc::c_char; 5]>() as libc::c_ulong)
                    .wrapping_sub(1 as libc::c_int as libc::c_ulong)
                    as libc::c_uint,
                val_len: (::core::mem::size_of::<[libc::c_char; 1]>() as libc::c_ulong)
                    .wrapping_sub(1 as libc::c_int as libc::c_ulong)
                    as libc::c_uint,
                name: b"date\0" as *const u8 as *const libc::c_char,
                val: b"\0" as *const u8 as *const libc::c_char,
            };
            init
        },
        {
            let mut init = C2RustUnnamed_20 {
                name_len: (::core::mem::size_of::<[libc::c_char; 5]>() as libc::c_ulong)
                    .wrapping_sub(1 as libc::c_int as libc::c_ulong)
                    as libc::c_uint,
                val_len: (::core::mem::size_of::<[libc::c_char; 1]>() as libc::c_ulong)
                    .wrapping_sub(1 as libc::c_int as libc::c_ulong)
                    as libc::c_uint,
                name: b"etag\0" as *const u8 as *const libc::c_char,
                val: b"\0" as *const u8 as *const libc::c_char,
            };
            init
        },
        {
            let mut init = C2RustUnnamed_20 {
                name_len: (::core::mem::size_of::<[libc::c_char; 7]>() as libc::c_ulong)
                    .wrapping_sub(1 as libc::c_int as libc::c_ulong)
                    as libc::c_uint,
                val_len: (::core::mem::size_of::<[libc::c_char; 1]>() as libc::c_ulong)
                    .wrapping_sub(1 as libc::c_int as libc::c_ulong)
                    as libc::c_uint,
                name: b"expect\0" as *const u8 as *const libc::c_char,
                val: b"\0" as *const u8 as *const libc::c_char,
            };
            init
        },
        {
            let mut init = C2RustUnnamed_20 {
                name_len: (::core::mem::size_of::<[libc::c_char; 8]>() as libc::c_ulong)
                    .wrapping_sub(1 as libc::c_int as libc::c_ulong)
                    as libc::c_uint,
                val_len: (::core::mem::size_of::<[libc::c_char; 1]>() as libc::c_ulong)
                    .wrapping_sub(1 as libc::c_int as libc::c_ulong)
                    as libc::c_uint,
                name: b"expires\0" as *const u8 as *const libc::c_char,
                val: b"\0" as *const u8 as *const libc::c_char,
            };
            init
        },
        {
            let mut init = C2RustUnnamed_20 {
                name_len: (::core::mem::size_of::<[libc::c_char; 5]>() as libc::c_ulong)
                    .wrapping_sub(1 as libc::c_int as libc::c_ulong)
                    as libc::c_uint,
                val_len: (::core::mem::size_of::<[libc::c_char; 1]>() as libc::c_ulong)
                    .wrapping_sub(1 as libc::c_int as libc::c_ulong)
                    as libc::c_uint,
                name: b"from\0" as *const u8 as *const libc::c_char,
                val: b"\0" as *const u8 as *const libc::c_char,
            };
            init
        },
        {
            let mut init = C2RustUnnamed_20 {
                name_len: (::core::mem::size_of::<[libc::c_char; 5]>() as libc::c_ulong)
                    .wrapping_sub(1 as libc::c_int as libc::c_ulong)
                    as libc::c_uint,
                val_len: (::core::mem::size_of::<[libc::c_char; 1]>() as libc::c_ulong)
                    .wrapping_sub(1 as libc::c_int as libc::c_ulong)
                    as libc::c_uint,
                name: b"host\0" as *const u8 as *const libc::c_char,
                val: b"\0" as *const u8 as *const libc::c_char,
            };
            init
        },
        {
            let mut init = C2RustUnnamed_20 {
                name_len: (::core::mem::size_of::<[libc::c_char; 9]>() as libc::c_ulong)
                    .wrapping_sub(1 as libc::c_int as libc::c_ulong)
                    as libc::c_uint,
                val_len: (::core::mem::size_of::<[libc::c_char; 1]>() as libc::c_ulong)
                    .wrapping_sub(1 as libc::c_int as libc::c_ulong)
                    as libc::c_uint,
                name: b"if-match\0" as *const u8 as *const libc::c_char,
                val: b"\0" as *const u8 as *const libc::c_char,
            };
            init
        },
        {
            let mut init = C2RustUnnamed_20 {
                name_len: (::core::mem::size_of::<[libc::c_char; 18]>() as libc::c_ulong)
                    .wrapping_sub(1 as libc::c_int as libc::c_ulong)
                    as libc::c_uint,
                val_len: (::core::mem::size_of::<[libc::c_char; 1]>() as libc::c_ulong)
                    .wrapping_sub(1 as libc::c_int as libc::c_ulong)
                    as libc::c_uint,
                name: b"if-modified-since\0" as *const u8 as *const libc::c_char,
                val: b"\0" as *const u8 as *const libc::c_char,
            };
            init
        },
        {
            let mut init = C2RustUnnamed_20 {
                name_len: (::core::mem::size_of::<[libc::c_char; 14]>() as libc::c_ulong)
                    .wrapping_sub(1 as libc::c_int as libc::c_ulong)
                    as libc::c_uint,
                val_len: (::core::mem::size_of::<[libc::c_char; 1]>() as libc::c_ulong)
                    .wrapping_sub(1 as libc::c_int as libc::c_ulong)
                    as libc::c_uint,
                name: b"if-none-match\0" as *const u8 as *const libc::c_char,
                val: b"\0" as *const u8 as *const libc::c_char,
            };
            init
        },
        {
            let mut init = C2RustUnnamed_20 {
                name_len: (::core::mem::size_of::<[libc::c_char; 9]>() as libc::c_ulong)
                    .wrapping_sub(1 as libc::c_int as libc::c_ulong)
                    as libc::c_uint,
                val_len: (::core::mem::size_of::<[libc::c_char; 1]>() as libc::c_ulong)
                    .wrapping_sub(1 as libc::c_int as libc::c_ulong)
                    as libc::c_uint,
                name: b"if-range\0" as *const u8 as *const libc::c_char,
                val: b"\0" as *const u8 as *const libc::c_char,
            };
            init
        },
        {
            let mut init = C2RustUnnamed_20 {
                name_len: (::core::mem::size_of::<[libc::c_char; 20]>() as libc::c_ulong)
                    .wrapping_sub(1 as libc::c_int as libc::c_ulong)
                    as libc::c_uint,
                val_len: (::core::mem::size_of::<[libc::c_char; 1]>() as libc::c_ulong)
                    .wrapping_sub(1 as libc::c_int as libc::c_ulong)
                    as libc::c_uint,
                name: b"if-unmodified-since\0" as *const u8 as *const libc::c_char,
                val: b"\0" as *const u8 as *const libc::c_char,
            };
            init
        },
        {
            let mut init = C2RustUnnamed_20 {
                name_len: (::core::mem::size_of::<[libc::c_char; 14]>() as libc::c_ulong)
                    .wrapping_sub(1 as libc::c_int as libc::c_ulong)
                    as libc::c_uint,
                val_len: (::core::mem::size_of::<[libc::c_char; 1]>() as libc::c_ulong)
                    .wrapping_sub(1 as libc::c_int as libc::c_ulong)
                    as libc::c_uint,
                name: b"last-modified\0" as *const u8 as *const libc::c_char,
                val: b"\0" as *const u8 as *const libc::c_char,
            };
            init
        },
        {
            let mut init = C2RustUnnamed_20 {
                name_len: (::core::mem::size_of::<[libc::c_char; 5]>() as libc::c_ulong)
                    .wrapping_sub(1 as libc::c_int as libc::c_ulong)
                    as libc::c_uint,
                val_len: (::core::mem::size_of::<[libc::c_char; 1]>() as libc::c_ulong)
                    .wrapping_sub(1 as libc::c_int as libc::c_ulong)
                    as libc::c_uint,
                name: b"link\0" as *const u8 as *const libc::c_char,
                val: b"\0" as *const u8 as *const libc::c_char,
            };
            init
        },
        {
            let mut init = C2RustUnnamed_20 {
                name_len: (::core::mem::size_of::<[libc::c_char; 9]>() as libc::c_ulong)
                    .wrapping_sub(1 as libc::c_int as libc::c_ulong)
                    as libc::c_uint,
                val_len: (::core::mem::size_of::<[libc::c_char; 1]>() as libc::c_ulong)
                    .wrapping_sub(1 as libc::c_int as libc::c_ulong)
                    as libc::c_uint,
                name: b"location\0" as *const u8 as *const libc::c_char,
                val: b"\0" as *const u8 as *const libc::c_char,
            };
            init
        },
        {
            let mut init = C2RustUnnamed_20 {
                name_len: (::core::mem::size_of::<[libc::c_char; 13]>() as libc::c_ulong)
                    .wrapping_sub(1 as libc::c_int as libc::c_ulong)
                    as libc::c_uint,
                val_len: (::core::mem::size_of::<[libc::c_char; 1]>() as libc::c_ulong)
                    .wrapping_sub(1 as libc::c_int as libc::c_ulong)
                    as libc::c_uint,
                name: b"max-forwards\0" as *const u8 as *const libc::c_char,
                val: b"\0" as *const u8 as *const libc::c_char,
            };
            init
        },
        {
            let mut init = C2RustUnnamed_20 {
                name_len: (::core::mem::size_of::<[libc::c_char; 19]>() as libc::c_ulong)
                    .wrapping_sub(1 as libc::c_int as libc::c_ulong)
                    as libc::c_uint,
                val_len: (::core::mem::size_of::<[libc::c_char; 1]>() as libc::c_ulong)
                    .wrapping_sub(1 as libc::c_int as libc::c_ulong)
                    as libc::c_uint,
                name: b"proxy-authenticate\0" as *const u8 as *const libc::c_char,
                val: b"\0" as *const u8 as *const libc::c_char,
            };
            init
        },
        {
            let mut init = C2RustUnnamed_20 {
                name_len: (::core::mem::size_of::<[libc::c_char; 20]>() as libc::c_ulong)
                    .wrapping_sub(1 as libc::c_int as libc::c_ulong)
                    as libc::c_uint,
                val_len: (::core::mem::size_of::<[libc::c_char; 1]>() as libc::c_ulong)
                    .wrapping_sub(1 as libc::c_int as libc::c_ulong)
                    as libc::c_uint,
                name: b"proxy-authorization\0" as *const u8 as *const libc::c_char,
                val: b"\0" as *const u8 as *const libc::c_char,
            };
            init
        },
        {
            let mut init = C2RustUnnamed_20 {
                name_len: (::core::mem::size_of::<[libc::c_char; 6]>() as libc::c_ulong)
                    .wrapping_sub(1 as libc::c_int as libc::c_ulong)
                    as libc::c_uint,
                val_len: (::core::mem::size_of::<[libc::c_char; 1]>() as libc::c_ulong)
                    .wrapping_sub(1 as libc::c_int as libc::c_ulong)
                    as libc::c_uint,
                name: b"range\0" as *const u8 as *const libc::c_char,
                val: b"\0" as *const u8 as *const libc::c_char,
            };
            init
        },
        {
            let mut init = C2RustUnnamed_20 {
                name_len: (::core::mem::size_of::<[libc::c_char; 8]>() as libc::c_ulong)
                    .wrapping_sub(1 as libc::c_int as libc::c_ulong)
                    as libc::c_uint,
                val_len: (::core::mem::size_of::<[libc::c_char; 1]>() as libc::c_ulong)
                    .wrapping_sub(1 as libc::c_int as libc::c_ulong)
                    as libc::c_uint,
                name: b"referer\0" as *const u8 as *const libc::c_char,
                val: b"\0" as *const u8 as *const libc::c_char,
            };
            init
        },
        {
            let mut init = C2RustUnnamed_20 {
                name_len: (::core::mem::size_of::<[libc::c_char; 8]>() as libc::c_ulong)
                    .wrapping_sub(1 as libc::c_int as libc::c_ulong)
                    as libc::c_uint,
                val_len: (::core::mem::size_of::<[libc::c_char; 1]>() as libc::c_ulong)
                    .wrapping_sub(1 as libc::c_int as libc::c_ulong)
                    as libc::c_uint,
                name: b"refresh\0" as *const u8 as *const libc::c_char,
                val: b"\0" as *const u8 as *const libc::c_char,
            };
            init
        },
        {
            let mut init = C2RustUnnamed_20 {
                name_len: (::core::mem::size_of::<[libc::c_char; 12]>() as libc::c_ulong)
                    .wrapping_sub(1 as libc::c_int as libc::c_ulong)
                    as libc::c_uint,
                val_len: (::core::mem::size_of::<[libc::c_char; 1]>() as libc::c_ulong)
                    .wrapping_sub(1 as libc::c_int as libc::c_ulong)
                    as libc::c_uint,
                name: b"retry-after\0" as *const u8 as *const libc::c_char,
                val: b"\0" as *const u8 as *const libc::c_char,
            };
            init
        },
        {
            let mut init = C2RustUnnamed_20 {
                name_len: (::core::mem::size_of::<[libc::c_char; 7]>() as libc::c_ulong)
                    .wrapping_sub(1 as libc::c_int as libc::c_ulong)
                    as libc::c_uint,
                val_len: (::core::mem::size_of::<[libc::c_char; 1]>() as libc::c_ulong)
                    .wrapping_sub(1 as libc::c_int as libc::c_ulong)
                    as libc::c_uint,
                name: b"server\0" as *const u8 as *const libc::c_char,
                val: b"\0" as *const u8 as *const libc::c_char,
            };
            init
        },
        {
            let mut init = C2RustUnnamed_20 {
                name_len: (::core::mem::size_of::<[libc::c_char; 11]>() as libc::c_ulong)
                    .wrapping_sub(1 as libc::c_int as libc::c_ulong)
                    as libc::c_uint,
                val_len: (::core::mem::size_of::<[libc::c_char; 1]>() as libc::c_ulong)
                    .wrapping_sub(1 as libc::c_int as libc::c_ulong)
                    as libc::c_uint,
                name: b"set-cookie\0" as *const u8 as *const libc::c_char,
                val: b"\0" as *const u8 as *const libc::c_char,
            };
            init
        },
        {
            let mut init = C2RustUnnamed_20 {
                name_len: (::core::mem::size_of::<[libc::c_char; 26]>() as libc::c_ulong)
                    .wrapping_sub(1 as libc::c_int as libc::c_ulong)
                    as libc::c_uint,
                val_len: (::core::mem::size_of::<[libc::c_char; 1]>() as libc::c_ulong)
                    .wrapping_sub(1 as libc::c_int as libc::c_ulong)
                    as libc::c_uint,
                name: b"strict-transport-security\0" as *const u8 as *const libc::c_char,
                val: b"\0" as *const u8 as *const libc::c_char,
            };
            init
        },
        {
            let mut init = C2RustUnnamed_20 {
                name_len: (::core::mem::size_of::<[libc::c_char; 18]>() as libc::c_ulong)
                    .wrapping_sub(1 as libc::c_int as libc::c_ulong)
                    as libc::c_uint,
                val_len: (::core::mem::size_of::<[libc::c_char; 1]>() as libc::c_ulong)
                    .wrapping_sub(1 as libc::c_int as libc::c_ulong)
                    as libc::c_uint,
                name: b"transfer-encoding\0" as *const u8 as *const libc::c_char,
                val: b"\0" as *const u8 as *const libc::c_char,
            };
            init
        },
        {
            let mut init = C2RustUnnamed_20 {
                name_len: (::core::mem::size_of::<[libc::c_char; 11]>() as libc::c_ulong)
                    .wrapping_sub(1 as libc::c_int as libc::c_ulong)
                    as libc::c_uint,
                val_len: (::core::mem::size_of::<[libc::c_char; 1]>() as libc::c_ulong)
                    .wrapping_sub(1 as libc::c_int as libc::c_ulong)
                    as libc::c_uint,
                name: b"user-agent\0" as *const u8 as *const libc::c_char,
                val: b"\0" as *const u8 as *const libc::c_char,
            };
            init
        },
        {
            let mut init = C2RustUnnamed_20 {
                name_len: (::core::mem::size_of::<[libc::c_char; 5]>() as libc::c_ulong)
                    .wrapping_sub(1 as libc::c_int as libc::c_ulong)
                    as libc::c_uint,
                val_len: (::core::mem::size_of::<[libc::c_char; 1]>() as libc::c_ulong)
                    .wrapping_sub(1 as libc::c_int as libc::c_ulong)
                    as libc::c_uint,
                name: b"vary\0" as *const u8 as *const libc::c_char,
                val: b"\0" as *const u8 as *const libc::c_char,
            };
            init
        },
        {
            let mut init = C2RustUnnamed_20 {
                name_len: (::core::mem::size_of::<[libc::c_char; 4]>() as libc::c_ulong)
                    .wrapping_sub(1 as libc::c_int as libc::c_ulong)
                    as libc::c_uint,
                val_len: (::core::mem::size_of::<[libc::c_char; 1]>() as libc::c_ulong)
                    .wrapping_sub(1 as libc::c_int as libc::c_ulong)
                    as libc::c_uint,
                name: b"via\0" as *const u8 as *const libc::c_char,
                val: b"\0" as *const u8 as *const libc::c_char,
            };
            init
        },
        {
            let mut init = C2RustUnnamed_20 {
                name_len: (::core::mem::size_of::<[libc::c_char; 17]>() as libc::c_ulong)
                    .wrapping_sub(1 as libc::c_int as libc::c_ulong)
                    as libc::c_uint,
                val_len: (::core::mem::size_of::<[libc::c_char; 1]>() as libc::c_ulong)
                    .wrapping_sub(1 as libc::c_int as libc::c_ulong)
                    as libc::c_uint,
                name: b"www-authenticate\0" as *const u8 as *const libc::c_char,
                val: b"\0" as *const u8 as *const libc::c_char,
            };
            init
        },
    ];
    cpk = [
        {
            let mut init = config_plugin_keys_t {
                k: b"ssl.engine\0" as *const u8 as *const libc::c_char,
                klen: (::core::mem::size_of::<[libc::c_char; 11]>() as libc::c_ulong as uint32_t)
                    .wrapping_sub(1 as libc::c_int as libc::c_uint)
                    as uint8_t,
                ktype: T_CONFIG_BOOL as libc::c_int as uint8_t,
                scope: T_CONFIG_SCOPE_CONNECTION as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = config_plugin_keys_t {
                k: b"server.listen-backlog\0" as *const u8 as *const libc::c_char,
                klen: (::core::mem::size_of::<[libc::c_char; 22]>() as libc::c_ulong as uint32_t)
                    .wrapping_sub(1 as libc::c_int as libc::c_uint)
                    as uint8_t,
                ktype: T_CONFIG_INT as libc::c_int as uint8_t,
                scope: T_CONFIG_SCOPE_CONNECTION as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = config_plugin_keys_t {
                k: b"server.socket-perms\0" as *const u8 as *const libc::c_char,
                klen: (::core::mem::size_of::<[libc::c_char; 20]>() as libc::c_ulong as uint32_t)
                    .wrapping_sub(1 as libc::c_int as libc::c_uint)
                    as uint8_t,
                ktype: T_CONFIG_STRING as libc::c_int as uint8_t,
                scope: T_CONFIG_SCOPE_CONNECTION as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = config_plugin_keys_t {
                k: b"server.bsd-accept-filter\0" as *const u8 as *const libc::c_char,
                klen: (::core::mem::size_of::<[libc::c_char; 25]>() as libc::c_ulong as uint32_t)
                    .wrapping_sub(1 as libc::c_int as libc::c_uint)
                    as uint8_t,
                ktype: T_CONFIG_STRING as libc::c_int as uint8_t,
                scope: T_CONFIG_SCOPE_CONNECTION as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = config_plugin_keys_t {
                k: b"server.defer-accept\0" as *const u8 as *const libc::c_char,
                klen: (::core::mem::size_of::<[libc::c_char; 20]>() as libc::c_ulong as uint32_t)
                    .wrapping_sub(1 as libc::c_int as libc::c_uint)
                    as uint8_t,
                ktype: T_CONFIG_BOOL as libc::c_int as uint8_t,
                scope: T_CONFIG_SCOPE_CONNECTION as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = config_plugin_keys_t {
                k: b"server.use-ipv6\0" as *const u8 as *const libc::c_char,
                klen: (::core::mem::size_of::<[libc::c_char; 16]>() as libc::c_ulong as uint32_t)
                    .wrapping_sub(1 as libc::c_int as libc::c_uint)
                    as uint8_t,
                ktype: T_CONFIG_BOOL as libc::c_int as uint8_t,
                scope: T_CONFIG_SCOPE_CONNECTION as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = config_plugin_keys_t {
                k: b"server.set-v6only\0" as *const u8 as *const libc::c_char,
                klen: (::core::mem::size_of::<[libc::c_char; 18]>() as libc::c_ulong as uint32_t)
                    .wrapping_sub(1 as libc::c_int as libc::c_uint)
                    as uint8_t,
                ktype: T_CONFIG_BOOL as libc::c_int as uint8_t,
                scope: T_CONFIG_SCOPE_CONNECTION as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = config_plugin_keys_t {
                k: b"server.v4mapped\0" as *const u8 as *const libc::c_char,
                klen: (::core::mem::size_of::<[libc::c_char; 16]>() as libc::c_ulong as uint32_t)
                    .wrapping_sub(1 as libc::c_int as libc::c_uint)
                    as uint8_t,
                ktype: T_CONFIG_BOOL as libc::c_int as uint8_t,
                scope: T_CONFIG_SCOPE_CONNECTION as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = config_plugin_keys_t {
                k: 0 as *const libc::c_char,
                klen: 0 as libc::c_int as uint8_t,
                ktype: T_CONFIG_UNSET as libc::c_int as uint8_t,
                scope: T_CONFIG_SCOPE_UNSET as libc::c_int as uint8_t,
            };
            init
        },
    ];
    cpk_0 = [
        {
            let mut init = config_plugin_keys_t {
                k: b"server.document-root\0" as *const u8 as *const libc::c_char,
                klen: (::core::mem::size_of::<[libc::c_char; 21]>() as libc::c_ulong as uint32_t)
                    .wrapping_sub(1 as libc::c_int as libc::c_uint)
                    as uint8_t,
                ktype: T_CONFIG_STRING as libc::c_int as uint8_t,
                scope: T_CONFIG_SCOPE_CONNECTION as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = config_plugin_keys_t {
                k: b"server.name\0" as *const u8 as *const libc::c_char,
                klen: (::core::mem::size_of::<[libc::c_char; 12]>() as libc::c_ulong as uint32_t)
                    .wrapping_sub(1 as libc::c_int as libc::c_uint)
                    as uint8_t,
                ktype: T_CONFIG_STRING as libc::c_int as uint8_t,
                scope: T_CONFIG_SCOPE_CONNECTION as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = config_plugin_keys_t {
                k: b"server.tag\0" as *const u8 as *const libc::c_char,
                klen: (::core::mem::size_of::<[libc::c_char; 11]>() as libc::c_ulong as uint32_t)
                    .wrapping_sub(1 as libc::c_int as libc::c_uint)
                    as uint8_t,
                ktype: T_CONFIG_STRING as libc::c_int as uint8_t,
                scope: T_CONFIG_SCOPE_CONNECTION as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = config_plugin_keys_t {
                k: b"server.max-request-size\0" as *const u8 as *const libc::c_char,
                klen: (::core::mem::size_of::<[libc::c_char; 24]>() as libc::c_ulong as uint32_t)
                    .wrapping_sub(1 as libc::c_int as libc::c_uint)
                    as uint8_t,
                ktype: T_CONFIG_INT as libc::c_int as uint8_t,
                scope: T_CONFIG_SCOPE_CONNECTION as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = config_plugin_keys_t {
                k: b"server.max-keep-alive-requests\0" as *const u8 as *const libc::c_char,
                klen: (::core::mem::size_of::<[libc::c_char; 31]>() as libc::c_ulong as uint32_t)
                    .wrapping_sub(1 as libc::c_int as libc::c_uint)
                    as uint8_t,
                ktype: T_CONFIG_SHORT as libc::c_int as uint8_t,
                scope: T_CONFIG_SCOPE_CONNECTION as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = config_plugin_keys_t {
                k: b"server.max-keep-alive-idle\0" as *const u8 as *const libc::c_char,
                klen: (::core::mem::size_of::<[libc::c_char; 27]>() as libc::c_ulong as uint32_t)
                    .wrapping_sub(1 as libc::c_int as libc::c_uint)
                    as uint8_t,
                ktype: T_CONFIG_SHORT as libc::c_int as uint8_t,
                scope: T_CONFIG_SCOPE_CONNECTION as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = config_plugin_keys_t {
                k: b"server.max-read-idle\0" as *const u8 as *const libc::c_char,
                klen: (::core::mem::size_of::<[libc::c_char; 21]>() as libc::c_ulong as uint32_t)
                    .wrapping_sub(1 as libc::c_int as libc::c_uint)
                    as uint8_t,
                ktype: T_CONFIG_SHORT as libc::c_int as uint8_t,
                scope: T_CONFIG_SCOPE_CONNECTION as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = config_plugin_keys_t {
                k: b"server.max-write-idle\0" as *const u8 as *const libc::c_char,
                klen: (::core::mem::size_of::<[libc::c_char; 22]>() as libc::c_ulong as uint32_t)
                    .wrapping_sub(1 as libc::c_int as libc::c_uint)
                    as uint8_t,
                ktype: T_CONFIG_SHORT as libc::c_int as uint8_t,
                scope: T_CONFIG_SCOPE_CONNECTION as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = config_plugin_keys_t {
                k: b"server.errorfile-prefix\0" as *const u8 as *const libc::c_char,
                klen: (::core::mem::size_of::<[libc::c_char; 24]>() as libc::c_ulong as uint32_t)
                    .wrapping_sub(1 as libc::c_int as libc::c_uint)
                    as uint8_t,
                ktype: T_CONFIG_STRING as libc::c_int as uint8_t,
                scope: T_CONFIG_SCOPE_CONNECTION as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = config_plugin_keys_t {
                k: b"server.error-handler\0" as *const u8 as *const libc::c_char,
                klen: (::core::mem::size_of::<[libc::c_char; 21]>() as libc::c_ulong as uint32_t)
                    .wrapping_sub(1 as libc::c_int as libc::c_uint)
                    as uint8_t,
                ktype: T_CONFIG_STRING as libc::c_int as uint8_t,
                scope: T_CONFIG_SCOPE_CONNECTION as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = config_plugin_keys_t {
                k: b"server.error-handler-404\0" as *const u8 as *const libc::c_char,
                klen: (::core::mem::size_of::<[libc::c_char; 25]>() as libc::c_ulong as uint32_t)
                    .wrapping_sub(1 as libc::c_int as libc::c_uint)
                    as uint8_t,
                ktype: T_CONFIG_STRING as libc::c_int as uint8_t,
                scope: T_CONFIG_SCOPE_CONNECTION as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = config_plugin_keys_t {
                k: b"server.error-intercept\0" as *const u8 as *const libc::c_char,
                klen: (::core::mem::size_of::<[libc::c_char; 23]>() as libc::c_ulong as uint32_t)
                    .wrapping_sub(1 as libc::c_int as libc::c_uint)
                    as uint8_t,
                ktype: T_CONFIG_BOOL as libc::c_int as uint8_t,
                scope: T_CONFIG_SCOPE_CONNECTION as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = config_plugin_keys_t {
                k: b"server.force-lowercase-filenames\0" as *const u8 as *const libc::c_char,
                klen: (::core::mem::size_of::<[libc::c_char; 33]>() as libc::c_ulong as uint32_t)
                    .wrapping_sub(1 as libc::c_int as libc::c_uint)
                    as uint8_t,
                ktype: T_CONFIG_BOOL as libc::c_int as uint8_t,
                scope: T_CONFIG_SCOPE_CONNECTION as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = config_plugin_keys_t {
                k: b"server.follow-symlink\0" as *const u8 as *const libc::c_char,
                klen: (::core::mem::size_of::<[libc::c_char; 22]>() as libc::c_ulong as uint32_t)
                    .wrapping_sub(1 as libc::c_int as libc::c_uint)
                    as uint8_t,
                ktype: T_CONFIG_BOOL as libc::c_int as uint8_t,
                scope: T_CONFIG_SCOPE_CONNECTION as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = config_plugin_keys_t {
                k: b"server.protocol-http11\0" as *const u8 as *const libc::c_char,
                klen: (::core::mem::size_of::<[libc::c_char; 23]>() as libc::c_ulong as uint32_t)
                    .wrapping_sub(1 as libc::c_int as libc::c_uint)
                    as uint8_t,
                ktype: T_CONFIG_BOOL as libc::c_int as uint8_t,
                scope: T_CONFIG_SCOPE_CONNECTION as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = config_plugin_keys_t {
                k: b"server.range-requests\0" as *const u8 as *const libc::c_char,
                klen: (::core::mem::size_of::<[libc::c_char; 22]>() as libc::c_ulong as uint32_t)
                    .wrapping_sub(1 as libc::c_int as libc::c_uint)
                    as uint8_t,
                ktype: T_CONFIG_BOOL as libc::c_int as uint8_t,
                scope: T_CONFIG_SCOPE_CONNECTION as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = config_plugin_keys_t {
                k: b"server.stream-request-body\0" as *const u8 as *const libc::c_char,
                klen: (::core::mem::size_of::<[libc::c_char; 27]>() as libc::c_ulong as uint32_t)
                    .wrapping_sub(1 as libc::c_int as libc::c_uint)
                    as uint8_t,
                ktype: T_CONFIG_SHORT as libc::c_int as uint8_t,
                scope: T_CONFIG_SCOPE_CONNECTION as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = config_plugin_keys_t {
                k: b"server.stream-response-body\0" as *const u8 as *const libc::c_char,
                klen: (::core::mem::size_of::<[libc::c_char; 28]>() as libc::c_ulong as uint32_t)
                    .wrapping_sub(1 as libc::c_int as libc::c_uint)
                    as uint8_t,
                ktype: T_CONFIG_SHORT as libc::c_int as uint8_t,
                scope: T_CONFIG_SCOPE_CONNECTION as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = config_plugin_keys_t {
                k: b"server.kbytes-per-second\0" as *const u8 as *const libc::c_char,
                klen: (::core::mem::size_of::<[libc::c_char; 25]>() as libc::c_ulong as uint32_t)
                    .wrapping_sub(1 as libc::c_int as libc::c_uint)
                    as uint8_t,
                ktype: T_CONFIG_SHORT as libc::c_int as uint8_t,
                scope: T_CONFIG_SCOPE_CONNECTION as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = config_plugin_keys_t {
                k: b"connection.kbytes-per-second\0" as *const u8 as *const libc::c_char,
                klen: (::core::mem::size_of::<[libc::c_char; 29]>() as libc::c_ulong as uint32_t)
                    .wrapping_sub(1 as libc::c_int as libc::c_uint)
                    as uint8_t,
                ktype: T_CONFIG_SHORT as libc::c_int as uint8_t,
                scope: T_CONFIG_SCOPE_CONNECTION as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = config_plugin_keys_t {
                k: b"mimetype.assign\0" as *const u8 as *const libc::c_char,
                klen: (::core::mem::size_of::<[libc::c_char; 16]>() as libc::c_ulong as uint32_t)
                    .wrapping_sub(1 as libc::c_int as libc::c_uint)
                    as uint8_t,
                ktype: T_CONFIG_ARRAY_KVSTRING as libc::c_int as uint8_t,
                scope: T_CONFIG_SCOPE_CONNECTION as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = config_plugin_keys_t {
                k: b"mimetype.use-xattr\0" as *const u8 as *const libc::c_char,
                klen: (::core::mem::size_of::<[libc::c_char; 19]>() as libc::c_ulong as uint32_t)
                    .wrapping_sub(1 as libc::c_int as libc::c_uint)
                    as uint8_t,
                ktype: T_CONFIG_BOOL as libc::c_int as uint8_t,
                scope: T_CONFIG_SCOPE_CONNECTION as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = config_plugin_keys_t {
                k: b"etag.use-inode\0" as *const u8 as *const libc::c_char,
                klen: (::core::mem::size_of::<[libc::c_char; 15]>() as libc::c_ulong as uint32_t)
                    .wrapping_sub(1 as libc::c_int as libc::c_uint)
                    as uint8_t,
                ktype: T_CONFIG_BOOL as libc::c_int as uint8_t,
                scope: T_CONFIG_SCOPE_CONNECTION as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = config_plugin_keys_t {
                k: b"etag.use-mtime\0" as *const u8 as *const libc::c_char,
                klen: (::core::mem::size_of::<[libc::c_char; 15]>() as libc::c_ulong as uint32_t)
                    .wrapping_sub(1 as libc::c_int as libc::c_uint)
                    as uint8_t,
                ktype: T_CONFIG_BOOL as libc::c_int as uint8_t,
                scope: T_CONFIG_SCOPE_CONNECTION as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = config_plugin_keys_t {
                k: b"etag.use-size\0" as *const u8 as *const libc::c_char,
                klen: (::core::mem::size_of::<[libc::c_char; 14]>() as libc::c_ulong as uint32_t)
                    .wrapping_sub(1 as libc::c_int as libc::c_uint)
                    as uint8_t,
                ktype: T_CONFIG_BOOL as libc::c_int as uint8_t,
                scope: T_CONFIG_SCOPE_CONNECTION as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = config_plugin_keys_t {
                k: b"debug.log-condition-handling\0" as *const u8 as *const libc::c_char,
                klen: (::core::mem::size_of::<[libc::c_char; 29]>() as libc::c_ulong as uint32_t)
                    .wrapping_sub(1 as libc::c_int as libc::c_uint)
                    as uint8_t,
                ktype: T_CONFIG_BOOL as libc::c_int as uint8_t,
                scope: T_CONFIG_SCOPE_CONNECTION as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = config_plugin_keys_t {
                k: b"debug.log-file-not-found\0" as *const u8 as *const libc::c_char,
                klen: (::core::mem::size_of::<[libc::c_char; 25]>() as libc::c_ulong as uint32_t)
                    .wrapping_sub(1 as libc::c_int as libc::c_uint)
                    as uint8_t,
                ktype: T_CONFIG_BOOL as libc::c_int as uint8_t,
                scope: T_CONFIG_SCOPE_CONNECTION as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = config_plugin_keys_t {
                k: b"debug.log-request-handling\0" as *const u8 as *const libc::c_char,
                klen: (::core::mem::size_of::<[libc::c_char; 27]>() as libc::c_ulong as uint32_t)
                    .wrapping_sub(1 as libc::c_int as libc::c_uint)
                    as uint8_t,
                ktype: T_CONFIG_BOOL as libc::c_int as uint8_t,
                scope: T_CONFIG_SCOPE_CONNECTION as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = config_plugin_keys_t {
                k: b"debug.log-request-header\0" as *const u8 as *const libc::c_char,
                klen: (::core::mem::size_of::<[libc::c_char; 25]>() as libc::c_ulong as uint32_t)
                    .wrapping_sub(1 as libc::c_int as libc::c_uint)
                    as uint8_t,
                ktype: T_CONFIG_BOOL as libc::c_int as uint8_t,
                scope: T_CONFIG_SCOPE_CONNECTION as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = config_plugin_keys_t {
                k: b"debug.log-response-header\0" as *const u8 as *const libc::c_char,
                klen: (::core::mem::size_of::<[libc::c_char; 26]>() as libc::c_ulong as uint32_t)
                    .wrapping_sub(1 as libc::c_int as libc::c_uint)
                    as uint8_t,
                ktype: T_CONFIG_BOOL as libc::c_int as uint8_t,
                scope: T_CONFIG_SCOPE_CONNECTION as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = config_plugin_keys_t {
                k: b"debug.log-timeouts\0" as *const u8 as *const libc::c_char,
                klen: (::core::mem::size_of::<[libc::c_char; 19]>() as libc::c_ulong as uint32_t)
                    .wrapping_sub(1 as libc::c_int as libc::c_uint)
                    as uint8_t,
                ktype: T_CONFIG_BOOL as libc::c_int as uint8_t,
                scope: T_CONFIG_SCOPE_CONNECTION as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = config_plugin_keys_t {
                k: b"debug.log-state-handling\0" as *const u8 as *const libc::c_char,
                klen: (::core::mem::size_of::<[libc::c_char; 25]>() as libc::c_ulong as uint32_t)
                    .wrapping_sub(1 as libc::c_int as libc::c_uint)
                    as uint8_t,
                ktype: T_CONFIG_BOOL as libc::c_int as uint8_t,
                scope: T_CONFIG_SCOPE_CONNECTION as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = config_plugin_keys_t {
                k: b"server.errorlog\0" as *const u8 as *const libc::c_char,
                klen: (::core::mem::size_of::<[libc::c_char; 16]>() as libc::c_ulong as uint32_t)
                    .wrapping_sub(1 as libc::c_int as libc::c_uint)
                    as uint8_t,
                ktype: T_CONFIG_STRING as libc::c_int as uint8_t,
                scope: T_CONFIG_SCOPE_CONNECTION as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = config_plugin_keys_t {
                k: b"server.breakagelog\0" as *const u8 as *const libc::c_char,
                klen: (::core::mem::size_of::<[libc::c_char; 19]>() as libc::c_ulong as uint32_t)
                    .wrapping_sub(1 as libc::c_int as libc::c_uint)
                    as uint8_t,
                ktype: T_CONFIG_STRING as libc::c_int as uint8_t,
                scope: T_CONFIG_SCOPE_CONNECTION as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = config_plugin_keys_t {
                k: 0 as *const libc::c_char,
                klen: 0 as libc::c_int as uint8_t,
                ktype: T_CONFIG_UNSET as libc::c_int as uint8_t,
                scope: T_CONFIG_SCOPE_UNSET as libc::c_int as uint8_t,
            };
            init
        },
    ];
    cpk_1 = [
        {
            let mut init = config_plugin_keys_t {
                k: b"server.modules\0" as *const u8 as *const libc::c_char,
                klen: (::core::mem::size_of::<[libc::c_char; 15]>() as libc::c_ulong as uint32_t)
                    .wrapping_sub(1 as libc::c_int as libc::c_uint)
                    as uint8_t,
                ktype: T_CONFIG_ARRAY_VLIST as libc::c_int as uint8_t,
                scope: T_CONFIG_SCOPE_SERVER as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = config_plugin_keys_t {
                k: b"server.compat-module-load\0" as *const u8 as *const libc::c_char,
                klen: (::core::mem::size_of::<[libc::c_char; 26]>() as libc::c_ulong as uint32_t)
                    .wrapping_sub(1 as libc::c_int as libc::c_uint)
                    as uint8_t,
                ktype: T_CONFIG_BOOL as libc::c_int as uint8_t,
                scope: T_CONFIG_SCOPE_SERVER as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = config_plugin_keys_t {
                k: b"server.systemd-socket-activation\0" as *const u8 as *const libc::c_char,
                klen: (::core::mem::size_of::<[libc::c_char; 33]>() as libc::c_ulong as uint32_t)
                    .wrapping_sub(1 as libc::c_int as libc::c_uint)
                    as uint8_t,
                ktype: T_CONFIG_BOOL as libc::c_int as uint8_t,
                scope: T_CONFIG_SCOPE_SERVER as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = config_plugin_keys_t {
                k: b"server.port\0" as *const u8 as *const libc::c_char,
                klen: (::core::mem::size_of::<[libc::c_char; 12]>() as libc::c_ulong as uint32_t)
                    .wrapping_sub(1 as libc::c_int as libc::c_uint)
                    as uint8_t,
                ktype: T_CONFIG_SHORT as libc::c_int as uint8_t,
                scope: T_CONFIG_SCOPE_SERVER as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = config_plugin_keys_t {
                k: b"server.bind\0" as *const u8 as *const libc::c_char,
                klen: (::core::mem::size_of::<[libc::c_char; 12]>() as libc::c_ulong as uint32_t)
                    .wrapping_sub(1 as libc::c_int as libc::c_uint)
                    as uint8_t,
                ktype: T_CONFIG_STRING as libc::c_int as uint8_t,
                scope: T_CONFIG_SCOPE_SERVER as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = config_plugin_keys_t {
                k: b"server.network-backend\0" as *const u8 as *const libc::c_char,
                klen: (::core::mem::size_of::<[libc::c_char; 23]>() as libc::c_ulong as uint32_t)
                    .wrapping_sub(1 as libc::c_int as libc::c_uint)
                    as uint8_t,
                ktype: T_CONFIG_STRING as libc::c_int as uint8_t,
                scope: T_CONFIG_SCOPE_SERVER as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = config_plugin_keys_t {
                k: b"server.chroot\0" as *const u8 as *const libc::c_char,
                klen: (::core::mem::size_of::<[libc::c_char; 14]>() as libc::c_ulong as uint32_t)
                    .wrapping_sub(1 as libc::c_int as libc::c_uint)
                    as uint8_t,
                ktype: T_CONFIG_STRING as libc::c_int as uint8_t,
                scope: T_CONFIG_SCOPE_SERVER as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = config_plugin_keys_t {
                k: b"server.username\0" as *const u8 as *const libc::c_char,
                klen: (::core::mem::size_of::<[libc::c_char; 16]>() as libc::c_ulong as uint32_t)
                    .wrapping_sub(1 as libc::c_int as libc::c_uint)
                    as uint8_t,
                ktype: T_CONFIG_STRING as libc::c_int as uint8_t,
                scope: T_CONFIG_SCOPE_SERVER as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = config_plugin_keys_t {
                k: b"server.groupname\0" as *const u8 as *const libc::c_char,
                klen: (::core::mem::size_of::<[libc::c_char; 17]>() as libc::c_ulong as uint32_t)
                    .wrapping_sub(1 as libc::c_int as libc::c_uint)
                    as uint8_t,
                ktype: T_CONFIG_STRING as libc::c_int as uint8_t,
                scope: T_CONFIG_SCOPE_SERVER as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = config_plugin_keys_t {
                k: b"server.errorlog-placeholder-moved-to-config-insert\0" as *const u8
                    as *const libc::c_char,
                klen: (::core::mem::size_of::<[libc::c_char; 51]>() as libc::c_ulong as uint32_t)
                    .wrapping_sub(1 as libc::c_int as libc::c_uint)
                    as uint8_t,
                ktype: T_CONFIG_STRING as libc::c_int as uint8_t,
                scope: T_CONFIG_SCOPE_SERVER as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = config_plugin_keys_t {
                k: b"server.breakagelog-placeholder-moved-to-config-insert\0" as *const u8
                    as *const libc::c_char,
                klen: (::core::mem::size_of::<[libc::c_char; 54]>() as libc::c_ulong as uint32_t)
                    .wrapping_sub(1 as libc::c_int as libc::c_uint)
                    as uint8_t,
                ktype: T_CONFIG_STRING as libc::c_int as uint8_t,
                scope: T_CONFIG_SCOPE_SERVER as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = config_plugin_keys_t {
                k: b"server.errorlog-use-syslog\0" as *const u8 as *const libc::c_char,
                klen: (::core::mem::size_of::<[libc::c_char; 27]>() as libc::c_ulong as uint32_t)
                    .wrapping_sub(1 as libc::c_int as libc::c_uint)
                    as uint8_t,
                ktype: T_CONFIG_BOOL as libc::c_int as uint8_t,
                scope: T_CONFIG_SCOPE_SERVER as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = config_plugin_keys_t {
                k: b"server.syslog-facility\0" as *const u8 as *const libc::c_char,
                klen: (::core::mem::size_of::<[libc::c_char; 23]>() as libc::c_ulong as uint32_t)
                    .wrapping_sub(1 as libc::c_int as libc::c_uint)
                    as uint8_t,
                ktype: T_CONFIG_STRING as libc::c_int as uint8_t,
                scope: T_CONFIG_SCOPE_SERVER as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = config_plugin_keys_t {
                k: b"server.core-files\0" as *const u8 as *const libc::c_char,
                klen: (::core::mem::size_of::<[libc::c_char; 18]>() as libc::c_ulong as uint32_t)
                    .wrapping_sub(1 as libc::c_int as libc::c_uint)
                    as uint8_t,
                ktype: T_CONFIG_BOOL as libc::c_int as uint8_t,
                scope: T_CONFIG_SCOPE_SERVER as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = config_plugin_keys_t {
                k: b"server.event-handler\0" as *const u8 as *const libc::c_char,
                klen: (::core::mem::size_of::<[libc::c_char; 21]>() as libc::c_ulong as uint32_t)
                    .wrapping_sub(1 as libc::c_int as libc::c_uint)
                    as uint8_t,
                ktype: T_CONFIG_STRING as libc::c_int as uint8_t,
                scope: T_CONFIG_SCOPE_SERVER as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = config_plugin_keys_t {
                k: b"server.pid-file\0" as *const u8 as *const libc::c_char,
                klen: (::core::mem::size_of::<[libc::c_char; 16]>() as libc::c_ulong as uint32_t)
                    .wrapping_sub(1 as libc::c_int as libc::c_uint)
                    as uint8_t,
                ktype: T_CONFIG_STRING as libc::c_int as uint8_t,
                scope: T_CONFIG_SCOPE_SERVER as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = config_plugin_keys_t {
                k: b"server.max-worker\0" as *const u8 as *const libc::c_char,
                klen: (::core::mem::size_of::<[libc::c_char; 18]>() as libc::c_ulong as uint32_t)
                    .wrapping_sub(1 as libc::c_int as libc::c_uint)
                    as uint8_t,
                ktype: T_CONFIG_SHORT as libc::c_int as uint8_t,
                scope: T_CONFIG_SCOPE_SERVER as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = config_plugin_keys_t {
                k: b"server.max-fds\0" as *const u8 as *const libc::c_char,
                klen: (::core::mem::size_of::<[libc::c_char; 15]>() as libc::c_ulong as uint32_t)
                    .wrapping_sub(1 as libc::c_int as libc::c_uint)
                    as uint8_t,
                ktype: T_CONFIG_SHORT as libc::c_int as uint8_t,
                scope: T_CONFIG_SCOPE_SERVER as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = config_plugin_keys_t {
                k: b"server.max-connections\0" as *const u8 as *const libc::c_char,
                klen: (::core::mem::size_of::<[libc::c_char; 23]>() as libc::c_ulong as uint32_t)
                    .wrapping_sub(1 as libc::c_int as libc::c_uint)
                    as uint8_t,
                ktype: T_CONFIG_SHORT as libc::c_int as uint8_t,
                scope: T_CONFIG_SCOPE_SERVER as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = config_plugin_keys_t {
                k: b"server.max-request-field-size\0" as *const u8 as *const libc::c_char,
                klen: (::core::mem::size_of::<[libc::c_char; 30]>() as libc::c_ulong as uint32_t)
                    .wrapping_sub(1 as libc::c_int as libc::c_uint)
                    as uint8_t,
                ktype: T_CONFIG_INT as libc::c_int as uint8_t,
                scope: T_CONFIG_SCOPE_SERVER as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = config_plugin_keys_t {
                k: b"server.chunkqueue-chunk-sz\0" as *const u8 as *const libc::c_char,
                klen: (::core::mem::size_of::<[libc::c_char; 27]>() as libc::c_ulong as uint32_t)
                    .wrapping_sub(1 as libc::c_int as libc::c_uint)
                    as uint8_t,
                ktype: T_CONFIG_INT as libc::c_int as uint8_t,
                scope: T_CONFIG_SCOPE_SERVER as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = config_plugin_keys_t {
                k: b"server.upload-temp-file-size\0" as *const u8 as *const libc::c_char,
                klen: (::core::mem::size_of::<[libc::c_char; 29]>() as libc::c_ulong as uint32_t)
                    .wrapping_sub(1 as libc::c_int as libc::c_uint)
                    as uint8_t,
                ktype: T_CONFIG_INT as libc::c_int as uint8_t,
                scope: T_CONFIG_SCOPE_SERVER as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = config_plugin_keys_t {
                k: b"server.upload-dirs\0" as *const u8 as *const libc::c_char,
                klen: (::core::mem::size_of::<[libc::c_char; 19]>() as libc::c_ulong as uint32_t)
                    .wrapping_sub(1 as libc::c_int as libc::c_uint)
                    as uint8_t,
                ktype: T_CONFIG_ARRAY_VLIST as libc::c_int as uint8_t,
                scope: T_CONFIG_SCOPE_SERVER as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = config_plugin_keys_t {
                k: b"server.http-parseopts\0" as *const u8 as *const libc::c_char,
                klen: (::core::mem::size_of::<[libc::c_char; 22]>() as libc::c_ulong as uint32_t)
                    .wrapping_sub(1 as libc::c_int as libc::c_uint)
                    as uint8_t,
                ktype: T_CONFIG_ARRAY_KVSTRING as libc::c_int as uint8_t,
                scope: T_CONFIG_SCOPE_SERVER as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = config_plugin_keys_t {
                k: b"server.http-parseopt-header-strict\0" as *const u8 as *const libc::c_char,
                klen: (::core::mem::size_of::<[libc::c_char; 35]>() as libc::c_ulong as uint32_t)
                    .wrapping_sub(1 as libc::c_int as libc::c_uint)
                    as uint8_t,
                ktype: T_CONFIG_BOOL as libc::c_int as uint8_t,
                scope: T_CONFIG_SCOPE_SERVER as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = config_plugin_keys_t {
                k: b"server.http-parseopt-host-strict\0" as *const u8 as *const libc::c_char,
                klen: (::core::mem::size_of::<[libc::c_char; 33]>() as libc::c_ulong as uint32_t)
                    .wrapping_sub(1 as libc::c_int as libc::c_uint)
                    as uint8_t,
                ktype: T_CONFIG_BOOL as libc::c_int as uint8_t,
                scope: T_CONFIG_SCOPE_SERVER as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = config_plugin_keys_t {
                k: b"server.http-parseopt-host-normalize\0" as *const u8 as *const libc::c_char,
                klen: (::core::mem::size_of::<[libc::c_char; 36]>() as libc::c_ulong as uint32_t)
                    .wrapping_sub(1 as libc::c_int as libc::c_uint)
                    as uint8_t,
                ktype: T_CONFIG_BOOL as libc::c_int as uint8_t,
                scope: T_CONFIG_SCOPE_SERVER as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = config_plugin_keys_t {
                k: b"server.reject-expect-100-with-417\0" as *const u8 as *const libc::c_char,
                klen: (::core::mem::size_of::<[libc::c_char; 34]>() as libc::c_ulong as uint32_t)
                    .wrapping_sub(1 as libc::c_int as libc::c_uint)
                    as uint8_t,
                ktype: T_CONFIG_BOOL as libc::c_int as uint8_t,
                scope: T_CONFIG_SCOPE_SERVER as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = config_plugin_keys_t {
                k: b"server.stat-cache-engine\0" as *const u8 as *const libc::c_char,
                klen: (::core::mem::size_of::<[libc::c_char; 25]>() as libc::c_ulong as uint32_t)
                    .wrapping_sub(1 as libc::c_int as libc::c_uint)
                    as uint8_t,
                ktype: T_CONFIG_STRING as libc::c_int as uint8_t,
                scope: T_CONFIG_SCOPE_SERVER as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = config_plugin_keys_t {
                k: b"mimetype.xattr-name\0" as *const u8 as *const libc::c_char,
                klen: (::core::mem::size_of::<[libc::c_char; 20]>() as libc::c_ulong as uint32_t)
                    .wrapping_sub(1 as libc::c_int as libc::c_uint)
                    as uint8_t,
                ktype: T_CONFIG_STRING as libc::c_int as uint8_t,
                scope: T_CONFIG_SCOPE_SERVER as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = config_plugin_keys_t {
                k: b"ssl.engine\0" as *const u8 as *const libc::c_char,
                klen: (::core::mem::size_of::<[libc::c_char; 11]>() as libc::c_ulong as uint32_t)
                    .wrapping_sub(1 as libc::c_int as libc::c_uint)
                    as uint8_t,
                ktype: T_CONFIG_BOOL as libc::c_int as uint8_t,
                scope: T_CONFIG_SCOPE_CONNECTION as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = config_plugin_keys_t {
                k: b"debug.log-request-header-on-error\0" as *const u8 as *const libc::c_char,
                klen: (::core::mem::size_of::<[libc::c_char; 34]>() as libc::c_ulong as uint32_t)
                    .wrapping_sub(1 as libc::c_int as libc::c_uint)
                    as uint8_t,
                ktype: T_CONFIG_BOOL as libc::c_int as uint8_t,
                scope: T_CONFIG_SCOPE_SERVER as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = config_plugin_keys_t {
                k: b"server.feature-flags\0" as *const u8 as *const libc::c_char,
                klen: (::core::mem::size_of::<[libc::c_char; 21]>() as libc::c_ulong as uint32_t)
                    .wrapping_sub(1 as libc::c_int as libc::c_uint)
                    as uint8_t,
                ktype: T_CONFIG_ARRAY_KVANY as libc::c_int as uint8_t,
                scope: T_CONFIG_SCOPE_SERVER as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = config_plugin_keys_t {
                k: 0 as *const libc::c_char,
                klen: 0 as libc::c_int as uint8_t,
                ktype: T_CONFIG_UNSET as libc::c_int as uint8_t,
                scope: T_CONFIG_SCOPE_UNSET as libc::c_int as uint8_t,
            };
            init
        },
    ];
    comps = [
        {
            let mut init = C2RustUnnamed_30 {
                comp: COMP_HTTP_URL,
                len: (::core::mem::size_of::<[libc::c_char; 4]>() as libc::c_ulong as uint32_t)
                    .wrapping_sub(1 as libc::c_int as libc::c_uint),
                comp_tag: b"url\0" as *const u8 as *const libc::c_char,
            };
            init
        },
        {
            let mut init = C2RustUnnamed_30 {
                comp: COMP_HTTP_HOST,
                len: (::core::mem::size_of::<[libc::c_char; 5]>() as libc::c_ulong as uint32_t)
                    .wrapping_sub(1 as libc::c_int as libc::c_uint),
                comp_tag: b"host\0" as *const u8 as *const libc::c_char,
            };
            init
        },
        {
            let mut init = C2RustUnnamed_30 {
                comp: COMP_HTTP_REQUEST_HEADER,
                len: (::core::mem::size_of::<[libc::c_char; 8]>() as libc::c_ulong as uint32_t)
                    .wrapping_sub(1 as libc::c_int as libc::c_uint),
                comp_tag: b"referer\0" as *const u8 as *const libc::c_char,
            };
            init
        },
        {
            let mut init = C2RustUnnamed_30 {
                comp: COMP_HTTP_USER_AGENT,
                len: (::core::mem::size_of::<[libc::c_char; 10]>() as libc::c_ulong as uint32_t)
                    .wrapping_sub(1 as libc::c_int as libc::c_uint),
                comp_tag: b"useragent\0" as *const u8 as *const libc::c_char,
            };
            init
        },
        {
            let mut init = C2RustUnnamed_30 {
                comp: COMP_HTTP_REQUEST_HEADER,
                len: (::core::mem::size_of::<[libc::c_char; 11]>() as libc::c_ulong as uint32_t)
                    .wrapping_sub(1 as libc::c_int as libc::c_uint),
                comp_tag: b"user-agent\0" as *const u8 as *const libc::c_char,
            };
            init
        },
        {
            let mut init = C2RustUnnamed_30 {
                comp: COMP_HTTP_LANGUAGE,
                len: (::core::mem::size_of::<[libc::c_char; 9]>() as libc::c_ulong as uint32_t)
                    .wrapping_sub(1 as libc::c_int as libc::c_uint),
                comp_tag: b"language\0" as *const u8 as *const libc::c_char,
            };
            init
        },
        {
            let mut init = C2RustUnnamed_30 {
                comp: COMP_HTTP_REQUEST_HEADER,
                len: (::core::mem::size_of::<[libc::c_char; 7]>() as libc::c_ulong as uint32_t)
                    .wrapping_sub(1 as libc::c_int as libc::c_uint),
                comp_tag: b"cookie\0" as *const u8 as *const libc::c_char,
            };
            init
        },
        {
            let mut init = C2RustUnnamed_30 {
                comp: COMP_HTTP_REMOTE_IP,
                len: (::core::mem::size_of::<[libc::c_char; 9]>() as libc::c_ulong as uint32_t)
                    .wrapping_sub(1 as libc::c_int as libc::c_uint),
                comp_tag: b"remoteip\0" as *const u8 as *const libc::c_char,
            };
            init
        },
        {
            let mut init = C2RustUnnamed_30 {
                comp: COMP_HTTP_REMOTE_IP,
                len: (::core::mem::size_of::<[libc::c_char; 10]>() as libc::c_ulong as uint32_t)
                    .wrapping_sub(1 as libc::c_int as libc::c_uint),
                comp_tag: b"remote-ip\0" as *const u8 as *const libc::c_char,
            };
            init
        },
        {
            let mut init = C2RustUnnamed_30 {
                comp: COMP_HTTP_QUERY_STRING,
                len: (::core::mem::size_of::<[libc::c_char; 12]>() as libc::c_ulong as uint32_t)
                    .wrapping_sub(1 as libc::c_int as libc::c_uint),
                comp_tag: b"querystring\0" as *const u8 as *const libc::c_char,
            };
            init
        },
        {
            let mut init = C2RustUnnamed_30 {
                comp: COMP_HTTP_QUERY_STRING,
                len: (::core::mem::size_of::<[libc::c_char; 13]>() as libc::c_ulong as uint32_t)
                    .wrapping_sub(1 as libc::c_int as libc::c_uint),
                comp_tag: b"query-string\0" as *const u8 as *const libc::c_char,
            };
            init
        },
        {
            let mut init = C2RustUnnamed_30 {
                comp: COMP_HTTP_REQUEST_METHOD,
                len: (::core::mem::size_of::<[libc::c_char; 15]>() as libc::c_ulong as uint32_t)
                    .wrapping_sub(1 as libc::c_int as libc::c_uint),
                comp_tag: b"request-method\0" as *const u8 as *const libc::c_char,
            };
            init
        },
        {
            let mut init = C2RustUnnamed_30 {
                comp: COMP_HTTP_SCHEME,
                len: (::core::mem::size_of::<[libc::c_char; 7]>() as libc::c_ulong as uint32_t)
                    .wrapping_sub(1 as libc::c_int as libc::c_uint),
                comp_tag: b"scheme\0" as *const u8 as *const libc::c_char,
            };
            init
        },
    ];
    http_headers = [
        {
            let mut init = keyvlenvalue {
                key: HTTP_HEADER_TE as libc::c_int as int16_t,
                vlen: (::core::mem::size_of::<[libc::c_char; 3]>() as libc::c_ulong as uint32_t)
                    .wrapping_sub(1 as libc::c_int as libc::c_uint)
                    as uint16_t,
                value: *::core::mem::transmute::<&[u8; 28], &[libc::c_char; 28]>(
                    b"te\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0",
                ),
            };
            init
        },
        {
            let mut init = keyvlenvalue {
                key: HTTP_HEADER_AGE as libc::c_int as int16_t,
                vlen: (::core::mem::size_of::<[libc::c_char; 4]>() as libc::c_ulong as uint32_t)
                    .wrapping_sub(1 as libc::c_int as libc::c_uint)
                    as uint16_t,
                value: *::core::mem::transmute::<&[u8; 28], &[libc::c_char; 28]>(
                    b"age\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0",
                ),
            };
            init
        },
        {
            let mut init = keyvlenvalue {
                key: HTTP_HEADER_DNT as libc::c_int as int16_t,
                vlen: (::core::mem::size_of::<[libc::c_char; 4]>() as libc::c_ulong as uint32_t)
                    .wrapping_sub(1 as libc::c_int as libc::c_uint)
                    as uint16_t,
                value: *::core::mem::transmute::<&[u8; 28], &[libc::c_char; 28]>(
                    b"dnt\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0",
                ),
            };
            init
        },
        {
            let mut init = keyvlenvalue {
                key: HTTP_HEADER_P3P as libc::c_int as int16_t,
                vlen: (::core::mem::size_of::<[libc::c_char; 4]>() as libc::c_ulong as uint32_t)
                    .wrapping_sub(1 as libc::c_int as libc::c_uint)
                    as uint16_t,
                value: *::core::mem::transmute::<&[u8; 28], &[libc::c_char; 28]>(
                    b"p3p\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0",
                ),
            };
            init
        },
        {
            let mut init = keyvlenvalue {
                key: HTTP_HEADER_HOST as libc::c_int as int16_t,
                vlen: (::core::mem::size_of::<[libc::c_char; 5]>() as libc::c_ulong as uint32_t)
                    .wrapping_sub(1 as libc::c_int as libc::c_uint)
                    as uint16_t,
                value: *::core::mem::transmute::<&[u8; 28], &[libc::c_char; 28]>(
                    b"host\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0",
                ),
            };
            init
        },
        {
            let mut init = keyvlenvalue {
                key: HTTP_HEADER_DATE as libc::c_int as int16_t,
                vlen: (::core::mem::size_of::<[libc::c_char; 5]>() as libc::c_ulong as uint32_t)
                    .wrapping_sub(1 as libc::c_int as libc::c_uint)
                    as uint16_t,
                value: *::core::mem::transmute::<&[u8; 28], &[libc::c_char; 28]>(
                    b"date\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0",
                ),
            };
            init
        },
        {
            let mut init = keyvlenvalue {
                key: HTTP_HEADER_ETAG as libc::c_int as int16_t,
                vlen: (::core::mem::size_of::<[libc::c_char; 5]>() as libc::c_ulong as uint32_t)
                    .wrapping_sub(1 as libc::c_int as libc::c_uint)
                    as uint16_t,
                value: *::core::mem::transmute::<&[u8; 28], &[libc::c_char; 28]>(
                    b"etag\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0",
                ),
            };
            init
        },
        {
            let mut init = keyvlenvalue {
                key: HTTP_HEADER_VARY as libc::c_int as int16_t,
                vlen: (::core::mem::size_of::<[libc::c_char; 5]>() as libc::c_ulong as uint32_t)
                    .wrapping_sub(1 as libc::c_int as libc::c_uint)
                    as uint16_t,
                value: *::core::mem::transmute::<&[u8; 28], &[libc::c_char; 28]>(
                    b"vary\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0",
                ),
            };
            init
        },
        {
            let mut init = keyvlenvalue {
                key: HTTP_HEADER_LINK as libc::c_int as int16_t,
                vlen: (::core::mem::size_of::<[libc::c_char; 5]>() as libc::c_ulong as uint32_t)
                    .wrapping_sub(1 as libc::c_int as libc::c_uint)
                    as uint16_t,
                value: *::core::mem::transmute::<&[u8; 28], &[libc::c_char; 28]>(
                    b"link\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0",
                ),
            };
            init
        },
        {
            let mut init = keyvlenvalue {
                key: HTTP_HEADER_ALLOW as libc::c_int as int16_t,
                vlen: (::core::mem::size_of::<[libc::c_char; 6]>() as libc::c_ulong as uint32_t)
                    .wrapping_sub(1 as libc::c_int as libc::c_uint)
                    as uint16_t,
                value: *::core::mem::transmute::<&[u8; 28], &[libc::c_char; 28]>(
                    b"allow\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0",
                ),
            };
            init
        },
        {
            let mut init = keyvlenvalue {
                key: HTTP_HEADER_RANGE as libc::c_int as int16_t,
                vlen: (::core::mem::size_of::<[libc::c_char; 6]>() as libc::c_ulong as uint32_t)
                    .wrapping_sub(1 as libc::c_int as libc::c_uint)
                    as uint16_t,
                value: *::core::mem::transmute::<&[u8; 28], &[libc::c_char; 28]>(
                    b"range\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0",
                ),
            };
            init
        },
        {
            let mut init = keyvlenvalue {
                key: HTTP_HEADER_COOKIE as libc::c_int as int16_t,
                vlen: (::core::mem::size_of::<[libc::c_char; 7]>() as libc::c_ulong as uint32_t)
                    .wrapping_sub(1 as libc::c_int as libc::c_uint)
                    as uint16_t,
                value: *::core::mem::transmute::<&[u8; 28], &[libc::c_char; 28]>(
                    b"cookie\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0",
                ),
            };
            init
        },
        {
            let mut init = keyvlenvalue {
                key: HTTP_HEADER_ACCEPT as libc::c_int as int16_t,
                vlen: (::core::mem::size_of::<[libc::c_char; 7]>() as libc::c_ulong as uint32_t)
                    .wrapping_sub(1 as libc::c_int as libc::c_uint)
                    as uint16_t,
                value: *::core::mem::transmute::<&[u8; 28], &[libc::c_char; 28]>(
                    b"accept\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0",
                ),
            };
            init
        },
        {
            let mut init = keyvlenvalue {
                key: HTTP_HEADER_STATUS as libc::c_int as int16_t,
                vlen: (::core::mem::size_of::<[libc::c_char; 7]>() as libc::c_ulong as uint32_t)
                    .wrapping_sub(1 as libc::c_int as libc::c_uint)
                    as uint16_t,
                value: *::core::mem::transmute::<&[u8; 28], &[libc::c_char; 28]>(
                    b"status\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0",
                ),
            };
            init
        },
        {
            let mut init = keyvlenvalue {
                key: HTTP_HEADER_SERVER as libc::c_int as int16_t,
                vlen: (::core::mem::size_of::<[libc::c_char; 7]>() as libc::c_ulong as uint32_t)
                    .wrapping_sub(1 as libc::c_int as libc::c_uint)
                    as uint16_t,
                value: *::core::mem::transmute::<&[u8; 28], &[libc::c_char; 28]>(
                    b"server\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0",
                ),
            };
            init
        },
        {
            let mut init = keyvlenvalue {
                key: HTTP_HEADER_EXPECT as libc::c_int as int16_t,
                vlen: (::core::mem::size_of::<[libc::c_char; 7]>() as libc::c_ulong as uint32_t)
                    .wrapping_sub(1 as libc::c_int as libc::c_uint)
                    as uint16_t,
                value: *::core::mem::transmute::<&[u8; 28], &[libc::c_char; 28]>(
                    b"expect\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0",
                ),
            };
            init
        },
        {
            let mut init = keyvlenvalue {
                key: HTTP_HEADER_PRAGMA as libc::c_int as int16_t,
                vlen: (::core::mem::size_of::<[libc::c_char; 7]>() as libc::c_ulong as uint32_t)
                    .wrapping_sub(1 as libc::c_int as libc::c_uint)
                    as uint16_t,
                value: *::core::mem::transmute::<&[u8; 28], &[libc::c_char; 28]>(
                    b"pragma\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0",
                ),
            };
            init
        },
        {
            let mut init = keyvlenvalue {
                key: HTTP_HEADER_UPGRADE as libc::c_int as int16_t,
                vlen: (::core::mem::size_of::<[libc::c_char; 8]>() as libc::c_ulong as uint32_t)
                    .wrapping_sub(1 as libc::c_int as libc::c_uint)
                    as uint16_t,
                value: *::core::mem::transmute::<&[u8; 28], &[libc::c_char; 28]>(
                    b"upgrade\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0",
                ),
            };
            init
        },
        {
            let mut init = keyvlenvalue {
                key: HTTP_HEADER_REFERER as libc::c_int as int16_t,
                vlen: (::core::mem::size_of::<[libc::c_char; 8]>() as libc::c_ulong as uint32_t)
                    .wrapping_sub(1 as libc::c_int as libc::c_uint)
                    as uint16_t,
                value: *::core::mem::transmute::<&[u8; 28], &[libc::c_char; 28]>(
                    b"referer\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0",
                ),
            };
            init
        },
        {
            let mut init = keyvlenvalue {
                key: HTTP_HEADER_EXPIRES as libc::c_int as int16_t,
                vlen: (::core::mem::size_of::<[libc::c_char; 8]>() as libc::c_ulong as uint32_t)
                    .wrapping_sub(1 as libc::c_int as libc::c_uint)
                    as uint16_t,
                value: *::core::mem::transmute::<&[u8; 28], &[libc::c_char; 28]>(
                    b"expires\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0",
                ),
            };
            init
        },
        {
            let mut init = keyvlenvalue {
                key: HTTP_HEADER_ALT_SVC as libc::c_int as int16_t,
                vlen: (::core::mem::size_of::<[libc::c_char; 8]>() as libc::c_ulong as uint32_t)
                    .wrapping_sub(1 as libc::c_int as libc::c_uint)
                    as uint16_t,
                value: *::core::mem::transmute::<&[u8; 28], &[libc::c_char; 28]>(
                    b"alt-svc\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0",
                ),
            };
            init
        },
        {
            let mut init = keyvlenvalue {
                key: HTTP_HEADER_LOCATION as libc::c_int as int16_t,
                vlen: (::core::mem::size_of::<[libc::c_char; 9]>() as libc::c_ulong as uint32_t)
                    .wrapping_sub(1 as libc::c_int as libc::c_uint)
                    as uint16_t,
                value: *::core::mem::transmute::<&[u8; 28], &[libc::c_char; 28]>(
                    b"location\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0",
                ),
            };
            init
        },
        {
            let mut init = keyvlenvalue {
                key: HTTP_HEADER_IF_MATCH as libc::c_int as int16_t,
                vlen: (::core::mem::size_of::<[libc::c_char; 9]>() as libc::c_ulong as uint32_t)
                    .wrapping_sub(1 as libc::c_int as libc::c_uint)
                    as uint16_t,
                value: *::core::mem::transmute::<&[u8; 28], &[libc::c_char; 28]>(
                    b"if-match\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0",
                ),
            };
            init
        },
        {
            let mut init = keyvlenvalue {
                key: HTTP_HEADER_IF_RANGE as libc::c_int as int16_t,
                vlen: (::core::mem::size_of::<[libc::c_char; 9]>() as libc::c_ulong as uint32_t)
                    .wrapping_sub(1 as libc::c_int as libc::c_uint)
                    as uint16_t,
                value: *::core::mem::transmute::<&[u8; 28], &[libc::c_char; 28]>(
                    b"if-range\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0",
                ),
            };
            init
        },
        {
            let mut init = keyvlenvalue {
                key: HTTP_HEADER_ALT_USED as libc::c_int as int16_t,
                vlen: (::core::mem::size_of::<[libc::c_char; 9]>() as libc::c_ulong as uint32_t)
                    .wrapping_sub(1 as libc::c_int as libc::c_uint)
                    as uint16_t,
                value: *::core::mem::transmute::<&[u8; 28], &[libc::c_char; 28]>(
                    b"alt-used\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0",
                ),
            };
            init
        },
        {
            let mut init = keyvlenvalue {
                key: HTTP_HEADER_FORWARDED as libc::c_int as int16_t,
                vlen: (::core::mem::size_of::<[libc::c_char; 10]>() as libc::c_ulong as uint32_t)
                    .wrapping_sub(1 as libc::c_int as libc::c_uint)
                    as uint16_t,
                value: *::core::mem::transmute::<&[u8; 28], &[libc::c_char; 28]>(
                    b"forwarded\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0",
                ),
            };
            init
        },
        {
            let mut init = keyvlenvalue {
                key: HTTP_HEADER_EXPECT_CT as libc::c_int as int16_t,
                vlen: (::core::mem::size_of::<[libc::c_char; 10]>() as libc::c_ulong as uint32_t)
                    .wrapping_sub(1 as libc::c_int as libc::c_uint)
                    as uint16_t,
                value: *::core::mem::transmute::<&[u8; 28], &[libc::c_char; 28]>(
                    b"expect-ct\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0",
                ),
            };
            init
        },
        {
            let mut init = keyvlenvalue {
                key: HTTP_HEADER_CONNECTION as libc::c_int as int16_t,
                vlen: (::core::mem::size_of::<[libc::c_char; 11]>() as libc::c_ulong as uint32_t)
                    .wrapping_sub(1 as libc::c_int as libc::c_uint)
                    as uint16_t,
                value: *::core::mem::transmute::<&[u8; 28], &[libc::c_char; 28]>(
                    b"connection\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0",
                ),
            };
            init
        },
        {
            let mut init = keyvlenvalue {
                key: HTTP_HEADER_SET_COOKIE as libc::c_int as int16_t,
                vlen: (::core::mem::size_of::<[libc::c_char; 11]>() as libc::c_ulong as uint32_t)
                    .wrapping_sub(1 as libc::c_int as libc::c_uint)
                    as uint16_t,
                value: *::core::mem::transmute::<&[u8; 28], &[libc::c_char; 28]>(
                    b"set-cookie\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0",
                ),
            };
            init
        },
        {
            let mut init = keyvlenvalue {
                key: HTTP_HEADER_USER_AGENT as libc::c_int as int16_t,
                vlen: (::core::mem::size_of::<[libc::c_char; 11]>() as libc::c_ulong as uint32_t)
                    .wrapping_sub(1 as libc::c_int as libc::c_uint)
                    as uint16_t,
                value: *::core::mem::transmute::<&[u8; 28], &[libc::c_char; 28]>(
                    b"user-agent\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0",
                ),
            };
            init
        },
        {
            let mut init = keyvlenvalue {
                key: HTTP_HEADER_CONTENT_TYPE as libc::c_int as int16_t,
                vlen: (::core::mem::size_of::<[libc::c_char; 13]>() as libc::c_ulong as uint32_t)
                    .wrapping_sub(1 as libc::c_int as libc::c_uint)
                    as uint16_t,
                value: *::core::mem::transmute::<&[u8; 28], &[libc::c_char; 28]>(
                    b"content-type\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0",
                ),
            };
            init
        },
        {
            let mut init = keyvlenvalue {
                key: HTTP_HEADER_LAST_MODIFIED as libc::c_int as int16_t,
                vlen: (::core::mem::size_of::<[libc::c_char; 14]>() as libc::c_ulong as uint32_t)
                    .wrapping_sub(1 as libc::c_int as libc::c_uint)
                    as uint16_t,
                value: *::core::mem::transmute::<&[u8; 28], &[libc::c_char; 28]>(
                    b"last-modified\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0",
                ),
            };
            init
        },
        {
            let mut init = keyvlenvalue {
                key: HTTP_HEADER_AUTHORIZATION as libc::c_int as int16_t,
                vlen: (::core::mem::size_of::<[libc::c_char; 14]>() as libc::c_ulong as uint32_t)
                    .wrapping_sub(1 as libc::c_int as libc::c_uint)
                    as uint16_t,
                value: *::core::mem::transmute::<&[u8; 28], &[libc::c_char; 28]>(
                    b"authorization\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0",
                ),
            };
            init
        },
        {
            let mut init = keyvlenvalue {
                key: HTTP_HEADER_IF_NONE_MATCH as libc::c_int as int16_t,
                vlen: (::core::mem::size_of::<[libc::c_char; 14]>() as libc::c_ulong as uint32_t)
                    .wrapping_sub(1 as libc::c_int as libc::c_uint)
                    as uint16_t,
                value: *::core::mem::transmute::<&[u8; 28], &[libc::c_char; 28]>(
                    b"if-none-match\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0",
                ),
            };
            init
        },
        {
            let mut init = keyvlenvalue {
                key: HTTP_HEADER_CACHE_CONTROL as libc::c_int as int16_t,
                vlen: (::core::mem::size_of::<[libc::c_char; 14]>() as libc::c_ulong as uint32_t)
                    .wrapping_sub(1 as libc::c_int as libc::c_uint)
                    as uint16_t,
                value: *::core::mem::transmute::<&[u8; 28], &[libc::c_char; 28]>(
                    b"cache-control\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0",
                ),
            };
            init
        },
        {
            let mut init = keyvlenvalue {
                key: HTTP_HEADER_ACCEPT_RANGES as libc::c_int as int16_t,
                vlen: (::core::mem::size_of::<[libc::c_char; 14]>() as libc::c_ulong as uint32_t)
                    .wrapping_sub(1 as libc::c_int as libc::c_uint)
                    as uint16_t,
                value: *::core::mem::transmute::<&[u8; 28], &[libc::c_char; 28]>(
                    b"accept-ranges\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0",
                ),
            };
            init
        },
        {
            let mut init = keyvlenvalue {
                key: HTTP_HEADER_CONTENT_RANGE as libc::c_int as int16_t,
                vlen: (::core::mem::size_of::<[libc::c_char; 14]>() as libc::c_ulong as uint32_t)
                    .wrapping_sub(1 as libc::c_int as libc::c_uint)
                    as uint16_t,
                value: *::core::mem::transmute::<&[u8; 28], &[libc::c_char; 28]>(
                    b"content-range\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0",
                ),
            };
            init
        },
        {
            let mut init = keyvlenvalue {
                key: HTTP_HEADER_CONTENT_LENGTH as libc::c_int as int16_t,
                vlen: (::core::mem::size_of::<[libc::c_char; 15]>() as libc::c_ulong as uint32_t)
                    .wrapping_sub(1 as libc::c_int as libc::c_uint)
                    as uint16_t,
                value: *::core::mem::transmute::<&[u8; 28], &[libc::c_char; 28]>(
                    b"content-length\0\0\0\0\0\0\0\0\0\0\0\0\0\0",
                ),
            };
            init
        },
        {
            let mut init = keyvlenvalue {
                key: HTTP_HEADER_HTTP2_SETTINGS as libc::c_int as int16_t,
                vlen: (::core::mem::size_of::<[libc::c_char; 15]>() as libc::c_ulong as uint32_t)
                    .wrapping_sub(1 as libc::c_int as libc::c_uint)
                    as uint16_t,
                value: *::core::mem::transmute::<&[u8; 28], &[libc::c_char; 28]>(
                    b"http2-settings\0\0\0\0\0\0\0\0\0\0\0\0\0\0",
                ),
            };
            init
        },
        {
            let mut init = keyvlenvalue {
                key: HTTP_HEADER_ONION_LOCATION as libc::c_int as int16_t,
                vlen: (::core::mem::size_of::<[libc::c_char; 15]>() as libc::c_ulong as uint32_t)
                    .wrapping_sub(1 as libc::c_int as libc::c_uint)
                    as uint16_t,
                value: *::core::mem::transmute::<&[u8; 28], &[libc::c_char; 28]>(
                    b"onion-location\0\0\0\0\0\0\0\0\0\0\0\0\0\0",
                ),
            };
            init
        },
        {
            let mut init = keyvlenvalue {
                key: HTTP_HEADER_ACCEPT_ENCODING as libc::c_int as int16_t,
                vlen: (::core::mem::size_of::<[libc::c_char; 16]>() as libc::c_ulong as uint32_t)
                    .wrapping_sub(1 as libc::c_int as libc::c_uint)
                    as uint16_t,
                value: *::core::mem::transmute::<&[u8; 28], &[libc::c_char; 28]>(
                    b"accept-encoding\0\0\0\0\0\0\0\0\0\0\0\0\0",
                ),
            };
            init
        },
        {
            let mut init = keyvlenvalue {
                key: HTTP_HEADER_ACCEPT_LANGUAGE as libc::c_int as int16_t,
                vlen: (::core::mem::size_of::<[libc::c_char; 16]>() as libc::c_ulong as uint32_t)
                    .wrapping_sub(1 as libc::c_int as libc::c_uint)
                    as uint16_t,
                value: *::core::mem::transmute::<&[u8; 28], &[libc::c_char; 28]>(
                    b"accept-language\0\0\0\0\0\0\0\0\0\0\0\0\0",
                ),
            };
            init
        },
        {
            let mut init = keyvlenvalue {
                key: HTTP_HEADER_REFERRER_POLICY as libc::c_int as int16_t,
                vlen: (::core::mem::size_of::<[libc::c_char; 16]>() as libc::c_ulong as uint32_t)
                    .wrapping_sub(1 as libc::c_int as libc::c_uint)
                    as uint16_t,
                value: *::core::mem::transmute::<&[u8; 28], &[libc::c_char; 28]>(
                    b"referrer-policy\0\0\0\0\0\0\0\0\0\0\0\0\0",
                ),
            };
            init
        },
        {
            let mut init = keyvlenvalue {
                key: HTTP_HEADER_X_FORWARDED_FOR as libc::c_int as int16_t,
                vlen: (::core::mem::size_of::<[libc::c_char; 16]>() as libc::c_ulong as uint32_t)
                    .wrapping_sub(1 as libc::c_int as libc::c_uint)
                    as uint16_t,
                value: *::core::mem::transmute::<&[u8; 28], &[libc::c_char; 28]>(
                    b"x-forwarded-for\0\0\0\0\0\0\0\0\0\0\0\0\0",
                ),
            };
            init
        },
        {
            let mut init = keyvlenvalue {
                key: HTTP_HEADER_X_FRAME_OPTIONS as libc::c_int as int16_t,
                vlen: (::core::mem::size_of::<[libc::c_char; 16]>() as libc::c_ulong as uint32_t)
                    .wrapping_sub(1 as libc::c_int as libc::c_uint)
                    as uint16_t,
                value: *::core::mem::transmute::<&[u8; 28], &[libc::c_char; 28]>(
                    b"x-frame-options\0\0\0\0\0\0\0\0\0\0\0\0\0",
                ),
            };
            init
        },
        {
            let mut init = keyvlenvalue {
                key: HTTP_HEADER_WWW_AUTHENTICATE as libc::c_int as int16_t,
                vlen: (::core::mem::size_of::<[libc::c_char; 17]>() as libc::c_ulong as uint32_t)
                    .wrapping_sub(1 as libc::c_int as libc::c_uint)
                    as uint16_t,
                value: *::core::mem::transmute::<&[u8; 28], &[libc::c_char; 28]>(
                    b"www-authenticate\0\0\0\0\0\0\0\0\0\0\0\0",
                ),
            };
            init
        },
        {
            let mut init = keyvlenvalue {
                key: HTTP_HEADER_CONTENT_ENCODING as libc::c_int as int16_t,
                vlen: (::core::mem::size_of::<[libc::c_char; 17]>() as libc::c_ulong as uint32_t)
                    .wrapping_sub(1 as libc::c_int as libc::c_uint)
                    as uint16_t,
                value: *::core::mem::transmute::<&[u8; 28], &[libc::c_char; 28]>(
                    b"content-encoding\0\0\0\0\0\0\0\0\0\0\0\0",
                ),
            };
            init
        },
        {
            let mut init = keyvlenvalue {
                key: HTTP_HEADER_CONTENT_LOCATION as libc::c_int as int16_t,
                vlen: (::core::mem::size_of::<[libc::c_char; 17]>() as libc::c_ulong as uint32_t)
                    .wrapping_sub(1 as libc::c_int as libc::c_uint)
                    as uint16_t,
                value: *::core::mem::transmute::<&[u8; 28], &[libc::c_char; 28]>(
                    b"content-location\0\0\0\0\0\0\0\0\0\0\0\0",
                ),
            };
            init
        },
        {
            let mut init = keyvlenvalue {
                key: HTTP_HEADER_X_XSS_PROTECTION as libc::c_int as int16_t,
                vlen: (::core::mem::size_of::<[libc::c_char; 17]>() as libc::c_ulong as uint32_t)
                    .wrapping_sub(1 as libc::c_int as libc::c_uint)
                    as uint16_t,
                value: *::core::mem::transmute::<&[u8; 28], &[libc::c_char; 28]>(
                    b"x-xss-protection\0\0\0\0\0\0\0\0\0\0\0\0",
                ),
            };
            init
        },
        {
            let mut init = keyvlenvalue {
                key: HTTP_HEADER_IF_MODIFIED_SINCE as libc::c_int as int16_t,
                vlen: (::core::mem::size_of::<[libc::c_char; 18]>() as libc::c_ulong as uint32_t)
                    .wrapping_sub(1 as libc::c_int as libc::c_uint)
                    as uint16_t,
                value: *::core::mem::transmute::<&[u8; 28], &[libc::c_char; 28]>(
                    b"if-modified-since\0\0\0\0\0\0\0\0\0\0\0",
                ),
            };
            init
        },
        {
            let mut init = keyvlenvalue {
                key: HTTP_HEADER_TRANSFER_ENCODING as libc::c_int as int16_t,
                vlen: (::core::mem::size_of::<[libc::c_char; 18]>() as libc::c_ulong as uint32_t)
                    .wrapping_sub(1 as libc::c_int as libc::c_uint)
                    as uint16_t,
                value: *::core::mem::transmute::<&[u8; 28], &[libc::c_char; 28]>(
                    b"transfer-encoding\0\0\0\0\0\0\0\0\0\0\0",
                ),
            };
            init
        },
        {
            let mut init = keyvlenvalue {
                key: HTTP_HEADER_X_FORWARDED_PROTO as libc::c_int as int16_t,
                vlen: (::core::mem::size_of::<[libc::c_char; 18]>() as libc::c_ulong as uint32_t)
                    .wrapping_sub(1 as libc::c_int as libc::c_uint)
                    as uint16_t,
                value: *::core::mem::transmute::<&[u8; 28], &[libc::c_char; 28]>(
                    b"x-forwarded-proto\0\0\0\0\0\0\0\0\0\0\0",
                ),
            };
            init
        },
        {
            let mut init = keyvlenvalue {
                key: HTTP_HEADER_IF_UNMODIFIED_SINCE as libc::c_int as int16_t,
                vlen: (::core::mem::size_of::<[libc::c_char; 20]>() as libc::c_ulong as uint32_t)
                    .wrapping_sub(1 as libc::c_int as libc::c_uint)
                    as uint16_t,
                value: *::core::mem::transmute::<&[u8; 28], &[libc::c_char; 28]>(
                    b"if-unmodified-since\0\0\0\0\0\0\0\0\0",
                ),
            };
            init
        },
        {
            let mut init = keyvlenvalue {
                key: HTTP_HEADER_X_CONTENT_TYPE_OPTIONS as libc::c_int as int16_t,
                vlen: (::core::mem::size_of::<[libc::c_char; 23]>() as libc::c_ulong as uint32_t)
                    .wrapping_sub(1 as libc::c_int as libc::c_uint)
                    as uint16_t,
                value: *::core::mem::transmute::<&[u8; 28], &[libc::c_char; 28]>(
                    b"x-content-type-options\0\0\0\0\0\0",
                ),
            };
            init
        },
        {
            let mut init = keyvlenvalue {
                key: HTTP_HEADER_CONTENT_SECURITY_POLICY as libc::c_int as int16_t,
                vlen: (::core::mem::size_of::<[libc::c_char; 24]>() as libc::c_ulong as uint32_t)
                    .wrapping_sub(1 as libc::c_int as libc::c_uint)
                    as uint16_t,
                value: *::core::mem::transmute::<&[u8; 28], &[libc::c_char; 28]>(
                    b"content-security-policy\0\0\0\0\0",
                ),
            };
            init
        },
        {
            let mut init = keyvlenvalue {
                key: HTTP_HEADER_STRICT_TRANSPORT_SECURITY as libc::c_int as int16_t,
                vlen: (::core::mem::size_of::<[libc::c_char; 26]>() as libc::c_ulong as uint32_t)
                    .wrapping_sub(1 as libc::c_int as libc::c_uint)
                    as uint16_t,
                value: *::core::mem::transmute::<&[u8; 28], &[libc::c_char; 28]>(
                    b"strict-transport-security\0\0\0",
                ),
            };
            init
        },
        {
            let mut init = keyvlenvalue {
                key: HTTP_HEADER_UPGRADE_INSECURE_REQUESTS as libc::c_int as int16_t,
                vlen: (::core::mem::size_of::<[libc::c_char; 26]>() as libc::c_ulong as uint32_t)
                    .wrapping_sub(1 as libc::c_int as libc::c_uint)
                    as uint16_t,
                value: *::core::mem::transmute::<&[u8; 28], &[libc::c_char; 28]>(
                    b"upgrade-insecure-requests\0\0\0",
                ),
            };
            init
        },
        {
            let mut init = keyvlenvalue {
                key: HTTP_HEADER_ACCESS_CONTROL_ALLOW_ORIGIN as libc::c_int as int16_t,
                vlen: (::core::mem::size_of::<[libc::c_char; 28]>() as libc::c_ulong as uint32_t)
                    .wrapping_sub(1 as libc::c_int as libc::c_uint)
                    as uint16_t,
                value: *::core::mem::transmute::<&[u8; 28], &[libc::c_char; 28]>(
                    b"access-control-allow-origin\0",
                ),
            };
            init
        },
        {
            let mut init = keyvlenvalue {
                key: HTTP_HEADER_OTHER as libc::c_int as int16_t,
                vlen: 0 as libc::c_int as uint16_t,
                value: *::core::mem::transmute::<&[u8; 28], &[libc::c_char; 28]>(
                    b"\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0",
                ),
            };
            init
        },
    ];
    http_versions = [
        {
            let mut init = keyvalue {
                key: HTTP_VERSION_2 as libc::c_int,
                vlen: (::core::mem::size_of::<[libc::c_char; 9]>() as libc::c_ulong as uint32_t)
                    .wrapping_sub(1 as libc::c_int as libc::c_uint),
                value: b"HTTP/2.0\0" as *const u8 as *const libc::c_char,
            };
            init
        },
        {
            let mut init = keyvalue {
                key: HTTP_VERSION_1_1 as libc::c_int,
                vlen: (::core::mem::size_of::<[libc::c_char; 9]>() as libc::c_ulong as uint32_t)
                    .wrapping_sub(1 as libc::c_int as libc::c_uint),
                value: b"HTTP/1.1\0" as *const u8 as *const libc::c_char,
            };
            init
        },
        {
            let mut init = keyvalue {
                key: HTTP_VERSION_1_0 as libc::c_int,
                vlen: (::core::mem::size_of::<[libc::c_char; 9]>() as libc::c_ulong as uint32_t)
                    .wrapping_sub(1 as libc::c_int as libc::c_uint),
                value: b"HTTP/1.0\0" as *const u8 as *const libc::c_char,
            };
            init
        },
        {
            let mut init = keyvalue {
                key: HTTP_VERSION_UNSET as libc::c_int,
                vlen: 0 as libc::c_int as libc::c_uint,
                value: 0 as *const libc::c_char,
            };
            init
        },
    ];
    http_methods = [
        {
            let mut init = buffer {
                ptr: b"GET\0" as *const u8 as *const libc::c_char as *mut libc::c_char,
                used: (::core::mem::size_of::<[libc::c_char; 4]>() as libc::c_ulong as uint32_t)
                    .wrapping_sub(1 as libc::c_int as libc::c_uint)
                    .wrapping_add(1 as libc::c_int as libc::c_uint),
                size: 0 as libc::c_int as uint32_t,
            };
            init
        },
        {
            let mut init = buffer {
                ptr: b"HEAD\0" as *const u8 as *const libc::c_char as *mut libc::c_char,
                used: (::core::mem::size_of::<[libc::c_char; 5]>() as libc::c_ulong as uint32_t)
                    .wrapping_sub(1 as libc::c_int as libc::c_uint)
                    .wrapping_add(1 as libc::c_int as libc::c_uint),
                size: 0 as libc::c_int as uint32_t,
            };
            init
        },
        {
            let mut init = buffer {
                ptr: b"POST\0" as *const u8 as *const libc::c_char as *mut libc::c_char,
                used: (::core::mem::size_of::<[libc::c_char; 5]>() as libc::c_ulong as uint32_t)
                    .wrapping_sub(1 as libc::c_int as libc::c_uint)
                    .wrapping_add(1 as libc::c_int as libc::c_uint),
                size: 0 as libc::c_int as uint32_t,
            };
            init
        },
        {
            let mut init = buffer {
                ptr: b"PUT\0" as *const u8 as *const libc::c_char as *mut libc::c_char,
                used: (::core::mem::size_of::<[libc::c_char; 4]>() as libc::c_ulong as uint32_t)
                    .wrapping_sub(1 as libc::c_int as libc::c_uint)
                    .wrapping_add(1 as libc::c_int as libc::c_uint),
                size: 0 as libc::c_int as uint32_t,
            };
            init
        },
        {
            let mut init = buffer {
                ptr: b"DELETE\0" as *const u8 as *const libc::c_char as *mut libc::c_char,
                used: (::core::mem::size_of::<[libc::c_char; 7]>() as libc::c_ulong as uint32_t)
                    .wrapping_sub(1 as libc::c_int as libc::c_uint)
                    .wrapping_add(1 as libc::c_int as libc::c_uint),
                size: 0 as libc::c_int as uint32_t,
            };
            init
        },
        {
            let mut init = buffer {
                ptr: b"CONNECT\0" as *const u8 as *const libc::c_char as *mut libc::c_char,
                used: (::core::mem::size_of::<[libc::c_char; 8]>() as libc::c_ulong as uint32_t)
                    .wrapping_sub(1 as libc::c_int as libc::c_uint)
                    .wrapping_add(1 as libc::c_int as libc::c_uint),
                size: 0 as libc::c_int as uint32_t,
            };
            init
        },
        {
            let mut init = buffer {
                ptr: b"OPTIONS\0" as *const u8 as *const libc::c_char as *mut libc::c_char,
                used: (::core::mem::size_of::<[libc::c_char; 8]>() as libc::c_ulong as uint32_t)
                    .wrapping_sub(1 as libc::c_int as libc::c_uint)
                    .wrapping_add(1 as libc::c_int as libc::c_uint),
                size: 0 as libc::c_int as uint32_t,
            };
            init
        },
        {
            let mut init = buffer {
                ptr: b"TRACE\0" as *const u8 as *const libc::c_char as *mut libc::c_char,
                used: (::core::mem::size_of::<[libc::c_char; 6]>() as libc::c_ulong as uint32_t)
                    .wrapping_sub(1 as libc::c_int as libc::c_uint)
                    .wrapping_add(1 as libc::c_int as libc::c_uint),
                size: 0 as libc::c_int as uint32_t,
            };
            init
        },
        {
            let mut init = buffer {
                ptr: b"ACL\0" as *const u8 as *const libc::c_char as *mut libc::c_char,
                used: (::core::mem::size_of::<[libc::c_char; 4]>() as libc::c_ulong as uint32_t)
                    .wrapping_sub(1 as libc::c_int as libc::c_uint)
                    .wrapping_add(1 as libc::c_int as libc::c_uint),
                size: 0 as libc::c_int as uint32_t,
            };
            init
        },
        {
            let mut init = buffer {
                ptr: b"BASELINE-CONTROL\0" as *const u8 as *const libc::c_char as *mut libc::c_char,
                used: (::core::mem::size_of::<[libc::c_char; 17]>() as libc::c_ulong as uint32_t)
                    .wrapping_sub(1 as libc::c_int as libc::c_uint)
                    .wrapping_add(1 as libc::c_int as libc::c_uint),
                size: 0 as libc::c_int as uint32_t,
            };
            init
        },
        {
            let mut init = buffer {
                ptr: b"BIND\0" as *const u8 as *const libc::c_char as *mut libc::c_char,
                used: (::core::mem::size_of::<[libc::c_char; 5]>() as libc::c_ulong as uint32_t)
                    .wrapping_sub(1 as libc::c_int as libc::c_uint)
                    .wrapping_add(1 as libc::c_int as libc::c_uint),
                size: 0 as libc::c_int as uint32_t,
            };
            init
        },
        {
            let mut init = buffer {
                ptr: b"CHECKIN\0" as *const u8 as *const libc::c_char as *mut libc::c_char,
                used: (::core::mem::size_of::<[libc::c_char; 8]>() as libc::c_ulong as uint32_t)
                    .wrapping_sub(1 as libc::c_int as libc::c_uint)
                    .wrapping_add(1 as libc::c_int as libc::c_uint),
                size: 0 as libc::c_int as uint32_t,
            };
            init
        },
        {
            let mut init = buffer {
                ptr: b"CHECKOUT\0" as *const u8 as *const libc::c_char as *mut libc::c_char,
                used: (::core::mem::size_of::<[libc::c_char; 9]>() as libc::c_ulong as uint32_t)
                    .wrapping_sub(1 as libc::c_int as libc::c_uint)
                    .wrapping_add(1 as libc::c_int as libc::c_uint),
                size: 0 as libc::c_int as uint32_t,
            };
            init
        },
        {
            let mut init = buffer {
                ptr: b"COPY\0" as *const u8 as *const libc::c_char as *mut libc::c_char,
                used: (::core::mem::size_of::<[libc::c_char; 5]>() as libc::c_ulong as uint32_t)
                    .wrapping_sub(1 as libc::c_int as libc::c_uint)
                    .wrapping_add(1 as libc::c_int as libc::c_uint),
                size: 0 as libc::c_int as uint32_t,
            };
            init
        },
        {
            let mut init = buffer {
                ptr: b"LABEL\0" as *const u8 as *const libc::c_char as *mut libc::c_char,
                used: (::core::mem::size_of::<[libc::c_char; 6]>() as libc::c_ulong as uint32_t)
                    .wrapping_sub(1 as libc::c_int as libc::c_uint)
                    .wrapping_add(1 as libc::c_int as libc::c_uint),
                size: 0 as libc::c_int as uint32_t,
            };
            init
        },
        {
            let mut init = buffer {
                ptr: b"LINK\0" as *const u8 as *const libc::c_char as *mut libc::c_char,
                used: (::core::mem::size_of::<[libc::c_char; 5]>() as libc::c_ulong as uint32_t)
                    .wrapping_sub(1 as libc::c_int as libc::c_uint)
                    .wrapping_add(1 as libc::c_int as libc::c_uint),
                size: 0 as libc::c_int as uint32_t,
            };
            init
        },
        {
            let mut init = buffer {
                ptr: b"LOCK\0" as *const u8 as *const libc::c_char as *mut libc::c_char,
                used: (::core::mem::size_of::<[libc::c_char; 5]>() as libc::c_ulong as uint32_t)
                    .wrapping_sub(1 as libc::c_int as libc::c_uint)
                    .wrapping_add(1 as libc::c_int as libc::c_uint),
                size: 0 as libc::c_int as uint32_t,
            };
            init
        },
        {
            let mut init = buffer {
                ptr: b"MERGE\0" as *const u8 as *const libc::c_char as *mut libc::c_char,
                used: (::core::mem::size_of::<[libc::c_char; 6]>() as libc::c_ulong as uint32_t)
                    .wrapping_sub(1 as libc::c_int as libc::c_uint)
                    .wrapping_add(1 as libc::c_int as libc::c_uint),
                size: 0 as libc::c_int as uint32_t,
            };
            init
        },
        {
            let mut init = buffer {
                ptr: b"MKACTIVITY\0" as *const u8 as *const libc::c_char as *mut libc::c_char,
                used: (::core::mem::size_of::<[libc::c_char; 11]>() as libc::c_ulong as uint32_t)
                    .wrapping_sub(1 as libc::c_int as libc::c_uint)
                    .wrapping_add(1 as libc::c_int as libc::c_uint),
                size: 0 as libc::c_int as uint32_t,
            };
            init
        },
        {
            let mut init = buffer {
                ptr: b"MKCALENDAR\0" as *const u8 as *const libc::c_char as *mut libc::c_char,
                used: (::core::mem::size_of::<[libc::c_char; 11]>() as libc::c_ulong as uint32_t)
                    .wrapping_sub(1 as libc::c_int as libc::c_uint)
                    .wrapping_add(1 as libc::c_int as libc::c_uint),
                size: 0 as libc::c_int as uint32_t,
            };
            init
        },
        {
            let mut init = buffer {
                ptr: b"MKCOL\0" as *const u8 as *const libc::c_char as *mut libc::c_char,
                used: (::core::mem::size_of::<[libc::c_char; 6]>() as libc::c_ulong as uint32_t)
                    .wrapping_sub(1 as libc::c_int as libc::c_uint)
                    .wrapping_add(1 as libc::c_int as libc::c_uint),
                size: 0 as libc::c_int as uint32_t,
            };
            init
        },
        {
            let mut init = buffer {
                ptr: b"MKREDIRECTREF\0" as *const u8 as *const libc::c_char as *mut libc::c_char,
                used: (::core::mem::size_of::<[libc::c_char; 14]>() as libc::c_ulong as uint32_t)
                    .wrapping_sub(1 as libc::c_int as libc::c_uint)
                    .wrapping_add(1 as libc::c_int as libc::c_uint),
                size: 0 as libc::c_int as uint32_t,
            };
            init
        },
        {
            let mut init = buffer {
                ptr: b"MKWORKSPACE\0" as *const u8 as *const libc::c_char as *mut libc::c_char,
                used: (::core::mem::size_of::<[libc::c_char; 12]>() as libc::c_ulong as uint32_t)
                    .wrapping_sub(1 as libc::c_int as libc::c_uint)
                    .wrapping_add(1 as libc::c_int as libc::c_uint),
                size: 0 as libc::c_int as uint32_t,
            };
            init
        },
        {
            let mut init = buffer {
                ptr: b"MOVE\0" as *const u8 as *const libc::c_char as *mut libc::c_char,
                used: (::core::mem::size_of::<[libc::c_char; 5]>() as libc::c_ulong as uint32_t)
                    .wrapping_sub(1 as libc::c_int as libc::c_uint)
                    .wrapping_add(1 as libc::c_int as libc::c_uint),
                size: 0 as libc::c_int as uint32_t,
            };
            init
        },
        {
            let mut init = buffer {
                ptr: b"ORDERPATCH\0" as *const u8 as *const libc::c_char as *mut libc::c_char,
                used: (::core::mem::size_of::<[libc::c_char; 11]>() as libc::c_ulong as uint32_t)
                    .wrapping_sub(1 as libc::c_int as libc::c_uint)
                    .wrapping_add(1 as libc::c_int as libc::c_uint),
                size: 0 as libc::c_int as uint32_t,
            };
            init
        },
        {
            let mut init = buffer {
                ptr: b"PATCH\0" as *const u8 as *const libc::c_char as *mut libc::c_char,
                used: (::core::mem::size_of::<[libc::c_char; 6]>() as libc::c_ulong as uint32_t)
                    .wrapping_sub(1 as libc::c_int as libc::c_uint)
                    .wrapping_add(1 as libc::c_int as libc::c_uint),
                size: 0 as libc::c_int as uint32_t,
            };
            init
        },
        {
            let mut init = buffer {
                ptr: b"PROPFIND\0" as *const u8 as *const libc::c_char as *mut libc::c_char,
                used: (::core::mem::size_of::<[libc::c_char; 9]>() as libc::c_ulong as uint32_t)
                    .wrapping_sub(1 as libc::c_int as libc::c_uint)
                    .wrapping_add(1 as libc::c_int as libc::c_uint),
                size: 0 as libc::c_int as uint32_t,
            };
            init
        },
        {
            let mut init = buffer {
                ptr: b"PROPPATCH\0" as *const u8 as *const libc::c_char as *mut libc::c_char,
                used: (::core::mem::size_of::<[libc::c_char; 10]>() as libc::c_ulong as uint32_t)
                    .wrapping_sub(1 as libc::c_int as libc::c_uint)
                    .wrapping_add(1 as libc::c_int as libc::c_uint),
                size: 0 as libc::c_int as uint32_t,
            };
            init
        },
        {
            let mut init = buffer {
                ptr: b"REBIND\0" as *const u8 as *const libc::c_char as *mut libc::c_char,
                used: (::core::mem::size_of::<[libc::c_char; 7]>() as libc::c_ulong as uint32_t)
                    .wrapping_sub(1 as libc::c_int as libc::c_uint)
                    .wrapping_add(1 as libc::c_int as libc::c_uint),
                size: 0 as libc::c_int as uint32_t,
            };
            init
        },
        {
            let mut init = buffer {
                ptr: b"REPORT\0" as *const u8 as *const libc::c_char as *mut libc::c_char,
                used: (::core::mem::size_of::<[libc::c_char; 7]>() as libc::c_ulong as uint32_t)
                    .wrapping_sub(1 as libc::c_int as libc::c_uint)
                    .wrapping_add(1 as libc::c_int as libc::c_uint),
                size: 0 as libc::c_int as uint32_t,
            };
            init
        },
        {
            let mut init = buffer {
                ptr: b"SEARCH\0" as *const u8 as *const libc::c_char as *mut libc::c_char,
                used: (::core::mem::size_of::<[libc::c_char; 7]>() as libc::c_ulong as uint32_t)
                    .wrapping_sub(1 as libc::c_int as libc::c_uint)
                    .wrapping_add(1 as libc::c_int as libc::c_uint),
                size: 0 as libc::c_int as uint32_t,
            };
            init
        },
        {
            let mut init = buffer {
                ptr: b"UNBIND\0" as *const u8 as *const libc::c_char as *mut libc::c_char,
                used: (::core::mem::size_of::<[libc::c_char; 7]>() as libc::c_ulong as uint32_t)
                    .wrapping_sub(1 as libc::c_int as libc::c_uint)
                    .wrapping_add(1 as libc::c_int as libc::c_uint),
                size: 0 as libc::c_int as uint32_t,
            };
            init
        },
        {
            let mut init = buffer {
                ptr: b"UNCHECKOUT\0" as *const u8 as *const libc::c_char as *mut libc::c_char,
                used: (::core::mem::size_of::<[libc::c_char; 11]>() as libc::c_ulong as uint32_t)
                    .wrapping_sub(1 as libc::c_int as libc::c_uint)
                    .wrapping_add(1 as libc::c_int as libc::c_uint),
                size: 0 as libc::c_int as uint32_t,
            };
            init
        },
        {
            let mut init = buffer {
                ptr: b"UNLINK\0" as *const u8 as *const libc::c_char as *mut libc::c_char,
                used: (::core::mem::size_of::<[libc::c_char; 7]>() as libc::c_ulong as uint32_t)
                    .wrapping_sub(1 as libc::c_int as libc::c_uint)
                    .wrapping_add(1 as libc::c_int as libc::c_uint),
                size: 0 as libc::c_int as uint32_t,
            };
            init
        },
        {
            let mut init = buffer {
                ptr: b"UNLOCK\0" as *const u8 as *const libc::c_char as *mut libc::c_char,
                used: (::core::mem::size_of::<[libc::c_char; 7]>() as libc::c_ulong as uint32_t)
                    .wrapping_sub(1 as libc::c_int as libc::c_uint)
                    .wrapping_add(1 as libc::c_int as libc::c_uint),
                size: 0 as libc::c_int as uint32_t,
            };
            init
        },
        {
            let mut init = buffer {
                ptr: b"UPDATE\0" as *const u8 as *const libc::c_char as *mut libc::c_char,
                used: (::core::mem::size_of::<[libc::c_char; 7]>() as libc::c_ulong as uint32_t)
                    .wrapping_sub(1 as libc::c_int as libc::c_uint)
                    .wrapping_add(1 as libc::c_int as libc::c_uint),
                size: 0 as libc::c_int as uint32_t,
            };
            init
        },
        {
            let mut init = buffer {
                ptr: b"UPDATEREDIRECTREF\0" as *const u8 as *const libc::c_char
                    as *mut libc::c_char,
                used: (::core::mem::size_of::<[libc::c_char; 18]>() as libc::c_ulong as uint32_t)
                    .wrapping_sub(1 as libc::c_int as libc::c_uint)
                    .wrapping_add(1 as libc::c_int as libc::c_uint),
                size: 0 as libc::c_int as uint32_t,
            };
            init
        },
        {
            let mut init = buffer {
                ptr: b"VERSION-CONTROL\0" as *const u8 as *const libc::c_char as *mut libc::c_char,
                used: (::core::mem::size_of::<[libc::c_char; 16]>() as libc::c_ulong as uint32_t)
                    .wrapping_sub(1 as libc::c_int as libc::c_uint)
                    .wrapping_add(1 as libc::c_int as libc::c_uint),
                size: 0 as libc::c_int as uint32_t,
            };
            init
        },
        {
            let mut init = buffer {
                ptr: b"PRI\0" as *const u8 as *const libc::c_char as *mut libc::c_char,
                used: (::core::mem::size_of::<[libc::c_char; 4]>() as libc::c_ulong as uint32_t)
                    .wrapping_sub(1 as libc::c_int as libc::c_uint)
                    .wrapping_add(1 as libc::c_int as libc::c_uint),
                size: 0 as libc::c_int as uint32_t,
            };
            init
        },
        {
            let mut init = buffer {
                ptr: b"\0" as *const u8 as *const libc::c_char as *mut libc::c_char,
                used: 0 as libc::c_int as uint32_t,
                size: 0 as libc::c_int as uint32_t,
            };
            init
        },
    ];
    http_status = [
        {
            let mut init = keyvalue {
                key: 100 as libc::c_int,
                vlen: (::core::mem::size_of::<[libc::c_char; 13]>() as libc::c_ulong as uint32_t)
                    .wrapping_sub(1 as libc::c_int as libc::c_uint),
                value: b"100 Continue\0" as *const u8 as *const libc::c_char,
            };
            init
        },
        {
            let mut init = keyvalue {
                key: 101 as libc::c_int,
                vlen: (::core::mem::size_of::<[libc::c_char; 24]>() as libc::c_ulong as uint32_t)
                    .wrapping_sub(1 as libc::c_int as libc::c_uint),
                value: b"101 Switching Protocols\0" as *const u8 as *const libc::c_char,
            };
            init
        },
        {
            let mut init = keyvalue {
                key: 102 as libc::c_int,
                vlen: (::core::mem::size_of::<[libc::c_char; 15]>() as libc::c_ulong as uint32_t)
                    .wrapping_sub(1 as libc::c_int as libc::c_uint),
                value: b"102 Processing\0" as *const u8 as *const libc::c_char,
            };
            init
        },
        {
            let mut init = keyvalue {
                key: 103 as libc::c_int,
                vlen: (::core::mem::size_of::<[libc::c_char; 16]>() as libc::c_ulong as uint32_t)
                    .wrapping_sub(1 as libc::c_int as libc::c_uint),
                value: b"103 Early Hints\0" as *const u8 as *const libc::c_char,
            };
            init
        },
        {
            let mut init = keyvalue {
                key: 200 as libc::c_int,
                vlen: (::core::mem::size_of::<[libc::c_char; 7]>() as libc::c_ulong as uint32_t)
                    .wrapping_sub(1 as libc::c_int as libc::c_uint),
                value: b"200 OK\0" as *const u8 as *const libc::c_char,
            };
            init
        },
        {
            let mut init = keyvalue {
                key: 201 as libc::c_int,
                vlen: (::core::mem::size_of::<[libc::c_char; 12]>() as libc::c_ulong as uint32_t)
                    .wrapping_sub(1 as libc::c_int as libc::c_uint),
                value: b"201 Created\0" as *const u8 as *const libc::c_char,
            };
            init
        },
        {
            let mut init = keyvalue {
                key: 202 as libc::c_int,
                vlen: (::core::mem::size_of::<[libc::c_char; 13]>() as libc::c_ulong as uint32_t)
                    .wrapping_sub(1 as libc::c_int as libc::c_uint),
                value: b"202 Accepted\0" as *const u8 as *const libc::c_char,
            };
            init
        },
        {
            let mut init = keyvalue {
                key: 203 as libc::c_int,
                vlen: (::core::mem::size_of::<[libc::c_char; 34]>() as libc::c_ulong as uint32_t)
                    .wrapping_sub(1 as libc::c_int as libc::c_uint),
                value: b"203 Non-Authoritative Information\0" as *const u8 as *const libc::c_char,
            };
            init
        },
        {
            let mut init = keyvalue {
                key: 204 as libc::c_int,
                vlen: (::core::mem::size_of::<[libc::c_char; 15]>() as libc::c_ulong as uint32_t)
                    .wrapping_sub(1 as libc::c_int as libc::c_uint),
                value: b"204 No Content\0" as *const u8 as *const libc::c_char,
            };
            init
        },
        {
            let mut init = keyvalue {
                key: 205 as libc::c_int,
                vlen: (::core::mem::size_of::<[libc::c_char; 18]>() as libc::c_ulong as uint32_t)
                    .wrapping_sub(1 as libc::c_int as libc::c_uint),
                value: b"205 Reset Content\0" as *const u8 as *const libc::c_char,
            };
            init
        },
        {
            let mut init = keyvalue {
                key: 206 as libc::c_int,
                vlen: (::core::mem::size_of::<[libc::c_char; 20]>() as libc::c_ulong as uint32_t)
                    .wrapping_sub(1 as libc::c_int as libc::c_uint),
                value: b"206 Partial Content\0" as *const u8 as *const libc::c_char,
            };
            init
        },
        {
            let mut init = keyvalue {
                key: 207 as libc::c_int,
                vlen: (::core::mem::size_of::<[libc::c_char; 17]>() as libc::c_ulong as uint32_t)
                    .wrapping_sub(1 as libc::c_int as libc::c_uint),
                value: b"207 Multi-status\0" as *const u8 as *const libc::c_char,
            };
            init
        },
        {
            let mut init = keyvalue {
                key: 208 as libc::c_int,
                vlen: (::core::mem::size_of::<[libc::c_char; 21]>() as libc::c_ulong as uint32_t)
                    .wrapping_sub(1 as libc::c_int as libc::c_uint),
                value: b"208 Already Reported\0" as *const u8 as *const libc::c_char,
            };
            init
        },
        {
            let mut init = keyvalue {
                key: 226 as libc::c_int,
                vlen: (::core::mem::size_of::<[libc::c_char; 12]>() as libc::c_ulong as uint32_t)
                    .wrapping_sub(1 as libc::c_int as libc::c_uint),
                value: b"226 IM Used\0" as *const u8 as *const libc::c_char,
            };
            init
        },
        {
            let mut init = keyvalue {
                key: 300 as libc::c_int,
                vlen: (::core::mem::size_of::<[libc::c_char; 21]>() as libc::c_ulong as uint32_t)
                    .wrapping_sub(1 as libc::c_int as libc::c_uint),
                value: b"300 Multiple Choices\0" as *const u8 as *const libc::c_char,
            };
            init
        },
        {
            let mut init = keyvalue {
                key: 301 as libc::c_int,
                vlen: (::core::mem::size_of::<[libc::c_char; 22]>() as libc::c_ulong as uint32_t)
                    .wrapping_sub(1 as libc::c_int as libc::c_uint),
                value: b"301 Moved Permanently\0" as *const u8 as *const libc::c_char,
            };
            init
        },
        {
            let mut init = keyvalue {
                key: 302 as libc::c_int,
                vlen: (::core::mem::size_of::<[libc::c_char; 10]>() as libc::c_ulong as uint32_t)
                    .wrapping_sub(1 as libc::c_int as libc::c_uint),
                value: b"302 Found\0" as *const u8 as *const libc::c_char,
            };
            init
        },
        {
            let mut init = keyvalue {
                key: 303 as libc::c_int,
                vlen: (::core::mem::size_of::<[libc::c_char; 14]>() as libc::c_ulong as uint32_t)
                    .wrapping_sub(1 as libc::c_int as libc::c_uint),
                value: b"303 See Other\0" as *const u8 as *const libc::c_char,
            };
            init
        },
        {
            let mut init = keyvalue {
                key: 304 as libc::c_int,
                vlen: (::core::mem::size_of::<[libc::c_char; 17]>() as libc::c_ulong as uint32_t)
                    .wrapping_sub(1 as libc::c_int as libc::c_uint),
                value: b"304 Not Modified\0" as *const u8 as *const libc::c_char,
            };
            init
        },
        {
            let mut init = keyvalue {
                key: 305 as libc::c_int,
                vlen: (::core::mem::size_of::<[libc::c_char; 14]>() as libc::c_ulong as uint32_t)
                    .wrapping_sub(1 as libc::c_int as libc::c_uint),
                value: b"305 Use Proxy\0" as *const u8 as *const libc::c_char,
            };
            init
        },
        {
            let mut init = keyvalue {
                key: 306 as libc::c_int,
                vlen: (::core::mem::size_of::<[libc::c_char; 13]>() as libc::c_ulong as uint32_t)
                    .wrapping_sub(1 as libc::c_int as libc::c_uint),
                value: b"306 (Unused)\0" as *const u8 as *const libc::c_char,
            };
            init
        },
        {
            let mut init = keyvalue {
                key: 307 as libc::c_int,
                vlen: (::core::mem::size_of::<[libc::c_char; 23]>() as libc::c_ulong as uint32_t)
                    .wrapping_sub(1 as libc::c_int as libc::c_uint),
                value: b"307 Temporary Redirect\0" as *const u8 as *const libc::c_char,
            };
            init
        },
        {
            let mut init = keyvalue {
                key: 308 as libc::c_int,
                vlen: (::core::mem::size_of::<[libc::c_char; 23]>() as libc::c_ulong as uint32_t)
                    .wrapping_sub(1 as libc::c_int as libc::c_uint),
                value: b"308 Permanent Redirect\0" as *const u8 as *const libc::c_char,
            };
            init
        },
        {
            let mut init = keyvalue {
                key: 400 as libc::c_int,
                vlen: (::core::mem::size_of::<[libc::c_char; 16]>() as libc::c_ulong as uint32_t)
                    .wrapping_sub(1 as libc::c_int as libc::c_uint),
                value: b"400 Bad Request\0" as *const u8 as *const libc::c_char,
            };
            init
        },
        {
            let mut init = keyvalue {
                key: 401 as libc::c_int,
                vlen: (::core::mem::size_of::<[libc::c_char; 17]>() as libc::c_ulong as uint32_t)
                    .wrapping_sub(1 as libc::c_int as libc::c_uint),
                value: b"401 Unauthorized\0" as *const u8 as *const libc::c_char,
            };
            init
        },
        {
            let mut init = keyvalue {
                key: 402 as libc::c_int,
                vlen: (::core::mem::size_of::<[libc::c_char; 21]>() as libc::c_ulong as uint32_t)
                    .wrapping_sub(1 as libc::c_int as libc::c_uint),
                value: b"402 Payment Required\0" as *const u8 as *const libc::c_char,
            };
            init
        },
        {
            let mut init = keyvalue {
                key: 403 as libc::c_int,
                vlen: (::core::mem::size_of::<[libc::c_char; 14]>() as libc::c_ulong as uint32_t)
                    .wrapping_sub(1 as libc::c_int as libc::c_uint),
                value: b"403 Forbidden\0" as *const u8 as *const libc::c_char,
            };
            init
        },
        {
            let mut init = keyvalue {
                key: 404 as libc::c_int,
                vlen: (::core::mem::size_of::<[libc::c_char; 14]>() as libc::c_ulong as uint32_t)
                    .wrapping_sub(1 as libc::c_int as libc::c_uint),
                value: b"404 Not Found\0" as *const u8 as *const libc::c_char,
            };
            init
        },
        {
            let mut init = keyvalue {
                key: 405 as libc::c_int,
                vlen: (::core::mem::size_of::<[libc::c_char; 23]>() as libc::c_ulong as uint32_t)
                    .wrapping_sub(1 as libc::c_int as libc::c_uint),
                value: b"405 Method Not Allowed\0" as *const u8 as *const libc::c_char,
            };
            init
        },
        {
            let mut init = keyvalue {
                key: 406 as libc::c_int,
                vlen: (::core::mem::size_of::<[libc::c_char; 19]>() as libc::c_ulong as uint32_t)
                    .wrapping_sub(1 as libc::c_int as libc::c_uint),
                value: b"406 Not Acceptable\0" as *const u8 as *const libc::c_char,
            };
            init
        },
        {
            let mut init = keyvalue {
                key: 407 as libc::c_int,
                vlen: (::core::mem::size_of::<[libc::c_char; 34]>() as libc::c_ulong as uint32_t)
                    .wrapping_sub(1 as libc::c_int as libc::c_uint),
                value: b"407 Proxy Authentication Required\0" as *const u8 as *const libc::c_char,
            };
            init
        },
        {
            let mut init = keyvalue {
                key: 408 as libc::c_int,
                vlen: (::core::mem::size_of::<[libc::c_char; 20]>() as libc::c_ulong as uint32_t)
                    .wrapping_sub(1 as libc::c_int as libc::c_uint),
                value: b"408 Request Timeout\0" as *const u8 as *const libc::c_char,
            };
            init
        },
        {
            let mut init = keyvalue {
                key: 409 as libc::c_int,
                vlen: (::core::mem::size_of::<[libc::c_char; 13]>() as libc::c_ulong as uint32_t)
                    .wrapping_sub(1 as libc::c_int as libc::c_uint),
                value: b"409 Conflict\0" as *const u8 as *const libc::c_char,
            };
            init
        },
        {
            let mut init = keyvalue {
                key: 410 as libc::c_int,
                vlen: (::core::mem::size_of::<[libc::c_char; 9]>() as libc::c_ulong as uint32_t)
                    .wrapping_sub(1 as libc::c_int as libc::c_uint),
                value: b"410 Gone\0" as *const u8 as *const libc::c_char,
            };
            init
        },
        {
            let mut init = keyvalue {
                key: 411 as libc::c_int,
                vlen: (::core::mem::size_of::<[libc::c_char; 20]>() as libc::c_ulong as uint32_t)
                    .wrapping_sub(1 as libc::c_int as libc::c_uint),
                value: b"411 Length Required\0" as *const u8 as *const libc::c_char,
            };
            init
        },
        {
            let mut init = keyvalue {
                key: 412 as libc::c_int,
                vlen: (::core::mem::size_of::<[libc::c_char; 24]>() as libc::c_ulong as uint32_t)
                    .wrapping_sub(1 as libc::c_int as libc::c_uint),
                value: b"412 Precondition Failed\0" as *const u8 as *const libc::c_char,
            };
            init
        },
        {
            let mut init = keyvalue {
                key: 413 as libc::c_int,
                vlen: (::core::mem::size_of::<[libc::c_char; 22]>() as libc::c_ulong as uint32_t)
                    .wrapping_sub(1 as libc::c_int as libc::c_uint),
                value: b"413 Payload Too Large\0" as *const u8 as *const libc::c_char,
            };
            init
        },
        {
            let mut init = keyvalue {
                key: 414 as libc::c_int,
                vlen: (::core::mem::size_of::<[libc::c_char; 17]>() as libc::c_ulong as uint32_t)
                    .wrapping_sub(1 as libc::c_int as libc::c_uint),
                value: b"414 URI Too Long\0" as *const u8 as *const libc::c_char,
            };
            init
        },
        {
            let mut init = keyvalue {
                key: 415 as libc::c_int,
                vlen: (::core::mem::size_of::<[libc::c_char; 27]>() as libc::c_ulong as uint32_t)
                    .wrapping_sub(1 as libc::c_int as libc::c_uint),
                value: b"415 Unsupported Media Type\0" as *const u8 as *const libc::c_char,
            };
            init
        },
        {
            let mut init = keyvalue {
                key: 416 as libc::c_int,
                vlen: (::core::mem::size_of::<[libc::c_char; 26]>() as libc::c_ulong as uint32_t)
                    .wrapping_sub(1 as libc::c_int as libc::c_uint),
                value: b"416 Range Not Satisfiable\0" as *const u8 as *const libc::c_char,
            };
            init
        },
        {
            let mut init = keyvalue {
                key: 417 as libc::c_int,
                vlen: (::core::mem::size_of::<[libc::c_char; 23]>() as libc::c_ulong as uint32_t)
                    .wrapping_sub(1 as libc::c_int as libc::c_uint),
                value: b"417 Expectation Failed\0" as *const u8 as *const libc::c_char,
            };
            init
        },
        {
            let mut init = keyvalue {
                key: 421 as libc::c_int,
                vlen: (::core::mem::size_of::<[libc::c_char; 24]>() as libc::c_ulong as uint32_t)
                    .wrapping_sub(1 as libc::c_int as libc::c_uint),
                value: b"421 Misdirected Request\0" as *const u8 as *const libc::c_char,
            };
            init
        },
        {
            let mut init = keyvalue {
                key: 422 as libc::c_int,
                vlen: (::core::mem::size_of::<[libc::c_char; 25]>() as libc::c_ulong as uint32_t)
                    .wrapping_sub(1 as libc::c_int as libc::c_uint),
                value: b"422 Unprocessable Entity\0" as *const u8 as *const libc::c_char,
            };
            init
        },
        {
            let mut init = keyvalue {
                key: 423 as libc::c_int,
                vlen: (::core::mem::size_of::<[libc::c_char; 11]>() as libc::c_ulong as uint32_t)
                    .wrapping_sub(1 as libc::c_int as libc::c_uint),
                value: b"423 Locked\0" as *const u8 as *const libc::c_char,
            };
            init
        },
        {
            let mut init = keyvalue {
                key: 424 as libc::c_int,
                vlen: (::core::mem::size_of::<[libc::c_char; 22]>() as libc::c_ulong as uint32_t)
                    .wrapping_sub(1 as libc::c_int as libc::c_uint),
                value: b"424 Failed Dependency\0" as *const u8 as *const libc::c_char,
            };
            init
        },
        {
            let mut init = keyvalue {
                key: 426 as libc::c_int,
                vlen: (::core::mem::size_of::<[libc::c_char; 21]>() as libc::c_ulong as uint32_t)
                    .wrapping_sub(1 as libc::c_int as libc::c_uint),
                value: b"426 Upgrade Required\0" as *const u8 as *const libc::c_char,
            };
            init
        },
        {
            let mut init = keyvalue {
                key: 428 as libc::c_int,
                vlen: (::core::mem::size_of::<[libc::c_char; 26]>() as libc::c_ulong as uint32_t)
                    .wrapping_sub(1 as libc::c_int as libc::c_uint),
                value: b"428 Precondition Required\0" as *const u8 as *const libc::c_char,
            };
            init
        },
        {
            let mut init = keyvalue {
                key: 429 as libc::c_int,
                vlen: (::core::mem::size_of::<[libc::c_char; 22]>() as libc::c_ulong as uint32_t)
                    .wrapping_sub(1 as libc::c_int as libc::c_uint),
                value: b"429 Too Many Requests\0" as *const u8 as *const libc::c_char,
            };
            init
        },
        {
            let mut init = keyvalue {
                key: 431 as libc::c_int,
                vlen: (::core::mem::size_of::<[libc::c_char; 36]>() as libc::c_ulong as uint32_t)
                    .wrapping_sub(1 as libc::c_int as libc::c_uint),
                value: b"431 Request Header Fields Too Large\0" as *const u8 as *const libc::c_char,
            };
            init
        },
        {
            let mut init = keyvalue {
                key: 451 as libc::c_int,
                vlen: (::core::mem::size_of::<[libc::c_char; 34]>() as libc::c_ulong as uint32_t)
                    .wrapping_sub(1 as libc::c_int as libc::c_uint),
                value: b"451 Unavailable For Legal Reasons\0" as *const u8 as *const libc::c_char,
            };
            init
        },
        {
            let mut init = keyvalue {
                key: 500 as libc::c_int,
                vlen: (::core::mem::size_of::<[libc::c_char; 26]>() as libc::c_ulong as uint32_t)
                    .wrapping_sub(1 as libc::c_int as libc::c_uint),
                value: b"500 Internal Server Error\0" as *const u8 as *const libc::c_char,
            };
            init
        },
        {
            let mut init = keyvalue {
                key: 501 as libc::c_int,
                vlen: (::core::mem::size_of::<[libc::c_char; 20]>() as libc::c_ulong as uint32_t)
                    .wrapping_sub(1 as libc::c_int as libc::c_uint),
                value: b"501 Not Implemented\0" as *const u8 as *const libc::c_char,
            };
            init
        },
        {
            let mut init = keyvalue {
                key: 502 as libc::c_int,
                vlen: (::core::mem::size_of::<[libc::c_char; 16]>() as libc::c_ulong as uint32_t)
                    .wrapping_sub(1 as libc::c_int as libc::c_uint),
                value: b"502 Bad Gateway\0" as *const u8 as *const libc::c_char,
            };
            init
        },
        {
            let mut init = keyvalue {
                key: 503 as libc::c_int,
                vlen: (::core::mem::size_of::<[libc::c_char; 24]>() as libc::c_ulong as uint32_t)
                    .wrapping_sub(1 as libc::c_int as libc::c_uint),
                value: b"503 Service Unavailable\0" as *const u8 as *const libc::c_char,
            };
            init
        },
        {
            let mut init = keyvalue {
                key: 504 as libc::c_int,
                vlen: (::core::mem::size_of::<[libc::c_char; 20]>() as libc::c_ulong as uint32_t)
                    .wrapping_sub(1 as libc::c_int as libc::c_uint),
                value: b"504 Gateway Timeout\0" as *const u8 as *const libc::c_char,
            };
            init
        },
        {
            let mut init = keyvalue {
                key: 505 as libc::c_int,
                vlen: (::core::mem::size_of::<[libc::c_char; 31]>() as libc::c_ulong as uint32_t)
                    .wrapping_sub(1 as libc::c_int as libc::c_uint),
                value: b"505 HTTP Version Not Supported\0" as *const u8 as *const libc::c_char,
            };
            init
        },
        {
            let mut init = keyvalue {
                key: 506 as libc::c_int,
                vlen: (::core::mem::size_of::<[libc::c_char; 28]>() as libc::c_ulong as uint32_t)
                    .wrapping_sub(1 as libc::c_int as libc::c_uint),
                value: b"506 Variant Also Negotiates\0" as *const u8 as *const libc::c_char,
            };
            init
        },
        {
            let mut init = keyvalue {
                key: 507 as libc::c_int,
                vlen: (::core::mem::size_of::<[libc::c_char; 25]>() as libc::c_ulong as uint32_t)
                    .wrapping_sub(1 as libc::c_int as libc::c_uint),
                value: b"507 Insufficient Storage\0" as *const u8 as *const libc::c_char,
            };
            init
        },
        {
            let mut init = keyvalue {
                key: 508 as libc::c_int,
                vlen: (::core::mem::size_of::<[libc::c_char; 18]>() as libc::c_ulong as uint32_t)
                    .wrapping_sub(1 as libc::c_int as libc::c_uint),
                value: b"508 Loop Detected\0" as *const u8 as *const libc::c_char,
            };
            init
        },
        {
            let mut init = keyvalue {
                key: 510 as libc::c_int,
                vlen: (::core::mem::size_of::<[libc::c_char; 17]>() as libc::c_ulong as uint32_t)
                    .wrapping_sub(1 as libc::c_int as libc::c_uint),
                value: b"510 Not Extended\0" as *const u8 as *const libc::c_char,
            };
            init
        },
        {
            let mut init = keyvalue {
                key: 511 as libc::c_int,
                vlen: (::core::mem::size_of::<[libc::c_char; 36]>() as libc::c_ulong as uint32_t)
                    .wrapping_sub(1 as libc::c_int as libc::c_uint),
                value: b"511 Network Authentication Required\0" as *const u8 as *const libc::c_char,
            };
            init
        },
        {
            let mut init = keyvalue {
                key: -(1 as libc::c_int),
                vlen: 0 as libc::c_int as libc::c_uint,
                value: 0 as *const libc::c_char,
            };
            init
        },
    ];
    cpk_2 = [
        {
            let mut init = config_plugin_keys_t {
                k: b"host\0" as *const u8 as *const libc::c_char,
                klen: (::core::mem::size_of::<[libc::c_char; 5]>() as libc::c_ulong as uint32_t)
                    .wrapping_sub(1 as libc::c_int as libc::c_uint)
                    as uint8_t,
                ktype: T_CONFIG_STRING as libc::c_int as uint8_t,
                scope: T_CONFIG_SCOPE_CONNECTION as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = config_plugin_keys_t {
                k: b"port\0" as *const u8 as *const libc::c_char,
                klen: (::core::mem::size_of::<[libc::c_char; 5]>() as libc::c_ulong as uint32_t)
                    .wrapping_sub(1 as libc::c_int as libc::c_uint)
                    as uint8_t,
                ktype: T_CONFIG_SHORT as libc::c_int as uint8_t,
                scope: T_CONFIG_SCOPE_CONNECTION as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = config_plugin_keys_t {
                k: b"socket\0" as *const u8 as *const libc::c_char,
                klen: (::core::mem::size_of::<[libc::c_char; 7]>() as libc::c_ulong as uint32_t)
                    .wrapping_sub(1 as libc::c_int as libc::c_uint)
                    as uint8_t,
                ktype: T_CONFIG_STRING as libc::c_int as uint8_t,
                scope: T_CONFIG_SCOPE_CONNECTION as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = config_plugin_keys_t {
                k: b"listen-backlog\0" as *const u8 as *const libc::c_char,
                klen: (::core::mem::size_of::<[libc::c_char; 15]>() as libc::c_ulong as uint32_t)
                    .wrapping_sub(1 as libc::c_int as libc::c_uint)
                    as uint8_t,
                ktype: T_CONFIG_INT as libc::c_int as uint8_t,
                scope: T_CONFIG_SCOPE_CONNECTION as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = config_plugin_keys_t {
                k: b"bin-path\0" as *const u8 as *const libc::c_char,
                klen: (::core::mem::size_of::<[libc::c_char; 9]>() as libc::c_ulong as uint32_t)
                    .wrapping_sub(1 as libc::c_int as libc::c_uint)
                    as uint8_t,
                ktype: T_CONFIG_STRING as libc::c_int as uint8_t,
                scope: T_CONFIG_SCOPE_CONNECTION as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = config_plugin_keys_t {
                k: b"kill-signal\0" as *const u8 as *const libc::c_char,
                klen: (::core::mem::size_of::<[libc::c_char; 12]>() as libc::c_ulong as uint32_t)
                    .wrapping_sub(1 as libc::c_int as libc::c_uint)
                    as uint8_t,
                ktype: T_CONFIG_SHORT as libc::c_int as uint8_t,
                scope: T_CONFIG_SCOPE_CONNECTION as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = config_plugin_keys_t {
                k: b"check-local\0" as *const u8 as *const libc::c_char,
                klen: (::core::mem::size_of::<[libc::c_char; 12]>() as libc::c_ulong as uint32_t)
                    .wrapping_sub(1 as libc::c_int as libc::c_uint)
                    as uint8_t,
                ktype: T_CONFIG_BOOL as libc::c_int as uint8_t,
                scope: T_CONFIG_SCOPE_CONNECTION as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = config_plugin_keys_t {
                k: b"mode\0" as *const u8 as *const libc::c_char,
                klen: (::core::mem::size_of::<[libc::c_char; 5]>() as libc::c_ulong as uint32_t)
                    .wrapping_sub(1 as libc::c_int as libc::c_uint)
                    as uint8_t,
                ktype: T_CONFIG_STRING as libc::c_int as uint8_t,
                scope: T_CONFIG_SCOPE_CONNECTION as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = config_plugin_keys_t {
                k: b"docroot\0" as *const u8 as *const libc::c_char,
                klen: (::core::mem::size_of::<[libc::c_char; 8]>() as libc::c_ulong as uint32_t)
                    .wrapping_sub(1 as libc::c_int as libc::c_uint)
                    as uint8_t,
                ktype: T_CONFIG_STRING as libc::c_int as uint8_t,
                scope: T_CONFIG_SCOPE_CONNECTION as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = config_plugin_keys_t {
                k: b"min-procs\0" as *const u8 as *const libc::c_char,
                klen: (::core::mem::size_of::<[libc::c_char; 10]>() as libc::c_ulong as uint32_t)
                    .wrapping_sub(1 as libc::c_int as libc::c_uint)
                    as uint8_t,
                ktype: T_CONFIG_SHORT as libc::c_int as uint8_t,
                scope: T_CONFIG_SCOPE_CONNECTION as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = config_plugin_keys_t {
                k: b"max-procs\0" as *const u8 as *const libc::c_char,
                klen: (::core::mem::size_of::<[libc::c_char; 10]>() as libc::c_ulong as uint32_t)
                    .wrapping_sub(1 as libc::c_int as libc::c_uint)
                    as uint8_t,
                ktype: T_CONFIG_SHORT as libc::c_int as uint8_t,
                scope: T_CONFIG_SCOPE_CONNECTION as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = config_plugin_keys_t {
                k: b"max-load-per-proc\0" as *const u8 as *const libc::c_char,
                klen: (::core::mem::size_of::<[libc::c_char; 18]>() as libc::c_ulong as uint32_t)
                    .wrapping_sub(1 as libc::c_int as libc::c_uint)
                    as uint8_t,
                ktype: T_CONFIG_SHORT as libc::c_int as uint8_t,
                scope: T_CONFIG_SCOPE_CONNECTION as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = config_plugin_keys_t {
                k: b"idle-timeout\0" as *const u8 as *const libc::c_char,
                klen: (::core::mem::size_of::<[libc::c_char; 13]>() as libc::c_ulong as uint32_t)
                    .wrapping_sub(1 as libc::c_int as libc::c_uint)
                    as uint8_t,
                ktype: T_CONFIG_SHORT as libc::c_int as uint8_t,
                scope: T_CONFIG_SCOPE_CONNECTION as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = config_plugin_keys_t {
                k: b"disable-time\0" as *const u8 as *const libc::c_char,
                klen: (::core::mem::size_of::<[libc::c_char; 13]>() as libc::c_ulong as uint32_t)
                    .wrapping_sub(1 as libc::c_int as libc::c_uint)
                    as uint8_t,
                ktype: T_CONFIG_SHORT as libc::c_int as uint8_t,
                scope: T_CONFIG_SCOPE_CONNECTION as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = config_plugin_keys_t {
                k: b"bin-environment\0" as *const u8 as *const libc::c_char,
                klen: (::core::mem::size_of::<[libc::c_char; 16]>() as libc::c_ulong as uint32_t)
                    .wrapping_sub(1 as libc::c_int as libc::c_uint)
                    as uint8_t,
                ktype: T_CONFIG_ARRAY_KVSTRING as libc::c_int as uint8_t,
                scope: T_CONFIG_SCOPE_CONNECTION as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = config_plugin_keys_t {
                k: b"bin-copy-environment\0" as *const u8 as *const libc::c_char,
                klen: (::core::mem::size_of::<[libc::c_char; 21]>() as libc::c_ulong as uint32_t)
                    .wrapping_sub(1 as libc::c_int as libc::c_uint)
                    as uint8_t,
                ktype: T_CONFIG_ARRAY_VLIST as libc::c_int as uint8_t,
                scope: T_CONFIG_SCOPE_CONNECTION as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = config_plugin_keys_t {
                k: b"broken-scriptfilename\0" as *const u8 as *const libc::c_char,
                klen: (::core::mem::size_of::<[libc::c_char; 22]>() as libc::c_ulong as uint32_t)
                    .wrapping_sub(1 as libc::c_int as libc::c_uint)
                    as uint8_t,
                ktype: T_CONFIG_BOOL as libc::c_int as uint8_t,
                scope: T_CONFIG_SCOPE_CONNECTION as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = config_plugin_keys_t {
                k: b"strip-request-uri\0" as *const u8 as *const libc::c_char,
                klen: (::core::mem::size_of::<[libc::c_char; 18]>() as libc::c_ulong as uint32_t)
                    .wrapping_sub(1 as libc::c_int as libc::c_uint)
                    as uint8_t,
                ktype: T_CONFIG_STRING as libc::c_int as uint8_t,
                scope: T_CONFIG_SCOPE_CONNECTION as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = config_plugin_keys_t {
                k: b"fix-root-scriptname\0" as *const u8 as *const libc::c_char,
                klen: (::core::mem::size_of::<[libc::c_char; 20]>() as libc::c_ulong as uint32_t)
                    .wrapping_sub(1 as libc::c_int as libc::c_uint)
                    as uint8_t,
                ktype: T_CONFIG_BOOL as libc::c_int as uint8_t,
                scope: T_CONFIG_SCOPE_CONNECTION as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = config_plugin_keys_t {
                k: b"allow-x-send-file\0" as *const u8 as *const libc::c_char,
                klen: (::core::mem::size_of::<[libc::c_char; 18]>() as libc::c_ulong as uint32_t)
                    .wrapping_sub(1 as libc::c_int as libc::c_uint)
                    as uint8_t,
                ktype: T_CONFIG_BOOL as libc::c_int as uint8_t,
                scope: T_CONFIG_SCOPE_CONNECTION as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = config_plugin_keys_t {
                k: b"x-sendfile\0" as *const u8 as *const libc::c_char,
                klen: (::core::mem::size_of::<[libc::c_char; 11]>() as libc::c_ulong as uint32_t)
                    .wrapping_sub(1 as libc::c_int as libc::c_uint)
                    as uint8_t,
                ktype: T_CONFIG_BOOL as libc::c_int as uint8_t,
                scope: T_CONFIG_SCOPE_CONNECTION as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = config_plugin_keys_t {
                k: b"x-sendfile-docroot\0" as *const u8 as *const libc::c_char,
                klen: (::core::mem::size_of::<[libc::c_char; 19]>() as libc::c_ulong as uint32_t)
                    .wrapping_sub(1 as libc::c_int as libc::c_uint)
                    as uint8_t,
                ktype: T_CONFIG_ARRAY_VLIST as libc::c_int as uint8_t,
                scope: T_CONFIG_SCOPE_CONNECTION as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = config_plugin_keys_t {
                k: b"tcp-fin-propagate\0" as *const u8 as *const libc::c_char,
                klen: (::core::mem::size_of::<[libc::c_char; 18]>() as libc::c_ulong as uint32_t)
                    .wrapping_sub(1 as libc::c_int as libc::c_uint)
                    as uint8_t,
                ktype: T_CONFIG_BOOL as libc::c_int as uint8_t,
                scope: T_CONFIG_SCOPE_CONNECTION as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = config_plugin_keys_t {
                k: b"connect-timeout\0" as *const u8 as *const libc::c_char,
                klen: (::core::mem::size_of::<[libc::c_char; 16]>() as libc::c_ulong as uint32_t)
                    .wrapping_sub(1 as libc::c_int as libc::c_uint)
                    as uint8_t,
                ktype: T_CONFIG_INT as libc::c_int as uint8_t,
                scope: T_CONFIG_SCOPE_CONNECTION as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = config_plugin_keys_t {
                k: b"write-timeout\0" as *const u8 as *const libc::c_char,
                klen: (::core::mem::size_of::<[libc::c_char; 14]>() as libc::c_ulong as uint32_t)
                    .wrapping_sub(1 as libc::c_int as libc::c_uint)
                    as uint8_t,
                ktype: T_CONFIG_INT as libc::c_int as uint8_t,
                scope: T_CONFIG_SCOPE_CONNECTION as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = config_plugin_keys_t {
                k: b"read-timeout\0" as *const u8 as *const libc::c_char,
                klen: (::core::mem::size_of::<[libc::c_char; 13]>() as libc::c_ulong as uint32_t)
                    .wrapping_sub(1 as libc::c_int as libc::c_uint)
                    as uint8_t,
                ktype: T_CONFIG_INT as libc::c_int as uint8_t,
                scope: T_CONFIG_SCOPE_CONNECTION as libc::c_int as uint8_t,
            };
            init
        },
        {
            let mut init = config_plugin_keys_t {
                k: 0 as *const libc::c_char,
                klen: 0 as libc::c_int as uint8_t,
                ktype: T_CONFIG_UNSET as libc::c_int as uint8_t,
                scope: T_CONFIG_SCOPE_UNSET as libc::c_int as uint8_t,
            };
            init
        },
    ];
    lhost = {
        let mut init = buffer {
            ptr: b"127.0.0.1\0" as *const u8 as *const libc::c_char as *mut libc::c_char,
            used: (::core::mem::size_of::<[libc::c_char; 10]>() as libc::c_ulong as uint32_t)
                .wrapping_sub(1 as libc::c_int as libc::c_uint)
                .wrapping_add(1 as libc::c_int as libc::c_uint),
            size: 0 as libc::c_int as uint32_t,
        };
        init
    };
    octet_stream = {
        let mut init = buffer {
            ptr: b"application/octet-stream\0" as *const u8 as *const libc::c_char
                as *mut libc::c_char,
            used: (::core::mem::size_of::<[libc::c_char; 25]>() as libc::c_ulong as uint32_t)
                .wrapping_sub(1 as libc::c_int as libc::c_uint)
                .wrapping_add(1 as libc::c_int as libc::c_uint),
            size: 0 as libc::c_int as uint32_t,
        };
        init
    };
}
#[used]
#[cfg_attr(target_os = "linux", link_section = ".init_array")]
#[cfg_attr(target_os = "windows", link_section = ".CRT$XIB")]
#[cfg_attr(target_os = "macos", link_section = "__DATA,__mod_init_func")]
static INIT_ARRAY: [unsafe extern "C" fn(); 1] = [run_static_initializers];
